diff --git a/coin4/configure b/coin4/configure
old mode 100644
new mode 100755
diff --git a/coin4/include/Inventor/C/glue/gl.h b/coin4/include/Inventor/C/glue/gl.h
index dd8d515..bfb8eb2 100644
--- a/coin4/include/Inventor/C/glue/gl.h
+++ b/coin4/include/Inventor/C/glue/gl.h
@@ -641,7 +641,7 @@ typedef struct cc_glglue_offscreen_cb_functions {
     void (*destruct)(cc_glglue_offscreen_data context);
 } cc_glglue_offscreen_cb_functions; 
 
-/* Set callback functions for external offscreen rendering. Pass NULL 
+/* Set callback functions for external offscreen rendering. Pass nullptr 
    to restore default, built-in offscreen rendering. 
  */
 COIN_DLL_API void cc_glglue_context_set_offscreen_cb_functions(cc_glglue_offscreen_cb_functions* p);
diff --git a/coin4/include/Inventor/SbBSPTree.h b/coin4/include/Inventor/SbBSPTree.h
index c44ebc3..a69a504 100644
--- a/coin4/include/Inventor/SbBSPTree.h
+++ b/coin4/include/Inventor/SbBSPTree.h
@@ -24,7 +24,6 @@
  *
 \**************************************************************************/
 
-#include <stddef.h> // for NULL definition
 #include <Inventor/lists/SbList.h>
 #include <Inventor/SbVec3f.h>
 #include <Inventor/SbBox3f.h>
@@ -53,7 +52,7 @@ public:
   void * getUserData(const int idx) const;
   void setUserData(const int idx, void * const data);
 
-  int addPoint(const SbVec3f & pt, void * const userdata = NULL);
+  int addPoint(const SbVec3f & pt, void * const userdata = nullptr);
   int removePoint(const SbVec3f & pt);
   void removePoint(const int idx);
   int findPoint(const SbVec3f & pos) const;
diff --git a/coin4/include/Inventor/SbByteBuffer.h b/coin4/include/Inventor/SbByteBuffer.h
index e5262e9..2d2b18f 100644
--- a/coin4/include/Inventor/SbByteBuffer.h
+++ b/coin4/include/Inventor/SbByteBuffer.h
@@ -35,7 +35,7 @@ class COIN_DLL_API SbByteBuffer {
  public:
   SbByteBuffer(const char * buffer);
   SbByteBuffer(const SbByteBuffer & buffer);
-  SbByteBuffer(size_t size = 0, const char * buffer = NULL);
+  SbByteBuffer(size_t size = 0, const char * buffer = nullptr);
   SbByteBuffer(size_t size, const unsigned char * buffer);
   ~SbByteBuffer();
 
diff --git a/coin4/include/Inventor/SbClip.h b/coin4/include/Inventor/SbClip.h
index 7a17866..dc0325c 100644
--- a/coin4/include/Inventor/SbClip.h
+++ b/coin4/include/Inventor/SbClip.h
@@ -38,15 +38,15 @@ typedef void * SbClipCallback(const SbVec3f & v0, void * vdata0,
 
 class COIN_DLL_API SbClip {
 public:
-  SbClip(SbClipCallback * callback = NULL, void * userdata = NULL);
+  SbClip(SbClipCallback * callback = nullptr, void * userdata = nullptr);
   
-  void addVertex(const SbVec3f &v, void * vdata = NULL);  
+  void addVertex(const SbVec3f &v, void * vdata = nullptr);  
   void reset(void);
 
   void clip(const SbPlane & plane);
 
   int getNumVertices(void) const;
-  void getVertex(const int idx, SbVec3f & v, void ** vdata = NULL) const; 
+  void getVertex(const int idx, SbVec3f & v, void ** vdata = nullptr) const; 
   void * getVertexData(const int idx) const;
   
 private:
diff --git a/coin4/include/Inventor/SbHeap.h b/coin4/include/Inventor/SbHeap.h
index decc930..9a5fc29 100644
--- a/coin4/include/Inventor/SbHeap.h
+++ b/coin4/include/Inventor/SbHeap.h
@@ -51,8 +51,8 @@ public:
   void *operator[](const int idx);
 
   void newWeight(void *obj, int hpos = -1);
-  bool buildHeap(bool (*progresscb)(float percentage, void *data) = NULL,
-                   void *data = NULL);
+  bool buildHeap(bool (*progresscb)(float percentage, void *data) = nullptr,
+                   void *data = nullptr);
   bool traverseHeap(bool (*func)(void *, void *), void *userdata) const;
 
 private:
diff --git a/coin4/include/Inventor/SbImage.h b/coin4/include/Inventor/SbImage.h
index 6796d7b..e33f8c1 100644
--- a/coin4/include/Inventor/SbImage.h
+++ b/coin4/include/Inventor/SbImage.h
@@ -27,7 +27,6 @@
 #include <Inventor/SbVec2s.h>
 #include <Inventor/SbVec3s.h>
 #include <Inventor/SbString.h>
-#include <stddef.h> // for NULL
 
 class SbImage;
 
@@ -57,7 +56,7 @@ public:
   SbVec3s getSize(void) const;
 
   bool readFile(const SbString & filename,
-                  const SbString * const * searchdirectories = NULL,
+                  const SbString * const * searchdirectories = nullptr,
                   const int numdirectories = 0);
 
   bool operator==(const SbImage & image) const;
@@ -88,7 +87,7 @@ public:
   bool scheduleReadFile(SbImageScheduleReadCB * cb,
                           void * closure,
                           const SbString & filename,
-                          const SbString * const * searchdirectories = NULL,
+                          const SbString * const * searchdirectories = nullptr,
                           const int numdirectories = 0);
 };
 
diff --git a/coin4/include/Inventor/SbTesselator.h b/coin4/include/Inventor/SbTesselator.h
index eb0a8b1..2ffbeda 100644
--- a/coin4/include/Inventor/SbTesselator.h
+++ b/coin4/include/Inventor/SbTesselator.h
@@ -33,7 +33,7 @@ typedef void SbTesselatorCB(void * v0, void * v1, void * v2, void * data);
 
 class COIN_DLL_API SbTesselator {
 public:
-  SbTesselator(SbTesselatorCB * func = NULL, void * data = NULL);
+  SbTesselator(SbTesselatorCB * func = nullptr, void * data = nullptr);
   ~SbTesselator(void);
 
   void beginPolygon(bool keepVertices = false,
diff --git a/coin4/include/Inventor/SbTime.h b/coin4/include/Inventor/SbTime.h
index 1048896..2a6ccfa 100644
--- a/coin4/include/Inventor/SbTime.h
+++ b/coin4/include/Inventor/SbTime.h
@@ -60,7 +60,7 @@ public:
   void getValue(struct timeval * tv) const;
   unsigned long getMsecValue(void) const;
   SbString format(const char * const fmt = "%S.%i") const;
-  SbString formatDate(const char * const fmt = NULL) const;
+  SbString formatDate(const char * const fmt = nullptr) const;
   bool parsedate(const char * const date);
   friend COIN_DLL_API SbTime operator+(const SbTime & t0, const SbTime & t1);
   friend COIN_DLL_API SbTime operator-(const SbTime & t0, const SbTime & t1);
diff --git a/coin4/include/Inventor/SoDB.h b/coin4/include/Inventor/SoDB.h
index b7c257e..a25b1b0 100644
--- a/coin4/include/Inventor/SoDB.h
+++ b/coin4/include/Inventor/SoDB.h
@@ -61,7 +61,7 @@ public:
                                float ivversion,
                                SoDBHeaderCB * precallback,
                                SoDBHeaderCB * postcallback,
-                               void * userdata = NULL);
+                               void * userdata = nullptr);
   static bool getHeaderData(const SbString & headerstring,
                               bool & isbinary,
                               float & ivversion,
diff --git a/coin4/include/Inventor/SoInput.h b/coin4/include/Inventor/SoInput.h
index cc9e32f..1c3796b 100644
--- a/coin4/include/Inventor/SoInput.h
+++ b/coin4/include/Inventor/SoInput.h
@@ -149,7 +149,7 @@ protected:
   void setIVVersion(float version);
   FILE * findFile(const char * fileName, SbString & fullName);
   void initFile(FILE * newFP, const char * fileName, SbString * fullName,
-                bool openedHere, SbDict * refDict = NULL);
+                bool openedHere, SbDict * refDict = nullptr);
   bool checkHeader(bool bValidateBufferHeader = false);
   bool fromBuffer(void) const;
   bool skipWhiteSpace(void);
diff --git a/coin4/include/Inventor/SoPickedPoint.h b/coin4/include/Inventor/SoPickedPoint.h
index 2cd0a69..fee3a56 100644
--- a/coin4/include/Inventor/SoPickedPoint.h
+++ b/coin4/include/Inventor/SoPickedPoint.h
@@ -49,14 +49,14 @@ public:
   int getMaterialIndex() const;
   SoPath *getPath() const;
   bool isOnGeometry() const;
-  const SoDetail *getDetail(const SoNode * const node = NULL) const;
-  const SbMatrix &getObjectToWorld(const SoNode * const node = NULL) const;
-  const SbMatrix &getWorldToObject(const SoNode * const node = NULL) const;
-  const SbMatrix &getObjectToImage(const SoNode * const node = NULL) const;
-  const SbMatrix &getImageToObject(const SoNode * const node = NULL) const;
-  SbVec3f getObjectPoint(const SoNode * const node = NULL) const;
-  SbVec3f getObjectNormal(const SoNode * const node = NULL) const;
-  SbVec4f getObjectTextureCoords(const SoNode * const node = NULL) const;
+  const SoDetail *getDetail(const SoNode * const node = nullptr) const;
+  const SbMatrix &getObjectToWorld(const SoNode * const node = nullptr) const;
+  const SbMatrix &getWorldToObject(const SoNode * const node = nullptr) const;
+  const SbMatrix &getObjectToImage(const SoNode * const node = nullptr) const;
+  const SbMatrix &getImageToObject(const SoNode * const node = nullptr) const;
+  SbVec3f getObjectPoint(const SoNode * const node = nullptr) const;
+  SbVec3f getObjectNormal(const SoNode * const node = nullptr) const;
+  SbVec4f getObjectTextureCoords(const SoNode * const node = nullptr) const;
 
   void setObjectNormal(const SbVec3f &normal);
   void setObjectTextureCoords(const SbVec4f &texCoords);
diff --git a/coin4/include/Inventor/SoRenderManager.h b/coin4/include/Inventor/SoRenderManager.h
index 39a1453..51482de 100644
--- a/coin4/include/Inventor/SoRenderManager.h
+++ b/coin4/include/Inventor/SoRenderManager.h
@@ -138,7 +138,7 @@ public:
   float getStereoOffset(void) const;
 
   void setRenderCallback(SoRenderManagerRenderCB * f,
-                         void * const userData = NULL);
+                         void * const userData = nullptr);
 
   bool isAutoRedraw(void) const;
   void setRedrawPriority(const uint32_t priority);
diff --git a/coin4/include/Inventor/SoSceneManager.h b/coin4/include/Inventor/SoSceneManager.h
index 06e3497..276e899 100644
--- a/coin4/include/Inventor/SoSceneManager.h
+++ b/coin4/include/Inventor/SoSceneManager.h
@@ -77,7 +77,7 @@ public:
   virtual void activate(void);
   virtual void deactivate(void);
   void setRenderCallback(SoSceneManagerRenderCB * f,
-                         void * const userData = NULL);
+                         void * const userData = nullptr);
   bool isAutoRedraw(void) const;
   void setRedrawPriority(const uint32_t priority);
   uint32_t getRedrawPriority(void) const;
diff --git a/coin4/include/Inventor/SoType.h b/coin4/include/Inventor/SoType.h
index b21aa84..123f237 100644
--- a/coin4/include/Inventor/SoType.h
+++ b/coin4/include/Inventor/SoType.h
@@ -25,7 +25,6 @@
 \**************************************************************************/
 
 #include <Inventor/SbBasic.h>
-#include <stdlib.h> // For NULL definition.
 
 #ifndef COIN_INTERNAL
 // The next include for Open Inventor compatibility.
@@ -73,11 +72,11 @@ public:
   bool operator>(const SoType type) const;
 
   static const SoType createType(const SoType parent, const SbName name,
-                                 const instantiationMethod method = NULL,
+                                 const instantiationMethod method = nullptr,
                                  const uint16_t data = 0);
 
   static const SoType overrideType(const SoType originalType,
-                                   const instantiationMethod method = NULL);
+                                   const instantiationMethod method = nullptr);
 
   static bool removeType(const SbName & name);
 
diff --git a/coin4/include/Inventor/actions/SoAction.h b/coin4/include/Inventor/actions/SoAction.h
index fb734de..7a1b3b8 100644
--- a/coin4/include/Inventor/actions/SoAction.h
+++ b/coin4/include/Inventor/actions/SoAction.h
@@ -107,11 +107,11 @@ public:
   virtual SoNode * getCurPathTail(void);
   void usePathCode(int & numindices, const int * & indices);
   
-  void pushCurPath(const int childindex, SoNode * node = NULL);
+  void pushCurPath(const int childindex, SoNode * node = nullptr);
   void popCurPath(const PathCode prevpathcode);
   void pushCurPath(void);
   
-  void popPushCurPath(const int childindex, SoNode * node = NULL);
+  void popPushCurPath(const int childindex, SoNode * node = nullptr);
   void popCurPath(void);
 
 public:
diff --git a/coin4/include/Inventor/actions/SoGLRenderAction.h b/coin4/include/Inventor/actions/SoGLRenderAction.h
index cb41a23..20cd6b6 100644
--- a/coin4/include/Inventor/actions/SoGLRenderAction.h
+++ b/coin4/include/Inventor/actions/SoGLRenderAction.h
@@ -117,8 +117,8 @@ public:
   int getSortedLayersNumPasses(void) const;
 
   void setSortedObjectOrderStrategy(const SortedObjectOrderStrategy strategy,
-                                    SoGLSortedObjectOrderCB * cb = NULL,
-                                    void * closure = NULL);
+                                    SoGLSortedObjectOrderCB * cb = nullptr,
+                                    void * closure = nullptr);
 
   void setDelayedObjDepthWrite(bool write);
   bool getDelayedObjDepthWrite(void) const;
diff --git a/coin4/include/Inventor/actions/SoReorganizeAction.h b/coin4/include/Inventor/actions/SoReorganizeAction.h
index 93299bd..9e640af 100644
--- a/coin4/include/Inventor/actions/SoReorganizeAction.h
+++ b/coin4/include/Inventor/actions/SoReorganizeAction.h
@@ -38,7 +38,7 @@ class COIN_DLL_API SoReorganizeAction : public SoSimplifyAction {
 public: 
   static void initClass(void);
 
-  SoReorganizeAction(SoSimplifier * simplifier = NULL);
+  SoReorganizeAction(SoSimplifier * simplifier = nullptr);
   virtual ~SoReorganizeAction(void);
 
   SoSeparator * getSimplifiedSceneGraph(void) const;
diff --git a/coin4/include/Inventor/actions/SoSubAction.h b/coin4/include/Inventor/actions/SoSubAction.h
index cf90c1e..55fb89d 100644
--- a/coin4/include/Inventor/actions/SoSubAction.h
+++ b/coin4/include/Inventor/actions/SoSubAction.h
@@ -77,8 +77,8 @@ private: \
 // *************************************************************************
 
 #define SO_ACTION_SOURCE(_classname_) \
-SoEnabledElementsList * _classname_::enabledElements = NULL; \
-SoActionMethodList * _classname_::methods = NULL; \
+SoEnabledElementsList * _classname_::enabledElements = nullptr; \
+SoActionMethodList * _classname_::methods = nullptr; \
 SoEnabledElementsList * _classname_::getClassEnabledElements(void) { return _classname_::enabledElements; } \
 SoActionMethodList * _classname_::getClassActionMethods(void) { return _classname_::methods; } \
 SoType _classname_::classTypeId STATIC_SOTYPE_INIT; \
@@ -105,9 +105,9 @@ void \
 _classname_::atexit_cleanup(void) \
 { \
   delete _classname_::enabledElements; \
-  _classname_::enabledElements = NULL; \
+  _classname_::enabledElements = nullptr; \
   delete _classname_::methods; \
-  _classname_::methods = NULL; \
+  _classname_::methods = nullptr; \
   _classname_::classTypeId STATIC_SOTYPE_INIT; \
 }
 
diff --git a/coin4/include/Inventor/annex/ForeignFiles/SoForeignFileKit.h b/coin4/include/Inventor/annex/ForeignFiles/SoForeignFileKit.h
index c10df9a..768c6a7 100644
--- a/coin4/include/Inventor/annex/ForeignFiles/SoForeignFileKit.h
+++ b/coin4/include/Inventor/annex/ForeignFiles/SoForeignFileKit.h
@@ -49,10 +49,10 @@ public:
   static SoForeignFileKit * createForeignFileKit(const char * filename, bool exhaust = false);
 
   // foreign read support
-  virtual bool canReadFile(const char * filename = NULL) const;
+  virtual bool canReadFile(const char * filename = nullptr) const;
   virtual bool readFile(const char * filename);
   // foreign write support
-  virtual bool canWriteFile(const char * filename = NULL) const;
+  virtual bool canWriteFile(const char * filename = nullptr) const;
   virtual bool writeFile(const char * filename);
 
   /*!
diff --git a/coin4/include/Inventor/annex/ForeignFiles/SoSTLFileKit.h b/coin4/include/Inventor/annex/ForeignFiles/SoSTLFileKit.h
index b56b945..dafca07 100644
--- a/coin4/include/Inventor/annex/ForeignFiles/SoSTLFileKit.h
+++ b/coin4/include/Inventor/annex/ForeignFiles/SoSTLFileKit.h
@@ -61,10 +61,10 @@ public:
   SoSFEnum colorization;
 
   static bool identify(const char * filename);
-  virtual bool canReadFile(const char * filename = NULL) const;
+  virtual bool canReadFile(const char * filename = nullptr) const;
   virtual bool readFile(const char * filename);
 
-  virtual bool canWriteFile(const char * filename = NULL) const;
+  virtual bool canWriteFile(const char * filename = nullptr) const;
   virtual bool writeFile(const char * filename);
 
 
diff --git a/coin4/include/Inventor/caches/SoCache.h b/coin4/include/Inventor/caches/SoCache.h
index 1704363..d119e24 100644
--- a/coin4/include/Inventor/caches/SoCache.h
+++ b/coin4/include/Inventor/caches/SoCache.h
@@ -29,14 +29,13 @@ class SoElement;
 class SoCacheP;
 
 #include <Inventor/SbBasic.h>
-#include <stddef.h> // for NULL
 
 class COIN_DLL_API SoCache {
 public:
   SoCache(SoState * const state);
 
   void ref(void);
-  void unref(SoState * state = NULL);
+  void unref(SoState * state = nullptr);
 
   void addElement(const SoElement * const elem);
 
diff --git a/coin4/include/Inventor/caches/SoNormalCache.h b/coin4/include/Inventor/caches/SoNormalCache.h
index 1d9aac7..21cd82f 100644
--- a/coin4/include/Inventor/caches/SoNormalCache.h
+++ b/coin4/include/Inventor/caches/SoNormalCache.h
@@ -52,7 +52,7 @@ public:
                          const int32_t *coordindices,
                          const int numcoordindices,
                          const float crease_angle,
-                         const SbVec3f *facenormals = NULL,
+                         const SbVec3f *facenormals = nullptr,
                          const int numfacenormals = -1,
                          const bool ccw = true,
                          const bool tristrip = false);
diff --git a/coin4/include/Inventor/caches/SoPrimitiveVertexCache.h b/coin4/include/Inventor/caches/SoPrimitiveVertexCache.h
index 7c27dd1..17d98d6 100644
--- a/coin4/include/Inventor/caches/SoPrimitiveVertexCache.h
+++ b/coin4/include/Inventor/caches/SoPrimitiveVertexCache.h
@@ -59,7 +59,7 @@ public:
   void addTriangle(const SoPrimitiveVertex * v0,
                    const SoPrimitiveVertex * v1,
                    const SoPrimitiveVertex * v2,
-                   const int * pointdetailidx = NULL);
+                   const int * pointdetailidx = nullptr);
   void addLine(const SoPrimitiveVertex * v0,
                const SoPrimitiveVertex * v1);
   void addPoint(const SoPrimitiveVertex * v);
diff --git a/coin4/include/Inventor/collision/SoIntersectionDetectionAction.h b/coin4/include/Inventor/collision/SoIntersectionDetectionAction.h
index 48b11da..5a3157a 100644
--- a/coin4/include/Inventor/collision/SoIntersectionDetectionAction.h
+++ b/coin4/include/Inventor/collision/SoIntersectionDetectionAction.h
@@ -83,9 +83,9 @@ public:
   virtual void apply(SoPath * path);
   virtual void apply(const SoPathList & paths, bool obeysRules = false);
 
-  virtual void setFilterCallback(SoIntersectionFilterCB * cb, void * closure = NULL);
-  virtual void addIntersectionCallback(SoIntersectionCB * cb, void * closure  = NULL);
-  virtual void removeIntersectionCallback(SoIntersectionCB * cb, void * closure  = NULL);
+  virtual void setFilterCallback(SoIntersectionFilterCB * cb, void * closure = nullptr);
+  virtual void addIntersectionCallback(SoIntersectionCB * cb, void * closure  = nullptr);
+  virtual void removeIntersectionCallback(SoIntersectionCB * cb, void * closure  = nullptr);
 
 private:
   class PImpl;
diff --git a/coin4/include/Inventor/draggers/SoDragger.h b/coin4/include/Inventor/draggers/SoDragger.h
index 4ce4a16..37efbf0 100644
--- a/coin4/include/Inventor/draggers/SoDragger.h
+++ b/coin4/include/Inventor/draggers/SoDragger.h
@@ -75,20 +75,20 @@ public:
   void setProjectorEpsilon(const float epsilon);
   float getProjectorEpsilon(void) const;
 
-  void addStartCallback(SoDraggerCB * func, void * data = NULL);
-  void removeStartCallback(SoDraggerCB * func, void * data = NULL);
-  void addMotionCallback(SoDraggerCB * func, void * data = NULL);
-  void removeMotionCallback(SoDraggerCB * func, void * data = NULL);
-  void addFinishCallback(SoDraggerCB * func, void * data = NULL);
-  void removeFinishCallback(SoDraggerCB * func, void * data = NULL);
-  void addValueChangedCallback(SoDraggerCB * func, void * data = NULL);
-  void removeValueChangedCallback(SoDraggerCB * func, void * data = NULL);
+  void addStartCallback(SoDraggerCB * func, void * data = nullptr);
+  void removeStartCallback(SoDraggerCB * func, void * data = nullptr);
+  void addMotionCallback(SoDraggerCB * func, void * data = nullptr);
+  void removeMotionCallback(SoDraggerCB * func, void * data = nullptr);
+  void addFinishCallback(SoDraggerCB * func, void * data = nullptr);
+  void removeFinishCallback(SoDraggerCB * func, void * data = nullptr);
+  void addValueChangedCallback(SoDraggerCB * func, void * data = nullptr);
+  void removeValueChangedCallback(SoDraggerCB * func, void * data = nullptr);
   void setMinGesture(int pixels);
   int getMinGesture(void) const;
   bool enableValueChangedCallbacks(bool newval);
   const SbMatrix & getMotionMatrix(void);
-  void addOtherEventCallback(SoDraggerCB * func, void * data = NULL);
-  void removeOtherEventCallback(SoDraggerCB * func, void * data = NULL);
+  void addOtherEventCallback(SoDraggerCB * func, void * data = nullptr);
+  void removeOtherEventCallback(SoDraggerCB * func, void * data = nullptr);
   void registerChildDragger(SoDragger * child);
   void unregisterChildDragger(SoDragger * child);
   void registerChildDraggerMovingIndependently(SoDragger * child);
@@ -131,9 +131,9 @@ public:
   static void workValuesIntoTransform(SbMatrix & mtx, const SbVec3f * translationptr, const SbRotation * rotationptr, const SbVec3f * scalefactorptr, const SbRotation * scaleorientationptr, const SbVec3f * centerptr);
   static void getTransformFast(SbMatrix & mtx, SbVec3f & translation, SbRotation & rotation, SbVec3f & scalefactor, SbRotation & scaleorientation, const SbVec3f & center);
   static void getTransformFast(SbMatrix & mtx, SbVec3f & translation, SbRotation & rotation, SbVec3f & scalefactor, SbRotation & scaleorientation);
-  static SbMatrix appendTranslation(const SbMatrix & mtx, const SbVec3f & translation, const SbMatrix * conversion = NULL);
-  static SbMatrix appendScale(const SbMatrix & mtx, const SbVec3f & scale, const SbVec3f & scalecenter, const SbMatrix * conversion = NULL);
-  static SbMatrix appendRotation(const SbMatrix & mtx, const SbRotation & rot, const SbVec3f & rotcenter, const SbMatrix * conversion = NULL);
+  static SbMatrix appendTranslation(const SbMatrix & mtx, const SbVec3f & translation, const SbMatrix * conversion = nullptr);
+  static SbMatrix appendScale(const SbMatrix & mtx, const SbVec3f & scale, const SbVec3f & scalecenter, const SbMatrix * conversion = nullptr);
+  static SbMatrix appendRotation(const SbMatrix & mtx, const SbRotation & rot, const SbVec3f & rotcenter, const SbMatrix * conversion = nullptr);
   static void initClass(void);
   static void initClasses(void);
 
diff --git a/coin4/include/Inventor/elements/SoGLDisplayList.h b/coin4/include/Inventor/elements/SoGLDisplayList.h
index b8dc42e..2d4d59d 100644
--- a/coin4/include/Inventor/elements/SoGLDisplayList.h
+++ b/coin4/include/Inventor/elements/SoGLDisplayList.h
@@ -40,7 +40,7 @@ public:
   SoGLDisplayList(SoState * state, Type type, int allocnum = 1,
                   bool mipmaptexobj = false);
   void ref(void);
-  void unref(SoState * state = NULL);
+  void unref(SoState * state = nullptr);
 
   void open(SoState *state, int index = 0);
   void close(SoState *state);
diff --git a/coin4/include/Inventor/elements/SoGLMultiTextureCoordinateElement.h b/coin4/include/Inventor/elements/SoGLMultiTextureCoordinateElement.h
index 0e6991e..f5d5631 100644
--- a/coin4/include/Inventor/elements/SoGLMultiTextureCoordinateElement.h
+++ b/coin4/include/Inventor/elements/SoGLMultiTextureCoordinateElement.h
@@ -47,9 +47,9 @@ public:
   static  void setTexGen(SoState * const state, SoNode * const node,
                          const int unit,
                          SoTexCoordTexgenCB * const texgenFunc,
-                         void * const texgenData = NULL,
-                         SoTextureCoordinateFunctionCB * const func = NULL,
-                         void * const funcData = NULL);
+                         void * const texgenData = nullptr,
+                         SoTextureCoordinateFunctionCB * const func = nullptr,
+                         void * const funcData = nullptr);
 
   virtual CoordType getType(const int unit = 0) const;
 
@@ -60,7 +60,7 @@ public:
 
   class GLUnitData {
   public:
-    GLUnitData() : texgenCB(NULL), texgenData(NULL) {}
+    GLUnitData() : texgenCB(nullptr), texgenData(nullptr) {}
     GLUnitData(const GLUnitData & org) : texgenCB(org.texgenCB), texgenData(org.texgenData) {}
     SoTexCoordTexgenCB * texgenCB;
     void * texgenData;
@@ -86,16 +86,16 @@ public:
   void initMulti(SoState * state) const;
   static  void setTexGen(SoState * const state, SoNode * const node,
                          SoTexCoordTexgenCB * const texgenFunc,
-                         void * const texgenData = NULL,
-                         SoTextureCoordinateFunctionCB * const func = NULL,
-                         void * const funcData = NULL) {
+                         void * const texgenData = nullptr,
+                         SoTextureCoordinateFunctionCB * const func = nullptr,
+                         void * const funcData = nullptr) {
     setTexGen(state, node, 0, texgenFunc, texgenData, func, funcData);
   }
 
 protected:
   virtual void setElt(const int unit,
                       SoTexCoordTexgenCB *func,
-                      void *data = NULL);
+                      void *data = nullptr);
 
 private:
   void doCallback(const int unit) const;
diff --git a/coin4/include/Inventor/elements/SoMultiTextureEnabledElement.h b/coin4/include/Inventor/elements/SoMultiTextureEnabledElement.h
index 8dc23d3..15b7860 100644
--- a/coin4/include/Inventor/elements/SoMultiTextureEnabledElement.h
+++ b/coin4/include/Inventor/elements/SoMultiTextureEnabledElement.h
@@ -74,7 +74,7 @@ public:
   // Coin-3 support
   static void set(SoState * state, 
                   const bool enabled) {
-    set(state, NULL, 0, enabled);
+    set(state, nullptr, 0, enabled);
   }
 
   static void set(SoState * state, SoNode * node,
diff --git a/coin4/include/Inventor/elements/SoSubElement.h b/coin4/include/Inventor/elements/SoSubElement.h
index 021578c..cedc853 100644
--- a/coin4/include/Inventor/elements/SoSubElement.h
+++ b/coin4/include/Inventor/elements/SoSubElement.h
@@ -111,7 +111,7 @@ void * _class_::createInstance(void) { return static_cast<void *>(new _class_);
 
 
 #define SO_ELEMENT_INIT_ABSTRACT_CLASS(_class_, _parent_) \
-  PRIVATE_SOELEMENT_INIT(_class_, _parent_, NULL)
+  PRIVATE_SOELEMENT_INIT(_class_, _parent_, nullptr)
 
 #define SO_ELEMENT_INIT_CLASS(_class_, _parent_) \
   PRIVATE_SOELEMENT_INIT(_class_, _parent_, &_class_::createInstance)
diff --git a/coin4/include/Inventor/engines/SoSubEngine.h b/coin4/include/Inventor/engines/SoSubEngine.h
index ecbea57..7a96c22 100644
--- a/coin4/include/Inventor/engines/SoSubEngine.h
+++ b/coin4/include/Inventor/engines/SoSubEngine.h
@@ -77,10 +77,10 @@ SoType _class_::classTypeId STATIC_SOTYPE_INIT
 PRIVATE_ENGINE_TYPESYSTEM_SOURCE(_class_); \
  \
 unsigned int _class_::classinstances = 0; \
-SoFieldData * _class_::inputdata = NULL; \
-const SoFieldData ** _class_::parentinputdata = NULL; \
-SoEngineOutputData * _class_::outputdata = NULL; \
-const SoEngineOutputData ** _class_::parentoutputdata = NULL; \
+SoFieldData * _class_::inputdata = nullptr; \
+const SoFieldData ** _class_::parentinputdata = nullptr; \
+SoEngineOutputData * _class_::outputdata = nullptr; \
+const SoEngineOutputData ** _class_::parentoutputdata = nullptr; \
  \
 const SoFieldData ** \
 _class_::getInputDataPtr(void) \
@@ -111,10 +111,10 @@ _class_::atexit_cleanup(void) \
 { \
   delete _class_::inputdata; \
   delete _class_::outputdata; \
-  _class_::inputdata = NULL; \
-  _class_::outputdata = NULL; \
-  _class_::parentinputdata = NULL; \
-  _class_::parentoutputdata = NULL; \
+  _class_::inputdata = nullptr; \
+  _class_::outputdata = nullptr; \
+  _class_::parentinputdata = nullptr; \
+  _class_::parentoutputdata = nullptr; \
   assert(_class_::classTypeId != SoType::badType()); \
   SoType::removeType(_class_::classTypeId.getName()); \
   _class_::classTypeId STATIC_SOTYPE_INIT; \
@@ -145,10 +145,10 @@ _class_::createInstance(void) \
     if (!_class_::inputdata) { \
       _class_::inputdata = \
         new SoFieldData(_class_::parentinputdata ? \
-                        *_class_::parentinputdata : NULL); \
+                        *_class_::parentinputdata : nullptr); \
       _class_::outputdata = \
         new SoEngineOutputData(_class_::parentoutputdata ? \
-                               *_class_::parentoutputdata : NULL); \
+                               *_class_::parentoutputdata : nullptr); \
     } \
     /* Extension classes from the application programmers should not be */ \
     /* considered native. This is important to get the export code to do */ \
@@ -189,7 +189,7 @@ _class_::createInstance(void) \
 #define SO_ENGINE_INIT_ABSTRACT_CLASS(_class_, _parentclass_, _parentname_) \
   do { \
     const char * classname = SO__QUOTE(_class_); \
-    PRIVATE_COMMON_ENGINE_INIT_CODE(_class_, classname, NULL, _parentclass_); \
+    PRIVATE_COMMON_ENGINE_INIT_CODE(_class_, classname, nullptr, _parentclass_); \
   } while (0)
 
 // *************************************************************************
diff --git a/coin4/include/Inventor/engines/SoSubNodeEngine.h b/coin4/include/Inventor/engines/SoSubNodeEngine.h
index 133ef84..6edb4f7 100644
--- a/coin4/include/Inventor/engines/SoSubNodeEngine.h
+++ b/coin4/include/Inventor/engines/SoSubNodeEngine.h
@@ -45,8 +45,8 @@ private: \
 
 #define SO_NODEENGINE_ABSTRACT_SOURCE(_class_) \
 SO_NODE_ABSTRACT_SOURCE(_class_); \
-SoEngineOutputData * _class_::outputdata = NULL; \
-const SoEngineOutputData ** _class_::parentoutputdata = NULL; \
+SoEngineOutputData * _class_::outputdata = nullptr; \
+const SoEngineOutputData ** _class_::parentoutputdata = nullptr; \
  \
 const SoEngineOutputData ** \
 _class_::getOutputDataPtr(void) \
@@ -63,8 +63,8 @@ _class_::getOutputData(void) const \
 void \
 _class_::atexit_cleanupnodeengine(void) { \
   delete _class_::outputdata; \
-  _class_::outputdata = NULL; \
-  _class_::parentoutputdata = NULL; \
+  _class_::outputdata = nullptr; \
+  _class_::parentoutputdata = nullptr; \
   _class_::classTypeId STATIC_SOTYPE_INIT; \
 }
 
@@ -87,10 +87,10 @@ _class_::createInstance(void) \
     if (!_class_::fieldData) { \
       _class_::fieldData = \
         new SoFieldData(_class_::parentFieldData ? \
-                        *_class_::parentFieldData : NULL); \
+                        *_class_::parentFieldData : nullptr); \
       _class_::outputdata = \
         new SoEngineOutputData(_class_::parentoutputdata ? \
-                               *_class_::parentoutputdata : NULL); \
+                               *_class_::parentoutputdata : nullptr); \
     } \
     /* Extension classes from the application programmers should not be */ \
     /* considered native. This is important to get the export code to do */ \
@@ -131,7 +131,7 @@ _class_::createInstance(void) \
 #define SO_NODEENGINE_INIT_ABSTRACT_CLASS(_class_, _parentclass_, _parentname_) \
   do { \
     const char * classname = SO__QUOTE(_class_); \
-    PRIVATE_COMMON_INIT_CODE(_class_, classname, NULL, _parentclass_); \
+    PRIVATE_COMMON_INIT_CODE(_class_, classname, nullptr, _parentclass_); \
   } while (0)
 
 #define SO_NODEENGINE_ADD_OUTPUT(_output_, _type_) \
diff --git a/coin4/include/Inventor/fields/SoSubField.h b/coin4/include/Inventor/fields/SoSubField.h
index bab61a9..ac6f57a 100644
--- a/coin4/include/Inventor/fields/SoSubField.h
+++ b/coin4/include/Inventor/fields/SoSubField.h
@@ -282,7 +282,7 @@ public: \
 _class_::_class_(void) \
 { \
   assert(_class_::classTypeId != SoType::badType()); \
-  this->values = NULL; \
+  this->values = nullptr; \
 } \
  \
 _class_::~_class_(void) \
@@ -424,7 +424,7 @@ _class_::allocValues(int newnum) \
   this->setChangedIndices(); \
   if (newnum == 0) { \
     if (!this->userDataIsUsed) delete[] this->values; /* don't fetch pointer through valuesPtr() (avoids void* cast) */ \
-    this->setValuesPtr(NULL); \
+    this->setValuesPtr(nullptr); \
     this->maxNum = 0; \
     this->userDataIsUsed = false; \
   } \
diff --git a/coin4/include/Inventor/lists/SbList.h b/coin4/include/Inventor/lists/SbList.h
index 02e5a56..45f49b8 100644
--- a/coin4/include/Inventor/lists/SbList.h
+++ b/coin4/include/Inventor/lists/SbList.h
@@ -25,7 +25,6 @@
 \**************************************************************************/
 
 #include <assert.h>
-#include <stddef.h> // NULL definition
 
 // We usually implement inline functions below the class definition,
 // since we think that makes the file more readable. However, this is
diff --git a/coin4/include/Inventor/lists/SbPList.h b/coin4/include/Inventor/lists/SbPList.h
index 70cf5e9..b85574e 100644
--- a/coin4/include/Inventor/lists/SbPList.h
+++ b/coin4/include/Inventor/lists/SbPList.h
@@ -26,7 +26,6 @@
 
 #include <Inventor/SbBasic.h>
 #include <assert.h>
-#include <stddef.h> // NULL definition
 
 class COIN_DLL_API SbPList {
   enum { DEFAULTSIZE = 4 };
diff --git a/coin4/include/Inventor/lists/SoAuditorList.h b/coin4/include/Inventor/lists/SoAuditorList.h
index 048b433..cc02813 100644
--- a/coin4/include/Inventor/lists/SoAuditorList.h
+++ b/coin4/include/Inventor/lists/SoAuditorList.h
@@ -66,7 +66,7 @@ private:
   // that they need to be rewritten to behave correctly.
   SoAuditorList(const int) { }
   SoAuditorList(const SoAuditorList & l) : SbPList(l) { }
-  void * get(const int) const { return NULL; }
+  void * get(const int) const { return nullptr; }
   void set(const int, void * const) { }
   void copy(const SbPList &) { }
   void append(const void *) { }
@@ -75,11 +75,11 @@ private:
   void removeFast(const int) { }
   void truncate(const int, const int = 0) { }
   void push(const void *) { }
-  void * pop(void) { return NULL; }
+  void * pop(void) { return nullptr; }
   SbPList & operator=(const SbPList &) { return *this; }
-  operator void ** (void) { return static_cast<void **> (NULL); }
-  operator const void ** (void) const { return static_cast<const void **>(NULL); }
-  void * operator[](const int) const { return NULL; }
+  operator void ** (void) { return static_cast<void **> (nullptr); }
+  operator const void ** (void) const { return static_cast<const void **>(nullptr); }
+  void * operator[](const int) const { return nullptr; }
   void * & operator[](const int) { return SbPList::operator[](0); }
   bool operator==(const SbPList &) const { return 0; }
   bool operator!=(const SbPList &) const { return 0; }
diff --git a/coin4/include/Inventor/lists/SoCallbackList.h b/coin4/include/Inventor/lists/SoCallbackList.h
index 8777ecc..19cacfe 100644
--- a/coin4/include/Inventor/lists/SoCallbackList.h
+++ b/coin4/include/Inventor/lists/SoCallbackList.h
@@ -37,8 +37,8 @@ public:
   SoCallbackList(void);
   ~SoCallbackList();
 
-  void addCallback(SoCallbackListCB * f, void * userData = NULL);
-  void removeCallback(SoCallbackListCB * f, void * userdata = NULL);
+  void addCallback(SoCallbackListCB * f, void * userData = nullptr);
+  void removeCallback(SoCallbackListCB * f, void * userdata = nullptr);
 
   void clearCallbacks(void);
   int getNumCallbacks(void) const;
diff --git a/coin4/include/Inventor/misc/SoGLBigImage.h b/coin4/include/Inventor/misc/SoGLBigImage.h
index 0d2c77c..d6608f2 100644
--- a/coin4/include/Inventor/misc/SoGLBigImage.h
+++ b/coin4/include/Inventor/misc/SoGLBigImage.h
@@ -35,7 +35,7 @@ class COIN_DLL_API SoGLBigImage : public SoGLImage {
 public:
 
   SoGLBigImage();
-  virtual void unref(SoState * state = NULL);
+  virtual void unref(SoState * state = nullptr);
 
   static SoType getClassTypeId(void);
   virtual SoType getTypeId(void) const ;
@@ -45,7 +45,7 @@ public:
                        const Wrap wrapt = REPEAT,
                        const float quality = 0.5f,
                        const int border = 0,
-                       SoState * createinstate = NULL);
+                       SoState * createinstate = nullptr);
 
   virtual void setData(const SbImage * image,
                        const Wrap wraps,
@@ -53,7 +53,7 @@ public:
                        const Wrap wrapr,
                        const float quality = 0.5f,
                        const int border = 0,
-                       SoState * createinstate = NULL);
+                       SoState * createinstate = nullptr);
 
   int initSubImages(const SbVec2s & subimagesize) const;
   void handleSubImage(const int idx, SbVec2f & start, SbVec2f & end,
@@ -63,7 +63,7 @@ public:
   bool exceededChangeLimit(void);
   static int setChangeLimit(const int limit);
 
-  // will return NULL to avoid that SoGLTextureImageElement will
+  // will return nullptr to avoid that SoGLTextureImageElement will
   // update the texture state.
   virtual SoGLDisplayList * getGLDisplayList(SoState * state);
 
diff --git a/coin4/include/Inventor/misc/SoGLCubeMapImage.h b/coin4/include/Inventor/misc/SoGLCubeMapImage.h
index a928fb5..f839161 100644
--- a/coin4/include/Inventor/misc/SoGLCubeMapImage.h
+++ b/coin4/include/Inventor/misc/SoGLCubeMapImage.h
@@ -33,7 +33,7 @@ class COIN_DLL_API SoGLCubeMapImage : public SoGLImage {
 public:
 
   SoGLCubeMapImage();
-  virtual void unref(SoState * state = NULL);
+  virtual void unref(SoState * state = nullptr);
 
   static SoType getClassTypeId(void);
   virtual SoType getTypeId(void) const ;
@@ -57,7 +57,7 @@ public:
                        const Wrap wrapt = REPEAT,
                        const float quality = 0.5f,
                        const int border = 0,
-                       SoState * createinstate = NULL);
+                       SoState * createinstate = nullptr);
 
   virtual void setData(const SbImage * image,
                        const Wrap wraps,
@@ -65,7 +65,7 @@ public:
                        const Wrap wrapr,
                        const float quality = 0.5f,
                        const int border = 0,
-                       SoState * createinstate = NULL);
+                       SoState * createinstate = nullptr);
 
   virtual SoGLDisplayList * getGLDisplayList(SoState * state);
 
diff --git a/coin4/include/Inventor/misc/SoGLImage.h b/coin4/include/Inventor/misc/SoGLImage.h
index a2ae1a3..a3d216a 100644
--- a/coin4/include/Inventor/misc/SoGLImage.h
+++ b/coin4/include/Inventor/misc/SoGLImage.h
@@ -45,7 +45,7 @@ class COIN_DLL_API SoGLImage {
 public:
 
   SoGLImage();
-  virtual void unref(SoState * state = NULL);
+  virtual void unref(SoState * state = nullptr);
 
   static SoType getClassTypeId(void);
   virtual SoType getTypeId(void) const ;
@@ -90,7 +90,7 @@ public:
                const Wrap wrapt = REPEAT,
                const float quality = 0.5f,
                const int border = 0,
-               SoState * createinstate = NULL);
+               SoState * createinstate = nullptr);
 
   void setData(const unsigned char * bytes,
                const SbVec3s & size,
@@ -100,14 +100,14 @@ public:
                const Wrap wrapr = REPEAT,
                const float quality = 0.5f,
                const int border = 0,
-               SoState * createinstate = NULL);
+               SoState * createinstate = nullptr);
 
   virtual void setData(const SbImage * image,
                        const Wrap wraps = REPEAT,
                        const Wrap wrapt = REPEAT,
                        const float quality = 0.5f,
                        const int border = 0,
-                       SoState * createinstate = NULL);
+                       SoState * createinstate = nullptr);
 
   virtual void setData(const SbImage * image,
                        const Wrap wraps,
@@ -115,7 +115,7 @@ public:
                        const Wrap wrapr,
                        const float quality = 0.5f,
                        const int border = 0,
-                       SoState * createinstate = NULL);
+                       SoState * createinstate = nullptr);
 
   // these flags can be used to set texture properties.
   enum Flags {
@@ -179,7 +179,7 @@ public:
   static void tagImage(SoState * state, SoGLImage * image);
   static void endFrame(SoState * state);
   static void setDisplayListMaxAge(const uint32_t maxage);
-  static void freeAllImages(SoState * state = NULL);
+  static void freeAllImages(SoState * state = nullptr);
 
   void setEndFrameCallback(void (*cb)(void *), void * closure);
   int getNumFramesSinceUsed(void) const;
diff --git a/coin4/include/Inventor/misc/SoJavaScriptEngine.h b/coin4/include/Inventor/misc/SoJavaScriptEngine.h
index b723def..abbca5b 100644
--- a/coin4/include/Inventor/misc/SoJavaScriptEngine.h
+++ b/coin4/include/Inventor/misc/SoJavaScriptEngine.h
@@ -51,7 +51,7 @@ public:
   virtual bool executeFile(const SbName & filename) const;
   virtual bool executeFunction(const SbName &name, int argc, 
                                  const SoField * argv, 
-                                 SoField * rval = NULL) const;
+                                 SoField * rval = nullptr) const;
 
   virtual bool setScriptField(const SbName & name, const SoField * f) const;
   virtual bool unsetScriptField(const SbName & name) const;
diff --git a/coin4/include/Inventor/misc/SoNormalGenerator.h b/coin4/include/Inventor/misc/SoNormalGenerator.h
index fdff674..bdb3118 100644
--- a/coin4/include/Inventor/misc/SoNormalGenerator.h
+++ b/coin4/include/Inventor/misc/SoNormalGenerator.h
@@ -49,7 +49,7 @@ public:
             const SbVec3f &v3);
 
   void generate(const float creaseAngle,
-                const int32_t * striplens = NULL,
+                const int32_t * striplens = nullptr,
                 const int numstrips = 0);
 
   void generatePerStrip(const int32_t * striplens,
diff --git a/coin4/include/Inventor/misc/SoScriptEngine.h b/coin4/include/Inventor/misc/SoScriptEngine.h
index 782d9da..483b160 100644
--- a/coin4/include/Inventor/misc/SoScriptEngine.h
+++ b/coin4/include/Inventor/misc/SoScriptEngine.h
@@ -41,7 +41,7 @@ public:
   virtual bool executeFile(const SbName & filename) const = 0;
   virtual bool executeFunction(const SbName & name, int argc, 
                                  const SoField * argv, 
-                                 SoField * rval = NULL) const = 0;
+                                 SoField * rval = nullptr) const = 0;
 
   virtual bool setScriptField(const SbName & name, 
                                 const SoField * f) const = 0;
diff --git a/coin4/include/Inventor/misc/SoState.h b/coin4/include/Inventor/misc/SoState.h
index 1cc0ff3..c67194e 100644
--- a/coin4/include/Inventor/misc/SoState.h
+++ b/coin4/include/Inventor/misc/SoState.h
@@ -69,7 +69,7 @@ private:
 inline bool
 SoState::isElementEnabled(const int stackindex) const
 {
-  return (stackindex < this->numstacks) && (this->stack[stackindex] != NULL);
+  return (stackindex < this->numstacks) && (this->stack[stackindex] != nullptr);
 }
 
 inline const SoElement *
diff --git a/coin4/include/Inventor/nodekits/SoBaseKit.h b/coin4/include/Inventor/nodekits/SoBaseKit.h
index a047069..cd30d99 100644
--- a/coin4/include/Inventor/nodekits/SoBaseKit.h
+++ b/coin4/include/Inventor/nodekits/SoBaseKit.h
@@ -72,7 +72,7 @@ public:
   SbString getPartString(const SoBase * part);
   virtual SoNodeKitPath * createPathToPart(const SbName & partname,
                                            bool makeifneeded,
-                                           const SoPath * pathtoextend = NULL);
+                                           const SoPath * pathtoextend = nullptr);
   virtual bool setPart(const SbName & partname, SoNode * from);
   bool set(const char * namevaluepairliststring);
   bool set(const char * partnamestring, const char * parameterstring);
@@ -118,7 +118,7 @@ protected:
                                               bool makeifneeded,
                                               bool leafcheck = false,
                                               bool publiccheck = false,
-                                              const SoPath * pathtoextend = NULL);
+                                              const SoPath * pathtoextend = nullptr);
   virtual bool setAnyPart(const SbName & partname, SoNode * from,
                             bool anypart = true);
   void createNodekitPartsList(void); // not part of Coin
@@ -142,7 +142,7 @@ private:
   friend class SoInteractionKit;
   static bool findPart(const SbString & partname, SoBaseKit *& kit,
                          int & partnum, bool & islist, int & listidx,
-                         const bool makeifneeded, SoPath * path = NULL,
+                         const bool makeifneeded, SoPath * path = nullptr,
                          const bool recsearch = false);
   static void atexit_cleanupkit(void);
 
diff --git a/coin4/include/Inventor/nodekits/SoSubKit.h b/coin4/include/Inventor/nodekits/SoSubKit.h
index c045d69..8b010dc 100644
--- a/coin4/include/Inventor/nodekits/SoSubKit.h
+++ b/coin4/include/Inventor/nodekits/SoSubKit.h
@@ -64,8 +64,8 @@ protected: SoSFNode _entry_
 
 
 #define PRIVATE_KIT_SOURCE(_class_) \
-SoNodekitCatalog * _class_::classcatalog = NULL; \
-const SoNodekitCatalog ** _class_::parentcatalogptr = NULL; \
+SoNodekitCatalog * _class_::classcatalog = nullptr; \
+const SoNodekitCatalog ** _class_::parentcatalogptr = nullptr; \
  \
 const SoNodekitCatalog * \
 _class_::getClassNodekitCatalog(void) \
@@ -89,8 +89,8 @@ void \
 _class_::atexit_cleanupkit(void) \
 { \
    delete _class_::classcatalog; \
-  _class_::classcatalog = NULL; \
-  _class_::parentcatalogptr = NULL; \
+  _class_::classcatalog = nullptr; \
+  _class_::parentcatalogptr = nullptr; \
 }
 
 #define SO_KIT_SOURCE(_class_) \
@@ -121,7 +121,7 @@ PRIVATE_KIT_SOURCE(_class_)
   do { \
     SO_NODE_CONSTRUCTOR(_class_); \
     SoBase::staticDataLock(); \
-    if (_class_::classcatalog == NULL) { \
+    if (_class_::classcatalog == nullptr) { \
       SoType mytype = SoType::fromName(SO__QUOTE(_class_)); \
       _class_::classcatalog = (*_class_::parentcatalogptr)->clone(mytype); \
       cc_coin_atexit_static_internal(_class_::atexit_cleanupkit); \
@@ -143,7 +143,7 @@ PRIVATE_KIT_SOURCE(_class_)
                            SoType::badType(), \
                            SoType::badType(), \
                            _ispublic_); \
-    SO_NODE_ADD_FIELD(_part_,(NULL)); \
+    SO_NODE_ADD_FIELD(_part_,(nullptr)); \
   } while (0)
 
 
@@ -160,7 +160,7 @@ PRIVATE_KIT_SOURCE(_class_)
                            _containertype_::getClassTypeId(), \
                            _itemtype_::getClassTypeId(), \
                            _ispublic_); \
-    SO_NODE_ADD_FIELD(_part_,(NULL)); \
+    SO_NODE_ADD_FIELD(_part_,(nullptr)); \
   } while (0)
 
 
@@ -177,7 +177,7 @@ PRIVATE_KIT_SOURCE(_class_)
                            SoType::badType(), \
                            SoType::badType(), \
                            _ispublic_); \
-    SO_NODE_ADD_FIELD(_part_,(NULL)); \
+    SO_NODE_ADD_FIELD(_part_,(nullptr)); \
   } while (0)
 
 
diff --git a/coin4/include/Inventor/nodes/SoCallback.h b/coin4/include/Inventor/nodes/SoCallback.h
index 3c0ced0..ca61ebf 100644
--- a/coin4/include/Inventor/nodes/SoCallback.h
+++ b/coin4/include/Inventor/nodes/SoCallback.h
@@ -37,7 +37,7 @@ public:
   static void initClass(void);
   SoCallback(void);
 
-  void setCallback(SoCallbackCB * function, void * userdata = NULL);
+  void setCallback(SoCallbackCB * function, void * userdata = nullptr);
 
   virtual void doAction(SoAction * action);
   virtual void callback(SoCallbackAction * action);
diff --git a/coin4/include/Inventor/nodes/SoEventCallback.h b/coin4/include/Inventor/nodes/SoEventCallback.h
index 9daa65e..24f786f 100644
--- a/coin4/include/Inventor/nodes/SoEventCallback.h
+++ b/coin4/include/Inventor/nodes/SoEventCallback.h
@@ -53,9 +53,9 @@ public:
   const SoPath * getPath(void);
 
   void addEventCallback(SoType eventtype, SoEventCallbackCB * f,
-                        void * userdata = NULL);
+                        void * userdata = nullptr);
   void removeEventCallback(SoType eventtype, SoEventCallbackCB * f,
-                           void * userdata = NULL);
+                           void * userdata = nullptr);
 
   SoHandleEventAction * getAction(void) const;
   const SoEvent * getEvent(void) const;
diff --git a/coin4/include/Inventor/nodes/SoExtSelection.h b/coin4/include/Inventor/nodes/SoExtSelection.h
index 28f152c..d131e5d 100644
--- a/coin4/include/Inventor/nodes/SoExtSelection.h
+++ b/coin4/include/Inventor/nodes/SoExtSelection.h
@@ -27,7 +27,6 @@
 #include <Inventor/nodes/SoSubNode.h>
 #include <Inventor/nodes/SoSelection.h>
 #include <Inventor/fields/SoSFEnum.h>
-#include <stddef.h> // NULL
 
 #ifndef COIN_INTERNAL
 #include <Inventor/actions/SoCallbackAction.h>
@@ -115,15 +114,15 @@ public:
   const SbVec3f * getLassoCoordsWC(int & numCoords);
   const SoPathList & getSelectionPathList() const;
 
-  void setLassoFilterCallback(SoLassoSelectionFilterCB * f, void * userdata = NULL,
+  void setLassoFilterCallback(SoLassoSelectionFilterCB * f, void * userdata = nullptr,
                               const bool callonlyifselectable = true);
 
   void setTriangleFilterCallback(SoExtSelectionTriangleCB * func,
-                                 void * userdata = NULL);
+                                 void * userdata = nullptr);
   void setLineSegmentFilterCallback(SoExtSelectionLineSegmentCB * func,
-                                    void * userdata = NULL);
+                                    void * userdata = nullptr);
   void setPointFilterCallback(SoExtSelectionPointCB * func,
-                              void * userdata = NULL);
+                              void * userdata = nullptr);
   bool wasShiftDown(void) const;
 
 protected:
diff --git a/coin4/include/Inventor/nodes/SoGroup.h b/coin4/include/Inventor/nodes/SoGroup.h
index 9ea582c..4f0a5d3 100644
--- a/coin4/include/Inventor/nodes/SoGroup.h
+++ b/coin4/include/Inventor/nodes/SoGroup.h
@@ -75,8 +75,8 @@ protected:
   virtual SoNotRec createNotRec(void);
 
   void setOperation(const SoNotRec::OperationType opType = SoNotRec::UNSPECIFIED,
-		    const SoNode * cc = NULL,
-		    const SoNode * pc = NULL,
+		    const SoNode * cc = nullptr,
+		    const SoNode * pc = nullptr,
 		    const int ci = -1);
 
   SoChildList * children;
diff --git a/coin4/include/Inventor/nodes/SoSelection.h b/coin4/include/Inventor/nodes/SoSelection.h
index 9aa14c8..edc74a0 100644
--- a/coin4/include/Inventor/nodes/SoSelection.h
+++ b/coin4/include/Inventor/nodes/SoSelection.h
@@ -69,22 +69,22 @@ public:
   const SoPathList * getList(void) const;
   SoPath * getPath(const int index) const;
   SoPath * operator[](const int i) const;
-  void addSelectionCallback(SoSelectionPathCB * f, void * userData = NULL);
-  void removeSelectionCallback(SoSelectionPathCB * f, void * userData = NULL);
-  void addDeselectionCallback(SoSelectionPathCB * f, void * userData = NULL);
+  void addSelectionCallback(SoSelectionPathCB * f, void * userData = nullptr);
+  void removeSelectionCallback(SoSelectionPathCB * f, void * userData = nullptr);
+  void addDeselectionCallback(SoSelectionPathCB * f, void * userData = nullptr);
   void removeDeselectionCallback(SoSelectionPathCB * f,
-                                 void * userData = NULL);
-  void addStartCallback(SoSelectionClassCB * f, void * userData = NULL);
-  void removeStartCallback(SoSelectionClassCB * f, void * userData = NULL);
-  void addFinishCallback(SoSelectionClassCB * f, void * userData = NULL);
-  void removeFinishCallback(SoSelectionClassCB * f, void * userData = NULL);
-  void setPickFilterCallback(SoSelectionPickCB * f, void * userData = NULL,
+                                 void * userData = nullptr);
+  void addStartCallback(SoSelectionClassCB * f, void * userData = nullptr);
+  void removeStartCallback(SoSelectionClassCB * f, void * userData = nullptr);
+  void addFinishCallback(SoSelectionClassCB * f, void * userData = nullptr);
+  void removeFinishCallback(SoSelectionClassCB * f, void * userData = nullptr);
+  void setPickFilterCallback(SoSelectionPickCB * f, void * userData = nullptr,
                              const bool callOnlyIfSelectable = true);
   void setPickMatching(const bool pickMatching);
   bool isPickMatching(void) const;
   bool getPickMatching(void) const;
-  void addChangeCallback(SoSelectionClassCB * f, void * userData = NULL);
-  void removeChangeCallback(SoSelectionClassCB * f, void * userData = NULL);
+  void addChangeCallback(SoSelectionClassCB * f, void * userData = nullptr);
+  void removeChangeCallback(SoSelectionClassCB * f, void * userData = nullptr);
 
 protected:
   virtual ~SoSelection();
diff --git a/coin4/include/Inventor/nodes/SoShape.h b/coin4/include/Inventor/nodes/SoShape.h
index 01dbfb6..d9c910e 100644
--- a/coin4/include/Inventor/nodes/SoShape.h
+++ b/coin4/include/Inventor/nodes/SoShape.h
@@ -109,7 +109,7 @@ protected:
   void invokePointCallbacks(SoAction * const action,
                             const SoPrimitiveVertex * const v);
   void beginShape(SoAction * const action, const TriangleShape shapetype,
-                  SoDetail * const detail = NULL);
+                  SoDetail * const detail = nullptr);
   void shapeVertex(const SoPrimitiveVertex * const v);
   void endShape(void);
 
diff --git a/coin4/include/Inventor/nodes/SoSubNode.h b/coin4/include/Inventor/nodes/SoSubNode.h
index cfc75a6..8208a41 100644
--- a/coin4/include/Inventor/nodes/SoSubNode.h
+++ b/coin4/include/Inventor/nodes/SoSubNode.h
@@ -95,8 +95,8 @@ SoType _class_::classTypeId STATIC_SOTYPE_INIT
 PRIVATE_NODE_TYPESYSTEM_SOURCE(_class_); \
  \
 unsigned int _class_::classinstances = 0; \
-const SoFieldData ** _class_::parentFieldData = NULL; \
-SoFieldData * _class_::fieldData = NULL; \
+const SoFieldData ** _class_::parentFieldData = nullptr; \
+SoFieldData * _class_::fieldData = nullptr; \
  \
 const SoFieldData ** \
 _class_::getFieldDataPtr(void) \
@@ -114,8 +114,8 @@ void \
 _class_::atexit_cleanup(void) \
 { \
   delete _class_::fieldData; \
-  _class_::fieldData = NULL; \
-  _class_::parentFieldData = NULL; \
+  _class_::fieldData = nullptr; \
+  _class_::parentFieldData = nullptr; \
   SoType::removeType(_class_::classTypeId.getName()); \
   _class_::classTypeId STATIC_SOTYPE_INIT; \
   _class_::classinstances = 0; \
@@ -152,7 +152,7 @@ _class_::createInstance(void) \
       /* Internal Coin nodes are handled properly though. pederb, 20041122 */ \
       _class_::fieldData = \
         new SoFieldData(_class_::parentFieldData ? \
-                        *_class_::parentFieldData : NULL); \
+                        *_class_::parentFieldData : nullptr); \
     } \
     /* Extension classes from the application programmers should not be \
        considered native. This is important to get the export code to do \
@@ -214,7 +214,7 @@ _class_::createInstance(void) \
 #define SO_NODE_INIT_ABSTRACT_CLASS(_class_, _parentclass_, _parentname_) \
   do { \
     const char * classname = SO__QUOTE(_class_); \
-    PRIVATE_COMMON_INIT_CODE(_class_, classname, NULL, _parentclass_); \
+    PRIVATE_COMMON_INIT_CODE(_class_, classname, nullptr, _parentclass_); \
   } while (0)
 
 
diff --git a/coin4/include/Inventor/nodes/SoTexture3.h b/coin4/include/Inventor/nodes/SoTexture3.h
index 17c0cc1..449214f 100644
--- a/coin4/include/Inventor/nodes/SoTexture3.h
+++ b/coin4/include/Inventor/nodes/SoTexture3.h
@@ -78,7 +78,7 @@ protected:
   void setReadStatus(int s);
 
 private:
-  bool loadFilenames(SoInput * in = NULL);
+  bool loadFilenames(SoInput * in = nullptr);
   int readstatus;
   class SoGLImage *glimage;
   bool glimagevalid;
diff --git a/coin4/include/Inventor/scxml/ScXMLEventTarget.h b/coin4/include/Inventor/scxml/ScXMLEventTarget.h
index 6b9fd8b..037195e 100644
--- a/coin4/include/Inventor/scxml/ScXMLEventTarget.h
+++ b/coin4/include/Inventor/scxml/ScXMLEventTarget.h
@@ -78,10 +78,10 @@ protected:
 
   virtual bool processOneEvent(const ScXMLEvent * event);
 
-  static void registerEventTarget(ScXMLEventTarget * target, const char * sessionid = NULL);
-  static void unregisterEventTarget(ScXMLEventTarget * target, const char * sessionid = NULL);
+  static void registerEventTarget(ScXMLEventTarget * target, const char * sessionid = nullptr);
+  static void unregisterEventTarget(ScXMLEventTarget * target, const char * sessionid = nullptr);
 
-  static ScXMLEventTarget * getEventTarget(const char * targettype, const char * targetname, const char * sessionid = NULL);
+  static ScXMLEventTarget * getEventTarget(const char * targettype, const char * targetname, const char * sessionid = nullptr);
 
 private:
   ScXMLEventTarget(const ScXMLEventTarget & rhs); // N/A
diff --git a/coin4/include/Inventor/scxml/ScXMLSubObject.h b/coin4/include/Inventor/scxml/ScXMLSubObject.h
index ac5af52..b972a92 100644
--- a/coin4/include/Inventor/scxml/ScXMLSubObject.h
+++ b/coin4/include/Inventor/scxml/ScXMLSubObject.h
@@ -106,7 +106,7 @@ classname::getClassTypeId(void)                                 \
   SCXML_OBJECT_ABSTRACT_SOURCE(classname)
 
 #define SCXML_ELEMENT_SOURCE(classname)                         \
-ScXMLEltReader * classname::elementReader = NULL;               \
+ScXMLEltReader * classname::elementReader = nullptr;            \
                                                                 \
 ScXMLEltReader *                                                \
 classname::getElementReader(void)                               \
@@ -136,10 +136,10 @@ classname::getElementReader(void)                               \
     thisclass::elementReader = new classname;                           \
   } while ( false )
 
-#define SCXML_ELEMENT_UNREGISTER_READER(thisclass) \
+#define SCXML_ELEMENT_UNREGISTER_READER(thisclass)                      \
   do {                                                                  \
     delete thisclass::elementReader;                                    \
-    thisclass::elementReader = NULL;                                    \
+    thisclass::elementReader = nullptr;                                 \
   } while ( false )
 
 // *************************************************************************
diff --git a/coin4/include/Inventor/sensors/SoDataSensor.h b/coin4/include/Inventor/sensors/SoDataSensor.h
index 560ca6a..6391310 100644
--- a/coin4/include/Inventor/sensors/SoDataSensor.h
+++ b/coin4/include/Inventor/sensors/SoDataSensor.h
@@ -26,7 +26,6 @@
 
 #include <Inventor/sensors/SoDelayQueueSensor.h>
 #include <Inventor/misc/SoNotRec.h>
-#include <stdlib.h> // for NULL definition
 
 class SoNode;
 class SoField;
@@ -41,7 +40,7 @@ public:
   SoDataSensor(SoSensorCB * func, void * data);
   virtual ~SoDataSensor(void);
 
-  void setDeleteCallback(SoSensorCB * function, void * data = NULL);
+  void setDeleteCallback(SoSensorCB * function, void * data = nullptr);
   SoNode * getTriggerNode(void) const;
   SoField * getTriggerField(void) const;
   SoPath * getTriggerPath(void) const;
diff --git a/coin4/include/Inventor/threads/SbThreadAutoLock.h b/coin4/include/Inventor/threads/SbThreadAutoLock.h
index 83e21ed..b2f31cf 100644
--- a/coin4/include/Inventor/threads/SbThreadAutoLock.h
+++ b/coin4/include/Inventor/threads/SbThreadAutoLock.h
@@ -37,12 +37,12 @@ public:
   SbThreadAutoLock(SbMutex * mutexptr) {
     this->mutex = mutexptr;
     this->mutex->lock();
-    this->recmutex = NULL;
+    this->recmutex = nullptr;
   }
   SbThreadAutoLock(SbThreadMutex * mutexptr) {
     this->recmutex = mutexptr;
     this->recmutex->lock();
-    this->mutex = NULL;
+    this->mutex = nullptr;
   }
 
   ~SbThreadAutoLock() {
diff --git a/coin4/include/Inventor/tools/SbLazyPimplPtr.hpp b/coin4/include/Inventor/tools/SbLazyPimplPtr.hpp
index 834efa7..bd09525 100644
--- a/coin4/include/Inventor/tools/SbLazyPimplPtr.hpp
+++ b/coin4/include/Inventor/tools/SbLazyPimplPtr.hpp
@@ -32,7 +32,7 @@
 
 template <typename T>
 SbLazyPimplPtr<T>::SbLazyPimplPtr(void)
-: ptr(NULL)
+: ptr(nullptr)
 {
 }
 
@@ -51,7 +51,7 @@ SbLazyPimplPtr<T>::SbLazyPimplPtr(const SbLazyPimplPtr<T> & copy)
 template <typename T>
 SbLazyPimplPtr<T>::~SbLazyPimplPtr(void)
 {
-  this->set(NULL);
+  this->set(nullptr);
 }
 
 template <typename T>
@@ -68,7 +68,7 @@ template <typename T>
 T &
 SbLazyPimplPtr<T>::get(void) const
 {
-  if (this->ptr == NULL) {
+  if (this->ptr == nullptr) {
     this->ptr = this->getNew();
   }
   return *(this->ptr);
diff --git a/coin4/src/3ds/3dsLoader.cpp b/coin4/src/3ds/3dsLoader.cpp
index 0dac910..317d630 100644
--- a/coin4/src/3ds/3dsLoader.cpp
+++ b/coin4/src/3ds/3dsLoader.cpp
@@ -389,8 +389,8 @@ typedef struct tagMaterial {
   bool hasTexture2Transform(tagContext *con);
   SoTexture2Transform* getSoTexture2Transform(tagContext *con);
 
-  tagMaterial() : matCache(NULL), texture2Cache(NULL),
-                  texture2TransformCache(NULL)  {}
+  tagMaterial() : matCache(nullptr), texture2Cache(nullptr),
+                  texture2TransformCache(nullptr)  {}
   ~tagMaterial()  {
     if (matCache) matCache->unref();
     if (texture2Cache) texture2Cache->unref();
@@ -460,11 +460,11 @@ typedef struct tagContext {
   SoShapeHints* genGetOneSidedHints();
   SoShapeHints* genGetTwoSidedHints();
 
-  tagContext(SoStream &stream) : s(stream), root(NULL), cObj(NULL),
+  tagContext(SoStream &stream) : s(stream), root(nullptr), cObj(nullptr),
       totalVertices(0), totalFaces(0),
-      vertexList(NULL), faceList(NULL),
-      genEmptyTexture(NULL), genEmptyTexTransform(NULL),
-      genOneSidedHints(NULL), genTwoSidedHints(NULL)  {}
+      vertexList(nullptr), faceList(nullptr),
+      genEmptyTexture(nullptr), genEmptyTexTransform(nullptr),
+      genOneSidedHints(nullptr), genTwoSidedHints(nullptr)  {}
   ~tagContext() {
       for (int i=matList.getLength()-1; i>=1; i--)
         delete matList[i];
@@ -572,7 +572,7 @@ read3dsFile(SoStream *in, SoSeparator *&root,
 #endif
 
   // center model and scale it
-  SoMatrixTransform *matrix = NULL;
+  SoMatrixTransform *matrix = nullptr;
   if (con.centerModel || modelSize != 0.f) {
     matrix = new SoMatrixTransform;
     con.root->addChild(matrix);
@@ -611,7 +611,7 @@ read3dsFile(SoStream *in, SoSeparator *&root,
   // handle errors
   if (con.s.isBad()) {
     con.root->unref();
-    con.root = NULL;
+    con.root = nullptr;
 
     SoDebugError::post("read3dsFile",
                        "3ds loading failed.");
@@ -642,7 +642,7 @@ read3dsFile(SoStream *in, SoSeparator *&root,
   // return root
   con.root->unrefNoDelete();
   root = con.root;
-  con.root = NULL;
+  con.root = nullptr;
 
   // debug info
   if (coin_debug_3ds() >= 2)
@@ -786,7 +786,7 @@ CHUNK(LoadNamedObject)
     if (con->cObj->getNumChildren() > 0)
       con->root->addChild(con->cObj);
     con->cObj->unref();
-    con->cObj = NULL;
+    con->cObj = nullptr;
   }
 }
 
@@ -830,9 +830,9 @@ CHUNK(LoadNTriObject)
   con->cObj = new SoSeparator;
   con->cObj->ref();
 
-  con->genCurrentTexture = NULL;
-  con->genCurrentTexTransform = NULL;
-  con->genCurrentMaterial = NULL;
+  con->genCurrentTexture = nullptr;
+  con->genCurrentTexTransform = nullptr;
+  con->genCurrentMaterial = nullptr;
   con->genTwoSided = -1;
 
   // create coordinates (in indexed mode)
@@ -986,9 +986,9 @@ CHUNK(LoadNTriObject)
 
   // clean up memory
   delete[] con->vertexList;
-  con->vertexList = NULL;
+  con->vertexList = nullptr;
   delete[] con->faceList;
-  con->faceList = NULL;
+  con->faceList = nullptr;
   for (int j=con->faceGroupList.getLength()-1; j>=0; j--) {
     delete con->faceGroupList[j];
     con->faceGroupList.removeFast(j);
@@ -1011,7 +1011,7 @@ CHUNK(LoadPointArray)
   con->s >> num;
 
   // alloc memory for Vertices
-  assert(con->vertexList == NULL && "Forgot to free memory.");
+  assert(con->vertexList == nullptr && "Forgot to free memory.");
   con->vertexList = new Vertex[num];
   con->numVertices = num;
 
@@ -1041,7 +1041,7 @@ CHUNK(LoadFaceArray)
   con->s >> num;
 
   // alloc memory for Faces
-  assert(con->faceList == NULL && "Forgot to free memory.");
+  assert(con->faceList == nullptr && "Forgot to free memory.");
   con->faceList = new Face[num];
   con->numFaces = num;
 
@@ -1053,7 +1053,7 @@ CHUNK(LoadFaceArray)
 
   // make sure vertices are present yet
   if (num > 0) {
-    if (con->vertexList == NULL) {
+    if (con->vertexList == nullptr) {
       assert(false && "Vertex list not present.");
       con->s.setBadBit();
       return;
@@ -1156,7 +1156,7 @@ CHUNK(LoadMshMatGroup)
 
   // make sure faces are present yet
   if (num > 0) {
-    if (con->faceList == NULL) {
+    if (con->faceList == nullptr) {
       assert(false && "Face list not present.");
       con->s.setBadBit();
       return;
@@ -1168,7 +1168,7 @@ CHUNK(LoadMshMatGroup)
   for (int i=0; i<num; i++) {
     con->s >> faceMatIndex;
     if (faceMatIndex < con->numFaces) {
-      assert(con->faceList[faceMatIndex].faceGroup == NULL &&
+      assert(con->faceList[faceMatIndex].faceGroup == nullptr &&
              "3ds file error: Two materials on one face.");
       con->faceList[faceMatIndex].faceGroup = mm;
       mm->faceList.append(&con->faceList[faceMatIndex]);
@@ -1202,7 +1202,7 @@ CHUNK(LoadTexVerts)
 
   // make sure vertices are present yet
   if (num > 0) {
-    if (con->vertexList == NULL) {
+    if (con->vertexList == nullptr) {
       assert(false && "Vertex list not present.");
       con->s.setBadBit();
       return;
@@ -1235,7 +1235,7 @@ CHUNK(LoadMatEntry)
     return;
   }
 
-  assert(con->cMat == NULL);
+  assert(con->cMat == nullptr);
   con->cMat = new Material;
   con->matList.append(con->cMat);
 
@@ -1264,7 +1264,7 @@ CHUNK(LoadMatEntry)
   con->cMat->matCache->ref();
   con->cMat->updateSoMaterial(0, con->cMat->matCache);
 
-  con->cMat = NULL;
+  con->cMat = nullptr;
 }
 
 
@@ -1626,7 +1626,7 @@ SbVec3f Face::getWeightedNormal(tagContext *con, uint16_t vertexIndex) const
 void Face::init(tagContext *con, uint16_t a, uint16_t b, uint16_t c, uint16_t f)
 {
   v1=a; v2=b; v3=c; flags=f;
-  faceGroup = NULL;
+  faceGroup = nullptr;
 
   isDegenerated = (con->vertexList[v2].point-con->vertexList[v1].point).cross(
       con->vertexList[v3].point - con->vertexList[v1].point).sqrLength() == 0.f;
@@ -1852,7 +1852,7 @@ bool DefaultFaceGroup::isEmpty(Context *con)
 {
   int num = con->numFaces;
   for (int i=0; i<num; i++)
-    if (con->faceList[i].faceGroup == NULL) return false;
+    if (con->faceList[i].faceGroup == nullptr) return false;
   return true;
 }
 
@@ -1875,7 +1875,7 @@ SoNormal* DefaultFaceGroup::createSoNormal(tagContext *con)
     SbVec3f *v = normals->vector.startEditing();
     for (int i=0; i<num; i++) {
       Face *f = &con->faceList[i];
-      if (f->faceGroup == NULL && !f->isDegenerated) {
+      if (f->faceGroup == nullptr && !f->isDegenerated) {
         *(v++) = f->getNormal(con);
         j++;
       }
@@ -1901,7 +1901,7 @@ SoCoordinate3* DefaultFaceGroup::createSoCoordinate3_n(tagContext *con)
   int j = 0;
   for (int i=0; i<num; i++) {
     Face *f = &con->faceList[i];
-    if (f->faceGroup == NULL && !f->isDegenerated) {
+    if (f->faceGroup == nullptr && !f->isDegenerated) {
       *(c++) = con->vertexList[f->v1].point;
       *(c++) = con->vertexList[f->v2].point;
       *(c++) = con->vertexList[f->v3].point;
@@ -1925,7 +1925,7 @@ SoTriangleStripSet* DefaultFaceGroup::createSoTriStripSet_n(tagContext *con)
   int j = 0;
   for (i=0; i<num; i++) {
     Face *f = &con->faceList[i];
-    if (f->faceGroup == NULL)  j++;
+    if (f->faceGroup == nullptr)  j++;
   }
   j -= con->numDefaultDegFaces;
 
@@ -1951,7 +1951,7 @@ SoIndexedTriangleStripSet* DefaultFaceGroup::createSoIndexedTriStripSet_i(tagCon
   int j = 0;
   for (i=0; i<num; i++) {
     Face *f = &con->faceList[i];
-    if (f->faceGroup == NULL)  j++;
+    if (f->faceGroup == nullptr)  j++;
   }
   j -= con->numDefaultDegFaces;
 
@@ -1960,7 +1960,7 @@ SoIndexedTriangleStripSet* DefaultFaceGroup::createSoIndexedTriStripSet_i(tagCon
   int32_t *c = triSet->coordIndex.startEditing();
   for (i=0; i<num; i++) {
     Face *f = &con->faceList[i];
-    if (f->faceGroup == NULL && !f->isDegenerated) {
+    if (f->faceGroup == nullptr && !f->isDegenerated) {
       *(c++) = f->v1;
       *(c++) = f->v2;
       *(c++) = f->v3;
@@ -1992,7 +1992,7 @@ SoMaterial* Material::getSoMaterial(Context COIN_UNUSED_ARG(*con))
 
 
 bool Material::hasTexture2(tagContext COIN_UNUSED_ARG(*con))
-{ return (texture2Cache != NULL); }
+{ return (texture2Cache != nullptr); }
 
 
 
@@ -2002,7 +2002,7 @@ SoTexture2* Material::getSoTexture2(tagContext COIN_UNUSED_ARG(*con))
 
 
 bool Material::hasTexture2Transform(tagContext COIN_UNUSED_ARG(*con))
-{ return (texture2TransformCache != NULL); }
+{ return (texture2TransformCache != nullptr); }
 
 
 
diff --git a/coin4/src/3ds/SoStream.cpp b/coin4/src/3ds/SoStream.cpp
index cd3f098..4b2716e 100644
--- a/coin4/src/3ds/SoStream.cpp
+++ b/coin4/src/3ds/SoStream.cpp
@@ -608,7 +608,7 @@ bool SoStream::reallocBuffer(size_t newSize)
     newAllocSize = newSize;
 
   char *newBuffer = static_cast<char*>(realloc(buffer, newAllocSize));
-  if (newBuffer != NULL) {
+  if (newBuffer != nullptr) {
     buffer = newBuffer;
     bufferSize = newSize;
     bufferAllocSize = newAllocSize;
@@ -647,7 +647,7 @@ void SoStream::emptyBuffer(size_t streamSize)
   closeStream();
   streamType = MEMORY;
   if (streamSize == 0) {
-    buffer = NULL;
+    buffer = nullptr;
   } else {
     buffer = static_cast<char*>(malloc(streamSize));
   }
diff --git a/coin4/src/SbBasicP.h b/coin4/src/SbBasicP.h
index ec8cc94..6e03344 100644
--- a/coin4/src/SbBasicP.h
+++ b/coin4/src/SbBasicP.h
@@ -60,26 +60,26 @@ struct coin_depointer<Type * const> {
 template<typename To,typename From>
 To coin_internal_safe_cast2(From * ptr) {
 #ifdef COIN_DEPOINTER_AVAILABLE
-  if((ptr != NULL) && ptr->getTypeId().isDerivedFrom(coin_depointer<To>::type::getClassTypeId()))
+  if((ptr != nullptr) && ptr->getTypeId().isDerivedFrom(coin_depointer<To>::type::getClassTypeId()))
 #else
   //FIXME Can we avoid declaring an unused variable also for MSVC6? - BFG 20080807
-  To retVal = NULL;
-  if((ptr != NULL) && ptr->getTypeId().isDerivedFrom(retVal->getClassTypeId()))
+  To retVal = nullptr;
+  if((ptr != nullptr) && ptr->getTypeId().isDerivedFrom(retVal->getClassTypeId()))
 #endif //OLDMSVC
   return static_cast<To>(ptr);
-  return NULL;
+  return nullptr;
 }
 
 template<typename To,typename From>
 To
 coin_internal_safe_cast(From * ptr) {
 #ifdef COIN_DEPOINTER_AVAILABLE
-  if((ptr != NULL) && ptr->isOfType(coin_depointer<To>::type::getClassTypeId()))
+  if((ptr != nullptr) && ptr->isOfType(coin_depointer<To>::type::getClassTypeId()))
 #else
-  if((ptr != NULL) && ptr->isOfType(((To) NULL)->getClassTypeId()))
+  if((ptr != nullptr) && ptr->isOfType(((To) nullptr)->getClassTypeId()))
 #endif //OLDMSVC
     return static_cast<To>(ptr);
-  return NULL;
+  return nullptr;
 }
 
 template<typename To>
diff --git a/coin4/src/actions/SoAction.cpp b/coin4/src/actions/SoAction.cpp
index a0db1d2..e1201c0 100644
--- a/coin4/src/actions/SoAction.cpp
+++ b/coin4/src/actions/SoAction.cpp
@@ -232,8 +232,8 @@
 
 // *************************************************************************
 
-SoEnabledElementsList * SoAction::enabledElements = NULL;
-SoActionMethodList * SoAction::methods = NULL;
+SoEnabledElementsList * SoAction::enabledElements = nullptr;
+SoActionMethodList * SoAction::methods = nullptr;
 SoType SoAction::classTypeId STATIC_SOTYPE_INIT;
 
 // *************************************************************************
@@ -331,13 +331,13 @@ SoType SoAction::classTypeId STATIC_SOTYPE_INIT;
   Default constructor, does all necessary toplevel initialization.
 */
 SoAction::SoAction(void)
-  : state(NULL),
-    traversalMethods(NULL),
+  : state(nullptr),
+    traversalMethods(nullptr),
     currentpath(8),
     currentpathcode(NO_PATH)
 {
   PRIVATE(this)->appliedcode = NODE;
-  PRIVATE(this)->applieddata.node = NULL;
+  PRIVATE(this)->applieddata.node = nullptr;
   PRIVATE(this)->terminated = false;
   PRIVATE(this)->prevenabledelementscounter = 0;
 
@@ -367,9 +367,9 @@ SoAction::initClass(void)
 {
   SoAction::classTypeId = SoType::createType(SoType::badType(), "SoAction");
 
-  // Pass NULL pointers for the parent lists.
-  SoAction::enabledElements = new SoEnabledElementsList(NULL);
-  SoAction::methods = new SoActionMethodList(NULL);
+  // Pass nullptr pointers for the parent lists.
+  SoAction::enabledElements = new SoEnabledElementsList(nullptr);
+  SoAction::methods = new SoActionMethodList(nullptr);
 
   // Override element is used everywhere.
   SoAction::enabledElements->enable(SoOverrideElement::getClassTypeId(),
@@ -391,9 +391,9 @@ void
 SoAction::atexit_cleanup(void)
 {
   delete SoAction::enabledElements;
-  SoAction::enabledElements = NULL;
+  SoAction::enabledElements = nullptr;
   delete SoAction::methods;
-  SoAction::methods = NULL;
+  SoAction::methods = nullptr;
   SoAction::classTypeId STATIC_SOTYPE_INIT;
 }
 
@@ -582,14 +582,14 @@ SoAction::apply(SoNode * root)
       SoType profileactiontype = SoProfilerP::getActionType();
       if (this->isOfType(SoProfilerP::getActionType())) {
         SoProfilerElement * pelt = SoProfilerElement::get(state);
-        if (pelt != NULL) {
+        if (pelt != nullptr) {
           const SbProfilingData & pdata = pelt->getProfilingData();
           SoProfilerP::dumpToConsole(pdata);
         }
       }
     }
 
-    PRIVATE(this)->applieddata.node = NULL;
+    PRIVATE(this)->applieddata.node = nullptr;
     root->unrefNoDelete();
   }
   PRIVATE(this)->appliedcode = storedcode;
@@ -698,7 +698,7 @@ SoAction::apply(const SoPathList & pathlist, bool obeysrules)
 
   PRIVATE(this)->applieddata.pathlistdata.origpathlist = &pathlist;
   PRIVATE(this)->applieddata.pathlistdata.pathlist = &pathlist;
-  PRIVATE(this)->applieddata.pathlistdata.compactlist = NULL;
+  PRIVATE(this)->applieddata.pathlistdata.compactlist = nullptr;
   PRIVATE(this)->appliedcode = PATH_LIST;
   this->currentpathcode = pathlist[0]->getFullLength() > 1 ?
     SoAction::IN_PATH : SoAction::BELOW_PATH;
@@ -712,7 +712,7 @@ SoAction::apply(const SoPathList & pathlist, bool obeysrules)
     this->beginTraversal(pathlist[0]->getHead());
     this->endTraversal(pathlist[0]->getHead());
     delete PRIVATE(this)->applieddata.pathlistdata.compactlist;
-    PRIVATE(this)->applieddata.pathlistdata.compactlist = NULL;
+    PRIVATE(this)->applieddata.pathlistdata.compactlist = nullptr;
   }
   else {
     // make copy of path list and make sure it obeys rules
@@ -731,12 +731,12 @@ SoAction::apply(const SoPathList & pathlist, bool obeysrules)
         PRIVATE(this)->applieddata.pathlistdata.compactlist = new SoCompactPathList(sortedlist);
       }
       else {
-        PRIVATE(this)->applieddata.pathlistdata.compactlist = NULL;
+        PRIVATE(this)->applieddata.pathlistdata.compactlist = nullptr;
       }
       this->beginTraversal(sortedlist[0]->getHead());
       this->endTraversal(sortedlist[0]->getHead());
       delete PRIVATE(this)->applieddata.pathlistdata.compactlist;
-      PRIVATE(this)->applieddata.pathlistdata.compactlist = NULL;
+      PRIVATE(this)->applieddata.pathlistdata.compactlist = nullptr;
     }
     else {
       // make one pass per head node. sortedlist is sorted on
@@ -762,11 +762,11 @@ SoAction::apply(const SoPathList & pathlist, bool obeysrules)
           PRIVATE(this)->applieddata.pathlistdata.compactlist = new SoCompactPathList(templist);
         }
         else {
-          PRIVATE(this)->applieddata.pathlistdata.compactlist = NULL;
+          PRIVATE(this)->applieddata.pathlistdata.compactlist = nullptr;
         }
         this->beginTraversal(templist[0]->getHead());
         delete PRIVATE(this)->applieddata.pathlistdata.compactlist;
-        PRIVATE(this)->applieddata.pathlistdata.compactlist = NULL;
+        PRIVATE(this)->applieddata.pathlistdata.compactlist = nullptr;
         templist.truncate(0);
       }
     }
@@ -788,7 +788,7 @@ SoAction::apply(const SoPathList & pathlist, bool obeysrules)
 void
 SoAction::apply(SoAction * beingApplied)
 {
-  assert(beingApplied != NULL);
+  assert(beingApplied != nullptr);
   switch ( beingApplied->getWhatAppliedTo() ) {
   case NODE:
     this->apply(beingApplied->getNodeAppliedTo());
@@ -818,7 +818,7 @@ void
 SoAction::invalidateState(void)
 {
   delete this->state;
-  this->state = NULL;
+  this->state = nullptr;
 }
 
 // *************************************************************************
@@ -846,12 +846,12 @@ SoAction::getWhatAppliedTo(void) const
   Returns a pointer to the node the action is being applied to.
 
   If action is not being applied to a node (but a path or a pathlist),
-  the method returns \c NULL.
+  the method returns \c nullptr.
 */
 SoNode *
 SoAction::getNodeAppliedTo(void) const
 {
-  return PRIVATE(this)->appliedcode == SoAction::NODE ? PRIVATE(this)->applieddata.node : NULL;
+  return PRIVATE(this)->appliedcode == SoAction::NODE ? PRIVATE(this)->applieddata.node : nullptr;
 }
 
 /*!
@@ -860,12 +860,12 @@ SoAction::getNodeAppliedTo(void) const
   modified by the caller.
 
   If action is not being applied to a path (but a node or a pathlist),
-  the method returns \c NULL.
+  the method returns \c nullptr.
 */
 SoPath *
 SoAction::getPathAppliedTo(void) const
 {
-  return PRIVATE(this)->appliedcode == SoAction::PATH ? PRIVATE(this)->applieddata.path : NULL;
+  return PRIVATE(this)->appliedcode == SoAction::PATH ? PRIVATE(this)->applieddata.path : nullptr;
 }
 
 /*!
@@ -874,7 +874,7 @@ SoAction::getPathAppliedTo(void) const
   should not be destroyed or modified by the caller.
 
   If action is not being applied to a path list (but a node or a
-  path), the method returns \c NULL.
+  path), the method returns \c nullptr.
 
   The returned pathlist pointer need not be equal to the list apply()
   was called with, as the action may have reorganized the path list
@@ -886,7 +886,7 @@ const SoPathList *
 SoAction::getPathListAppliedTo(void) const
 {
   return PRIVATE(this)->appliedcode == SoAction::PATH_LIST ?
-    PRIVATE(this)->applieddata.pathlistdata.pathlist : NULL;
+    PRIVATE(this)->applieddata.pathlistdata.pathlist : nullptr;
 }
 
 /*!
@@ -894,14 +894,14 @@ SoAction::getPathListAppliedTo(void) const
   applied to.
 
   If the action is not being applied to a path list (but a node or a
-  path), the method returns \c NULL.
+  path), the method returns \c nullptr.
 */
 
 const SoPathList *
 SoAction::getOriginalPathListAppliedTo(void) const
 {
   return PRIVATE(this)->appliedcode == SoAction::PATH_LIST ?
-    PRIVATE(this)->applieddata.pathlistdata.origpathlist : NULL;
+    PRIVATE(this)->applieddata.pathlistdata.origpathlist : nullptr;
 }
 
 /*!
@@ -1085,9 +1085,9 @@ SoAction::getState(void) const
       (SoEnabledElementsList::getCounter() != PRIVATE(this)->prevenabledelementscounter)) {
     SoAction * thisp = const_cast<SoAction*> (this);
     delete thisp->state;
-    thisp->state = NULL;
+    thisp->state = nullptr;
   }
-  if (this->state == NULL) {
+  if (this->state == nullptr) {
     // cast away constness to set state
     const_cast<SoAction*>(this)->state =
       new SoState(const_cast<SoAction*>(this), this->getEnabledElements().getElements());
@@ -1166,7 +1166,7 @@ SoAction::usePathCode(int & numindices, const int * & indices)
 }
 
 /*!
-  Pushes a NULL node onto the current path. Use this before
+  Pushes a nullptr node onto the current path. Use this before
   traversing all children when you know that the path code will not
   change while traversing children.
 
@@ -1176,7 +1176,7 @@ SoAction::usePathCode(int & numindices, const int * & indices)
 void
 SoAction::pushCurPath(void)
 {
-  this->currentpath.simpleAppend(static_cast<SoNode*>( NULL), -1);
+  this->currentpath.simpleAppend(static_cast<SoNode*>( nullptr), -1);
 }
 
 /*!
@@ -1189,8 +1189,8 @@ SoAction::pushCurPath(void)
 void
 SoAction::popPushCurPath(const int childindex, SoNode * node)
 {
-  if (node == NULL) {
-    this->currentpath.pop(); // pop off previous or NULL node
+  if (node == nullptr) {
+    this->currentpath.pop(); // pop off previous or nullptr node
     this->currentpath.append(childindex);
   }
   else {
@@ -1361,7 +1361,7 @@ SoAction::switchToNodeTraversal(SoNode * node)
 SoProfilerStats *
 SoActionP::getProfilerStatsNode(void)
 {
-  static SoProfilerStats * pstats = NULL;
+  static SoProfilerStats * pstats = nullptr;
   if (!pstats) {
     pstats = new SoProfilerStats;
     pstats->ref();
@@ -1373,11 +1373,11 @@ SoNode *
 SoActionP::getProfilerOverlay(void)
 {
   if (!SoProfiler::isEnabled() || !SoProfiler::isOverlayActive())
-    return NULL;
+    return nullptr;
 
-  static SoNode * nodekit = NULL;
+  static SoNode * nodekit = nullptr;
 #ifdef HAVE_NODEKITS
-  if (nodekit == NULL) {
+  if (nodekit == nullptr) {
     SoProfilerTopKit * kit = new SoProfilerTopKit;
     kit->ref();
     kit->setPart("profilingStats",
diff --git a/coin4/src/actions/SoBoxHighlightRenderAction.cpp b/coin4/src/actions/SoBoxHighlightRenderAction.cpp
index e8f0d44..8f98146 100644
--- a/coin4/src/actions/SoBoxHighlightRenderAction.cpp
+++ b/coin4/src/actions/SoBoxHighlightRenderAction.cpp
@@ -70,7 +70,7 @@
 
 class SoBoxHighlightRenderActionP {
 public:
-  SoBoxHighlightRenderActionP(void) : master(NULL) { }
+  SoBoxHighlightRenderActionP(void) : master(nullptr) { }
 
   SoBoxHighlightRenderAction * master;
   SoSearchAction * searchaction;
@@ -128,7 +128,7 @@ SoBoxHighlightRenderActionP::initBoxGraph()
 void
 SoBoxHighlightRenderActionP::drawHighlightBox(const SoPath * path)
 {
-  if (this->camerasearch == NULL) {
+  if (this->camerasearch == nullptr) {
     this->camerasearch = new SoSearchAction;
   }
 
@@ -143,7 +143,7 @@ SoBoxHighlightRenderActionP::drawHighlightBox(const SoPath * path)
   }
   this->camerasearch->reset();
 
-  if (this->bboxaction == NULL) {
+  if (this->bboxaction == nullptr) {
     this->bboxaction = new SoGetBoundingBoxAction(SbViewportRegion(100, 100));
   }
   this->bboxaction->setViewportRegion(PUBLIC(this)->getViewportRegion());
@@ -227,9 +227,9 @@ SoBoxHighlightRenderAction::init(void)
   PRIVATE(this)->basecolor->rgb.setValue(1.0f, 0.0f, 0.0f);
   PRIVATE(this)->drawstyle->linePattern = 0xffff;
   PRIVATE(this)->drawstyle->lineWidth = 3.0f;
-  PRIVATE(this)->searchaction = NULL;
-  PRIVATE(this)->camerasearch = NULL;
-  PRIVATE(this)->bboxaction = NULL;
+  PRIVATE(this)->searchaction = nullptr;
+  PRIVATE(this)->camerasearch = nullptr;
+  PRIVATE(this)->bboxaction = nullptr;
 
   // SoBase-derived objects should be dynamically allocated.
   PRIVATE(this)->postprocpath = new SoTempPath(32);
@@ -257,7 +257,7 @@ SoBoxHighlightRenderAction::apply(SoNode * node)
 {
   SoGLRenderAction::apply(node);
   if (this->hlVisible) {
-    if (PRIVATE(this)->searchaction == NULL) {
+    if (PRIVATE(this)->searchaction == nullptr) {
       PRIVATE(this)->searchaction = new SoSearchAction;
     }
     const bool searchall = false;
diff --git a/coin4/src/actions/SoCallbackAction.cpp b/coin4/src/actions/SoCallbackAction.cpp
index 34c09b4..e2ff748 100644
--- a/coin4/src/actions/SoCallbackAction.cpp
+++ b/coin4/src/actions/SoCallbackAction.cpp
@@ -52,8 +52,8 @@
    #include <Inventor/nodes/SoTranslation.h>
 
 
-   static SoCoordinate3 * coord3 = NULL;
-   static SoIndexedFaceSet * ifs = NULL;
+   static SoCoordinate3 * coord3 = nullptr;
+   static SoIndexedFaceSet * ifs = nullptr;
 
    static int coord3idx = 0;
 
@@ -113,7 +113,7 @@
      ifs->coordIndex.setNum(0);
 
      SoCallbackAction ca;
-     ca.addTriangleCallback(SoShape::getClassTypeId(), triangle_cb, NULL);
+     ca.addTriangleCallback(SoShape::getClassTypeId(), triangle_cb, nullptr);
      ca.apply(root);
 
      root->unref();
@@ -216,13 +216,13 @@
 
 class SoCallbackData { //internal class
 public:
-  SoCallbackData(void * cbfunc = NULL, void * userdata = NULL)
-    : func(cbfunc), data(userdata), next(NULL) {}
+  SoCallbackData(void * cbfunc = nullptr, void * userdata = nullptr)
+    : func(cbfunc), data(userdata), next(nullptr) {}
 
 
   void append(SoCallbackData * newdata) {
     SoCallbackData * cbdata = this;
-    while (cbdata->next != NULL) cbdata = cbdata->next;
+    while (cbdata->next != nullptr) cbdata = cbdata->next;
     cbdata->next = newdata;
   }
 
@@ -263,7 +263,7 @@ SoCallbackData::doNodeCallbacks(SoCallbackAction * action,
   SoCallbackData * cbdata = this;
   SoCallbackAction::Response response = SoCallbackAction::CONTINUE;
   while (cbdata) {
-    assert(cbdata->func != NULL);
+    assert(cbdata->func != nullptr);
     SoCallbackAction::SoCallbackActionCB * cbfunc =
       object_to_function_cast<SoCallbackAction::SoCallbackActionCB *>( cbdata->func);
     SoCallbackAction::Response ret = cbfunc(cbdata->data, action, node);
@@ -282,7 +282,7 @@ SoCallbackData::doTriangleCallbacks(SoCallbackAction * action,
 {
   SoCallbackData * cbdata = this;
   while (cbdata) {
-    assert(cbdata->func != NULL);
+    assert(cbdata->func != nullptr);
     SoTriangleCB * tricb = object_to_function_cast<SoTriangleCB *> (cbdata->func);
     tricb(cbdata->data, action, v1, v2, v3);
     cbdata = cbdata->next;
@@ -296,7 +296,7 @@ SoCallbackData::doLineSegmentCallbacks(SoCallbackAction * action,
 {
   SoCallbackData * cbdata = this;
   while (cbdata) {
-    assert(cbdata->func != NULL);
+    assert(cbdata->func != nullptr);
     SoLineSegmentCB * linecb = object_to_function_cast<SoLineSegmentCB *>( cbdata->func);
     linecb(cbdata->data, action, v1, v2);
     cbdata = cbdata->next;
@@ -309,7 +309,7 @@ SoCallbackData::doPointCallbacks(SoCallbackAction * action,
 {
   SoCallbackData * cbdata = this;
   while (cbdata) {
-    assert(cbdata->func != NULL);
+    assert(cbdata->func != nullptr);
     SoPointCB * ptcb = object_to_function_cast<SoPointCB *>( cbdata->func);
     ptcb(cbdata->data, action, v);
     cbdata = cbdata->next;
@@ -427,8 +427,8 @@ SoCallbackAction::commonConstructor(void)
 {
   SO_ACTION_CONSTRUCTOR(SoCallbackAction);
 
-  PRIVATE(this)->pretailcallback = NULL;
-  PRIVATE(this)->posttailcallback = NULL;
+  PRIVATE(this)->pretailcallback = nullptr;
+  PRIVATE(this)->posttailcallback = nullptr;
   PRIVATE(this)->viewportset = false;
   PRIVATE(this)->callbackall = false;
 }
@@ -474,7 +474,7 @@ SoCallbackAction::~SoCallbackAction()
 }
 
 //
-// for setting node callbacks. makes sure NULLs are filled in where not set
+// for setting node callbacks. makes sure nullptr are filled in where not set
 //
 static void
 set_callback_data_idx(SbList<SoCallbackData *> & list, const int idx,
@@ -482,10 +482,10 @@ set_callback_data_idx(SbList<SoCallbackData *> & list, const int idx,
 {
   int n = list.getLength();
   while (n <= idx) {
-    list.append(NULL);
+    list.append(nullptr);
     n++;
   }
-  if (list[idx] == NULL) list[idx] = new SoCallbackData(func, data);
+  if (list[idx] == nullptr) list[idx] = new SoCallbackData(func, data);
   else list[idx]->append(new SoCallbackData(func, data));
 }
 
@@ -530,7 +530,7 @@ SoCallbackAction::addPostCallback(const SoType type, SoCallbackActionCB * cb,
 void
 SoCallbackAction::addPreTailCallback(SoCallbackActionCB * cb, void * userdata)
 {
-  if (PRIVATE(this)->pretailcallback == NULL)
+  if (PRIVATE(this)->pretailcallback == nullptr)
     PRIVATE(this)->pretailcallback = new SoCallbackData(function_to_object_cast<void *>(cb), userdata);
   else
     PRIVATE(this)->pretailcallback->append(new SoCallbackData(function_to_object_cast<void *>(cb), userdata));
@@ -543,7 +543,7 @@ SoCallbackAction::addPreTailCallback(SoCallbackActionCB * cb, void * userdata)
 void
 SoCallbackAction::addPostTailCallback(SoCallbackActionCB * cb, void * userdata)
 {
-  if (PRIVATE(this)->posttailcallback == NULL)
+  if (PRIVATE(this)->posttailcallback == nullptr)
     PRIVATE(this)->posttailcallback = new SoCallbackData(function_to_object_cast<void *>(cb), userdata);
   else
     PRIVATE(this)->posttailcallback->append(new SoCallbackData(function_to_object_cast<void *>(cb), userdata));
@@ -1121,7 +1121,7 @@ SoCallbackAction::invokePreCallbacks(const SoNode * const node)
 
   int idx = static_cast<int>(node->getTypeId().getData());
 
-  if (idx < PRIVATE(this)->precallback.getLength() && PRIVATE(this)->precallback[idx] != NULL) {
+  if (idx < PRIVATE(this)->precallback.getLength() && PRIVATE(this)->precallback[idx] != nullptr) {
     PRIVATE(this)->response = PRIVATE(this)->precallback[idx]->doNodeCallbacks(this, node);
     if (PRIVATE(this)->response == SoCallbackAction::ABORT) {
       this->setTerminated(true);
@@ -1130,7 +1130,7 @@ SoCallbackAction::invokePreCallbacks(const SoNode * const node)
   }
 
   if (this->getWhatAppliedTo() == SoAction::PATH &&
-      this->getPathAppliedTo()->getTail() == node && PRIVATE(this)->pretailcallback != NULL) {
+      this->getPathAppliedTo()->getTail() == node && PRIVATE(this)->pretailcallback != nullptr) {
     PRIVATE(this)->response = PRIVATE(this)->pretailcallback->doNodeCallbacks(this, node);
     if (PRIVATE(this)->response == SoCallbackAction::ABORT) {
       this->setTerminated(true);
@@ -1153,7 +1153,7 @@ SoCallbackAction::invokePostCallbacks(const SoNode * const node)
   if (PRIVATE(this)->response == PRUNE) PRIVATE(this)->response = CONTINUE;
 
   int idx = static_cast<int>(node->getTypeId().getData());
-  if (idx < PRIVATE(this)->postcallback.getLength() && PRIVATE(this)->postcallback[idx] != NULL) {
+  if (idx < PRIVATE(this)->postcallback.getLength() && PRIVATE(this)->postcallback[idx] != nullptr) {
     PRIVATE(this)->response = static_cast<Response>(PRIVATE(this)->postcallback[idx]->doNodeCallbacks(this, node));
     if (PRIVATE(this)->response == SoCallbackAction::ABORT) {
       this->setTerminated(true);
@@ -1185,7 +1185,7 @@ SoCallbackAction::invokeTriangleCallbacks(const SoShape * const shape,
                                           const SoPrimitiveVertex * const v3)
 {
   int idx = static_cast<int>(shape->getTypeId().getData());
-  if (idx < PRIVATE(this)->trianglecallback.getLength() && PRIVATE(this)->trianglecallback[idx] != NULL)
+  if (idx < PRIVATE(this)->trianglecallback.getLength() && PRIVATE(this)->trianglecallback[idx] != nullptr)
     PRIVATE(this)->trianglecallback[idx]->doTriangleCallbacks(this, v1, v2, v3);
 }
 
@@ -1200,7 +1200,7 @@ SoCallbackAction::invokeLineSegmentCallbacks(const SoShape * const shape,
                                              const SoPrimitiveVertex * const v2)
 {
   int idx = static_cast<int>(shape->getTypeId().getData());
-  if (idx < PRIVATE(this)->linecallback.getLength() && PRIVATE(this)->linecallback[idx] != NULL)
+  if (idx < PRIVATE(this)->linecallback.getLength() && PRIVATE(this)->linecallback[idx] != nullptr)
     PRIVATE(this)->linecallback[idx]->doLineSegmentCallbacks(this, v1, v2);
 }
 
@@ -1214,7 +1214,7 @@ SoCallbackAction::invokePointCallbacks(const SoShape * const shape,
                                        const SoPrimitiveVertex * const v)
 {
   int idx = static_cast<int>(shape->getTypeId().getData());
-  if (idx < PRIVATE(this)->pointcallback.getLength() && PRIVATE(this)->pointcallback[idx] != NULL)
+  if (idx < PRIVATE(this)->pointcallback.getLength() && PRIVATE(this)->pointcallback[idx] != nullptr)
     PRIVATE(this)->pointcallback[idx]->doPointCallbacks(this, v);
 }
 
diff --git a/coin4/src/actions/SoGLRenderAction.cpp b/coin4/src/actions/SoGLRenderAction.cpp
index 3d7cf37..fe66c2f 100644
--- a/coin4/src/actions/SoGLRenderAction.cpp
+++ b/coin4/src/actions/SoGLRenderAction.cpp
@@ -531,7 +531,7 @@
 
 class SoGLRenderActionP {
 public:
-  SoGLRenderActionP(void) : action(NULL) { }
+  SoGLRenderActionP(void) : action(nullptr) { }
 
   SoGLRenderAction * action;
   SbViewportRegion viewport;
@@ -695,8 +695,8 @@ SoGLRenderAction::SoGLRenderAction(const SbViewportRegion & viewportregion)
   // state hasn't been made yet.
   PRIVATE(this)->viewport = viewportregion;
 
-  PRIVATE(this)->passcallback = NULL;
-  PRIVATE(this)->passcallbackdata = NULL;
+  PRIVATE(this)->passcallback = nullptr;
+  PRIVATE(this)->passcallbackdata = nullptr;
   PRIVATE(this)->smoothing = false;
   PRIVATE(this)->currentpass = 0;
   PRIVATE(this)->numpasses = 1;
@@ -711,7 +711,7 @@ SoGLRenderAction::SoGLRenderAction(const SbViewportRegion & viewportregion)
   PRIVATE(this)->updateorigin.setValue(0.0f, 0.0f);
   PRIVATE(this)->updatesize.setValue(1.0f, 1.0f);
   PRIVATE(this)->rendering = SoGLRenderActionP::RENDERING_UNSET;
-  PRIVATE(this)->abortcallback = NULL;
+  PRIVATE(this)->abortcallback = nullptr;
   PRIVATE(this)->cachecontext = 0;
   PRIVATE(this)->needglinit = true;
   PRIVATE(this)->sortedlayersblendpasses = 4;
@@ -720,14 +720,14 @@ SoGLRenderAction::SoGLRenderAction(const SbViewportRegion & viewportregion)
   PRIVATE(this)->sortedlayersblendinitialized = false;
   PRIVATE(this)->sortedlayersblendcounter = 0;
   PRIVATE(this)->usenvidiaregistercombiners = false;
-  PRIVATE(this)->cachedprofilingsg = NULL;
+  PRIVATE(this)->cachedprofilingsg = nullptr;
   PRIVATE(this)->transpobjdepthwrite = false;
   PRIVATE(this)->transpdelayedrendertype = ONE_PASS;
   PRIVATE(this)->renderingtranspbackfaces = false;
 
   PRIVATE(this)->sortedobjectstrategy = BBOX_CENTER;
-  PRIVATE(this)->sortedobjectcb = NULL;
-  PRIVATE(this)->sortedobjectclosure = NULL;
+  PRIVATE(this)->sortedobjectcb = nullptr;
+  PRIVATE(this)->sortedobjectclosure = nullptr;
 }
 
 /*!
@@ -1016,7 +1016,7 @@ SoGLRenderAction::getSortedLayersNumPasses() const
 void
 SoGLRenderAction::beginTraversal(SoNode * node)
 {
-  if (PRIVATE(this)->cachedprofilingsg == NULL) {
+  if (PRIVATE(this)->cachedprofilingsg == nullptr) {
     if (node->isOfType(SoGroup::getClassTypeId()) &&
         (coin_assert_cast<SoGroup *>(node))->getNumChildren() > 0) {
       PRIVATE(this)->cachedprofilingsg = node;
@@ -1036,7 +1036,7 @@ SoGLRenderAction::beginTraversal(SoNode * node)
         for (int i = 0, n = plist.getLength(); i < n; ++i) {
           SoFullPath * path = reclassify_cast<SoFullPath *>(plist[i]);
           SoNode * tail = path->getTail();
-          if ((tail != NULL) &&
+          if ((tail != nullptr) &&
               (tail->isOfType(SoProfilerVisualizeKit::getClassTypeId()))) {
             SoProfilerVisualizeKit * viskit = coin_assert_cast<SoProfilerVisualizeKit *>(tail);
             viskit->root.setValue(node);
@@ -1123,7 +1123,7 @@ SoGLRenderAction::endTraversal(SoNode * node)
     if (delay == 0.0f) {
       node->touch();
     } else {
-      if (PRIVATE(this)->redrawSensor.get() == NULL) {
+      if (PRIVATE(this)->redrawSensor.get() == nullptr) {
         PRIVATE(this)->redrawSensor.reset(new SoAlarmSensor);
       }
       if (PRIVATE(this)->redrawSensor->isScheduled()) {
@@ -1133,7 +1133,7 @@ SoGLRenderAction::endTraversal(SoNode * node)
       PRIVATE(this)->redrawSensor->setData(node);
       PRIVATE(this)->redrawSensor->setTimeFromNow(SbTime(static_cast<double>(delay)));
       PRIVATE(this)->redrawSensor->schedule();
-      if (PRIVATE(this)->deleteSensor.get() == NULL) {
+      if (PRIVATE(this)->deleteSensor.get() == nullptr) {
         PRIVATE(this)->deleteSensor.reset(new SoNodeSensor);
       }
       PRIVATE(this)->deleteSensor->setDeleteCallback(SoGLRenderActionP::deleteNodeCB, &(PRIVATE(this).get()));
@@ -1167,9 +1167,9 @@ SoGLRenderActionP::deleteNodeCB(void * userdata, SoSensor * COIN_UNUSED_ARG(sens
 {
   assert(userdata);
   SoGLRenderActionP * thisp = static_cast<SoGLRenderActionP *>(userdata);
-  if (thisp->redrawSensor.get() != NULL) {
+  if (thisp->redrawSensor.get() != nullptr) {
     thisp->redrawSensor->unschedule();
-    thisp->redrawSensor->setData(NULL);
+    thisp->redrawSensor->setData(nullptr);
   }
 }
 
@@ -1583,7 +1583,7 @@ SoGLRenderActionP::addSortTransPath(SoPath * path)
 
   // check and handle callback first
   if ((this->sortedobjectstrategy == SoGLRenderAction::CUSTOM_CALLBACK) &&
-      (this->sortedobjectcb != NULL)) {
+      (this->sortedobjectcb != nullptr)) {
     this->sorttranspobjdistances.append(this->sortedobjectcb(this->sortedobjectclosure,
                                                              this->action));
     return;
@@ -2458,7 +2458,7 @@ SoGLRenderActionP::setupSortedLayersBlendTextures(const SoState * state)
     glGenTextures(1, &this->depthtextureid);
     glBindTexture(GL_TEXTURE_RECTANGLE_EXT, this->depthtextureid);
     glTexImage2D(GL_TEXTURE_RECTANGLE_EXT, 0, GL_DEPTH_COMPONENT24, canvassize[0], canvassize[1],
-                 0, GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, NULL);
+                 0, GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, nullptr);
     glTexParameteri(GL_TEXTURE_RECTANGLE_EXT, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
     glTexParameteri(GL_TEXTURE_RECTANGLE_EXT, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
     glTexParameteri(GL_TEXTURE_RECTANGLE_EXT, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
diff --git a/coin4/src/actions/SoGetBoundingBoxAction.cpp b/coin4/src/actions/SoGetBoundingBoxAction.cpp
index 1ce34e2..eeacf83 100644
--- a/coin4/src/actions/SoGetBoundingBoxAction.cpp
+++ b/coin4/src/actions/SoGetBoundingBoxAction.cpp
@@ -270,7 +270,7 @@ SoGetBoundingBoxAction::SoGetBoundingBoxAction(const SbViewportRegion & vp)
   : center(0, 0, 0),
     vpregion(vp),
     resettype(SoGetBoundingBoxAction::ALL),
-    resetpath(NULL),
+    resetpath(nullptr),
     flags(SoGetBoundingBoxAction::RESET_BEFORE)
 {
   SO_ACTION_CONSTRUCTOR(SoGetBoundingBoxAction);
@@ -368,7 +368,7 @@ SoGetBoundingBoxAction::isInCameraSpace(void) const
 /*!
   Forces the computed bounding box to be reset and the transformation
   to be identity before or after the tail node of \a path, depending
-  on the \a resetbefore argument.  \c NULL can be specified for the \a
+  on the \a resetbefore argument.  \c nullptr can be specified for the \a
   path argument to disable this behavior.
 
   \sa getResetPath(), isResetPath(), isResetBefore(), getWhatReset()
@@ -386,7 +386,7 @@ SoGetBoundingBoxAction::setResetPath(const SoPath * path,
 }
 
 /*!
-  Returns the reset path (or \c NULL).
+  Returns the reset path (or \c nullptr).
 
   \sa setResetPath(), isResetPath(), isResetBefore(), getWhatReset()
 */
@@ -404,7 +404,7 @@ SoGetBoundingBoxAction::getResetPath(void) const
 bool
 SoGetBoundingBoxAction::isResetPath(void) const
 {
-  return this->resetpath != NULL;
+  return this->resetpath != nullptr;
 }
 
 /*!
diff --git a/coin4/src/actions/SoGetMatrixAction.cpp b/coin4/src/actions/SoGetMatrixAction.cpp
index ce3964b..283fabf 100644
--- a/coin4/src/actions/SoGetMatrixAction.cpp
+++ b/coin4/src/actions/SoGetMatrixAction.cpp
@@ -49,7 +49,7 @@
   searchaction->apply(myscenegraphroot);
 
   SoPath * path = searchaction->getPath();
-  assert(path != NULL);
+  assert(path != nullptr);
 
   // Then apply the SoGetMatrixAction to get the full transformation
   // matrix from world space.
diff --git a/coin4/src/actions/SoHandleEventAction.cpp b/coin4/src/actions/SoHandleEventAction.cpp
index 1cdd98a..762eeb0 100644
--- a/coin4/src/actions/SoHandleEventAction.cpp
+++ b/coin4/src/actions/SoHandleEventAction.cpp
@@ -58,7 +58,7 @@
 
 class SoHandleEventActionP {
 public:
-  SoHandleEventActionP(void) : owner(NULL) { }
+  SoHandleEventActionP(void) : owner(nullptr) { }
 
   // Hidden private methods.
 
@@ -108,12 +108,12 @@ SoHandleEventAction::SoHandleEventAction(const SbViewportRegion & viewportregion
 {
   PRIVATE(this)->owner = this;
   PRIVATE(this)->viewport = viewportregion;
-  PRIVATE(this)->event = NULL;
-  PRIVATE(this)->grabber = NULL;
-  PRIVATE(this)->pickroot = NULL;
+  PRIVATE(this)->event = nullptr;
+  PRIVATE(this)->grabber = nullptr;
+  PRIVATE(this)->pickroot = nullptr;
   PRIVATE(this)->pickvalid = false;
   PRIVATE(this)->didpickall = false;
-  PRIVATE(this)->pickaction = NULL;
+  PRIVATE(this)->pickaction = nullptr;
 
   SO_ACTION_CONSTRUCTOR(SoHandleEventAction);
 }
@@ -254,18 +254,18 @@ SoHandleEventAction::setGrabber(SoNode * node)
 void
 SoHandleEventAction::releaseGrabber(void)
 {
-  // Store old grabber node and set current node to NULL before
+  // Store old grabber node and set current node to nullptr before
   // calling SoNode::grabEventsCleanup(), to avoid being vulnerable to
   // recursive calls from grabEventsCleanup() back to this method
   // (which happens from dragger classes).
 
   SoNode * old = PRIVATE(this)->grabber;
-  PRIVATE(this)->grabber = NULL;
+  PRIVATE(this)->grabber = nullptr;
   if (old) old->grabEventsCleanup();
 }
 
 /*!
-  Returns the grabber node, or \c NULL if no grabber is active.
+  Returns the grabber node, or \c nullptr if no grabber is active.
 */
 SoNode *
 SoHandleEventAction::getGrabber(void) const
@@ -365,7 +365,7 @@ SoHandleEventAction::beginTraversal(SoNode * node)
 SoRayPickAction *
 SoHandleEventActionP::getPickAction(void)
 {
-  if (this->pickaction == NULL) {
+  if (this->pickaction == nullptr) {
     this->pickaction = new SoRayPickAction(this->viewport);
   }
   return this->pickaction;
diff --git a/coin4/src/actions/SoLineHighlightRenderAction.cpp b/coin4/src/actions/SoLineHighlightRenderAction.cpp
index 3ba81de..a42c031 100644
--- a/coin4/src/actions/SoLineHighlightRenderAction.cpp
+++ b/coin4/src/actions/SoLineHighlightRenderAction.cpp
@@ -93,12 +93,12 @@ class SoLineHighlightRenderActionP {
 public:
   SoLineHighlightRenderActionP(void)
     : colorpacker_storage(sizeof(void*), alloc_colorpacker, free_colorpacker),
-      owner(NULL)
+      owner(nullptr)
   {
     this->color = SbColor(1.0f, 0.0f, 0.0f);
     this->linepattern = 0xffff;
     this->linewidth = 3.0f;
-    this->searchaction = NULL;
+    this->searchaction = nullptr;
 
     // SoBase-derived objects should be dynamically allocated.
     this->postprocpath = new SoTempPath(32);
@@ -190,7 +190,7 @@ SoLineHighlightRenderAction::apply(SoNode * node)
   SoGLRenderAction::apply(node);
   
   if (this->hlVisible) {
-    if (PRIVATE(this)->searchaction == NULL) {
+    if (PRIVATE(this)->searchaction == nullptr) {
       PRIVATE(this)->searchaction = new SoSearchAction;
     }
     // Coin, and SGI Inventor, only supports one Selection node in a
@@ -361,18 +361,18 @@ SoLineHighlightRenderActionP::drawBoxes(SoPath * pathtothis,
   SoLinePatternElement::set(state, this->linepattern);
   SoTextureQualityElement::set(state, 0.0f);
   SoDrawStyleElement::set(state, SoDrawStyleElement::LINES);
-  SoPolygonOffsetElement::set(state, NULL, -1.0f, -1.0f, SoPolygonOffsetElement::LINES, true);
-  SoMaterialBindingElement::set(state, NULL, SoMaterialBindingElement::OVERALL); 
-  SoNormalElement::set(state, NULL, 0, NULL, false);
+  SoPolygonOffsetElement::set(state, nullptr, -1.0f, -1.0f, SoPolygonOffsetElement::LINES, true);
+  SoMaterialBindingElement::set(state, nullptr, SoMaterialBindingElement::OVERALL); 
+  SoNormalElement::set(state, nullptr, 0, nullptr, false);
  
-  SoOverrideElement::setNormalVectorOverride(state, NULL, true);
-  SoOverrideElement::setMaterialBindingOverride(state, NULL, true);
-  SoOverrideElement::setLightModelOverride(state, NULL, true);
-  SoOverrideElement::setDiffuseColorOverride(state, NULL, true);
-  SoOverrideElement::setLineWidthOverride(state, NULL, true);
-  SoOverrideElement::setLinePatternOverride(state, NULL, true);
-  SoOverrideElement::setDrawStyleOverride(state, NULL, true);
-  SoOverrideElement::setPolygonOffsetOverride(state, NULL, true);
+  SoOverrideElement::setNormalVectorOverride(state, nullptr, true);
+  SoOverrideElement::setMaterialBindingOverride(state, nullptr, true);
+  SoOverrideElement::setLightModelOverride(state, nullptr, true);
+  SoOverrideElement::setDiffuseColorOverride(state, nullptr, true);
+  SoOverrideElement::setLineWidthOverride(state, nullptr, true);
+  SoOverrideElement::setLinePatternOverride(state, nullptr, true);
+  SoOverrideElement::setDrawStyleOverride(state, nullptr, true);
+  SoOverrideElement::setPolygonOffsetOverride(state, nullptr, true);
   SoTextureOverrideElement::setQualityOverride(state, true);
 
   for (i = 0; i < pathlist->getLength(); i++) {
diff --git a/coin4/src/actions/SoRayPickAction.cpp b/coin4/src/actions/SoRayPickAction.cpp
index 50c248a..b047596 100644
--- a/coin4/src/actions/SoRayPickAction.cpp
+++ b/coin4/src/actions/SoRayPickAction.cpp
@@ -160,7 +160,7 @@
 
 class SoRayPickActionP {
 public:
-  SoRayPickActionP(void) : owner(NULL) { }
+  SoRayPickActionP(void) : owner(nullptr) { }
 
   // Hidden private methods.
 
@@ -448,7 +448,7 @@ SoRayPickAction::getPickedPointList(void) const
 /*!
   Returns the picked point with \a index in the list of picked points.
 
-  Returns \c NULL if less than \a index + 1 points where picked during
+  Returns \c nullptr if less than \a index + 1 points where picked during
   the last raypick action.
 */
 SoPickedPoint *
@@ -458,7 +458,7 @@ SoRayPickAction::getPickedPoint(const int index) const
   if (index < PRIVATE(this)->pickedpointlist.getLength()) {
     return this->getPickedPointList()[index];
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -989,7 +989,7 @@ SoPickedPoint *
 SoRayPickAction::addIntersection(const SbVec3f & objectspacepoint_in, bool frontpick)
 {
   if (PRIVATE(this)->isFlagSet(SoRayPickActionP::CULL_BACKFACES) && !frontpick)
-    return NULL;
+    return nullptr;
 
   SbVec3d objectspacepoint;
   objectspacepoint.setValue(objectspacepoint_in);
@@ -1000,7 +1000,7 @@ SoRayPickAction::addIntersection(const SbVec3f & objectspacepoint_in, bool front
 
   if (!PRIVATE(this)->isFlagSet(SoRayPickActionP::PICK_ALL) && PRIVATE(this)->pickedpointlist.getLength()) {
     // got to test if new candidate is closer than old one
-    if (dist >= PRIVATE(this)->ppdistance[0]) return NULL; // farther
+    if (dist >= PRIVATE(this)->ppdistance[0]) return nullptr; // farther
     // remove old point
     PRIVATE(this)->pickedpointlist.truncate(0);
     PRIVATE(this)->ppdistance.truncate(0);
diff --git a/coin4/src/actions/SoReorganizeAction.cpp b/coin4/src/actions/SoReorganizeAction.cpp
index e1f8156..223ee34 100644
--- a/coin4/src/actions/SoReorganizeAction.cpp
+++ b/coin4/src/actions/SoReorganizeAction.cpp
@@ -289,14 +289,14 @@
 class SoReorganizeActionP {
  public:
   SoReorganizeActionP(void)
-    : master(NULL),
+    : master(nullptr),
       gennormals(true),
       gentexcoords(true),
       gentristrips(false),
       genvp(false),
       matchidx(true),
       cbaction(SbViewportRegion(640, 480)),
-      pvcache(NULL)
+      pvcache(nullptr)
   {
     cbaction.addTriangleCallback(SoVertexShape::getClassTypeId(), triangle_cb, this);
     cbaction.addLineSegmentCallback(SoVertexShape::getClassTypeId(), line_segment_cb, this);
@@ -403,7 +403,7 @@ SoReorganizeAction::~SoReorganizeAction(void)
 SoSeparator *
 SoReorganizeAction::getSimplifiedSceneGraph(void) const
 {
-  return NULL;
+  return nullptr;
 }
 
 void
@@ -469,7 +469,7 @@ SoReorganizeAction::areIndexArraysMatched(void) const
 SoSimplifier *
 SoReorganizeAction::getSimplifier(void) const
 {
-  return NULL;
+  return nullptr;
 }
 
 void
@@ -583,7 +583,7 @@ SoReorganizeActionP::triangle_cb(void * userdata, SoCallbackAction * action,
 
   if (!thisp->didinit) {
     if (thisp->initShape(action)) {
-      assert(thisp->pvcache == NULL);
+      assert(thisp->pvcache == nullptr);
       thisp->pvcache = new SoPrimitiveVertexCache(action->getState());
       thisp->pvcache->ref();
     }
@@ -604,7 +604,7 @@ SoReorganizeActionP::line_segment_cb(void * userdata, SoCallbackAction * action,
 
   if (!thisp->didinit) {
     if (thisp->initShape(action)) {
-      assert(thisp->pvcache == NULL);
+      assert(thisp->pvcache == nullptr);
       thisp->pvcache = new SoPrimitiveVertexCache(action->getState());
       thisp->pvcache->ref();
     }
@@ -710,7 +710,7 @@ SoReorganizeActionP::initShape(SoCallbackAction * action)
 void
 SoReorganizeActionP::replaceNode(SoFullPath * path)
 {
-  if (this->pvcache == NULL) return;
+  if (this->pvcache == nullptr) return;
   this->pvcache->fit(); // needed to do optimize-sort of data
 
   if (this->pvcache->getNumTriangleIndices()) {
@@ -730,7 +730,7 @@ SoReorganizeActionP::replaceNode(SoFullPath * path)
     }
   }
   this->pvcache->unref();
-  this->pvcache = NULL;
+  this->pvcache = nullptr;
 }
 
 SoVertexProperty *
diff --git a/coin4/src/actions/SoSearchAction.cpp b/coin4/src/actions/SoSearchAction.cpp
index ede8839..efb93d5 100644
--- a/coin4/src/actions/SoSearchAction.cpp
+++ b/coin4/src/actions/SoSearchAction.cpp
@@ -123,8 +123,8 @@ SoSearchAction::initClass(void)
 */
 SoSearchAction::SoSearchAction(void)
   : lookfor(0), interest(FIRST), searchall(false),
-    node(NULL), type(SoType::badType()), name(""),
-    path(NULL) // paths(0)
+    node(nullptr), type(SoType::badType()), name(""),
+    path(nullptr) // paths(0)
 {
   SO_ACTION_CONSTRUCTOR(SoSearchAction);
 }
@@ -296,7 +296,7 @@ SoSearchAction::isSearchingAll(void) const
 
 /*!
   Returns the path to the node of interest that matched the search
-  criterions. If no match was found, \c NULL is returned.
+  criterions. If no match was found, \c nullptr is returned.
 
   Note that if \c ALL matches are of interest, the result of a search
   action must be fetched through SoSearchAction::getPaths().
@@ -349,11 +349,11 @@ SoSearchAction::reset(void)
   this->interest = SoSearchAction::FIRST;
   this->searchall = false;
   this->chkderived = true;
-  this->node = NULL;
+  this->node = nullptr;
   this->type = SoType::badType();
   this->name = SbName::empty();
   if (this->path) this->path->unref();
-  this->path = NULL;
+  this->path = nullptr;
   this->paths.truncate(0);
 }
 
@@ -397,7 +397,7 @@ SoSearchAction::addPath(SoPath * const pathptr)
 
   switch (this->interest) {
   case FIRST:
-    assert(! this->path); // should be NULL
+    assert(! this->path); // should be nullptr
     this->path = pathptr;
     this->path->ref();
     this->setFound();
@@ -429,7 +429,7 @@ SoSearchAction::beginTraversal(SoNode * nodeptr)
 {
   this->paths.truncate(0);
   if (this->path) this->path->unref();
-  this->path = NULL;
+  this->path = nullptr;
 
   // For compatibility with older application code which is using the
   // now obsoleted 'duringSearchAll' flag.
diff --git a/coin4/src/actions/SoToVRML2Action.cpp b/coin4/src/actions/SoToVRML2Action.cpp
index aaee671..5858906 100644
--- a/coin4/src/actions/SoToVRML2Action.cpp
+++ b/coin4/src/actions/SoToVRML2Action.cpp
@@ -91,7 +91,7 @@
   \endcode
 
   Note: if VRML97 support is not present in the Coin library, this
-  action does nothing and getVRML2SceneGraph always returns \c NULL.
+  action does nothing and getVRML2SceneGraph always returns \c nullptr.
 
   \sa SoToVRMLAction
 
@@ -203,7 +203,7 @@ SoToVRML2Action::initClass(void)
   Return a pointer to the root node of the generated scenegraph of
   only VRML2 / VRML97 nodes.
 
-  Will return \c NULL if VRML97 support was not compiled into the
+  Will return \c nullptr if VRML97 support was not compiled into the
   library.
 */
 
@@ -278,7 +278,7 @@ SoToVRML2Action::~SoToVRML2Action() { }
 void SoToVRML2Action::apply(SoNode * node) { }
 void SoToVRML2Action::apply(SoPath * path) { }
 void SoToVRML2Action::apply(const SoPathList & pathlist, bool obeysrules) { }
-SoVRMLGroup * SoToVRML2Action::getVRML2SceneGraph(void) const { return NULL; }
+SoVRMLGroup * SoToVRML2Action::getVRML2SceneGraph(void) const { return nullptr; }
 void SoToVRML2Action::beginTraversal(SoNode * node) { }
 void SoToVRML2Action::reuseAppearanceNodes(bool appearance) { }
 bool SoToVRML2Action::doReuseAppearanceNodes(void) const { return false; }
@@ -296,8 +296,8 @@ bool SoToVRML2Action::doReuseGeometryNodes(void) const { return false; }
 class SoToVRML2ActionP {
 public:
   SoToVRML2ActionP(void)
-    : master(NULL),nodefuse(false),reuseAppearanceNodes(false),reuseGeometryNodes(false),
-      vrml2path(NULL),vrml2root(NULL),bboxaction(NULL),vrmlcoords(NULL),vrmlnormals(NULL),vrmlcolors(NULL),vrmltexcoords(NULL)
+    : master(nullptr),nodefuse(false),reuseAppearanceNodes(false),reuseGeometryNodes(false),
+      vrml2path(nullptr),vrml2root(nullptr),bboxaction(nullptr),vrmlcoords(nullptr),vrmlnormals(nullptr),vrmlcolors(nullptr),vrmltexcoords(nullptr)
   {}
 
   ~SoToVRML2ActionP(void)
@@ -310,15 +310,15 @@ public:
 
   void init(void)
   {
-    this->bsptree = NULL;
-    this->bsptreetex = NULL;
-    this->bsptreenormal = NULL;
-    this->coordidx = NULL;
-    this->normalidx = NULL;
-    this->texidx = NULL;
-    this->coloridx = NULL;
-
-    recentTex2 = NULL;
+    this->bsptree = nullptr;
+    this->bsptreetex = nullptr;
+    this->bsptreenormal = nullptr;
+    this->coordidx = nullptr;
+    this->normalidx = nullptr;
+    this->texidx = nullptr;
+    this->coloridx = nullptr;
+
+    recentTex2 = nullptr;
     do_post_primitives = false;
     didpush = false;
 
@@ -347,7 +347,7 @@ public:
   }
 
   SoGetBoundingBoxAction * getBBoxAction(void) {
-    if (this->bboxaction == NULL) {
+    if (this->bboxaction == nullptr) {
       SbViewportRegion vp(DEFAULT_VIEWPORT_WIDTH, DEFAULT_VIEWPORT_HEIGHT);
       this->bboxaction = new SoGetBoundingBoxAction(vp);
     }
@@ -702,7 +702,7 @@ SoToVRML2ActionP::search_for_recent_node(SoAction * action, const SoType & type)
 
   this->searchaction.apply(const_cast<SoPath *>(action->getCurPath()));
 
-  SoNode * tail = NULL;
+  SoNode * tail = nullptr;
   SoFullPath * path = reclassify_cast<SoFullPath *>(this->searchaction.getPath());
   if (path) {
     tail = path->getTail();
@@ -874,11 +874,11 @@ SoToVRML2ActionP::insert_shape(SoCallbackAction * action, SoVRMLGeometry * geom)
     if (mat->transparency.getValue() != transp) mat->transparency = transp;
 
     // Texture
-    if (this->recentTex2 == NULL) {
+    if (this->recentTex2 == nullptr) {
       this->recentTex2 = coin_safe_cast<SoTexture2 *>(search_for_recent_node(action, SoTexture2::getClassTypeId()));
     }
 
-    if (this->recentTex2 != NULL) {
+    if (this->recentTex2 != nullptr) {
       SbVec2s size;
       int numComponents;
       const unsigned char * image = this->recentTex2->image.getValue(size, numComponents);
@@ -919,7 +919,7 @@ SoToVRML2ActionP::insert_shape(SoCallbackAction * action, SoVRMLGeometry * geom)
           appearance->textureTransform = textrans;
         }
       }
-      this->recentTex2 = NULL;
+      this->recentTex2 = nullptr;
     }
   } else {
     if (mat->emissiveColor.getValue() != diffuse) mat->emissiveColor = diffuse;
@@ -942,7 +942,7 @@ SoToVRML2ActionP::push_sep_cb(void * closure, SoCallbackAction * COIN_UNUSED_ARG
   }
 
   // Push a new SoVRMLGroup on the tail of the path
-  SoVRMLGroup * newgroup = NULL;
+  SoVRMLGroup * newgroup = nullptr;
 
   if (node->isOfType(SoVRMLTransform::getClassTypeId())) {
     const SoVRMLTransform * oldtrans = coin_assert_cast<const SoVRMLTransform*>(node);
@@ -1337,7 +1337,7 @@ SoToVRML2ActionP::soifs_cb(void * closure, SoCallbackAction * action, const SoNo
 
   const SoCoordinateElement * coordElem = SoCoordinateElement::getInstance(action->getState());
   if (coordElem->getNum() > 0) {
-    if (coordElem->getArrayPtr3() != NULL) {
+    if (coordElem->getArrayPtr3() != nullptr) {
       ifs->coord = thisp->get_or_create_coordinate(coordElem->getArrayPtr3(),
                                                    coordElem->getNum());
     } else {
@@ -1433,14 +1433,14 @@ SoToVRML2ActionP::soils_cb(void * closure, SoCallbackAction * action, const SoNo
     vp->callback(action);
   }
 
-  SoVRMLCoordinate * newcoord = NULL;
+  SoVRMLCoordinate * newcoord = nullptr;
   const SoCoordinateElement * coordElem = SoCoordinateElement::getInstance(action->getState());
   if (coordElem->getNum() > 0) {
     if (thisp->nodefuse) {
       newcoord = new SoVRMLCoordinate;
     }
     else {
-      if (coordElem->getArrayPtr3() != NULL) {
+      if (coordElem->getArrayPtr3() != nullptr) {
         newcoord = thisp->get_or_create_coordinate(coordElem->getArrayPtr3(),
                                                    coordElem->getNum());
       } else {
@@ -1475,7 +1475,7 @@ SoToVRML2ActionP::soils_cb(void * closure, SoCallbackAction * action, const SoNo
     const int32_t * src = oldils->coordIndex.getValues(0);
 
     SbVec3f * c = const_cast<SbVec3f*>(coordElem->getArrayPtr3());
-    if (c == NULL) {
+    if (c == nullptr) {
       SbVec3f * vec3f = new SbVec3f[coordElem->getNum()];
       const SbVec4f * coord4 = coordElem->getArrayPtr4();
       for (int i=coordElem->getNum()-1; i >= 0; i--) {
@@ -1498,7 +1498,7 @@ SoToVRML2ActionP::soils_cb(void * closure, SoCallbackAction * action, const SoNo
     newcoord->point.setValues(0, bsp.numPoints(),
                               bsp.getPointsArrayPtr());
 
-    if (coordElem->getArrayPtr3() == NULL) delete[] c;
+    if (coordElem->getArrayPtr3() == nullptr) delete[] c;
 
   }
   else {
@@ -1595,7 +1595,7 @@ SoToVRML2ActionP::solineset_cb(void * closure, SoCallbackAction * action, const
 
   const SoCoordinateElement * coordElem = SoCoordinateElement::getInstance(action->getState());
   if (coordElem->getNum() > 0) {
-    if (coordElem->getArrayPtr3() != NULL) {
+    if (coordElem->getArrayPtr3() != nullptr) {
       ils->coord = thisp->get_or_create_coordinate(coordElem->getArrayPtr3(),
                                                    coordElem->getNum());
     } else {
@@ -1721,7 +1721,7 @@ SoToVRML2ActionP::sopointset_cb(void * closure, SoCallbackAction * action, const
   if (numpts < 0 || numpts > coordElem->getNum()) numpts = coordElem->getNum();
 
   if (numpts) {
-    if (coordElem->getArrayPtr3() != NULL) {
+    if (coordElem->getArrayPtr3() != nullptr) {
       ps->coord = thisp->get_or_create_coordinate(coordElem->getArrayPtr3(), numpts);
     }
     else {
@@ -2103,10 +2103,10 @@ SoToVRML2ActionP::post_primitives_cb(void * closure, SoCallbackAction * action,
 
     // we need some specific handling for VRML nodes, since these
     // nodes store the state inside the node in fields
-    const SoSFBool * ccw_field = NULL;
-    const SoSFBool * solid_field = NULL;
-    const SoSFBool * convex_field = NULL;
-    const SoSFFloat * creaseangle_field = NULL;
+    const SoSFBool * ccw_field = nullptr;
+    const SoSFBool * solid_field = nullptr;
+    const SoSFBool * convex_field = nullptr;
+    const SoSFFloat * creaseangle_field = nullptr;
 
     if (node->isOfType(SoVRMLGeometry::getClassTypeId())) {
       ccw_field = static_cast<const SoSFBool*>(node->getField("ccw"));
@@ -2174,14 +2174,14 @@ SoToVRML2ActionP::post_primitives_cb(void * closure, SoCallbackAction * action,
 
   }
 
-  delete thisp->bsptree; thisp->bsptree = NULL;
-  delete thisp->bsptreetex; thisp->bsptreetex = NULL;
-  delete thisp->bsptreenormal; thisp->bsptreenormal = NULL;
+  delete thisp->bsptree; thisp->bsptree = nullptr;
+  delete thisp->bsptreetex; thisp->bsptreetex = nullptr;
+  delete thisp->bsptreenormal; thisp->bsptreenormal = nullptr;
 
-  delete thisp->coordidx; thisp->coordidx = NULL;
-  delete thisp->normalidx; thisp->normalidx = NULL;
-  delete thisp->texidx; thisp->texidx = NULL;
-  delete thisp->coloridx; thisp->coloridx = NULL;
+  delete thisp->coordidx; thisp->coordidx = nullptr;
+  delete thisp->normalidx; thisp->normalidx = nullptr;
+  delete thisp->texidx; thisp->texidx = nullptr;
+  delete thisp->coloridx; thisp->coloridx = nullptr;
 
   thisp->insert_shape(action, is);
 
diff --git a/coin4/src/actions/SoToVRMLAction.cpp b/coin4/src/actions/SoToVRMLAction.cpp
index 90144b0..0de89f2 100644
--- a/coin4/src/actions/SoToVRMLAction.cpp
+++ b/coin4/src/actions/SoToVRMLAction.cpp
@@ -112,7 +112,7 @@ SO_ACTION_SOURCE(SoToVRMLAction);
 class SoToVRMLActionP {
 public:
   SoToVRMLActionP(void)
-    : master(NULL)
+    : master(nullptr)
   {
     this->expandsofile = false;
     this->urlname = "";
@@ -127,15 +127,15 @@ public:
 
     this->nodefuse = false; // for optimizing bad scene graphs
 
-    this->bsptree = NULL;
-    this->bsptreetex = NULL;
-    this->bsptreenormal = NULL;
-    this->coordidx = NULL;
-    this->normalidx = NULL;
-    this->texidx = NULL;
-    this->coloridx = NULL;
-    this->vrmlpath = NULL;
-    this->vrmlroot = NULL;
+    this->bsptree = nullptr;
+    this->bsptreetex = nullptr;
+    this->bsptreenormal = nullptr;
+    this->coordidx = nullptr;
+    this->normalidx = nullptr;
+    this->texidx = nullptr;
+    this->coloridx = nullptr;
+    this->vrmlpath = nullptr;
+    this->vrmlroot = nullptr;
   }
 
   void init(void) {
@@ -467,12 +467,12 @@ SoNode *
 SoToVRMLActionP::search_for_node(SoNode * root, const SbName & name, const SoType & type)
 {
   SoNodeList mylist;
-  if (name == SbName::empty()) return NULL;
+  if (name == SbName::empty()) return nullptr;
 
   mylist.truncate(0);
   int num = SoNode::getByName(name, mylist);
   int cnt = 0;
-  SoNode * retnode = NULL;
+  SoNode * retnode = nullptr;
   for (int i = 0; i < num; i++) {
     SoNode * node = mylist[i];
     if (node->getTypeId() == type) {
@@ -483,7 +483,7 @@ SoToVRMLActionP::search_for_node(SoNode * root, const SbName & name, const SoTyp
 
   // if there is only one node with that name, return it
   if (retnode && cnt == 1) return retnode;
-  if (!retnode) return NULL;
+  if (!retnode) return nullptr;
 
   this->searchaction.setSearchingAll(true);
   this->searchaction.setName(name);
@@ -497,7 +497,7 @@ SoToVRMLActionP::search_for_node(SoNode * root, const SbName & name, const SoTyp
 #endif // HAVE_NODEKITS
 
   this->searchaction.apply(root);
-  SoNode * tail = NULL;
+  SoNode * tail = nullptr;
   SoFullPath * path = reclassify_cast<SoFullPath*>(this->searchaction.getPath());
   if (path) {
     tail = path->getTail();
@@ -520,17 +520,17 @@ SoToVRMLActionP::get_current_tail(void)
 SoMaterial *
 SoToVRMLActionP::find_or_create_material(void)
 {
-  SoMaterial * mat = NULL;
+  SoMaterial * mat = nullptr;
   SoGroup * tail = this->get_current_tail();
 
   int num = tail->getNumChildren();
-  while (--num >= 0 && mat == NULL) {
+  while (--num >= 0 && mat == nullptr) {
     SoNode * node = tail->getChild(num);
     if (node->isOfType(SoMaterial::getClassTypeId())) {
       mat = coin_assert_cast<SoMaterial*>(node);
     }
   }
-  if (mat == NULL) {
+  if (mat == nullptr) {
     mat = new SoMaterial;
     tail->addChild(mat);
   }
@@ -638,14 +638,14 @@ SoToVRMLActionP::post_primitives_cb(void * closure, SoCallbackAction * COIN_UNUS
 
   tail->addChild(ifs);
 
-  delete thisp->bsptree; thisp->bsptree = NULL;
-  delete thisp->bsptreetex; thisp->bsptreetex = NULL;
-  delete thisp->bsptreenormal; thisp->bsptreenormal = NULL;
+  delete thisp->bsptree; thisp->bsptree = nullptr;
+  delete thisp->bsptreetex; thisp->bsptreetex = nullptr;
+  delete thisp->bsptreenormal; thisp->bsptreenormal = nullptr;
 
-  delete thisp->coordidx; thisp->coordidx = NULL;
-  delete thisp->normalidx; thisp->normalidx = NULL;
-  delete thisp->texidx; thisp->texidx = NULL;
-  delete thisp->coloridx; thisp->coloridx = NULL;
+  delete thisp->coordidx; thisp->coordidx = nullptr;
+  delete thisp->normalidx; thisp->normalidx = nullptr;
+  delete thisp->texidx; thisp->texidx = nullptr;
+  delete thisp->coloridx; thisp->coloridx = nullptr;
 
   return SoCallbackAction::CONTINUE;
 }
@@ -982,7 +982,7 @@ SoToVRMLActionP::vrmlils_cb(void * closure, SoCallbackAction * COIN_UNUSED_ARG(a
   SoVRMLCoordinate * coord = coin_assert_cast<SoVRMLCoordinate *>(oldils->coord.getValue());
   SoGroup * tail = thisp->get_current_tail();
 
-  SoCoordinate3 * newcoord = NULL;
+  SoCoordinate3 * newcoord = nullptr;
 
   if (coord) {
     if (thisp->nodefuse) {
@@ -1132,7 +1132,7 @@ SoToVRMLActionP::vrmlelevation_cb(void * closure, SoCallbackAction * COIN_UNUSED
                                 color->color.getValues(0));
   }
 
-  thisp->init_gen(color != NULL);
+  thisp->init_gen(color != nullptr);
   return SoCallbackAction::CONTINUE;
 }
 
diff --git a/coin4/src/actions/SoWriteAction.cpp b/coin4/src/actions/SoWriteAction.cpp
index 80d3dec..87a4e26 100644
--- a/coin4/src/actions/SoWriteAction.cpp
+++ b/coin4/src/actions/SoWriteAction.cpp
@@ -220,7 +220,7 @@ void
 SoWriteAction::beginTraversal(SoNode * node)
 {
 #if COIN_DEBUG
-  SoNodeSensor *sensor = NULL;
+  SoNodeSensor *sensor = nullptr;
 #endif
   if (this->continuing == false) { // Run through both stages.
     // call SoWriterefCounter::instance() before traversing to set the
@@ -230,7 +230,7 @@ SoWriteAction::beginTraversal(SoNode * node)
 
 #if COIN_DEBUG
     if (SoWriterefCounter::debugWriterefs()) {
-      sensor = new SoNodeSensor(sensorCB, NULL);
+      sensor = new SoNodeSensor(sensorCB, nullptr);
       sensor->setPriority(0);
       sensor->attach(node);
     }
@@ -317,13 +317,13 @@ BOOST_AUTO_TEST_CASE(GlobalField)
   SoOutput out;
   const int buffer_size = 1024;
   char * buffer = (char *)malloc(buffer_size);
-  out.setBuffer(buffer, buffer_size, NULL);
+  out.setBuffer(buffer, buffer_size, nullptr);
 
   SoWriteAction wa(&out);
   wa.apply((SoNode *)top);
 
   top->unref();
-  top = NULL;
+  top = nullptr;
 
   // read scene again to check if realTime field was written
   in.setBuffer((void *)buffer, strlen(buffer));
diff --git a/coin4/src/base/SbBSPTree.cpp b/coin4/src/base/SbBSPTree.cpp
index 3ab024d..0b9db3f 100644
--- a/coin4/src/base/SbBSPTree.cpp
+++ b/coin4/src/base/SbBSPTree.cpp
@@ -84,7 +84,7 @@ private:
 coin_bspnode::coin_bspnode(SbList <SbVec3f> *ptsarray)
   : indices(4)
 {
-  this->left = this->right = NULL;
+  this->left = this->right = nullptr;
   this->pointsArray = ptsarray;
   this->dimension = DIM_NONE;
 }
@@ -236,7 +236,7 @@ coin_bspnode::removePoint(const SbVec3f &pt)
 void
 coin_bspnode::split()
 {
-  assert(this->left == NULL && this->right == NULL);
+  assert(this->left == nullptr && this->right == nullptr);
   this->left = new coin_bspnode(this->pointsArray);
   this->right = new coin_bspnode(this->pointsArray);
 
@@ -512,7 +512,7 @@ void
 SbBSPTree::clear(const int COIN_UNUSED_ARG(initsize))
 {
   delete this->topnode;
-  this->topnode = NULL;
+  this->topnode = nullptr;
   this->pointsArray.truncate(0, true);
   this->userdataArray.truncate(0, true);
   this->topnode = new coin_bspnode(&this->pointsArray);
diff --git a/coin4/src/base/SbClip.cpp b/coin4/src/base/SbClip.cpp
index e8ff1c1..b4395e1 100644
--- a/coin4/src/base/SbClip.cpp
+++ b/coin4/src/base/SbClip.cpp
@@ -95,7 +95,7 @@ SbClip::outputVertex(const SbVec3f & v, void * data)
 /*!
   Clip polygon against \a plane. This might change the number of
   vertices in the polygon. For each time a new vertex is created, the
-  callback supplied in the constructor (if != NULL) is called with the
+  callback supplied in the constructor (if != nullptr) is called with the
   line being clipped and the new vertex calculated. The callback
   should return a new void pointer to be stored by the clipper.
 */
@@ -127,7 +127,7 @@ SbClip::clip(const SbPlane & plane)
       (void) dir.normalize();
       float dot = dir.dot(planeN);
       SbVec3f newvertex = v0 - dir * (d0/dot);
-      void * newdata = NULL;
+      void * newdata = nullptr;
       if (this->callback) {
         newdata = this->callback(v0, data0, v1, data1, newvertex, this->cbdata);
       }
@@ -139,7 +139,7 @@ SbClip::clip(const SbPlane & plane)
       (void) dir.normalize();
       float dot = dir.dot(planeN);
       SbVec3f newvertex = v0 - dir * (d0/dot);
-      void * newdata = NULL;
+      void * newdata = nullptr;
       if (this->callback) {
         newdata = this->callback(v0, data0, v1, data1, newvertex, this->cbdata);
       }
diff --git a/coin4/src/base/SbDict.cpp b/coin4/src/base/SbDict.cpp
index f30f754..3689063 100644
--- a/coin4/src/base/SbDict.cpp
+++ b/coin4/src/base/SbDict.cpp
@@ -67,7 +67,7 @@ SbDict::SbDict(const int entries)
 */
 SbDict::SbDict(const SbDict & from)
 {
-  this->hashtable = NULL;
+  this->hashtable = nullptr;
   this->operator=(from);
 }
 
diff --git a/coin4/src/base/SbGLUTessellator.cpp b/coin4/src/base/SbGLUTessellator.cpp
index 053a4fa..eed6e19 100644
--- a/coin4/src/base/SbGLUTessellator.cpp
+++ b/coin4/src/base/SbGLUTessellator.cpp
@@ -27,6 +27,8 @@
 #include <Inventor/C/tidbits.h>
 #include <Inventor/system/gl.h>
 
+#include <cstdlib>
+
 // *************************************************************************
 
 bool
@@ -52,7 +54,7 @@ SbGLUTessellator::SbGLUTessellator(void (* cb)(void *, void *, void *, void *),
 
   // allocated later on demand, so there is no resource allocation
   // when just putting an SbGLUTessellator on the current stack frame:
-  this->tessobj = NULL;
+  this->tessobj = nullptr;
 }
 
 SbGLUTessellator::~SbGLUTessellator()
diff --git a/coin4/src/base/SbGLUTessellator.h b/coin4/src/base/SbGLUTessellator.h
index 7d392ec..0008aa1 100644
--- a/coin4/src/base/SbGLUTessellator.h
+++ b/coin4/src/base/SbGLUTessellator.h
@@ -42,7 +42,7 @@ public:
   static bool available(void);
 
   SbGLUTessellator(void (*callback)(void * v0, void * v1, void * v2,
-                                    void * data) = NULL, void * userdata = NULL);
+                                    void * data) = nullptr, void * userdata = nullptr);
   ~SbGLUTessellator(void);
 
   void beginPolygon(const SbVec3f & normal = SbVec3f(0.0f, 0.0f, 0.0f));
diff --git a/coin4/src/base/SbHeap.cpp b/coin4/src/base/SbHeap.cpp
index 30b0292..457f927 100644
--- a/coin4/src/base/SbHeap.cpp
+++ b/coin4/src/base/SbHeap.cpp
@@ -74,7 +74,7 @@ SbHeap::SbHeap(const SbHeapFuncs &hFuncs, const int initsize)
 {
   this->funcs = hFuncs;
   assert(funcs.eval_func);
-  this->heap.append(NULL);
+  this->heap.append(nullptr);
 }
 
 /*!
@@ -91,7 +91,7 @@ void
 SbHeap::emptyHeap(void)
 {
   this->heap.truncate(0);
-  this->heap.append(NULL);
+  this->heap.append(nullptr);
 }
 
 /*!
@@ -152,7 +152,7 @@ SbHeap::remove(void *obj)
 }
 
 /*!
-  Returns and removes the first element in the heap, or \a NULL
+  Returns and removes the first element in the heap, or \a nullptr
   if heap is empty.
 */
 void *
@@ -162,7 +162,7 @@ SbHeap::extractMin(void)
 }
 
 /*!
-  Returns the first element in the heap, or \e NULL if heap is empty.
+  Returns the first element in the heap, or \e nullptr if heap is empty.
 */
 void *
 SbHeap::getMin(void)
@@ -170,7 +170,7 @@ SbHeap::getMin(void)
   if (this->heap.getLength() > 1)
     return heap[1];
   else
-    return NULL;
+    return nullptr;
 }
 
 /*!
@@ -288,7 +288,7 @@ SbHeap::heapExtractMin(void)
 {
   int hsize = this->heap.getLength()-1;
   void *min;
-  if (hsize < 1) return NULL;
+  if (hsize < 1) return nullptr;
   min = this->heap[1];
   this->heap[1] = this->heap[hsize];
   if (this->funcs.set_index_func)
@@ -308,7 +308,7 @@ SbHeap::heapInsert(void *obj)
   void (*setindex)(void*,int) = this->funcs.set_index_func;
   float (*eval)(void*) = this->funcs.eval_func;
 
-  this->heap.append(NULL); // will be overwritten later
+  this->heap.append(nullptr); // will be overwritten later
 
   while (i > 1 && eval(this->heap[i>>1]) > eval(obj)) {
     this->heap[i] = this->heap[i>>1];
diff --git a/coin4/src/base/SbImage.cpp b/coin4/src/base/SbImage.cpp
index 770d687..05500a7 100644
--- a/coin4/src/base/SbImage.cpp
+++ b/coin4/src/base/SbImage.cpp
@@ -81,11 +81,11 @@ public:
   };
 
   SbImageP(void)
-    : bytes(NULL),
+    : bytes(nullptr),
       datatype(SETVALUEPTR_DATA),
       size(0,0,0),
       bpp(0),
-      schedulecb(NULL)
+      schedulecb(nullptr)
 #ifdef COIN_THREADSAFE
     , rwmutex(SbRWMutex::READ_PRECEDENCE)
 #endif // COIN_THREADSAFE
@@ -98,14 +98,14 @@ public:
         break;
       case INTERNAL_DATA:
         delete[] this->bytes;
-        this->bytes = NULL;
+        this->bytes = nullptr;
         break;
       case SIMAGE_DATA:
         simage_wrapper()->simage_free_image(this->bytes);
-        this->bytes = NULL;
+        this->bytes = nullptr;
         break;
       case SETVALUEPTR_DATA:
-        this->bytes = NULL;
+        this->bytes = nullptr;
         break;
       }
     }
@@ -155,12 +155,12 @@ extern "C" {
 
 static void SbImage_cleanup_callback(void) {
   delete SbImageP::readimagecallbacks;
-  SbImageP::readimagecallbacks = NULL;
+  SbImageP::readimagecallbacks = nullptr;
 }
 
 } // extern "C"
 
-SbList <SbImageP::ReadImageCBData> * SbImageP::readimagecallbacks = NULL;
+SbList <SbImageP::ReadImageCBData> * SbImageP::readimagecallbacks = nullptr;
 
 //////////////////////////////////////////////////////////////////////////
 
@@ -281,7 +281,7 @@ SbImage::setValuePtr(const SbVec3s & size, const int bytesperpixel,
 {
   PRIVATE(this)->writeLock();
   PRIVATE(this)->schedulename = "";
-  PRIVATE(this)->schedulecb = NULL;
+  PRIVATE(this)->schedulecb = nullptr;
   PRIVATE(this)->freeData();
   PRIVATE(this)->bytes = const_cast<unsigned char *>(bytes);
   PRIVATE(this)->datatype = SbImageP::SETVALUEPTR_DATA;
@@ -303,8 +303,8 @@ SbImage::setValue(const SbVec2s & size, const int bytesperpixel,
 
 /*!
   Sets the image to \a size and \a bytesperpixel. If \a bytes !=
-  NULL, data is copied from \a bytes into this class' image data. If
-  \a bytes == NULL, the image data is left uninitialized.
+  nullptr, data is copied from \a bytes into this class' image data. If
+  \a bytes == nullptr, the image data is left uninitialized.
 
   The image data will always be allocated in multiples of four. This
   means that if you set an image with size == (1,1,1) and bytesperpixel
@@ -323,7 +323,7 @@ SbImage::setValue(const SbVec3s & size, const int bytesperpixel,
 {
   PRIVATE(this)->writeLock();
   PRIVATE(this)->schedulename = "";
-  PRIVATE(this)->schedulecb = NULL;
+  PRIVATE(this)->schedulecb = nullptr;
   if (PRIVATE(this)->bytes && PRIVATE(this)->datatype == SbImageP::INTERNAL_DATA) {
     // check for special case where we don't have to reallocate
     if (bytes && (size == PRIVATE(this)->size) && (bytesperpixel == PRIVATE(this)->bpp)) {
@@ -382,7 +382,7 @@ SbImage::getValue(SbVec3s & size, int & bytesperpixel) const
     bool scheduled = PRIVATE(this)->schedulecb(PRIVATE(this)->schedulename, const_cast<SbImage *>(this),
                                         PRIVATE(this)->scheduleclosure);
     if (scheduled) {
-      PRIVATE(this)->schedulecb = NULL;
+      PRIVATE(this)->schedulecb = nullptr;
     }
   }
   size = PRIVATE(this)->size;
@@ -517,7 +517,7 @@ SbImage::readFile(const SbString & filename,
   }
 #endif // COIN_DEBUG
     
-  this->setValue(SbVec3s(0,0,0), 0, NULL);
+  this->setValue(SbVec3s(0,0,0), 0, nullptr);
   return false;
 }
 
@@ -540,7 +540,7 @@ SbImage::operator==(const SbImage & image) const
   if (!PRIVATE(this)->schedulecb && !PRIVATE(&image)->schedulecb) {
     if (PRIVATE(this)->size != PRIVATE(&image)->size) ret = 0;
     else if (PRIVATE(this)->bpp != PRIVATE(&image)->bpp) ret = 0;
-    else if (PRIVATE(this)->bytes == NULL || PRIVATE(&image)->bytes == NULL) {
+    else if (PRIVATE(this)->bytes == nullptr || PRIVATE(&image)->bytes == nullptr) {
       ret = (PRIVATE(this)->bytes == PRIVATE(&image)->bytes);
     }
     else {
@@ -611,9 +611,9 @@ SbImage::scheduleReadFile(SbImageScheduleReadCB * cb,
                           const SbString * const * searchdirectories,
                           const int numdirectories)
 {
-  this->setValue(SbVec3s(0,0,0), 0, NULL);
+  this->setValue(SbVec3s(0,0,0), 0, nullptr);
   PRIVATE(this)->writeLock();
-  PRIVATE(this)->schedulecb = NULL;
+  PRIVATE(this)->schedulecb = nullptr;
   PRIVATE(this)->schedulename =
     this->searchForFile(filename, searchdirectories, numdirectories);
   int len = PRIVATE(this)->schedulename.getLength();
@@ -637,7 +637,7 @@ SbImage::hasData(void) const
 {
   bool ret;
   this->readLock();
-  ret = PRIVATE(this)->bytes != NULL;
+  ret = PRIVATE(this)->bytes != nullptr;
   this->readUnlock();
   return ret;
 }
diff --git a/coin4/src/base/SbName.cpp b/coin4/src/base/SbName.cpp
index 7336871..677773d 100644
--- a/coin4/src/base/SbName.cpp
+++ b/coin4/src/base/SbName.cpp
@@ -341,13 +341,13 @@ SbName::operator const char * (void) const
 /* anonymous namespace for management of the empty SbName instance */
 namespace {
 
-  SbName * emptyname = NULL;
+  SbName * emptyname = nullptr;
 
   void
   SbName_atexit(void) {
-    if (emptyname != NULL) {
+    if (emptyname != nullptr) {
       delete emptyname;
-      emptyname = NULL;
+      emptyname = nullptr;
     }
   }
 }
@@ -362,7 +362,7 @@ namespace {
 const SbName &
 SbName::empty(void) // static
 {
-  if (emptyname == NULL) {
+  if (emptyname == nullptr) {
     emptyname = new SbName("");
     coin_atexit(SbName_atexit, CC_ATEXIT_SBNAME);
   }
diff --git a/coin4/src/base/SbOctTree.cpp b/coin4/src/base/SbOctTree.cpp
index fe4f02b..a39ce12 100644
--- a/coin4/src/base/SbOctTree.cpp
+++ b/coin4/src/base/SbOctTree.cpp
@@ -172,7 +172,7 @@ public:
   void debugTree(FILE *fp, const int indent) const;
 
 private:
-  bool isLeaf(void) const { return this->children[0] == NULL; }
+  bool isLeaf(void) const { return this->children[0] == nullptr; }
   bool isGroup(void) const { return ! this->isLeaf(); }
 
   unsigned int totalNumberOfItems(void) const;
@@ -235,7 +235,7 @@ add_to_array(SbList<void *> & array, void * ptr)
 SbOctTreeNode::SbOctTreeNode(const SbBox3f & b)
 {
   for (int i = 0; i < 8; i++) {
-    this->children[i] = NULL;
+    this->children[i] = nullptr;
   }
   this->nodesize = b;
 }
@@ -450,7 +450,7 @@ SbOctTreeNode::splitNode(const SbOctTreeFuncs & itemfuncs)
     if (this->children[i]->items.getLength() == n) {
       for (int j = 0; j < 8; j++) {
         delete this->children[j];
-        this->children[j] = NULL;
+        this->children[j] = nullptr;
       }
       return false;
     }
diff --git a/coin4/src/base/SbTesselator.cpp b/coin4/src/base/SbTesselator.cpp
index 869f861..9827474 100644
--- a/coin4/src/base/SbTesselator.cpp
+++ b/coin4/src/base/SbTesselator.cpp
@@ -56,7 +56,7 @@
     SbVec3f(0, 1, 0), SbVec3f(0, 0, 0)
   };
 
-  SbTesselator mytessellator(tess_cb, NULL);
+  SbTesselator mytessellator(tess_cb, nullptr);
   mytessellator.beginPolygon();
   for (int i=0; i < 4; i++) {
     mytessellator.addVertex(vertices[i], &vertices[i]);
@@ -236,7 +236,7 @@ SbTesselator::PImpl::heap_evaluate(void * v)
 SbTesselator::SbTesselator(SbTesselatorCB * func, void * data)
 {
   this->setCallback(func, data);
-  PRIVATE(this)->headV = PRIVATE(this)->tailV = NULL;
+  PRIVATE(this)->headV = PRIVATE(this)->tailV = nullptr;
   PRIVATE(this)->currVertex = 0;
 
   PRIVATE(this)->heap =
@@ -280,7 +280,7 @@ SbTesselator::beginPolygon(bool keepVerts, const SbVec3f &normal)
   else {
     PRIVATE(this)->hasNormal = false;
   }
-  PRIVATE(this)->headV = PRIVATE(this)->tailV = NULL;
+  PRIVATE(this)->headV = PRIVATE(this)->tailV = nullptr;
   PRIVATE(this)->numVerts = 0;
   PRIVATE(this)->bbox.makeEmpty();
 }
@@ -302,7 +302,7 @@ SbTesselator::addVertex(const SbVec3f &v,void *data)
   PImpl::Vertex *newv = PRIVATE(this)->newVertex();
   newv->v = v;
   newv->data = data;
-  newv->next = NULL;
+  newv->next = nullptr;
   newv->dirtyweight = 1;
   newv->weight = FLT_MAX;
   newv->prev = PRIVATE(this)->tailV;
@@ -331,7 +331,7 @@ SbTesselator::endPolygon(void)
     PImpl::Vertex * last = PRIVATE(this)->tailV;
     if (first->v == last->v) {
       PImpl::Vertex * newlast = last->prev;
-      newlast->next = NULL;
+      newlast->next = nullptr;
       // don't delete old tail. We have some special memory handling
       // in this class
       PRIVATE(this)->tailV = newlast;
@@ -740,7 +740,7 @@ SbTesselator::PImpl::calcPolygonNormal()
   Vertex *currvertex = this->headV;
   vert2 = currvertex->v;
 
-  while (currvertex->next != NULL && currvertex != tailV) {
+  while (currvertex->next != nullptr && currvertex != tailV) {
     vert1 = vert2;
     vert2 = currvertex->next->v;
     this->polyNormal[0] += (vert1[1] - vert2[1]) * (vert1[2] + vert2[2]);
@@ -782,7 +782,7 @@ SbTesselator::PImpl::newVertex()
 void
 SbTesselator::PImpl::cleanUp()
 {
-  this->headV = this->tailV = NULL;
+  this->headV = this->tailV = nullptr;
   this->currVertex = 0;
   this->numVerts = 0;
 }
diff --git a/coin4/src/base/SbTime.cpp b/coin4/src/base/SbTime.cpp
index 774172f..5ecab61 100644
--- a/coin4/src/base/SbTime.cpp
+++ b/coin4/src/base/SbTime.cpp
@@ -400,9 +400,9 @@ SbString
 SbTime::format(const char * const fmt) const
 {
 #if COIN_DEBUG
-  if (fmt==NULL) {
+  if (fmt==nullptr) {
     SoDebugError::postWarning("SbTime::format",
-                              "Format string is NULL.");
+                              "Format string is nullptr.");
     return SbString("");
   }
 #endif // COIN_DEBUG
@@ -513,7 +513,7 @@ SbTime::format(const char * const fmt) const
   your reference documentation for strftime() for information on the
   format modifiers available.
 
-  Default formatting is used if \a fmt is \c NULL. Note that the
+  Default formatting is used if \a fmt is \c nullptr. Note that the
   default formatting is different on Microsoft Windows systems versus
   all other systems. For Windows, it is \c "%#c", for other systems it
   is \c "%A, %D %r" (again, see system documentation on strftime() for
@@ -531,7 +531,7 @@ SbString
 SbTime::formatDate(const char * const fmt) const
 {
   const char * format = fmt;
-  if (format == NULL) {
+  if (format == nullptr) {
 #ifdef HAVE_WIN32_API
     format = "%#c";
 #else // ! HAVE_WIN32_API
@@ -551,7 +551,7 @@ SbTime::formatDate(const char * const fmt) const
 
   size_t ret = strftime(bufferpt, currentsize, format, ts);
   if ((ret == 0) || (ret == currentsize)) {
-    bufferpt = NULL;
+    bufferpt = nullptr;
     // The resulting string was too large, so we will allocate
     // a subsequently larger buffer until the date string fits.
     do {
@@ -595,7 +595,7 @@ SbTime::parsedate(const char * const date)
 #if COIN_DEBUG
   if (!date) {
     SoDebugError::postWarning("SbTime::parsedate",
-                              "date string is NULL.");
+                              "date string is nullptr.");
     return false;
   }
 #endif // COIN_DEBUG
diff --git a/coin4/src/base/coinString.h b/coin4/src/base/coinString.h
index 1965024..d82db88 100644
--- a/coin4/src/base/coinString.h
+++ b/coin4/src/base/coinString.h
@@ -5,7 +5,7 @@
 namespace CoinInternal {
   template<typename Target>
     Target
-    FromString(const SbString & input, bool * conversionOk = NULL ) {
+    FromString(const SbString & input, bool * conversionOk = nullptr ) {
     typename SbTypeInfo<Target>::SFieldType to;
     bool worked = to.set(input.getString());
     if (conversionOk)
@@ -37,7 +37,7 @@ template<class Then, class Else>
 
 template <typename T>
 struct Convert {
-  static T fromString(const SbString & input, bool * conversionOk = NULL)
+  static T fromString(const SbString & input, bool * conversionOk = nullptr)
   {
     T to;
     bool worked = to.fromString(input);
@@ -60,7 +60,7 @@ struct Convert {
 
 template <typename T>
 struct ConvertPrimitive {
-  static T fromString(const SbString & input, bool * conversionOk = NULL)
+  static T fromString(const SbString & input, bool * conversionOk = nullptr)
   {
     return CoinInternal::FromString<T>(input,conversionOk);
   }
@@ -74,7 +74,7 @@ struct ConvertPrimitive {
 
 template<typename Target>
 Target
-FromString(const SbString & input, bool * conversionOk = NULL)
+FromString(const SbString & input, bool * conversionOk = nullptr)
 {
   return IF<
     SbTypeInfo<Target>::isPrimitive,
diff --git a/coin4/src/base/dict.cpp b/coin4/src/base/dict.cpp
index 088c70f..aa80267 100644
--- a/coin4/src/base/dict.cpp
+++ b/coin4/src/base/dict.cpp
@@ -58,7 +58,7 @@ dict_default_hashfunc(const uintptr_t key)
 static unsigned int
 dict_get_index(cc_dict * ht, uintptr_t key)
 {
-  assert(ht != NULL);
+  assert(ht != nullptr);
   key = ht->hashfunc(key);
   return (unsigned int) (key % ht->size);
 }
@@ -244,12 +244,12 @@ cc_dict_remove(cc_dict * ht, uintptr_t key)
   unsigned int i = dict_get_index(ht, key);
 
   he = ht->buckets[i];
-  prev = NULL;
+  prev = nullptr;
   while (he) {
     next = he->next;
     if (he->key == key) {
       ht->elements--;
-      if (prev == NULL) {
+      if (prev == nullptr) {
         ht->buckets[i] = next;
       }
       else {
diff --git a/coin4/src/base/hash.cpp b/coin4/src/base/hash.cpp
index 68c002b..371ed65 100644
--- a/coin4/src/base/hash.cpp
+++ b/coin4/src/base/hash.cpp
@@ -66,7 +66,7 @@ hash_default_hashfunc(const cc_hash_key key)
 static unsigned int
 hash_get_index(cc_hash * ht, cc_hash_key key)
 {
-  assert(ht != NULL);
+  assert(ht != nullptr);
   key = ht->hashfunc(key);
   return key % ht->size;
 }
@@ -256,12 +256,12 @@ cc_hash_remove(cc_hash * ht, cc_hash_key key)
   unsigned int i = hash_get_index(ht, key);
 
   he = ht->buckets[i];
-  prev = NULL;
+  prev = nullptr;
   while (he) {
     next = he->next;
     if (he->key == key) {
       ht->elements--;
-      if (prev == NULL) {
+      if (prev == nullptr) {
         ht->buckets[i] = next;
       }
       else {
diff --git a/coin4/src/base/heap.cpp b/coin4/src/base/heap.cpp
index 47e3212..05ef7e8 100644
--- a/coin4/src/base/heap.cpp
+++ b/coin4/src/base/heap.cpp
@@ -122,7 +122,7 @@ cc_heap_construct(unsigned int size,
   assert(h->array);
   h->compare = comparecb;
   h->support_remove = support_remove;
-  h->hash = NULL;
+  h->hash = nullptr;
   if (support_remove) {
     h->hash = cc_dict_construct(size, 0.0f);
   }
@@ -184,24 +184,24 @@ cc_heap_add(cc_heap * h, void * o)
 
 /*!
   Returns the top element from the heap \a h. If the heap is empty,
-  NULL is returned.
+  nullptr is returned.
 */
 void *
 cc_heap_get_top(cc_heap * h)
 {
-  if (h->elements == 0) return NULL;
+  if (h->elements == 0) return nullptr;
   return h->array[0];
 }
 
 /*!
   Returns and removes the top element from the heap \a h. If the
-  heap is empty, NULL is returned.
+  heap is empty, nullptr is returned.
 */
 void *
 cc_heap_extract_top(cc_heap * h)
 {
   void * top;
-  if (h->elements == 0) return NULL;
+  if (h->elements == 0) return nullptr;
 
   top = h->array[0];
   h->array[0] = h->array[--h->elements];
diff --git a/coin4/src/base/memalloc.cpp b/coin4/src/base/memalloc.cpp
index 73cd6ac..401cc18 100644
--- a/coin4/src/base/memalloc.cpp
+++ b/coin4/src/base/memalloc.cpp
@@ -68,13 +68,13 @@ struct cc_memalloc {
 };
 
 /*
- * allocate 'numbytes' bytes from 'memnode'. Returns NULL if
+ * allocate 'numbytes' bytes from 'memnode'. Returns nullptr if
  * the memory node is full.
  */
 static void *
 node_alloc(struct cc_memalloc_memnode * memnode, const int numbytes)
 {
-  unsigned char * ret = NULL;
+  unsigned char * ret = nullptr;
   if (memnode->currpos + numbytes <= memnode->size) {
     ret = memnode->block + memnode->currpos;
     memnode->currpos += numbytes;
@@ -113,10 +113,10 @@ create_memnode(cc_memalloc * allocator)
 static void *
 alloc_from_memnode(cc_memalloc * allocator)
 {
-  void * ret = NULL;
+  void * ret = nullptr;
 
   if (allocator->memnode) ret = node_alloc(allocator->memnode, allocator->chunksize);
-  if (ret == NULL) {
+  if (ret == nullptr) {
     allocator->memnode = create_memnode(allocator);
     ret = node_alloc(allocator->memnode, allocator->chunksize);
     /* FIXME: I've seen this assert() hit, but I couldn't easily
@@ -142,11 +142,11 @@ cc_memalloc_construct(const unsigned int unitsize)
   if (unitsize < sizeof(cc_memalloc_free)) {
     allocator->chunksize = sizeof(cc_memalloc_free);
   }
-  allocator->free = NULL;
-  allocator->memnode = NULL;
+  allocator->free = nullptr;
+  allocator->memnode = nullptr;
   allocator->num_allocated_units = 0;
 
-  cc_memalloc_set_strategy(allocator, NULL); /* will insert default handler */
+  cc_memalloc_set_strategy(allocator, nullptr); /* will insert default handler */
 
   return allocator;
 }
@@ -203,8 +203,8 @@ cc_memalloc_clear(cc_memalloc * allocator)
     free(node);
     node = tmp;
   }
-  allocator->free = NULL;
-  allocator->memnode = NULL;
+  allocator->free = nullptr;
+  allocator->memnode = nullptr;
 }
 
 extern "C" {
@@ -232,6 +232,6 @@ default_strategy(const int numunits_allocated)
 void
 cc_memalloc_set_strategy(cc_memalloc * allocator, cc_memalloc_strategy_cb * cb)
 {
-  if (cb == NULL) allocator->strategy = default_strategy;
+  if (cb == nullptr) allocator->strategy = default_strategy;
   else allocator->strategy = cb;
 }
diff --git a/coin4/src/base/namemap.cpp b/coin4/src/base/namemap.cpp
index 81fa68e..e6f48ca 100644
--- a/coin4/src/base/namemap.cpp
+++ b/coin4/src/base/namemap.cpp
@@ -72,9 +72,9 @@ struct NamemapBucketEntry {
   struct NamemapBucketEntry * next;
 };
 
-static void * access_mutex = NULL;
-static struct NamemapBucketEntry ** nametable = NULL;
-static struct NamemapMemChunk * headchunk = NULL;
+static void * access_mutex = nullptr;
+static struct NamemapBucketEntry ** nametable = nullptr;
+static struct NamemapMemChunk * headchunk = nullptr;
 
 /* ************************************************************************* */
 
@@ -102,7 +102,7 @@ namemap_cleanup(void)
     }
   }
   free(nametable);
-  nametable = static_cast<struct NamemapBucketEntry **>(NULL);
+  nametable = static_cast<struct NamemapBucketEntry **>(nullptr);
 
   CC_MUTEX_DESTRUCT(access_mutex);
 }
@@ -117,9 +117,9 @@ namemap_init(void)
 
   nametable = static_cast<struct NamemapBucketEntry **>(
     malloc(sizeof(struct NamemapBucketEntry *) * NAME_TABLE_SIZE));
-  for (i = 0; i < NAME_TABLE_SIZE; i++) { nametable[i] = NULL; }
+  for (i = 0; i < NAME_TABLE_SIZE; i++) { nametable[i] = nullptr; }
 
-  headchunk = NULL;
+  headchunk = nullptr;
 
   coin_atexit(static_cast<coin_atexit_f *>(namemap_cleanup), CC_ATEXIT_SBNAME);
 }
@@ -132,7 +132,7 @@ find_string_address(const char * s)
   /* FIXME: this is an unacceptable limitation. 20030608 mortene. */
   assert(len < CHUNK_SIZE);
 
-  if (headchunk == NULL || headchunk->bytesleft < len) {
+  if (headchunk == nullptr || headchunk->bytesleft < len) {
     struct NamemapMemChunk * newchunk = static_cast<struct NamemapMemChunk *>(
       malloc(sizeof(struct NamemapMemChunk))
       );
@@ -159,22 +159,22 @@ namemap_find_or_add_string(const char * str, bool addifnotfound)
   unsigned long h, i;
   struct NamemapBucketEntry * entry;
 
-  if (access_mutex == NULL) { CC_MUTEX_CONSTRUCT(access_mutex); }
+  if (access_mutex == nullptr) { CC_MUTEX_CONSTRUCT(access_mutex); }
   CC_MUTEX_LOCK(access_mutex);
 
-  if (nametable == NULL) { namemap_init(); }
-  assert(nametable != static_cast<struct NamemapBucketEntry **>(NULL) && "name hash dead");
+  if (nametable == nullptr) { namemap_init(); }
+  assert(nametable != static_cast<struct NamemapBucketEntry **>(nullptr) && "name hash dead");
 
   h = cc_string_hash_text(str);
   i = h % NAME_TABLE_SIZE;
   entry = nametable[i];
 
-  while (entry != NULL) {
+  while (entry != nullptr) {
     if (entry->hashvalue == h && strcmp(entry->str, str) == 0) { break; }
     entry = entry->next;
   }
 
-  if ((entry == NULL) && addifnotfound) {
+  if ((entry == nullptr) && addifnotfound) {
     entry = static_cast<struct NamemapBucketEntry *>(malloc(sizeof(struct NamemapBucketEntry)));
     entry->str = find_string_address(str);
     entry->hashvalue = h;
@@ -184,7 +184,7 @@ namemap_find_or_add_string(const char * str, bool addifnotfound)
   }
 
   CC_MUTEX_UNLOCK(access_mutex);
-  return entry ? entry->str : NULL;
+  return entry ? entry->str : nullptr;
 }
 
 /* ************************************************************************* */
@@ -204,7 +204,7 @@ cc_namemap_get_address(const char * str)
   Returns address pointer of a given string.
 
   String will not be added if it doesn't exist in name hash (and \c
-  NULL will be returned).
+  nullptr will be returned).
 */
 const char *
 cc_namemap_peek_string(const char * str)
diff --git a/coin4/src/base/rbptree.cpp b/coin4/src/base/rbptree.cpp
index bce2078..8787817 100644
--- a/coin4/src/base/rbptree.cpp
+++ b/coin4/src/base/rbptree.cpp
@@ -353,10 +353,10 @@ cc_rbptree_init(cc_rbptree * t)
 {
   CC_GLOBAL_LOCK;
   if (!rbptree_isinitialized) {
-    rbptree_sentinel.left = NULL;
-    rbptree_sentinel.right = NULL;
-    rbptree_sentinel.parent = NULL;
-    rbptree_sentinel.pointer = NULL;
+    rbptree_sentinel.left = nullptr;
+    rbptree_sentinel.right = nullptr;
+    rbptree_sentinel.parent = nullptr;
+    rbptree_sentinel.pointer = nullptr;
     rbptree_sentinel.color = RBPTREE_BLACK;
     rbptree_isinitialized = true;
     coin_atexit(static_cast<coin_atexit_f*>(rbptree_atexit_cleanup), CC_ATEXIT_NORMAL);
@@ -634,7 +634,7 @@ BOOST_AUTO_TEST_CASE(rbptree_stress)
     SbList<void *> values;
     for (i = 0; i < FILL_COUNT; ++i) {
       void * entry = reinterpret_cast<void *>(rand());
-      cc_rbptree_insert(&tree, entry, NULL);
+      cc_rbptree_insert(&tree, entry, nullptr);
       values.append(entry);
     }
     BOOST_ASSERT(cc_rbptree_size(&tree) == FILL_COUNT);
@@ -651,7 +651,7 @@ BOOST_AUTO_TEST_CASE(rbptree_stress)
     SbList<void *> values;
     for (i = 0; i < FILL_COUNT; ++i) {
       void * entry = reinterpret_cast<void *>(((c & 2) == 0) ? i : (FILL_COUNT - i));
-      cc_rbptree_insert(&tree, entry, NULL);
+      cc_rbptree_insert(&tree, entry, nullptr);
       values.append(entry);
     }
     BOOST_ASSERT(cc_rbptree_size(&tree) == FILL_COUNT);
diff --git a/coin4/src/base/string.cpp b/coin4/src/base/string.cpp
index 2883537..e14e601 100644
--- a/coin4/src/base/string.cpp
+++ b/coin4/src/base/string.cpp
@@ -117,7 +117,7 @@ cc_string_grow_buffer(cc_string * me, size_t newsize)
      20050425 mortene. */
   newbuf = static_cast<char *>(malloc(newsize));
   if (debug) { printf("cc_string_grow_buffer: newbuf==%p\n", newbuf); }
-  assert(newbuf != NULL);
+  assert(newbuf != nullptr);
 
   (void) strcpy(newbuf, me->pointer);
 
@@ -156,7 +156,7 @@ cc_string_construct_new(void)
 {
   cc_string * me;
   me = static_cast<cc_string *>(malloc(sizeof(cc_string)));
-  assert(me != NULL);
+  assert(me != nullptr);
   cc_string_construct(me);
   return me;
 } /* cc_string_construct_new() */
@@ -192,7 +192,7 @@ cc_string_clean(cc_string * string_struct)
 void
 cc_string_destruct(cc_string * me)
 {
-  assert(me != NULL);
+  assert(me != nullptr);
   cc_string_clean(me);
   free(me);
 } /* cc_string_destruct() */
@@ -208,7 +208,7 @@ cc_string_set_text(cc_string * me, const char * text)
 {
   static char emptystring[] = "";
   size_t size;
-  if ( text == NULL ) text = emptystring;
+  if ( text == nullptr ) text = emptystring;
 
   if ( text >= me->pointer && text < (me->pointer + me->bufsize) ) {
     /* text is within own buffer */
@@ -242,7 +242,7 @@ cc_string_set_subtext(cc_string * me, const char * text, int start, int end)
   int len;
   size_t size;
 
-  if ( text == NULL ) text = emptystring;
+  if ( text == nullptr ) text = emptystring;
   len = cc_string_strnlen(text,end);
   if ( end == -1 ) end = len - 1;
 
@@ -496,7 +496,7 @@ void
 cc_string_apply(cc_string * string, cc_apply_f function)
 {
   int len, i;
-  assert(function != NULL);
+  assert(function != nullptr);
   len = cc_string_length(string);
   for ( i = 0; i < len; i++ )
     string->pointer[i] = function(string->pointer[i]);
@@ -621,7 +621,7 @@ cc_string_utf8_encode(char * buffer, size_t buflen, uint32_t value)
 uint32_t
 cc_string_utf8_get_char(const char * str)
 {
-  static const int disable_utf8 = (coin_getenv("COIN_DISABLE_UTF8") != NULL);
+  static const int disable_utf8 = (coin_getenv("COIN_DISABLE_UTF8") != nullptr);
   uint32_t value = 0;
   size_t declen = 0;
 
@@ -643,7 +643,7 @@ cc_string_utf8_get_char(const char * str)
 const char *
 cc_string_utf8_next_char(const char * str)
 {
-  static const int disable_utf8 = (coin_getenv("COIN_DISABLE_UTF8") != NULL);
+  static const int disable_utf8 = (coin_getenv("COIN_DISABLE_UTF8") != nullptr);
   uint32_t value = 0;
   size_t declen = 0;
 
@@ -665,7 +665,7 @@ cc_string_utf8_next_char(const char * str)
 size_t
 cc_string_utf8_validate_length(const char * str)
 {
-  static const int disable_utf8 = (coin_getenv("COIN_DISABLE_UTF8") != NULL);
+  static const int disable_utf8 = (coin_getenv("COIN_DISABLE_UTF8") != nullptr);
   const char * s = str;
   size_t declen = 0;
   size_t srclen = strlen(str);
diff --git a/coin4/src/base/time.cpp b/coin4/src/base/time.cpp
index 4cb774c..f0603dc 100644
--- a/coin4/src/base/time.cpp
+++ b/coin4/src/base/time.cpp
@@ -75,7 +75,7 @@ cc_internal_queryperformancecounter(cc_time * COIN_UNUSED_ARG(t))
       highperf_tick = 1.0 / frequency.QuadPart;
 
       {
-        time_t tt = time(NULL);
+        time_t tt = time(nullptr);
         LARGE_INTEGER counter;
         (void)QueryPerformanceCounter(&counter);
         highperf_start = tt - ((double)counter.QuadPart * highperf_tick);
@@ -101,7 +101,7 @@ cc_internal_gettimeofday(cc_time * t)
 {
 #ifdef HAVE_GETTIMEOFDAY
   struct timeval tv;
-  int result = gettimeofday(&tv, NULL);
+  int result = gettimeofday(&tv, nullptr);
   if (COIN_DEBUG && (result < 0)) {
     cc_debugerror_postwarning("SbTime_gettimeofday",
                               "Something went wrong (invalid timezone "
diff --git a/coin4/src/bundles/SoNormalBundle.cpp b/coin4/src/bundles/SoNormalBundle.cpp
index bdb119e..32dc2a5 100644
--- a/coin4/src/bundles/SoNormalBundle.cpp
+++ b/coin4/src/bundles/SoNormalBundle.cpp
@@ -46,9 +46,9 @@ SoNormalBundle::SoNormalBundle(SoAction * action, bool forrendering)
 {
   this->state->push();
   this->node = action->getCurPathTail();
-  this->generator = NULL;
+  this->generator = nullptr;
   this->elem = SoNormalElement::getInstance(this->state);
-  this->glelem = NULL;
+  this->glelem = nullptr;
   if (forrendering) {
     this->glelem = static_cast<const SoGLNormalElement *>(this->elem);
   }
@@ -165,7 +165,7 @@ SoNormalBundle::getGeneratedNormals(void) const
   if (this->generator) {
     return this->generator->getNormals();
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
diff --git a/coin4/src/bundles/SoTextureCoordinateBundle.cpp b/coin4/src/bundles/SoTextureCoordinateBundle.cpp
index 9d5037f..0096719 100644
--- a/coin4/src/bundles/SoTextureCoordinateBundle.cpp
+++ b/coin4/src/bundles/SoTextureCoordinateBundle.cpp
@@ -87,7 +87,7 @@ SoTextureCoordinateBundle(SoAction * const action,
     SoMultiTextureEnabledElement::getEnabledUnits(this->state, lastenabled);
   bool needinit = lastenabled >= 0;
   bool glrender = forRendering || action->isOfType(SoGLRenderAction::getClassTypeId());
-  bool bumpenabled = glrender && (SoBumpMapElement::get(this->state) != NULL);
+  bool bumpenabled = glrender && (SoBumpMapElement::get(this->state) != nullptr);
 
   if (!needinit && !multienabled && !bumpenabled) return;
   
@@ -135,7 +135,7 @@ SoTextureCoordinateBundle(SoAction * const action,
   if (this->flags & FLAG_DIDPUSH) {
     this->coordElt = SoMultiTextureCoordinateElement::getInstance(this->state);
   }
-  this->glElt = NULL;
+  this->glElt = nullptr;
   if (glrender) {
     bool needindices = false;
     if (!needindices && this->isFunction()) {
@@ -203,7 +203,7 @@ SoTextureCoordinateBundle::needIndices(void) const
 const SbVec4f &
 SoTextureCoordinateBundle::get(const SbVec3f &point, const SbVec3f &normal)
 {
-  assert(this->coordElt != NULL && (this->flags & FLAG_FUNCTION));
+  assert(this->coordElt != nullptr && (this->flags & FLAG_FUNCTION));
   if (this->flags & FLAG_DEFAULT) {
     SbVec3f pt;
     if (this->flags & FLAG_3DTEXTURES) {
diff --git a/coin4/src/bundles/SoVertexAttributeBundle.cpp b/coin4/src/bundles/SoVertexAttributeBundle.cpp
index 0b76e36..7ac7b46 100644
--- a/coin4/src/bundles/SoVertexAttributeBundle.cpp
+++ b/coin4/src/bundles/SoVertexAttributeBundle.cpp
@@ -40,7 +40,7 @@ SoVertexAttributeBundle::SoVertexAttributeBundle(SoAction * action, bool forrend
   : SoBundle(action)
 {
   this->elem = SoVertexAttributeElement::getInstance(this->state);
-  this->glelem = NULL;
+  this->glelem = nullptr;
   if (forrendering) {
     this->glelem = static_cast<const SoGLVertexAttributeElement *> (this->elem);
   }
diff --git a/coin4/src/caches/SoCache.cpp b/coin4/src/caches/SoCache.cpp
index a372e55..b6db723 100644
--- a/coin4/src/caches/SoCache.cpp
+++ b/coin4/src/caches/SoCache.cpp
@@ -143,7 +143,7 @@ public:
 SoCache::SoCache(SoState * const state)
 {
   PRIVATE(this) = new SoCacheP;
-  PRIVATE(this)->elementflags = NULL;
+  PRIVATE(this)->elementflags = nullptr;
   PRIVATE(this)->refcount = 0;
   PRIVATE(this)->invalidated = false;
   PRIVATE(this)->statedepth = state ? state->getDepth() : 0;
@@ -247,18 +247,18 @@ bool
 SoCache::isValid(const SoState * state) const
 {
   if (PRIVATE(this)->invalidated) return false;
-  return this->getInvalidElement(state) == NULL;
+  return this->getInvalidElement(state) == nullptr;
 }
 
 /*!
-  Returns the element that caused the invalidation. Returns \e NULL
+  Returns the element that caused the invalidation. Returns \e nullptr
   if the cache is valid, or if the cache was not invalidated
   bacause of an element.
 */
 const SoElement *
 SoCache::getInvalidElement(const SoState * const state) const
 {
-  if (PRIVATE(this)->invalidated) return NULL;
+  if (PRIVATE(this)->invalidated) return nullptr;
 
   // use local variables for speed
   int n = PRIVATE(this)->elements.getLength();
@@ -277,7 +277,7 @@ SoCache::getInvalidElement(const SoState * const state) const
       return elem;
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
diff --git a/coin4/src/caches/SoConvexDataCache.cpp b/coin4/src/caches/SoConvexDataCache.cpp
index 69283fc..2a3256a 100644
--- a/coin4/src/caches/SoConvexDataCache.cpp
+++ b/coin4/src/caches/SoConvexDataCache.cpp
@@ -111,7 +111,7 @@ const int32_t *
 SoConvexDataCache::getCoordIndices(void) const
 {
   if (PRIVATE(this)->coordIndices.getLength()) return PRIVATE(this)->coordIndices.getArrayPtr();
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -132,7 +132,7 @@ const int32_t *
 SoConvexDataCache::getMaterialIndices(void) const
 {
   if (PRIVATE(this)->materialIndices.getLength()) return PRIVATE(this)->materialIndices.getArrayPtr();
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -153,7 +153,7 @@ const int32_t *
 SoConvexDataCache::getNormalIndices(void) const
 {
   if (PRIVATE(this)->normalIndices.getLength()) return PRIVATE(this)->normalIndices.getArrayPtr();
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -174,7 +174,7 @@ const int32_t *
 SoConvexDataCache::getTexIndices(void) const
 {
   if (PRIVATE(this)->texIndices.getLength()) return PRIVATE(this)->texIndices.getArrayPtr();
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -261,10 +261,10 @@ SoConvexDataCache::generate(const SoCoordinateElement * const coords,
   // FIXME: stupid to have a separate struct for each coordIndex
   // should only allocate enough to hold the largest polygon
   tessdata.vertexInfo = new tVertexInfo[numv];
-  tessdata.vertexIndex = NULL;
-  tessdata.matIndex = NULL;
-  tessdata.normIndex = NULL;
-  tessdata.texIndex = NULL;
+  tessdata.vertexIndex = nullptr;
+  tessdata.matIndex = nullptr;
+  tessdata.normIndex = nullptr;
+  tessdata.texIndex = nullptr;
   tessdata.firstvertex = true;
 
   // create tessellator
diff --git a/coin4/src/caches/SoGLCacheList.cpp b/coin4/src/caches/SoGLCacheList.cpp
index 2c021ad..e33dbd9 100644
--- a/coin4/src/caches/SoGLCacheList.cpp
+++ b/coin4/src/caches/SoGLCacheList.cpp
@@ -109,12 +109,12 @@ SoGLCacheList::SoGLCacheList(int numcaches)
 {
   PRIVATE(this) = new SoGLCacheListP;
   PRIVATE(this)->numcaches = numcaches;
-  PRIVATE(this)->opencache = NULL;
+  PRIVATE(this)->opencache = nullptr;
   PRIVATE(this)->autocachebits = 0;
   PRIVATE(this)->numused = 0;
   PRIVATE(this)->numdiscarded = 0;
   PRIVATE(this)->needclose = false;
-  PRIVATE(this)->invalidelement = NULL;
+  PRIVATE(this)->invalidelement = nullptr;
   PRIVATE(this)->numframesok = 0;
   PRIVATE(this)->numshapes = 0;
 
@@ -457,7 +457,7 @@ SoGLCacheList::open(SoGLRenderAction * action, bool autocache)
 
   PRIVATE(this)->needclose = true;
 
-  assert(PRIVATE(this)->opencache == NULL);
+  assert(PRIVATE(this)->opencache == nullptr);
   SoState * state = action->getState();
 
   // will be restored in close()
@@ -574,7 +574,7 @@ SoGLCacheList::close(SoGLRenderAction * action)
     // just throw away the open cache, it's invalid
     if (PRIVATE(this)->opencache) {
       PRIVATE(this)->opencache->unref();
-      PRIVATE(this)->opencache = NULL;
+      PRIVATE(this)->opencache = nullptr;
       PRIVATE(this)->numdiscarded += 1;
 
 #if COIN_DEBUG
@@ -598,7 +598,7 @@ SoGLCacheList::close(SoGLRenderAction * action)
     }
 #endif // debug
     PRIVATE(this)->itemlist.append(PRIVATE(this)->opencache);
-    PRIVATE(this)->opencache = NULL;
+    PRIVATE(this)->opencache = nullptr;
   }
 
   PRIVATE(this)->numshapes = SoGLCacheContextElement::getNumShapes(state);
diff --git a/coin4/src/caches/SoGLRenderCache.cpp b/coin4/src/caches/SoGLRenderCache.cpp
index fc0349f..bd79218 100644
--- a/coin4/src/caches/SoGLRenderCache.cpp
+++ b/coin4/src/caches/SoGLRenderCache.cpp
@@ -30,6 +30,7 @@
 // *************************************************************************
 
 #include <cassert>
+#include <cstdlib>
 
 #include <Inventor/caches/SoGLRenderCache.h>
 #include <Inventor/elements/SoGLCacheContextElement.h>
@@ -60,8 +61,8 @@ SoGLRenderCache::SoGLRenderCache(SoState * state)
   : SoCache(state)
 {
   PRIVATE(this) = new SoGLRenderCacheP;
-  PRIVATE(this)->displaylist = NULL;
-  PRIVATE(this)->openstate = NULL;
+  PRIVATE(this)->displaylist = nullptr;
+  PRIVATE(this)->openstate = nullptr;
 }
 
 /*!
@@ -70,7 +71,7 @@ SoGLRenderCache::SoGLRenderCache(SoState * state)
 SoGLRenderCache::~SoGLRenderCache()
 {
   // stuff should have been deleted in destroy()
-  assert(PRIVATE(this)->displaylist == NULL);
+  assert(PRIVATE(this)->displaylist == nullptr);
   assert(PRIVATE(this)->nestedcachelist.getLength() == 0);
   
   delete PRIVATE(this);
@@ -85,8 +86,8 @@ SoGLRenderCache::~SoGLRenderCache()
 void
 SoGLRenderCache::open(SoState * state)
 {
-  assert(PRIVATE(this)->displaylist == NULL);
-  assert(PRIVATE(this)->openstate == NULL); // cache should not be open
+  assert(PRIVATE(this)->displaylist == nullptr);
+  assert(PRIVATE(this)->openstate == nullptr); // cache should not be open
   PRIVATE(this)->openstate = state;
   PRIVATE(this)->displaylist =
     new SoGLDisplayList(state, SoGLDisplayList::DISPLAY_LIST);
@@ -102,10 +103,10 @@ SoGLRenderCache::open(SoState * state)
 void
 SoGLRenderCache::close(void)
 {
-  assert(PRIVATE(this)->openstate != NULL);
-  assert(PRIVATE(this)->displaylist != NULL);
+  assert(PRIVATE(this)->openstate != nullptr);
+  assert(PRIVATE(this)->displaylist != nullptr);
   PRIVATE(this)->displaylist->close(PRIVATE(this)->openstate);
-  PRIVATE(this)->openstate = NULL;
+  PRIVATE(this)->openstate = nullptr;
 }
 
 /*!
@@ -116,7 +117,7 @@ SoGLRenderCache::close(void)
 void
 SoGLRenderCache::call(SoState * state)
 {
-  assert(PRIVATE(this)->displaylist != NULL);
+  assert(PRIVATE(this)->displaylist != nullptr);
 
   static int COIN_NESTED_CACHING = -1;
   if (COIN_NESTED_CACHING < 0) {
@@ -193,7 +194,7 @@ SoGLRenderCache::destroy(SoState * state)
   PRIVATE(this)->nestedcachelist.truncate(0);
   if (PRIVATE(this)->displaylist) {
     PRIVATE(this)->displaylist->unref(state);
-    PRIVATE(this)->displaylist = NULL;
+    PRIVATE(this)->displaylist = nullptr;
   }
 }
 
diff --git a/coin4/src/caches/SoGlyphCache.cpp b/coin4/src/caches/SoGlyphCache.cpp
index e51410a..c81b990 100644
--- a/coin4/src/caches/SoGlyphCache.cpp
+++ b/coin4/src/caches/SoGlyphCache.cpp
@@ -53,7 +53,7 @@ SoGlyphCache::SoGlyphCache(SoState * state)
   : SoCache(state)
 {
   PRIVATE(this) = new SoGlyphCacheP;
-  PRIVATE(this)->fontspec = NULL;
+  PRIVATE(this)->fontspec = nullptr;
 
 #if COIN_DEBUG
   if (coin_debug_caching_level() > 0) {
@@ -75,7 +75,7 @@ SoGlyphCache::~SoGlyphCache()
 #endif // debug
 
   int i;
-  this->readFontspec(NULL);
+  this->readFontspec(nullptr);
   for (i = 0; i < PRIVATE(this)->glyphlist2d.getLength(); i++) {
     cc_glyph2d_unref(PRIVATE(this)->glyphlist2d[i]);
   }
@@ -118,7 +118,7 @@ SoGlyphCache::readFontspec(SoState * state)
   if (PRIVATE(this)->fontspec) {
     cc_fontspec_clean(PRIVATE(this)->fontspec);
     delete PRIVATE(this)->fontspec;
-    PRIVATE(this)->fontspec = NULL;
+    PRIVATE(this)->fontspec = nullptr;
   }
   if (state) {
     PRIVATE(this)->fontspec = new cc_font_specification;
diff --git a/coin4/src/caches/SoNormalCache.cpp b/coin4/src/caches/SoNormalCache.cpp
index 0c6cda3..d178f2a 100644
--- a/coin4/src/caches/SoNormalCache.cpp
+++ b/coin4/src/caches/SoNormalCache.cpp
@@ -82,7 +82,7 @@ SoNormalCache::SoNormalCache(SoState * const state)
   : SoCache(state)
 {
   PRIVATE(this) = new SoNormalCacheP;
-  PRIVATE(this)->normalData.normals = NULL;
+  PRIVATE(this)->normalData.normals = nullptr;
   PRIVATE(this)->numNormals = 0;
 
 #if COIN_DEBUG
@@ -180,7 +180,7 @@ const int32_t *
 SoNormalCache::getIndices(void) const
 {
   if (PRIVATE(this)->indices.getLength()) return PRIVATE(this)->indices.getArrayPtr();
-  return NULL;
+  return nullptr;
 }
 
 //
@@ -260,9 +260,9 @@ SoNormalCache::generatePerVertex(const SbVec3f * const coords,
 
 
   int numfacenorm = numfacenormals;
-  SoNormalCache tempcache(NULL);
+  SoNormalCache tempcache(nullptr);
   const SbVec3f * facenorm = const_cast<SbVec3f *>(facenormals);
-  if (facenorm == NULL) {
+  if (facenorm == nullptr) {
     // use a SoNormalCache to store temporary data
     if (tristrip) {
       tempcache.generatePerFaceStrip(coords, numcoords, vindex, numvi, ccw);
@@ -906,7 +906,7 @@ SoNormalCache::generatePerVertexQuad(const SbVec3f * const coords,
   // avoid reallocations in growable array by setting the buffer size first
   PRIVATE(this)->normalArray.ensureCapacity(vPerRow * vPerColumn);
 
-  SoNormalCache tempcache(NULL);
+  SoNormalCache tempcache(nullptr);
   tempcache.generatePerFaceQuad(coords, numcoords, vPerRow, vPerColumn, ccw);
   const SbVec3f * facenormals = tempcache.getNormals();
   int numfacenormals = tempcache.getNum(); // Used for extra robustness
@@ -1123,7 +1123,7 @@ SoNormalCache::clearGenerator(void)
   if (PRIVATE(this)->numNormals == 0 && PRIVATE(this)->normalData.generator) {
     delete PRIVATE(this)->normalData.generator;
   }
-  PRIVATE(this)->normalData.normals = NULL;
+  PRIVATE(this)->normalData.normals = nullptr;
   PRIVATE(this)->numNormals = 0;
 }
 
diff --git a/coin4/src/caches/SoPrimitiveVertexCache.cpp b/coin4/src/caches/SoPrimitiveVertexCache.cpp
index ca0f46e..a697ea0 100644
--- a/coin4/src/caches/SoPrimitiveVertexCache.cpp
+++ b/coin4/src/caches/SoPrimitiveVertexCache.cpp
@@ -84,15 +84,15 @@ public:
       rgbalist(256),
       tangentlist(256),
       vhash(1024),
-      deptharray(NULL),
-      triangleindexer(NULL),
-      lineindexer(NULL),
-      pointindexer(NULL),
-      vertexvbo(NULL),
-      normalvbo(NULL),
-      texcoord0vbo(NULL),
-      rgbavbo(NULL),
-      tangentvbo(NULL)
+      deptharray(nullptr),
+      triangleindexer(nullptr),
+      lineindexer(nullptr),
+      pointindexer(nullptr),
+      vertexvbo(nullptr),
+      normalvbo(nullptr),
+      texcoord0vbo(nullptr),
+      rgbavbo(nullptr),
+      tangentvbo(nullptr)
   { }
 
   class Vertex {
@@ -232,11 +232,11 @@ SoPrimitiveVertexCache::SoPrimitiveVertexCache(SoState * state)
   PRIVATE(this)->numtransp = lelem->getNumTransparencies();
   if (lelem->isPacked()) {
     PRIVATE(this)->packedptr = lelem->getPackedPointer();
-    PRIVATE(this)->diffuseptr = NULL;
-    PRIVATE(this)->transpptr = NULL;
+    PRIVATE(this)->diffuseptr = nullptr;
+    PRIVATE(this)->transpptr = nullptr;
   }
   else {
-    PRIVATE(this)->packedptr = NULL;
+    PRIVATE(this)->packedptr = nullptr;
     PRIVATE(this)->diffuseptr = lelem->getDiffusePointer();
     PRIVATE(this)->transpptr = lelem->getTransparencyPointer();
   }
@@ -260,8 +260,8 @@ SoPrimitiveVertexCache::SoPrimitiveVertexCache(SoState * state)
   PRIVATE(this)->lastenabled = -1;
   PRIVATE(this)->enabledunits =
     SoMultiTextureEnabledElement::getEnabledUnits(state, PRIVATE(this)->lastenabled);
-  PRIVATE(this)->multielem = NULL;
-  PRIVATE(this)->multitexcoords = NULL;
+  PRIVATE(this)->multielem = nullptr;
+  PRIVATE(this)->multitexcoords = nullptr;
   if (PRIVATE(this)->lastenabled >= 1) {
     PRIVATE(this)->multitexcoords = new SbList<SbVec4f>[PRIVATE(this)->lastenabled+1];
     // delay fetching SoMultiTextureCoordinateElement until the first
@@ -339,7 +339,7 @@ SoPrimitiveVertexCache::renderTriangles(SoState * state, const int arrays) const
   const int n = this->getNumTriangleIndices();
   if (n == 0) return;
 
-  const bool * enabled = NULL;
+  const bool * enabled = nullptr;
   const bool normal = (arrays & NORMAL) != 0;
   const bool texture = (arrays & TEXCOORD) != 0;
   const bool color = this->colorPerVertex() && ((arrays & COLOR) != 0);
@@ -398,7 +398,7 @@ SoPrimitiveVertexCache::renderLines(SoState * state, const int arrays) const
   int lastenabled = -1;
   const int n = this->getNumLineIndices();
   if (n == 0) return;
-  const bool * enabled = NULL;
+  const bool * enabled = nullptr;
   const bool normal = (arrays & NORMAL) != 0;
   const bool texture = (arrays & TEXCOORD) != 0;
   bool color = this->colorPerVertex() && ((arrays & COLOR) != 0);
@@ -438,7 +438,7 @@ SoPrimitiveVertexCache::renderPoints(SoState * state, const int arrays) const
   int lastenabled = -1;
   const int n = this->getNumPointIndices();
   if (n == 0) return;
-  const bool * enabled = NULL;
+  const bool * enabled = nullptr;
   const bool normal = (arrays & NORMAL) != 0;
   const bool texture = (arrays & TEXCOORD) != 0;
   bool color = this->colorPerVertex() && ((arrays & COLOR) != 0);
@@ -478,7 +478,7 @@ SoPrimitiveVertexCache::addTriangle(const SoPrimitiveVertex * v0,
                                     const SoPrimitiveVertex * v2,
                                     const int * pointdetailidx)
 {
-  if (PRIVATE(this)->lastenabled >= 1 && PRIVATE(this)->multielem == NULL) {
+  if (PRIVATE(this)->lastenabled >= 1 && PRIVATE(this)->multielem == nullptr) {
     // fetch SoMultiTextureCoordinateElement the first time we get here
     PRIVATE(this)->multielem = SoMultiTextureCoordinateElement::getInstance(PRIVATE(this)->state);
   }
@@ -552,7 +552,7 @@ SoPrimitiveVertexCache::addTriangle(const SoPrimitiveVertex * v0,
       triangleindices[i] = idx;
     }
   }
-  if (PRIVATE(this)->triangleindexer == NULL) {
+  if (PRIVATE(this)->triangleindexer == nullptr) {
     PRIVATE(this)->triangleindexer = new SoVertexArrayIndexer;
   }
   PRIVATE(this)->triangleindexer->addTriangle(triangleindices[0],
@@ -564,7 +564,7 @@ void
 SoPrimitiveVertexCache::addLine(const SoPrimitiveVertex * v0,
                                 const SoPrimitiveVertex * v1)
 {
-  if (PRIVATE(this)->lastenabled >= 1 && PRIVATE(this)->multielem == NULL) {
+  if (PRIVATE(this)->lastenabled >= 1 && PRIVATE(this)->multielem == nullptr) {
     // fetch SoMultiTextureCoordinateElement the first time we get here
     PRIVATE(this)->multielem = SoMultiTextureCoordinateElement::getInstance(PRIVATE(this)->state);
   }
@@ -636,7 +636,7 @@ SoPrimitiveVertexCache::addLine(const SoPrimitiveVertex * v0,
       lineindices[i] = idx;
     }
   }
-  if (PRIVATE(this)->lineindexer == NULL) {
+  if (PRIVATE(this)->lineindexer == nullptr) {
     PRIVATE(this)->lineindexer = new SoVertexArrayIndexer;
   }
   PRIVATE(this)->lineindexer->addLine(lineindices[0], lineindices[1]);
@@ -645,7 +645,7 @@ SoPrimitiveVertexCache::addLine(const SoPrimitiveVertex * v0,
 void
 SoPrimitiveVertexCache::addPoint(const SoPrimitiveVertex * v0)
 {
-  if (PRIVATE(this)->lastenabled >= 1 && PRIVATE(this)->multielem == NULL) {
+  if (PRIVATE(this)->lastenabled >= 1 && PRIVATE(this)->multielem == nullptr) {
     // fetch SoMultiTextureCoordinateElement the first time we get here
     PRIVATE(this)->multielem = SoMultiTextureCoordinateElement::getInstance(PRIVATE(this)->state);
   }
@@ -684,7 +684,7 @@ SoPrimitiveVertexCache::addPoint(const SoPrimitiveVertex * v0)
     }
   }
 
-  if (PRIVATE(this)->pointindexer == NULL) {
+  if (PRIVATE(this)->pointindexer == nullptr) {
     PRIVATE(this)->pointindexer = new SoVertexArrayIndexer;
   }
 
@@ -836,7 +836,7 @@ SoPrimitiveVertexCache::depthSortTriangles(SoState * state)
   // move plane into object space
   sortplane.transform(SoModelMatrixElement::get(state).inverse());
 
-  if (PRIVATE(this)->deptharray == NULL ||
+  if (PRIVATE(this)->deptharray == nullptr ||
       (sortplane != PRIVATE(this)->prevsortplane)) {
     if (!PRIVATE(this)->deptharray) {
       PRIVATE(this)->deptharray = new float[numtri];
@@ -1003,31 +1003,31 @@ SoPrimitiveVertexCacheP::enableVBOs(const cc_glglue * glue,
 {
   int i;
   if (color) {
-    if (this->rgbavbo == NULL) {
+    if (this->rgbavbo == nullptr) {
       this->rgbavbo = new SoVBO;
       this->rgbavbo->setBufferData(this->rgbalist.getArrayPtr(),
                                    this->rgbalist.getLength() * sizeof(uint8_t));
     }
     this->rgbavbo->bindBuffer(contextid);
-    cc_glglue_glColorPointer(glue, 4, GL_UNSIGNED_BYTE, 0, NULL);
+    cc_glglue_glColorPointer(glue, 4, GL_UNSIGNED_BYTE, 0, nullptr);
     cc_glglue_glEnableClientState(glue, GL_COLOR_ARRAY);
   }
   if (texture) {
-    if (this->texcoord0vbo == NULL) {
+    if (this->texcoord0vbo == nullptr) {
       this->texcoord0vbo = new SoVBO;
       this->texcoord0vbo->setBufferData(this->texcoordlist.getArrayPtr(),
                                         this->texcoordlist.getLength()*4*sizeof(float));
     }
     this->texcoord0vbo->bindBuffer(contextid);
-    cc_glglue_glTexCoordPointer(glue, 4, GL_FLOAT, 0, NULL);
+    cc_glglue_glTexCoordPointer(glue, 4, GL_FLOAT, 0, nullptr);
     cc_glglue_glEnableClientState(glue, GL_TEXTURE_COORD_ARRAY);
 
     for (i = 1; i <= lastenabled; i++) {
       while (this->multitexvbo.getLength() <= i) {
-        this->multitexvbo.append(NULL);
+        this->multitexvbo.append(nullptr);
       }
       if (enabled[i]) {
-        if (this->multitexvbo[i] == NULL) {
+        if (this->multitexvbo[i] == nullptr) {
           SoVBO * vbo = new SoVBO;
           vbo->setBufferData(this->multitexcoords[i].getArrayPtr(),
                              this->multitexcoords[i].getLength()*4*sizeof(float));
@@ -1035,29 +1035,29 @@ SoPrimitiveVertexCacheP::enableVBOs(const cc_glglue * glue,
         }
         this->multitexvbo[i]->bindBuffer(contextid);
         cc_glglue_glClientActiveTexture(glue, GL_TEXTURE0 + i);
-        cc_glglue_glTexCoordPointer(glue, 4, GL_FLOAT, 0, NULL);
+        cc_glglue_glTexCoordPointer(glue, 4, GL_FLOAT, 0, nullptr);
         cc_glglue_glEnableClientState(glue, GL_TEXTURE_COORD_ARRAY);
       }
     }
   }
   if (normal) {
-    if (this->normalvbo == NULL) {
+    if (this->normalvbo == nullptr) {
       this->normalvbo = new SoVBO;
       this->normalvbo->setBufferData(this->normallist.getArrayPtr(),
                                      this->normallist.getLength()*3*sizeof(float));
     }
     this->normalvbo->bindBuffer(contextid);
-    cc_glglue_glNormalPointer(glue, GL_FLOAT, 0, NULL);
+    cc_glglue_glNormalPointer(glue, GL_FLOAT, 0, nullptr);
     cc_glglue_glEnableClientState(glue, GL_NORMAL_ARRAY);
   }
 
-  if (this->vertexvbo == NULL) {
+  if (this->vertexvbo == nullptr) {
     this->vertexvbo = new SoVBO;
     this->vertexvbo->setBufferData(this->vertexlist.getArrayPtr(),
                                    this->vertexlist.getLength()*3*sizeof(float));
   }
   this->vertexvbo->bindBuffer(contextid);
-  cc_glglue_glVertexPointer(glue, 3, GL_FLOAT, 0, NULL);
+  cc_glglue_glVertexPointer(glue, 3, GL_FLOAT, 0, nullptr);
   cc_glglue_glEnableClientState(glue, GL_VERTEX_ARRAY);
 }
 
@@ -1079,10 +1079,10 @@ SoPrimitiveVertexCacheP::renderImmediate(const cc_glglue * glue,
                                          const bool texture, const bool * enabled,
                                          const int lastenabled)
 {
-  const unsigned char * colorptr = NULL;
-  const SbVec3f * normalptr = NULL;
-  const SbVec3f * vertexptr = NULL;
-  const SbVec4f * texcoordptr = NULL;
+  const unsigned char * colorptr = nullptr;
+  const SbVec3f * normalptr = nullptr;
+  const SbVec3f * vertexptr = nullptr;
+  const SbVec4f * texcoordptr = nullptr;
 
   if (color) {
     colorptr = this->rgbalist.getArrayPtr();
diff --git a/coin4/src/caches/SoVBOCache.cpp b/coin4/src/caches/SoVBOCache.cpp
index 2c18ef2..cc06370 100644
--- a/coin4/src/caches/SoVBOCache.cpp
+++ b/coin4/src/caches/SoVBOCache.cpp
@@ -36,10 +36,10 @@
 class SoVBOCacheP {
 public:
   SoVBOCacheP(void) {
-    this->vaindexer = NULL;
-    this->coordvbo = NULL;
-    this->colorvbo = NULL;
-    this->normalvbo = NULL;
+    this->vaindexer = nullptr;
+    this->coordvbo = nullptr;
+    this->colorvbo = nullptr;
+    this->normalvbo = nullptr;
   }
   ~SoVBOCacheP() {
     delete this->vaindexer;
@@ -83,7 +83,7 @@ SoVBOCache::~SoVBOCache()
 SoVertexArrayIndexer * 
 SoVBOCache::getVertexArrayIndexer(const bool createifnull)
 {
-  if (createifnull && (this->pimpl->vaindexer == NULL)) {
+  if (createifnull && (this->pimpl->vaindexer == nullptr)) {
     this->pimpl->vaindexer = new SoVertexArrayIndexer;
   }
   return this->pimpl->vaindexer;
@@ -96,7 +96,7 @@ SoVBOCache::getVertexArrayIndexer(const bool createifnull)
 SoVBO * 
 SoVBOCache::getCoordVBO(const bool createifnull)
 {
-  if (createifnull && (this->pimpl->coordvbo == NULL)) {
+  if (createifnull && (this->pimpl->coordvbo == nullptr)) {
     this->pimpl->coordvbo = new SoVBO;
   }
   return this->pimpl->coordvbo;
@@ -110,7 +110,7 @@ SoVBOCache::getCoordVBO(const bool createifnull)
 SoVBO * 
 SoVBOCache::getNormalVBO(const bool createifnull)
 {
-  if (createifnull && (this->pimpl->normalvbo == NULL)) {
+  if (createifnull && (this->pimpl->normalvbo == nullptr)) {
     this->pimpl->normalvbo = new SoVBO;
   }
   return this->pimpl->normalvbo;
@@ -123,7 +123,7 @@ SoVBOCache::getNormalVBO(const bool createifnull)
 SoVBO * 
 SoVBOCache::getColorVBO(const bool createifnull)
 {
-  if (createifnull && (this->pimpl->colorvbo == NULL)) {
+  if (createifnull && (this->pimpl->colorvbo == nullptr)) {
     this->pimpl->colorvbo = new SoVBO;
   }
   return this->pimpl->colorvbo;
@@ -138,14 +138,14 @@ SoVBOCache::getTexCoordVBO(const int unit, const bool createifnull)
 {
   if (createifnull) {
     while (this->pimpl->texcoordvbo.getLength() <= unit) {
-      this->pimpl->texcoordvbo.append(NULL);
+      this->pimpl->texcoordvbo.append(nullptr);
     }
-    if (this->pimpl->texcoordvbo[unit] == NULL) {
+    if (this->pimpl->texcoordvbo[unit] == nullptr) {
       this->pimpl->texcoordvbo[unit] = new SoVBO;
     }
   }
   if (this->pimpl->texcoordvbo.getLength() > unit) {
     return this->pimpl->texcoordvbo[unit];
   }
-  return NULL;
+  return nullptr;
 }
diff --git a/coin4/src/collision/SbTri3f.h b/coin4/src/collision/SbTri3f.h
index 8f64e15..3502217 100644
--- a/coin4/src/collision/SbTri3f.h
+++ b/coin4/src/collision/SbTri3f.h
@@ -50,7 +50,7 @@ public:
                            const SbVec3f & b1, const SbVec3f & b2,
                            float * linP0, float * linP1);
   float sqrDistance(const SbVec3f & p1, 
-                    float * pfSParam = NULL, float * pfTParam = NULL) const;
+                    float * pfSParam = nullptr, float * pfTParam = nullptr) const;
 
   SbTri3f & operator = (const SbTri3f & t);
 
diff --git a/coin4/src/collision/SoIntersectionDetectionAction.cpp b/coin4/src/collision/SoIntersectionDetectionAction.cpp
index 05dc0c5..2dc7c74 100644
--- a/coin4/src/collision/SoIntersectionDetectionAction.cpp
+++ b/coin4/src/collision/SoIntersectionDetectionAction.cpp
@@ -79,7 +79,7 @@
     root->ref();
 
     SoIntersectionDetectionAction ida;
-    ida.addIntersectionCallback(intersectionCB, NULL);
+    ida.addIntersectionCallback(intersectionCB, nullptr);
     ida.setManipsEnabled(false);
     ida.setDraggersEnabled(false);
     ida.setIntersectionDetectionEpsilon(10.0f);
@@ -261,9 +261,9 @@ SoIntersectionDetectionAction::PImpl::PImpl(void)
   this->draggersenabled = true;
   this->manipsenabled = true;
   this->internalsenabled = false;
-  this->filtercb = NULL;
-  this->filterclosure = NULL;
-  this->traverser = NULL;
+  this->filtercb = nullptr;
+  this->filterclosure = nullptr;
+  this->traverser = nullptr;
   this->prunetypes = new SoTypeList;
   this->traversaltypes = new SoTypeList;
 }
@@ -730,8 +730,8 @@ class PrimitiveData {
 public:
   PrimitiveData(void)
   {
-    this->path = NULL;
-    this->octtree = NULL;
+    this->path = nullptr;
+    this->octtree = nullptr;
   }
 
   ~PrimitiveData()
@@ -742,12 +742,12 @@ public:
 
 
   const SbOctTree * getOctTree(void) {
-    if (this->octtree == NULL) {
+    if (this->octtree == nullptr) {
       const SbOctTreeFuncs funcs = {
-        NULL /* ptinsidefunc */,
+        nullptr /* ptinsidefunc */,
         PrimitiveData::insideboxfunc,
-        NULL /* insidespherefunc */,
-        NULL /* insideplanesfunc */
+        nullptr /* insidespherefunc */,
+        nullptr /* insideplanesfunc */
       };
 
       SbBox3f b = this->getBoundingBox();
@@ -786,7 +786,7 @@ public:
 
   void addTriangle(SbTri3f * t)
   {
-    assert(this->octtree == NULL && "all triangles must be added before making octtree");
+    assert(this->octtree == nullptr && "all triangles must be added before making octtree");
     this->triangles.append(t);
     this->bbox.extendBy(t->getBoundingBox());
   }
@@ -821,7 +821,7 @@ class ShapeData {
 public:
   ShapeData(void)
   {
-    this->primitives = NULL;
+    this->primitives = nullptr;
   }
 
   ~ShapeData()
@@ -1003,9 +1003,9 @@ SoIntersectionDetectionAction::PImpl::reset(void)
     delete data;
   }
   this->shapedata.truncate(0);
-  if (this->traverser != NULL) {
+  if (this->traverser != nullptr) {
     delete this->traverser;
-    this->traverser = NULL;
+    this->traverser = nullptr;
   }
   this->traverser = new SoCallbackAction;
 #ifdef HAVE_DRAGGERS
@@ -1016,7 +1016,7 @@ SoIntersectionDetectionAction::PImpl::reset(void)
                                   traverseCB, this);
   for (i = 0; i < this->prunetypes->getLength(); i++)
     this->traverser->addPreCallback((*(this->prunetypes))[i],
-                                    pruneCB, NULL);
+                                    pruneCB, nullptr);
   this->traverser->addPreCallback(SoShape::getClassTypeId(),
                                   shapeCB, this);
 }
@@ -1165,7 +1165,7 @@ SoIntersectionDetectionAction::PImpl::doIntersectionTesting(void)
   }
 
   delete this->traverser;
-  this->traverser = NULL;
+  this->traverser = nullptr;
 
   if (ida_debug()) {
     SoDebugError::postInfo("SoIntersectionDetectionAction::PImpl::doIntersectionTesting",
@@ -1175,10 +1175,10 @@ SoIntersectionDetectionAction::PImpl::doIntersectionTesting(void)
   }
 
   const SbOctTreeFuncs funcs = {
-    NULL /* ptinsidefunc */,
+    nullptr /* ptinsidefunc */,
     shapeinsideboxfunc,
-    NULL /* insidespherefunc */,
-    NULL /* insideplanesfunc */
+    nullptr /* insidespherefunc */,
+    nullptr /* insideplanesfunc */
   };
 
   SbBox3f b = this->fullxfbbox.project();
diff --git a/coin4/src/draggers/SoCenterballDragger.cpp b/coin4/src/draggers/SoCenterballDragger.cpp
index 3752e54..2d72e20 100644
--- a/coin4/src/draggers/SoCenterballDragger.cpp
+++ b/coin4/src/draggers/SoCenterballDragger.cpp
@@ -373,16 +373,16 @@ SoCenterballDragger::transferCenterDraggerMotion(SoDragger * childdragger)
 
 /*!
   Sets values for the internal SoSwitch parts. If \a activechild ==
-  \c NULL, all feedback is deactivated.
+  \c nullptr, all feedback is deactivated.
 */
 void
 SoCenterballDragger::setSwitches(SoDragger * activechild)
 {
   SoSwitch *sw;
 
-  if (activechild == NULL || coin_safe_cast<SoNode *>(activechild) == rotator.getValue()) {
+  if (activechild == nullptr || coin_safe_cast<SoNode *>(activechild) == rotator.getValue()) {
     // special feedback when rotator is activated/deactiveated
-    int switchval = activechild != NULL ? 1 : 0;
+    int switchval = activechild != nullptr ? 1 : 0;
     sw = SO_GET_ANY_PART(this, "XCenterChanger.translatorSwitch", SoSwitch);
     SoInteractionKit::setSwitchValue(sw, switchval);;
     sw = SO_GET_ANY_PART(this, "YCenterChanger.translatorSwitch", SoSwitch);
@@ -409,7 +409,7 @@ SoCenterballDragger::setSwitches(SoDragger * activechild)
   else if (coin_safe_cast<SoNode *>(activechild) == ZRotator.getValue()) {
     vals[2] = 0;
   }
-  else if (activechild != NULL) {
+  else if (activechild != nullptr) {
     vals[0] = vals[1] = vals[2] = 0;
   }
 
@@ -470,7 +470,7 @@ SoCenterballDragger::setUpConnections(bool onoff, bool doitalways)
     }
 
     // Update dragger in case fields have changed values before connection
-    SoCenterballDragger::fieldSensorCB(this, NULL);
+    SoCenterballDragger::fieldSensorCB(this, nullptr);
 
     if (this->rotFieldSensor->getAttachedField() != &this->rotation) {
       this->rotFieldSensor->attach(&this->rotation);
@@ -488,10 +488,10 @@ SoCenterballDragger::setUpConnections(bool onoff, bool doitalways)
     this->removeChildDragger("YCenterChanger");
     this->removeChildDragger("ZCenterChanger");
 
-    if (this->rotFieldSensor->getAttachedField() != NULL) {
+    if (this->rotFieldSensor->getAttachedField() != nullptr) {
       this->rotFieldSensor->detach();
     }
-    if (this->centerFieldSensor->getAttachedField() != NULL) {
+    if (this->centerFieldSensor->getAttachedField() != nullptr) {
       this->centerFieldSensor->detach();
     }
     inherited::setUpConnections(onoff, doitalways);
@@ -602,7 +602,7 @@ void
 SoCenterballDragger::kidFinishCB(void * d, SoDragger * COIN_UNUSED_ARG(child))
 {
   SoCenterballDragger * thisp = static_cast<SoCenterballDragger *>(d);
-  thisp->setSwitches(NULL);
+  thisp->setSwitches(nullptr);
 
   SoSurroundScale * scale = coin_safe_cast<SoSurroundScale *>(
     thisp->getPart("surroundScale", false)
diff --git a/coin4/src/draggers/SoDirectionalLightDragger.cpp b/coin4/src/draggers/SoDirectionalLightDragger.cpp
index fdd0bdc..ff553c3 100644
--- a/coin4/src/draggers/SoDirectionalLightDragger.cpp
+++ b/coin4/src/draggers/SoDirectionalLightDragger.cpp
@@ -272,9 +272,9 @@ SoDirectionalLightDragger::setUpConnections(bool onoff, bool doitalways)
     SoDragger * therotator = coin_assert_cast<SoDragger *>(this->getAnyPart("rotator", false));
     this->unregisterChildDragger(therotator);
 
-    if (this->rotFieldSensor->getAttachedField() != NULL)
+    if (this->rotFieldSensor->getAttachedField() != nullptr)
       this->rotFieldSensor->detach();
-    if (this->translFieldSensor->getAttachedField() != NULL)
+    if (this->translFieldSensor->getAttachedField() != nullptr)
       this->translFieldSensor->detach();
 
     inherited::setUpConnections(onoff, doitalways);
diff --git a/coin4/src/draggers/SoDragPointDragger.cpp b/coin4/src/draggers/SoDragPointDragger.cpp
index 1283b2d..9e33d5e 100644
--- a/coin4/src/draggers/SoDragPointDragger.cpp
+++ b/coin4/src/draggers/SoDragPointDragger.cpp
@@ -368,7 +368,7 @@ SoDragPointDragger::setUpConnections(bool onoff, bool doitalways)
     yzdragger->setPartAsDefault("translatorActive", "dragPointYZTranslatorTranslatorActive");
     this->registerDragger(yzdragger);
 
-    SoDragPointDragger::fieldSensorCB(this, NULL);
+    SoDragPointDragger::fieldSensorCB(this, nullptr);
     if (this->fieldSensor->getAttachedField() != &this->translation) {
       this->fieldSensor->attach(&this->translation);
     }
@@ -380,7 +380,7 @@ SoDragPointDragger::setUpConnections(bool onoff, bool doitalways)
     this->unregisterDragger("xyTranslator");
     this->unregisterDragger("xzTranslator");
     this->unregisterDragger("yzTranslator");
-    if (this->fieldSensor->getAttachedField() != NULL) {
+    if (this->fieldSensor->getAttachedField() != nullptr) {
       this->fieldSensor->detach();
     }
 
@@ -490,7 +490,7 @@ SoDragPointDragger::dragStart(void)
 {
   SoDragger * activechild = this->getActiveChildDragger();
 
-  assert(activechild != NULL);
+  assert(activechild != nullptr);
 
   SoSwitch * sw;
   if (activechild->isOfType(SoTranslate2Dragger::getClassTypeId())) {
@@ -509,7 +509,7 @@ SoDragPointDragger::dragStart(void)
       sw = SO_GET_ANY_PART(this, "zFeedbackSwitch", SoSwitch);
       break;
     default:
-      assert(0); sw = NULL; // Dummy assignment to avoid compiler warning.
+      assert(0); sw = nullptr; // Dummy assignment to avoid compiler warning.
       break;
     }
     SoInteractionKit::setSwitchValue(sw, 0);
diff --git a/coin4/src/draggers/SoDragger.cpp b/coin4/src/draggers/SoDragger.cpp
index 4c95c9a..e9063af 100644
--- a/coin4/src/draggers/SoDragger.cpp
+++ b/coin4/src/draggers/SoDragger.cpp
@@ -355,18 +355,18 @@ SoDragger::SoDragger(void)
   SO_KIT_INIT_INSTANCE();
 
   PRIVATE(this)->mingesture = 8;
-  PRIVATE(this)->eventaction = NULL;
+  PRIVATE(this)->eventaction = nullptr;
   PRIVATE(this)->frontonprojector = USE_PICK;
   PRIVATE(this)->valuechangedcbenabled = true;
   PRIVATE(this)->ignoreinbbox = false;
-  PRIVATE(this)->currentevent = NULL;
-  PRIVATE(this)->pickedpath = NULL;
-  PRIVATE(this)->draggercache = NULL;
+  PRIVATE(this)->currentevent = nullptr;
+  PRIVATE(this)->pickedpath = nullptr;
+  PRIVATE(this)->draggercache = nullptr;
   PRIVATE(this)->isgrabbing = false;
-  PRIVATE(this)->activechilddragger = NULL;
-  PRIVATE(this)->surrogateownerpath = NULL;
-  PRIVATE(this)->surrogatepath = NULL;
-  PRIVATE(this)->cbaction = NULL;
+  PRIVATE(this)->activechilddragger = nullptr;
+  PRIVATE(this)->surrogateownerpath = nullptr;
+  PRIVATE(this)->surrogatepath = nullptr;
+  PRIVATE(this)->cbaction = nullptr;
   PRIVATE(this)->didmousemove = false;
   PRIVATE(this)->projectorepsilon = 0.0f;
 }
@@ -465,7 +465,7 @@ SoDragger::updateElements(SoState * state)
 
   if (state->isElementEnabled(SoNormalElement::getClassStackIndex())) {
     // lines/shapes will use normals if on state. We don't want that.
-    SoNormalElement::set(state, this, 0, NULL);
+    SoNormalElement::set(state, this, 0, nullptr);
   }
   if (state->isElementEnabled(SoLineWidthElement::getClassStackIndex())) {
     // make default
@@ -1064,7 +1064,7 @@ typedef struct {
   SbViewVolume vv;
 } sodragger_vv_data;
 
-static sodragger_vv_data * vvdata = NULL;
+static sodragger_vv_data * vvdata = nullptr;
 
 static SoCallbackAction::Response
 sodragger_vv_cb(void * userdata, SoCallbackAction * action, const SoNode * node)
@@ -1084,7 +1084,7 @@ extern "C" {
 static void vv_data_cleanup(void)
 {
   delete vvdata;
-  vvdata = NULL;
+  vvdata = nullptr;
 }
 
 } // extern "C"
@@ -1100,11 +1100,11 @@ SoDragger::getViewVolume(void)
   // view volume can be found directly. pederb, 2002-10-30
 
   if (PRIVATE(this)->draggercache && PRIVATE(this)->draggercache->path) {
-    if (vvdata == NULL) {
+    if (vvdata == nullptr) {
       vvdata = new sodragger_vv_data;
       coin_atexit(static_cast<coin_atexit_f *>(vv_data_cleanup), CC_ATEXIT_NORMAL);
     }
-    if (PRIVATE(this)->cbaction == NULL) {
+    if (PRIVATE(this)->cbaction == nullptr) {
       PRIVATE(this)->cbaction = new SoCallbackAction;
       PRIVATE(this)->cbaction->addPostCallback(SoCamera::getClassTypeId(), sodragger_vv_cb, vvdata);
       PRIVATE(this)->cbaction->addPostCallback(SoDragger::getClassTypeId(), sodragger_vv_cb, this);
@@ -1206,11 +1206,11 @@ SoDragger::workFieldsIntoTransform(SbMatrix & matrix)
 {
   SoSFVec3f * vecfield;
   SoSFRotation * rotfield;
-  const SbVec3f * translation = NULL;
-  const SbVec3f * scaleFactor = NULL;
-  const SbRotation * rotation = NULL;
-  const SbRotation * scaleOrientation = NULL;
-  const SbVec3f * center = NULL;
+  const SbVec3f * translation = nullptr;
+  const SbVec3f * scaleFactor = nullptr;
+  const SbRotation * rotation = nullptr;
+  const SbRotation * scaleOrientation = nullptr;
+  const SbVec3f * center = nullptr;
 
   vecfield = coin_safe_cast<SoSFVec3f *>(this->getField("translation"));
   if (vecfield) translation = &vecfield->getValue();
@@ -1271,7 +1271,7 @@ SoDragger::getMinScale(void)
 
 /*!
   Same as above, but pointers to values are supplied. If a pointer is
-  \c NULL, the matrix value for that argument is used when
+  \c nullptr, the matrix value for that argument is used when
   reconstructing the matrix.
 */
 void
@@ -1322,12 +1322,12 @@ SoDragger::getTransformFast(SbMatrix & matrix, SbVec3f & translation,
 
   SoDragger::workValuesIntoTransform(matrix, &translation, &rotation,
                                      &scalefactor,
-                                     &scaleorientation, NULL);
+                                     &scaleorientation, nullptr);
 }
 
 /*!
   Returns \a matrix after \a translation has been appended.  If \a
-  conversion != \c NULL it is used to transform \a translation into
+  conversion != \c nullptr it is used to transform \a translation into
   the space \a matrix is defined.
 */
 SbMatrix
@@ -1345,7 +1345,7 @@ SoDragger::appendTranslation(const SbMatrix & matrix, const SbVec3f & translatio
 
 /*!
   Returns \a matrix after \a scale and \a scalecenter has been
-  appended.  If \a conversion != \c NULL it is used to transform scale
+  appended.  If \a conversion != \c nullptr it is used to transform scale
   into the space \a matrix is defined.
 */
 
@@ -1463,7 +1463,7 @@ SoDragger::appendScale(const SbMatrix & matrix, const SbVec3f & scale, const SbV
 
 /*!
   Appends \a rot, around \a rotcenter, to \a matrix. If \a conversion
-  is != \c NULL, this is used to move the rotation into that
+  is != \c nullptr, this is used to move the rotation into that
   coordinate systems before appending the rotation.
 */
 SbMatrix
@@ -1602,7 +1602,7 @@ SoDragger::handleEvent(SoHandleEventAction * action)
     if (!action->getGrabber())
       this->updateDraggerCache(action->getCurPath());
     else
-      this->updateDraggerCache(NULL);
+      this->updateDraggerCache(nullptr);
   }
   // try child draggers first
   if (action->getGrabber() != this) {
@@ -1666,7 +1666,7 @@ SoDragger::handleEvent(SoHandleEventAction * action)
       if (!action->getGrabber())
         this->updateDraggerCache(action->getCurPath());
       else
-        this->updateDraggerCache(NULL);
+        this->updateDraggerCache(nullptr);
 
       this->isActive = true;
       PRIVATE(this)->didmousemove = false;
@@ -1693,16 +1693,16 @@ SoDragger::handleEvent(SoHandleEventAction * action)
     if (PRIVATE(this)->isgrabbing) this->grabEventsCleanup();
     if (PRIVATE(this)->pickedpath) {
       PRIVATE(this)->pickedpath->unref();
-      PRIVATE(this)->pickedpath = NULL;
+      PRIVATE(this)->pickedpath = nullptr;
     }
     PRIVATE(this)->surrogatename = "";
     if (PRIVATE(this)->surrogateownerpath) {
       PRIVATE(this)->surrogateownerpath->unref();
-      PRIVATE(this)->surrogateownerpath = NULL;
+      PRIVATE(this)->surrogateownerpath = nullptr;
     }
     if (PRIVATE(this)->surrogatepath) {
       PRIVATE(this)->surrogatepath->unref();
-      PRIVATE(this)->surrogatepath = NULL;
+      PRIVATE(this)->surrogatepath = nullptr;
     }
 
     PRIVATE(this)->finishCB.invokeCallbacks(this);
@@ -1877,7 +1877,7 @@ SoDragger::childFinishCB(void * data, SoDragger * COIN_UNUSED_ARG(child))
 
   thisp->ref();
   PRIVATE(thisp)->finishCB.invokeCallbacks(thisp);
-  thisp->setActiveChildDragger(NULL);
+  thisp->setActiveChildDragger(nullptr);
   if (PRIVATE(thisp)->draggercache) PRIVATE(thisp)->draggercache->truncatePath();
   thisp->unref();
 }
@@ -1929,7 +1929,7 @@ SoDragger::eventHandled(const SoEvent * event, SoHandleEventAction * action)
 void
 SoDragger::updateDraggerCache(const SoPath * path)
 {
-  if (PRIVATE(this)->draggercache == NULL)
+  if (PRIVATE(this)->draggercache == nullptr)
     PRIVATE(this)->draggercache = new SoDraggerCache(this);
   if (path) PRIVATE(this)->draggercache->update(reclassify_cast<const SoFullPath *>(path), path->findNode(this));
   else PRIVATE(this)->draggercache->updateMatrix();
diff --git a/coin4/src/draggers/SoHandleBoxDragger.cpp b/coin4/src/draggers/SoHandleBoxDragger.cpp
index cecf83e..f76aa3b 100644
--- a/coin4/src/draggers/SoHandleBoxDragger.cpp
+++ b/coin4/src/draggers/SoHandleBoxDragger.cpp
@@ -507,7 +507,7 @@ SoHandleBoxDragger::setUpConnections(bool onoff, bool doitalways)
   if (onoff) {
     inherited::setUpConnections(onoff, doitalways);
 
-    SoHandleBoxDragger::fieldSensorCB(this, NULL);
+    SoHandleBoxDragger::fieldSensorCB(this, nullptr);
 
     if (this->translFieldSensor->getAttachedField() != &this->translation) {
       this->translFieldSensor->attach(&this->translation);
@@ -518,10 +518,10 @@ SoHandleBoxDragger::setUpConnections(bool onoff, bool doitalways)
 
   }
   else {
-    if (this->translFieldSensor->getAttachedField() != NULL) {
+    if (this->translFieldSensor->getAttachedField() != nullptr) {
       this->translFieldSensor->detach();
     }
-    if (this->scaleFieldSensor->getAttachedField() != NULL) {
+    if (this->scaleFieldSensor->getAttachedField() != nullptr) {
       this->scaleFieldSensor->detach();
     }
     inherited::setUpConnections(onoff, doitalways);
@@ -875,8 +875,8 @@ SoNode *
 SoHandleBoxDragger::getNodeFieldNode(const char * fieldname)
 {
   SoField * field = this->getField(fieldname);
-  assert(field != NULL);
-  assert(coin_assert_cast<SoSFNode *>(field)->getValue() != NULL);
+  assert(field != nullptr);
+  assert(coin_assert_cast<SoSFNode *>(field)->getValue() != nullptr);
   return coin_assert_cast<SoSFNode *>(field)->getValue();
 }
 
diff --git a/coin4/src/draggers/SoJackDragger.cpp b/coin4/src/draggers/SoJackDragger.cpp
index cce2b23..08f68ec 100644
--- a/coin4/src/draggers/SoJackDragger.cpp
+++ b/coin4/src/draggers/SoJackDragger.cpp
@@ -303,13 +303,13 @@ SoJackDragger::setUpConnections(bool onoff, bool doitalways)
     this->removeChildDragger("rotator");
     this->removeChildDragger("scaler");
     this->removeChildDragger("translator");
-    if (this->rotFieldSensor->getAttachedField() != NULL) {
+    if (this->rotFieldSensor->getAttachedField() != nullptr) {
       this->rotFieldSensor->detach();
     }
-    if (this->translFieldSensor->getAttachedField() != NULL) {
+    if (this->translFieldSensor->getAttachedField() != nullptr) {
       this->translFieldSensor->detach();
     }
-    if (this->scaleFieldSensor->getAttachedField() != NULL) {
+    if (this->scaleFieldSensor->getAttachedField() != nullptr) {
       this->scaleFieldSensor->detach();
     }
     inherited::setUpConnections(onoff, doitalways);
diff --git a/coin4/src/draggers/SoPointLightDragger.cpp b/coin4/src/draggers/SoPointLightDragger.cpp
index e1087f4..f6e77c9 100644
--- a/coin4/src/draggers/SoPointLightDragger.cpp
+++ b/coin4/src/draggers/SoPointLightDragger.cpp
@@ -209,7 +209,7 @@ SoPointLightDragger::setUpConnections(bool onoff, bool doitalways)
   else {
     SoDragger * child = coin_assert_cast<SoDragger *>(this->getAnyPart("translator", false));
     this->unregisterChildDragger(child);
-    if (this->fieldSensor->getAttachedField() != NULL) {
+    if (this->fieldSensor->getAttachedField() != nullptr) {
       this->fieldSensor->detach();
     }
     inherited::setUpConnections(onoff, doitalways);
diff --git a/coin4/src/draggers/SoRotateCylindricalDragger.cpp b/coin4/src/draggers/SoRotateCylindricalDragger.cpp
index 72b0d76..a26a4df 100644
--- a/coin4/src/draggers/SoRotateCylindricalDragger.cpp
+++ b/coin4/src/draggers/SoRotateCylindricalDragger.cpp
@@ -217,14 +217,14 @@ SoRotateCylindricalDragger::setUpConnections(bool onoff, bool doitalways)
   if (onoff) {
     inherited::setUpConnections(onoff, doitalways);
 
-    SoRotateCylindricalDragger::fieldSensorCB(this, NULL);
+    SoRotateCylindricalDragger::fieldSensorCB(this, nullptr);
 
     if (this->fieldSensor->getAttachedField() != &this->rotation) {
       this->fieldSensor->attach(&this->rotation);
     }
   }
   else {
-    if (this->fieldSensor->getAttachedField() != NULL) {
+    if (this->fieldSensor->getAttachedField() != nullptr) {
       this->fieldSensor->detach();
     }
     inherited::setUpConnections(onoff, doitalways);
@@ -305,7 +305,7 @@ SoRotateCylindricalDragger::copyContents(const SoFieldContainer * fromfc,
   if (!this->userProj) {
     delete this->cylinderProj;
   }
-  this->cylinderProj = NULL;
+  this->cylinderProj = nullptr;
 
   if (from->cylinderProj) {
     this->cylinderProj = static_cast<SbCylinderProjector *>(
diff --git a/coin4/src/draggers/SoRotateDiscDragger.cpp b/coin4/src/draggers/SoRotateDiscDragger.cpp
index 8816f85..9a50617 100644
--- a/coin4/src/draggers/SoRotateDiscDragger.cpp
+++ b/coin4/src/draggers/SoRotateDiscDragger.cpp
@@ -219,14 +219,14 @@ SoRotateDiscDragger::setUpConnections(bool onoff, bool doitalways)
   if (onoff) {
     inherited::setUpConnections(onoff, doitalways);
 
-    SoRotateDiscDragger::fieldSensorCB(this, NULL);
+    SoRotateDiscDragger::fieldSensorCB(this, nullptr);
 
     if (this->fieldSensor->getAttachedField() != &this->rotation) {
       this->fieldSensor->attach(&this->rotation);
     }
   }
   else {
-    if (this->fieldSensor->getAttachedField() != NULL) {
+    if (this->fieldSensor->getAttachedField() != nullptr) {
       this->fieldSensor->detach();
     }
     inherited::setUpConnections(onoff, doitalways);
diff --git a/coin4/src/draggers/SoRotateSphericalDragger.cpp b/coin4/src/draggers/SoRotateSphericalDragger.cpp
index 17f51a5..e55dbb3 100644
--- a/coin4/src/draggers/SoRotateSphericalDragger.cpp
+++ b/coin4/src/draggers/SoRotateSphericalDragger.cpp
@@ -226,14 +226,14 @@ SoRotateSphericalDragger::setUpConnections(bool onoff, bool doitalways)
   if (onoff) {
     inherited::setUpConnections(onoff, doitalways);
 
-    SoRotateSphericalDragger::fieldSensorCB(this, NULL);
+    SoRotateSphericalDragger::fieldSensorCB(this, nullptr);
 
     if (this->fieldSensor->getAttachedField() != &this->rotation) {
       this->fieldSensor->attach(&this->rotation);
     }
   }
   else {
-    if (this->fieldSensor->getAttachedField() != NULL) {
+    if (this->fieldSensor->getAttachedField() != nullptr) {
       this->fieldSensor->detach();
     }
     inherited::setUpConnections(onoff, doitalways);
diff --git a/coin4/src/draggers/SoScale1Dragger.cpp b/coin4/src/draggers/SoScale1Dragger.cpp
index 26941a3..fb93ec3 100644
--- a/coin4/src/draggers/SoScale1Dragger.cpp
+++ b/coin4/src/draggers/SoScale1Dragger.cpp
@@ -211,14 +211,14 @@ SoScale1Dragger::setUpConnections(bool onoff, bool doitalways)
   if (onoff) {
     inherited::setUpConnections(onoff, doitalways);
 
-    SoScale1Dragger::fieldSensorCB(this, NULL);
+    SoScale1Dragger::fieldSensorCB(this, nullptr);
 
     if (this->fieldSensor->getAttachedField() != &this->scaleFactor) {
       this->fieldSensor->attach(&this->scaleFactor);
     }
   }
   else {
-    if (this->fieldSensor->getAttachedField() != NULL) {
+    if (this->fieldSensor->getAttachedField() != nullptr) {
       this->fieldSensor->detach();
     }
     inherited::setUpConnections(onoff, doitalways);
diff --git a/coin4/src/draggers/SoScale2Dragger.cpp b/coin4/src/draggers/SoScale2Dragger.cpp
index 1276dbc..9b63aa4 100644
--- a/coin4/src/draggers/SoScale2Dragger.cpp
+++ b/coin4/src/draggers/SoScale2Dragger.cpp
@@ -212,14 +212,14 @@ SoScale2Dragger::setUpConnections(bool onoff, bool doitalways)
   if (onoff) {
     inherited::setUpConnections(onoff, doitalways);
 
-    SoScale2Dragger::fieldSensorCB(this, NULL);
+    SoScale2Dragger::fieldSensorCB(this, nullptr);
 
     if (this->fieldSensor->getAttachedField() != &this->scaleFactor) {
       this->fieldSensor->attach(&this->scaleFactor);
     }
   }
   else {
-    if (this->fieldSensor->getAttachedField() != NULL) {
+    if (this->fieldSensor->getAttachedField() != nullptr) {
       this->fieldSensor->detach();
     }
     inherited::setUpConnections(onoff, doitalways);
diff --git a/coin4/src/draggers/SoScale2UniformDragger.cpp b/coin4/src/draggers/SoScale2UniformDragger.cpp
index d309e31..a038fe0 100644
--- a/coin4/src/draggers/SoScale2UniformDragger.cpp
+++ b/coin4/src/draggers/SoScale2UniformDragger.cpp
@@ -219,14 +219,14 @@ SoScale2UniformDragger::setUpConnections(bool onoff, bool doitalways)
   if (onoff) {
     inherited::setUpConnections(onoff, doitalways);
 
-    SoScale2UniformDragger::fieldSensorCB(this, NULL);
+    SoScale2UniformDragger::fieldSensorCB(this, nullptr);
 
     if (this->fieldSensor->getAttachedField() != &this->scaleFactor) {
       this->fieldSensor->attach(&this->scaleFactor);
     }
   }
   else {
-    if (this->fieldSensor->getAttachedField() != NULL) {
+    if (this->fieldSensor->getAttachedField() != nullptr) {
       this->fieldSensor->detach();
     }
     inherited::setUpConnections(onoff, doitalways);
diff --git a/coin4/src/draggers/SoScaleUniformDragger.cpp b/coin4/src/draggers/SoScaleUniformDragger.cpp
index eba8f83..1787dfd 100644
--- a/coin4/src/draggers/SoScaleUniformDragger.cpp
+++ b/coin4/src/draggers/SoScaleUniformDragger.cpp
@@ -212,14 +212,14 @@ SoScaleUniformDragger::setUpConnections(bool onoff, bool doitalways)
   if (onoff) {
     inherited::setUpConnections(onoff, doitalways);
 
-    SoScaleUniformDragger::fieldSensorCB(this, NULL);
+    SoScaleUniformDragger::fieldSensorCB(this, nullptr);
 
     if (this->fieldSensor->getAttachedField() != &this->scaleFactor) {
       this->fieldSensor->attach(&this->scaleFactor);
     }
   }
   else {
-    if (this->fieldSensor->getAttachedField() != NULL) {
+    if (this->fieldSensor->getAttachedField() != nullptr) {
       this->fieldSensor->detach();
     }
     inherited::setUpConnections(onoff, doitalways);
diff --git a/coin4/src/draggers/SoSpotLightDragger.cpp b/coin4/src/draggers/SoSpotLightDragger.cpp
index f08078c..b56ac74 100644
--- a/coin4/src/draggers/SoSpotLightDragger.cpp
+++ b/coin4/src/draggers/SoSpotLightDragger.cpp
@@ -332,11 +332,11 @@ SoSpotLightDragger::setUpConnections(bool onoff, bool doitalways)
     SoDragger * therotator = coin_assert_cast<SoDragger *>(this->getAnyPart("rotator", false));
     this->unregisterChildDragger(therotator);
 
-    if (this->angleFieldSensor->getAttachedField() != NULL)
+    if (this->angleFieldSensor->getAttachedField() != nullptr)
       this->angleFieldSensor->detach();
-    if (this->rotFieldSensor->getAttachedField() != NULL)
+    if (this->rotFieldSensor->getAttachedField() != nullptr)
       this->rotFieldSensor->detach();
-    if (this->translFieldSensor->getAttachedField() != NULL)
+    if (this->translFieldSensor->getAttachedField() != nullptr)
       this->translFieldSensor->detach();
 
     inherited::setUpConnections(onoff, doitalways);
diff --git a/coin4/src/draggers/SoTabBoxDragger.cpp b/coin4/src/draggers/SoTabBoxDragger.cpp
index ef7bfb2..e3f139f 100644
--- a/coin4/src/draggers/SoTabBoxDragger.cpp
+++ b/coin4/src/draggers/SoTabBoxDragger.cpp
@@ -283,10 +283,10 @@ SoTabBoxDragger::setUpConnections(bool onoff, bool doitalways)
       this->unregisterChildDragger(child);
     }
 
-    if (this->translFieldSensor->getAttachedField() != NULL) {
+    if (this->translFieldSensor->getAttachedField() != nullptr) {
       this->translFieldSensor->detach();
     }
-    if (this->scaleFieldSensor->getAttachedField() != NULL) {
+    if (this->scaleFieldSensor->getAttachedField() != nullptr) {
       this->scaleFieldSensor->detach();
     }
     inherited::setUpConnections(onoff, doitalways);
diff --git a/coin4/src/draggers/SoTabPlaneDragger.cpp b/coin4/src/draggers/SoTabPlaneDragger.cpp
index 67ac7ca..7f1c4d5 100644
--- a/coin4/src/draggers/SoTabPlaneDragger.cpp
+++ b/coin4/src/draggers/SoTabPlaneDragger.cpp
@@ -249,7 +249,7 @@ SoTabPlaneDragger::SoTabPlaneDragger(void)
 
   this->createPrivateParts();
   this->prevsizex = this->prevsizey = 0.0f;
-  this->reallyAdjustScaleTabSize(NULL);
+  this->reallyAdjustScaleTabSize(nullptr);
   this->constraintState = CONSTRAINT_OFF;
   this->whatkind = WHATKIND_NONE;
   this->adjustTabs = true;
@@ -295,7 +295,7 @@ SoTabPlaneDragger::setUpConnections(bool onoff, bool doitalways)
   if (onoff) {
     inherited::setUpConnections(onoff, doitalways);
 
-    SoTabPlaneDragger::fieldSensorCB(this, NULL);
+    SoTabPlaneDragger::fieldSensorCB(this, nullptr);
 
     if (this->translFieldSensor->getAttachedField() != &this->translation) {
       this->translFieldSensor->attach(&this->translation);
@@ -305,10 +305,10 @@ SoTabPlaneDragger::setUpConnections(bool onoff, bool doitalways)
     }
   }
   else {
-    if (this->translFieldSensor->getAttachedField() != NULL) {
+    if (this->translFieldSensor->getAttachedField() != nullptr) {
       this->translFieldSensor->detach();
     }
-    if (this->scaleFieldSensor->getAttachedField() != NULL) {
+    if (this->scaleFieldSensor->getAttachedField() != nullptr) {
       this->scaleFieldSensor->detach();
     }
     inherited::setUpConnections(onoff, doitalways);
@@ -394,7 +394,7 @@ SoTabPlaneDragger::adjustScaleTabSize(void)
 /*!
   Recalculates the size of the tabs, based on the current view volume,
   the current viewport, the current model matrix and the current scale
-  factor. If \a action == \e NULL, a default size will be used.
+  factor. If \a action == \e nullptr, a default size will be used.
 */
 void
 SoTabPlaneDragger::reallyAdjustScaleTabSize(SoGLRenderAction *action)
@@ -404,7 +404,7 @@ SoTabPlaneDragger::reallyAdjustScaleTabSize(SoGLRenderAction *action)
 
   float sizex = 0.08f;
   float sizey = 0.08f;
-  if (action != NULL) {
+  if (action != nullptr) {
     SoState *state = action->getState();
     SbMatrix toworld = SoModelMatrixElement::get(state);
     toworld.multLeft(this->getMotionMatrix());
@@ -788,8 +788,8 @@ SoNode *
 SoTabPlaneDragger::getNodeFieldNode(const char *fieldname)
 {
   SoField * field = this->getField(fieldname);
-  assert(field != NULL);
-  assert(coin_assert_cast<SoSFNode *>(field)->getValue() != NULL);
+  assert(field != nullptr);
+  assert(coin_assert_cast<SoSFNode *>(field)->getValue() != nullptr);
   return coin_assert_cast<SoSFNode *>(field)->getValue();
 }
 
diff --git a/coin4/src/draggers/SoTrackballDragger.cpp b/coin4/src/draggers/SoTrackballDragger.cpp
index 0cd1993..a269977 100644
--- a/coin4/src/draggers/SoTrackballDragger.cpp
+++ b/coin4/src/draggers/SoTrackballDragger.cpp
@@ -131,7 +131,7 @@
 #ifndef DOXYGEN_SKIP_THIS
 class SoTrackballDraggerP {
 public:
-  SoTrackballDraggerP(void) : master(NULL) { }
+  SoTrackballDraggerP(void) : master(nullptr) { }
   SoTrackballDragger * master;
   SbSphereProjector * sphereProj;
   SbCylinderProjector * cylProj;
@@ -363,7 +363,7 @@ SoTrackballDragger::setUpConnections(bool onoff, bool doitalways)
   if (onoff) {
     inherited::setUpConnections(onoff, doitalways);
 
-    SoTrackballDragger::fieldSensorCB(this, NULL);
+    SoTrackballDragger::fieldSensorCB(this, nullptr);
 
     if (this->rotFieldSensor->getAttachedField() != &this->rotation) {
       this->rotFieldSensor->attach(&this->rotation);
@@ -373,10 +373,10 @@ SoTrackballDragger::setUpConnections(bool onoff, bool doitalways)
     }
   }
   else {
-    if (this->rotFieldSensor->getAttachedField() != NULL) {
+    if (this->rotFieldSensor->getAttachedField() != nullptr) {
       this->rotFieldSensor->detach();
     }
-    if (this->scaleFieldSensor->getAttachedField() != NULL) {
+    if (this->scaleFieldSensor->getAttachedField() != nullptr) {
       this->scaleFieldSensor->detach();
     }
     inherited::setUpConnections(onoff, doitalways);
@@ -725,7 +725,7 @@ SoTrackballDragger::dragFinish(void)
       rot.getValue(PRIVATE(this)->animAxis, PRIVATE(this)->animAngle);
     }
     this->saveStartParameters(); // store new startMotionMatrix
-    SoTrackballDragger::timerSensorCB(this, NULL);
+    SoTrackballDragger::timerSensorCB(this, nullptr);
     PRIVATE(this)->prevTime = get_current_time();
     PRIVATE(this)->timerSensor->setBaseTime(PRIVATE(this)->prevTime);
     // FIXME: get animation frame rate from somewhere?
@@ -810,8 +810,8 @@ SoNode *
 SoTrackballDragger::getNodeFieldNode(const char *fieldname)
 {
   SoField *field = this->getField(fieldname);
-  assert(field != NULL);
-  assert(coin_assert_cast<SoSFNode *>(field)->getValue() != NULL);
+  assert(field != nullptr);
+  assert(coin_assert_cast<SoSFNode *>(field)->getValue() != nullptr);
   return coin_assert_cast<SoSFNode *>(field)->getValue();
 }
 
diff --git a/coin4/src/draggers/SoTransformBoxDragger.cpp b/coin4/src/draggers/SoTransformBoxDragger.cpp
index ddef04a..306f36e 100644
--- a/coin4/src/draggers/SoTransformBoxDragger.cpp
+++ b/coin4/src/draggers/SoTransformBoxDragger.cpp
@@ -397,13 +397,13 @@ SoTransformBoxDragger::setUpConnections(bool onoff, bool doitalways)
     this->removeChildDragger(coin_assert_cast<SoDragger *>(this->getAnyPart("translator5", false)));
     this->removeChildDragger(coin_assert_cast<SoDragger *>(this->getAnyPart("translator6", false)));
 
-    if (this->translFieldSensor->getAttachedField() != NULL) {
+    if (this->translFieldSensor->getAttachedField() != nullptr) {
       this->translFieldSensor->detach();
     }
-    if (this->rotFieldSensor->getAttachedField() != NULL) {
+    if (this->rotFieldSensor->getAttachedField() != nullptr) {
       this->rotFieldSensor->detach();
     }
-    if (this->scaleFieldSensor->getAttachedField() != NULL) {
+    if (this->scaleFieldSensor->getAttachedField() != nullptr) {
       this->scaleFieldSensor->detach();
     }
     inherited::setUpConnections(onoff, doitalways);
diff --git a/coin4/src/draggers/SoTransformerDragger.cpp b/coin4/src/draggers/SoTransformerDragger.cpp
index 6f5dd23..a34c385 100644
--- a/coin4/src/draggers/SoTransformerDragger.cpp
+++ b/coin4/src/draggers/SoTransformerDragger.cpp
@@ -868,7 +868,7 @@ SoTransformerDragger::setUpConnections(bool onoff, bool doitalways)
   if (onoff) {
     inherited::setUpConnections(onoff, doitalways);
 
-    SoTransformerDragger::fieldSensorCB(this, NULL);
+    SoTransformerDragger::fieldSensorCB(this, nullptr);
 
     if (this->translFieldSensor->getAttachedField() != &this->translation) {
       this->translFieldSensor->attach(&this->translation);
@@ -881,13 +881,13 @@ SoTransformerDragger::setUpConnections(bool onoff, bool doitalways)
     }
   }
   else {
-    if (this->translFieldSensor->getAttachedField() != NULL) {
+    if (this->translFieldSensor->getAttachedField() != nullptr) {
       this->translFieldSensor->detach();
     }
-    if (this->scaleFieldSensor->getAttachedField() != NULL) {
+    if (this->scaleFieldSensor->getAttachedField() != nullptr) {
       this->scaleFieldSensor->detach();
     }
-    if (this->rotateFieldSensor->getAttachedField() != NULL) {
+    if (this->rotateFieldSensor->getAttachedField() != nullptr) {
       this->rotateFieldSensor->detach();
     }
     inherited::setUpConnections(onoff, doitalways);
@@ -1942,9 +1942,9 @@ SoNode *
 SoTransformerDragger::getNodeFieldNode(const char *fieldname)
 {
   SoField *field = this->getField(fieldname);
-  assert(field != NULL);
+  assert(field != nullptr);
   assert(field->isOfType(SoSFNode::getClassTypeId()));
-  assert(coin_assert_cast<SoSFNode *>(field)->getValue() != NULL);
+  assert(coin_assert_cast<SoSFNode *>(field)->getValue() != nullptr);
   return coin_assert_cast<SoSFNode *>(field)->getValue();
 }
 
@@ -2218,7 +2218,7 @@ register_cb(void * data, SoCallbackAction * action, const SoNode * node)
 {
   assert(data);
   SbDict * dict = static_cast<SbDict *>(data);
-  dict->enter(reinterpret_cast<uintptr_t>(node), NULL);
+  dict->enter(reinterpret_cast<uintptr_t>(node), nullptr);
   return SoCallbackAction::CONTINUE;
 }
 
@@ -2227,7 +2227,7 @@ void
 ensure_unique_cb(uintptr_t entry, void * value, void * data)
 {
   SbDict * copydict = static_cast<SbDict *>(data);
-  void * val = NULL;
+  void * val = nullptr;
   BOOST_ASSERT(!copydict->find(entry, val));
 }
 
diff --git a/coin4/src/draggers/SoTranslate1Dragger.cpp b/coin4/src/draggers/SoTranslate1Dragger.cpp
index 141a37e..8d9a5b8 100644
--- a/coin4/src/draggers/SoTranslate1Dragger.cpp
+++ b/coin4/src/draggers/SoTranslate1Dragger.cpp
@@ -252,14 +252,14 @@ SoTranslate1Dragger::setUpConnections(bool onoff, bool doitalways)
   if (onoff) {
     inherited::setUpConnections(onoff, doitalways);
 
-    SoTranslate1Dragger::fieldSensorCB(this, NULL);
+    SoTranslate1Dragger::fieldSensorCB(this, nullptr);
 
     if (this->fieldSensor->getAttachedField() != &this->translation) {
       this->fieldSensor->attach(&this->translation);
     }
   }
   else {
-    if (this->fieldSensor->getAttachedField() != NULL) {
+    if (this->fieldSensor->getAttachedField() != nullptr) {
       this->fieldSensor->detach();
     }
     inherited::setUpConnections(onoff, doitalways);
diff --git a/coin4/src/draggers/SoTranslate2Dragger.cpp b/coin4/src/draggers/SoTranslate2Dragger.cpp
index b3c1aee..2ad6764 100644
--- a/coin4/src/draggers/SoTranslate2Dragger.cpp
+++ b/coin4/src/draggers/SoTranslate2Dragger.cpp
@@ -276,14 +276,14 @@ SoTranslate2Dragger::setUpConnections(bool onoff, bool doitalways)
   if (onoff) {
     inherited::setUpConnections(onoff, doitalways);
 
-    SoTranslate2Dragger::fieldSensorCB(this, NULL);
+    SoTranslate2Dragger::fieldSensorCB(this, nullptr);
 
     if (this->fieldSensor->getAttachedField() != &this->translation) {
       this->fieldSensor->attach(&this->translation);
     }
   }
   else {
-    if (this->fieldSensor->getAttachedField() != NULL) {
+    if (this->fieldSensor->getAttachedField() != nullptr) {
       this->fieldSensor->detach();
     }
     inherited::setUpConnections(onoff, doitalways);
diff --git a/coin4/src/elements/GL/SoGLCacheContextElement.cpp b/coin4/src/elements/GL/SoGLCacheContextElement.cpp
index 2b7bc5d..b0cf2df 100644
--- a/coin4/src/elements/GL/SoGLCacheContextElement.cpp
+++ b/coin4/src/elements/GL/SoGLCacheContextElement.cpp
@@ -102,8 +102,8 @@ static void soglcachecontext_cleanup(void)
   CC_MUTEX_DESTRUCT(glcache_mutex);
 
   if (soglcache_contextdestructioncb) {
-    SoContextHandler::removeContextDestructionCallback(soglcache_contextdestructioncb, NULL);
-    soglcache_contextdestructioncb = NULL;
+    SoContextHandler::removeContextDestructionCallback(soglcache_contextdestructioncb, nullptr);
+    soglcache_contextdestructioncb = nullptr;
   }
 
   biggest_cache_context_id = 0;
@@ -169,7 +169,7 @@ SoGLCacheContextElement::initClass(void)
   // initClass() to make it work properly when destructing a
   // context. See comments in SoContextHandler.cpp for more
   // information.
-  SoContextHandler::addContextDestructionCallback(cleanupContext, NULL);
+  SoContextHandler::addContextDestructionCallback(cleanupContext, nullptr);
   soglcache_contextdestructioncb = cleanupContext;
 }
 
@@ -238,7 +238,7 @@ SoGLCacheContextElement::set(SoState * state, int context,
   if (remoterendering) elem->autocachebits = DO_AUTO_CACHE;
 
   // really delete GL resources scheduled for destruction
-  SoGLCacheContextElement::cleanupContext((uint32_t) context, NULL);
+  SoGLCacheContextElement::cleanupContext((uint32_t) context, nullptr);
 }
 
 /*!
diff --git a/coin4/src/elements/GL/SoGLLazyElement.cpp b/coin4/src/elements/GL/SoGLLazyElement.cpp
index bbbdf50..a3b9498 100644
--- a/coin4/src/elements/GL/SoGLLazyElement.cpp
+++ b/coin4/src/elements/GL/SoGLLazyElement.cpp
@@ -109,7 +109,7 @@ make_dither_matrix(uint32_t * ptr, int size)
   int currsize = 2;
 
   uint32_t * currmatrix = two_by_two;
-  uint32_t * nextmatrix = NULL;
+  uint32_t * nextmatrix = nullptr;
   int nextsize;
 
   while (currsize < size) {
@@ -397,12 +397,12 @@ SoGLLazyElement::init(SoState * stateptr)
   this->glstate.diffuse = 0xccccccff;
   this->glstate.diffusenodeid = 0;
   this->glstate.transpnodeid = 0;
-  this->packedpointer = NULL;
+  this->packedpointer = nullptr;
   // when doing screen door rendering, we need to always supply 0xff as alpha.
   this->transpmask = (this->coinstate.transptype == SoGLRenderAction::SCREEN_DOOR) ? 0xff : 0x00;
-  this->colorpacker = NULL;
-  this->precachestate = NULL;
-  this->postcachestate = NULL;
+  this->colorpacker = nullptr;
+  this->precachestate = nullptr;
+  this->postcachestate = nullptr;
   this->opencacheflags = 0;
 
   // initialize this here to avoid UMR reports from
@@ -840,7 +840,7 @@ SoGLLazyElement::setPackedElt(SoNode * node, int32_t numcolors,
                               const uint32_t * colors, const bool packedtransparency)
 {
   inherited::setPackedElt(node, numcolors, colors, packedtransparency);
-  this->colorpacker = NULL;
+  this->colorpacker = nullptr;
   this->packedpointer = colors;
 }
 
@@ -1022,8 +1022,8 @@ SoGLLazyElement::endCaching(SoState * state)
     elem->precachestate->cachebitmask |= DIFFUSE_MASK;
   }
 
-  elem->precachestate = NULL;
-  elem->postcachestate = NULL;
+  elem->precachestate = nullptr;
+  elem->postcachestate = nullptr;
   elem->opencacheflags = 0;
 }
 
diff --git a/coin4/src/elements/GL/SoGLLightIdElement.cpp b/coin4/src/elements/GL/SoGLLightIdElement.cpp
index 6ea613d..58db007 100644
--- a/coin4/src/elements/GL/SoGLLightIdElement.cpp
+++ b/coin4/src/elements/GL/SoGLLightIdElement.cpp
@@ -184,7 +184,7 @@ SoGLLightIdElement::getMaxGLSources(void)
 int32_t
 SoGLLightIdElement::increment(SoState * const state)
 {
-  return increment(state, NULL);
+  return increment(state, nullptr);
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/GL/SoGLModelMatrixElement.cpp b/coin4/src/elements/GL/SoGLModelMatrixElement.cpp
index 1821785..8befdeb 100644
--- a/coin4/src/elements/GL/SoGLModelMatrixElement.cpp
+++ b/coin4/src/elements/GL/SoGLModelMatrixElement.cpp
@@ -45,6 +45,8 @@
 #include <Inventor/errors/SoDebugError.h>
 #endif // COIN_DEBUG
 
+#include <cstdlib>
+
 SO_ELEMENT_SOURCE(SoGLModelMatrixElement);
 
 static int COIN_HANDLE_STACK_OVERFLOW = 0;
diff --git a/coin4/src/elements/GL/SoGLMultiTextureImageElement.cpp b/coin4/src/elements/GL/SoGLMultiTextureImageElement.cpp
index af6908c..7716ce8 100644
--- a/coin4/src/elements/GL/SoGLMultiTextureImageElement.cpp
+++ b/coin4/src/elements/GL/SoGLMultiTextureImageElement.cpp
@@ -170,7 +170,7 @@ SoGLMultiTextureImageElement::pop(SoState * state,
     if (thisud.glimage != prevud.glimage) this->updateGL(i);
     str.sprintf("coin_texunit%d_model", i);
     if (prog) prog->updateCoinParameter(state, SbName(str.getString()),
-                                        thisud.glimage != NULL ? this->getUnitData(i).model : 0);
+                                        thisud.glimage != nullptr ? this->getUnitData(i).model : 0);
   }
 }
 
@@ -208,7 +208,7 @@ SoGLMultiTextureImageElement::set(SoState * const state, SoNode * const node,
                    unit,
                    SbVec3s(0,0,0),
                    0,
-                   NULL,
+                   nullptr,
                    multi_translateWrap(image->getWrapS()),
                    multi_translateWrap(image->getWrapT()),
                    multi_translateWrap(image->getWrapR()),
@@ -220,7 +220,7 @@ SoGLMultiTextureImageElement::set(SoState * const state, SoNode * const node,
     // if (image->getImage()) image->getImage()->readLock();
   }
   else {
-    ud.glimage = NULL;
+    ud.glimage = nullptr;
     inherited::setDefault(state, node, unit);
   }
   elem->updateGL(unit);
@@ -264,7 +264,7 @@ SoGLMultiTextureImageElement::get(SoState * state,
     blendcolor = ud.blendColor;
     return PRIVATE(elem)->unitdata[unit].glimage;
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
diff --git a/coin4/src/elements/GL/SoGLTextureEnabledElement.cpp b/coin4/src/elements/GL/SoGLTextureEnabledElement.cpp
index c17c363..bbd72a9 100644
--- a/coin4/src/elements/GL/SoGLTextureEnabledElement.cpp
+++ b/coin4/src/elements/GL/SoGLTextureEnabledElement.cpp
@@ -155,7 +155,7 @@ SoGLTextureEnabledElement::pop(SoState * state,
 void
 SoGLTextureEnabledElement::set(SoState * const state, const bool enabled)
 {
-  SoGLTextureEnabledElement::set(state, NULL, enabled);
+  SoGLTextureEnabledElement::set(state, nullptr, enabled);
 }
 
 
diff --git a/coin4/src/elements/GL/SoGLVBOElement.cpp b/coin4/src/elements/GL/SoGLVBOElement.cpp
index f425472..28045c8 100644
--- a/coin4/src/elements/GL/SoGLVBOElement.cpp
+++ b/coin4/src/elements/GL/SoGLVBOElement.cpp
@@ -131,7 +131,7 @@ SoGLVBOElement::setTexCoordVBO(SoState * state, const int unit, SoVBO * vbo)
   SoGLVBOElement * elem = getElement(state);
   const int n = PRIVATE(elem)->texcoordvbo.getLength();
   for (int i = n; i <= unit; i++) {
-    PRIVATE(elem)->texcoordvbo.append(NULL);
+    PRIVATE(elem)->texcoordvbo.append(nullptr);
   }
   PRIVATE(elem)->texcoordvbo[unit] = vbo;
 }
@@ -140,9 +140,9 @@ SoGLVBOElement::setTexCoordVBO(SoState * state, const int unit, SoVBO * vbo)
 void
 SoGLVBOElement::init(SoState * COIN_UNUSED_ARG(state))
 {
-  PRIVATE(this)->vertexvbo = NULL;
-  PRIVATE(this)->normalvbo = NULL;
-  PRIVATE(this)->colorvbo = NULL;
+  PRIVATE(this)->vertexvbo = nullptr;
+  PRIVATE(this)->normalvbo = nullptr;
+  PRIVATE(this)->colorvbo = nullptr;
   PRIVATE(this)->texcoordvbo.truncate(0);
 }
 
@@ -183,7 +183,7 @@ SoElement *
 SoGLVBOElement::copyMatchInfo(void) const
 {
   assert(0 && "should never get here");
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -234,7 +234,7 @@ SoGLVBOElement::getTexCoordVBO(const int idx) const
   if (idx < PRIVATE(this)->texcoordvbo.getLength()) {
     return PRIVATE(this)->texcoordvbo[idx];
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
diff --git a/coin4/src/elements/GL/SoGLVertexAttributeElement.cpp b/coin4/src/elements/GL/SoGLVertexAttributeElement.cpp
index 522deee..c6ebfef 100644
--- a/coin4/src/elements/GL/SoGLVertexAttributeElement.cpp
+++ b/coin4/src/elements/GL/SoGLVertexAttributeElement.cpp
@@ -185,7 +185,7 @@ static void enable_vbo(const Key & COIN_UNUSED_ARG(key),
     SoCoordinateElement::getInstance(action->getState());
   assert(coords->getNum() == attribdata->data->getNum());
 
-  const void * dataptr = NULL;
+  const void * dataptr = nullptr;
 
   if (data->vbo) {
     data->vbo->bindBuffer(action->getCacheContext());
@@ -232,7 +232,7 @@ void
 SoGLVertexAttributeElement::addElt(SoVertexAttributeData * attribdata)
 {
   inherited::addElt(attribdata);
-  this->applyToAttributes(query_attribs, NULL);
+  this->applyToAttributes(query_attribs, nullptr);
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoAnnoText3FontSizeHintElement.cpp b/coin4/src/elements/SoAnnoText3FontSizeHintElement.cpp
index bc3247c..bd944ff 100644
--- a/coin4/src/elements/SoAnnoText3FontSizeHintElement.cpp
+++ b/coin4/src/elements/SoAnnoText3FontSizeHintElement.cpp
@@ -87,7 +87,7 @@ SoAnnoText3FontSizeHintElement::set(SoState * const state, SoNode * const node,
 void
 SoAnnoText3FontSizeHintElement::set(SoState * const state, const FontSizeHint hint)
 {
-  set(state, NULL, hint);
+  set(state, nullptr, hint);
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoAnnoText3RenderPrintElement.cpp b/coin4/src/elements/SoAnnoText3RenderPrintElement.cpp
index ac44015..ea9d123 100644
--- a/coin4/src/elements/SoAnnoText3RenderPrintElement.cpp
+++ b/coin4/src/elements/SoAnnoText3RenderPrintElement.cpp
@@ -88,7 +88,7 @@ void
 SoAnnoText3RenderPrintElement::set(SoState * const state,
                                    const RenderPrintType type)
 {
-  set(state, NULL, type);
+  set(state, nullptr, type);
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoBumpMapCoordinateElement.cpp b/coin4/src/elements/SoBumpMapCoordinateElement.cpp
index 84e700a..14b3346 100644
--- a/coin4/src/elements/SoBumpMapCoordinateElement.cpp
+++ b/coin4/src/elements/SoBumpMapCoordinateElement.cpp
@@ -80,7 +80,7 @@ SoBumpMapCoordinateElement::init(SoState * state)
 {
   inherited::init(state);
   this->numcoords = 0;
-  this->coords = NULL;
+  this->coords = nullptr;
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoBumpMapElement.cpp b/coin4/src/elements/SoBumpMapElement.cpp
index fca54bc..a0f78fa 100644
--- a/coin4/src/elements/SoBumpMapElement.cpp
+++ b/coin4/src/elements/SoBumpMapElement.cpp
@@ -80,7 +80,7 @@ void
 SoBumpMapElement::init(SoState * state)
 {
   inherited::init(state);
-  this->image = NULL;
+  this->image = nullptr;
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoCacheElement.cpp b/coin4/src/elements/SoCacheElement.cpp
index c1ffd6b..44e08cf 100644
--- a/coin4/src/elements/SoCacheElement.cpp
+++ b/coin4/src/elements/SoCacheElement.cpp
@@ -58,7 +58,7 @@ bool SoCacheElement::invalidated = false;
 
 #ifdef COIN_THREADSAFE
 
-static SbTypedStorage <bool*> * invalidated_storage = NULL;
+static SbTypedStorage <bool*> * invalidated_storage = nullptr;
 
 static void
 cacheelement_cleanup(void)
@@ -101,7 +101,7 @@ void
 SoCacheElement::init(SoState * state)
 {
   inherited::init(state);
-  this->cache = NULL;
+  this->cache = nullptr;
 }
 
 // *************************************************************************
@@ -111,7 +111,7 @@ void
 SoCacheElement::push(SoState * state)
 {
   inherited::push(state);
-  this->cache = NULL;
+  this->cache = nullptr;
 }
 
 // Documented in superclass. Overridden to unref the cache, since the
@@ -127,7 +127,7 @@ SoCacheElement::pop(SoState * state, const SoElement * prevTopElement)
      );
   if (prev->cache) {
     prev->cache->unref();
-    prev->cache = NULL;
+    prev->cache = nullptr;
   }
   inherited::pop(state, prevTopElement);
   if (!this->anyOpen(state)) state->setCacheOpen(false);
@@ -156,7 +156,7 @@ SoCacheElement::set(SoState * const state, SoCache * const cache)
 }
 
 /*!
-  This method returns the cache, or NULL if there is no cache.
+  This method returns the cache, or nullptr if there is no cache.
 */
 
 SoCache *
@@ -234,7 +234,7 @@ SoElement *
 SoCacheElement::copyMatchInfo(void) const
 {
   assert(false && "this method should not be called for this element");
-  return NULL;
+  return nullptr;
 }
 
 /*!
diff --git a/coin4/src/elements/SoComplexityElement.cpp b/coin4/src/elements/SoComplexityElement.cpp
index 1171266..95109fd 100644
--- a/coin4/src/elements/SoComplexityElement.cpp
+++ b/coin4/src/elements/SoComplexityElement.cpp
@@ -81,7 +81,7 @@ SoComplexityElement::set(SoState * const state, SoNode * const node,
 void
 SoComplexityElement::set(SoState * const state, const float complexity)
 {
-  set(state, NULL, complexity);
+  set(state, nullptr, complexity);
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoComplexityTypeElement.cpp b/coin4/src/elements/SoComplexityTypeElement.cpp
index 873dbad..3c0169f 100644
--- a/coin4/src/elements/SoComplexityTypeElement.cpp
+++ b/coin4/src/elements/SoComplexityTypeElement.cpp
@@ -93,7 +93,7 @@ SoComplexityTypeElement::init(SoState * state)
 void
 SoComplexityTypeElement::set(SoState * const state, const Type type)
 {
-  set(state, NULL, type);
+  set(state, nullptr, type);
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoCoordinateElement.cpp b/coin4/src/elements/SoCoordinateElement.cpp
index f90be79..e66cd2b 100644
--- a/coin4/src/elements/SoCoordinateElement.cpp
+++ b/coin4/src/elements/SoCoordinateElement.cpp
@@ -41,7 +41,7 @@
 #include "SbBasicP.h"
 
 // static variables
-SbVec3f * SoCoordinateElement::initialdefaultcoords = NULL;
+SbVec3f * SoCoordinateElement::initialdefaultcoords = nullptr;
 
 /*!
   \fn SoCoordinateElement::numCoords
@@ -109,7 +109,7 @@ SoCoordinateElement::init(SoState * state)
   inherited::init(state);
   this->numCoords = 1;
   this->coords3D = SoCoordinateElement::initialdefaultcoords;
-  this->coords4D = NULL;
+  this->coords4D = nullptr;
   this->areCoords3D = true;
 }
 
@@ -122,7 +122,7 @@ SoCoordinateElement::set3(SoState * const state,
                           const SbVec3f * const coords)
 {
   if (state->isElementEnabled(SoGLVBOElement::getClassStackIndex())) {
-    SoGLVBOElement::setVertexVBO(state, NULL);
+    SoGLVBOElement::setVertexVBO(state, nullptr);
   }
   SoCoordinateElement * elem =
     coin_safe_cast<SoCoordinateElement *>
@@ -147,7 +147,7 @@ SoCoordinateElement::set4(SoState * const state,
                           const SbVec4f * const coords)
 {
   if (state->isElementEnabled(SoGLVBOElement::getClassStackIndex())) {
-    SoGLVBOElement::setVertexVBO(state, NULL);
+    SoGLVBOElement::setVertexVBO(state, nullptr);
   }
   SoCoordinateElement * elem = coin_safe_cast<SoCoordinateElement *>
     (
diff --git a/coin4/src/elements/SoCreaseAngleElement.cpp b/coin4/src/elements/SoCreaseAngleElement.cpp
index c9ef5f6..52a4382 100644
--- a/coin4/src/elements/SoCreaseAngleElement.cpp
+++ b/coin4/src/elements/SoCreaseAngleElement.cpp
@@ -76,7 +76,7 @@ SoCreaseAngleElement::set(SoState * const state, SoNode * const node,
 void
 SoCreaseAngleElement::set(SoState * const state, const float complexity)
 {
-  SoCreaseAngleElement::set(state, NULL, complexity);
+  SoCreaseAngleElement::set(state, nullptr, complexity);
 }
 
 /*!
diff --git a/coin4/src/elements/SoCullElement.cpp b/coin4/src/elements/SoCullElement.cpp
index 64ccf30..3852a86 100644
--- a/coin4/src/elements/SoCullElement.cpp
+++ b/coin4/src/elements/SoCullElement.cpp
@@ -60,7 +60,7 @@
 
   [...]
   SoCallbackAction cba(myviewport);
-  cba.addPostCallback(SoCamera::getClassTypeId(), camera_cb, NULL);
+  cba.addPostCallback(SoCamera::getClassTypeId(), camera_cb, nullptr);
 
   \endverbatim
 
@@ -241,7 +241,7 @@ SoElement *
 SoCullElement::copyMatchInfo(void) const
 {
   assert(0 && "should not get here");
-  return NULL;
+  return nullptr;
 }
 
 //
diff --git a/coin4/src/elements/SoDecimationPercentageElement.cpp b/coin4/src/elements/SoDecimationPercentageElement.cpp
index b4ac65d..12939c4 100644
--- a/coin4/src/elements/SoDecimationPercentageElement.cpp
+++ b/coin4/src/elements/SoDecimationPercentageElement.cpp
@@ -81,7 +81,7 @@ SoDecimationPercentageElement::set(SoState * const state, SoNode * const node,
 void
 SoDecimationPercentageElement::set(SoState * const state, const float complexity)
 {
-  set(state, NULL, complexity);
+  set(state, nullptr, complexity);
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoDecimationTypeElement.cpp b/coin4/src/elements/SoDecimationTypeElement.cpp
index dcfc569..4ce20c0 100644
--- a/coin4/src/elements/SoDecimationTypeElement.cpp
+++ b/coin4/src/elements/SoDecimationTypeElement.cpp
@@ -89,7 +89,7 @@ SoDecimationTypeElement::init(SoState * state)
 void
 SoDecimationTypeElement::set(SoState * const state, const Type type)
 {
-  set(state, NULL, type);
+  set(state, nullptr, type);
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoDrawStyleElement.cpp b/coin4/src/elements/SoDrawStyleElement.cpp
index 440c0bc..3a007c3 100644
--- a/coin4/src/elements/SoDrawStyleElement.cpp
+++ b/coin4/src/elements/SoDrawStyleElement.cpp
@@ -89,7 +89,7 @@ SoDrawStyleElement::set(SoState * const state,
 void
 SoDrawStyleElement::set(SoState * const state, const Style style)
 {
-  set(state, NULL, style);
+  set(state, nullptr, style);
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoElement.cpp b/coin4/src/elements/SoElement.cpp
index 539eff2..bcc8a5a 100644
--- a/coin4/src/elements/SoElement.cpp
+++ b/coin4/src/elements/SoElement.cpp
@@ -250,8 +250,8 @@
     if (root) {
       root->ref();
       SoCallbackAction cbaction;
-      cbaction.addPreCallback(SoTexture2::getClassTypeId(), pre_tex2_cb, NULL);
-      cbaction.addPreCallback(SoShape::getClassTypeId(), pre_shape_cb, NULL);
+      cbaction.addPreCallback(SoTexture2::getClassTypeId(), pre_tex2_cb, nullptr);
+      cbaction.addPreCallback(SoShape::getClassTypeId(), pre_shape_cb, nullptr);
       cbaction.apply(root);
       root->unref();
       return 0;
@@ -313,7 +313,7 @@
   evaluation may have to be perfomed, so use getConstElement() instead
   if the instance shouldn't be modified.
 
-  If no instance is available and can not be made, \c NULL is
+  If no instance is available and can not be made, \c nullptr is
   returned.
 
   \sa const SoElement * SoElement::getConstElement(SoState * const state, const int stackIndex)
@@ -501,7 +501,7 @@ SoElement::initClass(void)
   // Make sure we only initialize once.
   assert(SoElement::classTypeId == SoType::badType());
   SoElement::classTypeId =
-    SoType::createType(SoType::badType(), "Element", NULL);
+    SoType::createType(SoType::badType(), "Element", nullptr);
 
   SoElement::classStackIndex = -1;
   SoElement::initElements();
@@ -522,8 +522,8 @@ SoElement::cleanup(void)
   for the elements type identifier..
 */
 SoElement::SoElement(void)
-  : nextup(NULL),
-    nextdown(NULL)
+  : nextup(nullptr),
+    nextdown(nullptr)
 {
 }
 
@@ -666,7 +666,7 @@ SoElement::getDepth() const
   returned instance is modified, strange, hard to find and generally
   wonderful bugs will most likely start to happen.)
 
-  If no instance can be returned, \c NULL is returned.
+  If no instance can be returned, \c nullptr is returned.
 
   \sa SoElement * SoElement::getElement(SoState * const state, const int stackIndex)
 */
diff --git a/coin4/src/elements/SoFloatElement.cpp b/coin4/src/elements/SoFloatElement.cpp
index 58b6f87..b2fac8d 100644
--- a/coin4/src/elements/SoFloatElement.cpp
+++ b/coin4/src/elements/SoFloatElement.cpp
@@ -128,7 +128,7 @@ void
 SoFloatElement::set(const int stackIndex, SoState * const state,
                     const float value)
 {
-  SoFloatElement::set(stackIndex, state, NULL, value);
+  SoFloatElement::set(stackIndex, state, nullptr, value);
 }
 
 /*!
@@ -141,7 +141,7 @@ SoFloatElement::get(const int index, SoState * const state)
   const SoFloatElement * element = coin_safe_cast<const SoFloatElement *>
     (
      getConstElement(state, index)
-     ); //, NULL );
+     ); //, nullptr );
   if (element) { return element->data; }
   return 0.0f;
 }
diff --git a/coin4/src/elements/SoFocalDistanceElement.cpp b/coin4/src/elements/SoFocalDistanceElement.cpp
index 561e082..bb94d0b 100644
--- a/coin4/src/elements/SoFocalDistanceElement.cpp
+++ b/coin4/src/elements/SoFocalDistanceElement.cpp
@@ -78,7 +78,7 @@ SoFocalDistanceElement::set(SoState * const state, SoNode * const node,
 void
 SoFocalDistanceElement::set(SoState * const state, const float distance)
 {
-  SoFocalDistanceElement::set(state, NULL, distance);
+  SoFocalDistanceElement::set(state, nullptr, distance);
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoFontNameElement.cpp b/coin4/src/elements/SoFontNameElement.cpp
index 94e0d87..32bce41 100644
--- a/coin4/src/elements/SoFontNameElement.cpp
+++ b/coin4/src/elements/SoFontNameElement.cpp
@@ -38,7 +38,7 @@
 
 
 
-SbName * SoFontNameElement::defaultfontname = NULL;
+SbName * SoFontNameElement::defaultfontname = nullptr;
 
 /*!
   \fn SoFontNameElement::fontName
diff --git a/coin4/src/elements/SoFontSizeElement.cpp b/coin4/src/elements/SoFontSizeElement.cpp
index d33c9a5..a0ef459 100644
--- a/coin4/src/elements/SoFontSizeElement.cpp
+++ b/coin4/src/elements/SoFontSizeElement.cpp
@@ -81,7 +81,7 @@ SoFontSizeElement::set(SoState * const state, SoNode * const node,
 void
 SoFontSizeElement::set(SoState * const state, const float fontSize)
 {
-  set(state, NULL, fontSize);
+  set(state, nullptr, fontSize);
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoInt32Element.cpp b/coin4/src/elements/SoInt32Element.cpp
index 5543fad..4d85543 100644
--- a/coin4/src/elements/SoInt32Element.cpp
+++ b/coin4/src/elements/SoInt32Element.cpp
@@ -121,7 +121,7 @@ void
 SoInt32Element::set(const int index, SoState * const state,
                     const int32_t value)
 {
-  set(index, state, NULL, value);
+  set(index, state, nullptr, value);
 }
 
 //! FIXME: write doc.
@@ -131,7 +131,7 @@ SoInt32Element::get(const int index,
                     SoState * const state)
 {
   const SoInt32Element * element;
-  element = coin_safe_cast<const SoInt32Element *>(getConstElement(state, index)); //, NULL );
+  element = coin_safe_cast<const SoInt32Element *>(getConstElement(state, index)); //, nullptr );
   if (element)
     return element->data;
   return 0;
diff --git a/coin4/src/elements/SoLazyElement.cpp b/coin4/src/elements/SoLazyElement.cpp
index 01c57b6..b83b14e 100644
--- a/coin4/src/elements/SoLazyElement.cpp
+++ b/coin4/src/elements/SoLazyElement.cpp
@@ -73,11 +73,11 @@
 #include <Inventor/misc/SoState.h>
 #include <Inventor/nodes/SoNode.h>
 
-static SbColor * lazy_defaultdiffuse = NULL;
-static float * lazy_defaulttransp = NULL;
-static int32_t * lazy_defaultindex = NULL;
-static uint32_t * lazy_defaultpacked = NULL;
-static SbColor * lazy_unpacked = NULL;
+static SbColor * lazy_defaultdiffuse = nullptr;
+static float * lazy_defaulttransp = nullptr;
+static int32_t * lazy_defaultindex = nullptr;
+static uint32_t * lazy_defaultpacked = nullptr;
+static SbColor * lazy_unpacked = nullptr;
 
 extern "C" {
 
@@ -89,7 +89,7 @@ lazyelement_cleanup(void)
   delete lazy_defaultindex;
   delete lazy_defaultpacked;
   delete lazy_unpacked;
-  lazy_defaultdiffuse = NULL; // Only need to NULL this; see initClass().
+  lazy_defaultdiffuse = nullptr; // Only need to nullptr this; see initClass().
 }
 
 } // extern "C"
@@ -124,7 +124,7 @@ SoLazyElement::initClass()
 {
   SO_ELEMENT_INIT_CLASS(SoLazyElement, inherited);
 
-  if (lazy_defaultdiffuse == NULL) {
+  if (lazy_defaultdiffuse == nullptr) {
     lazy_defaultdiffuse = new SbColor;
     lazy_defaulttransp = new float;
     lazy_defaultindex = new int32_t;
@@ -203,13 +203,13 @@ SoLazyElement::matches(const SoElement * COIN_UNUSED_ARG(element)) const
 }
 
 /*!
-  Just returns NULL in Coin.
+  Just returns nullptr in Coin.
 */
 SoElement *
 SoLazyElement::copyMatchInfo(void) const
 {
   assert(0 && "should never happen");
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -230,7 +230,7 @@ SoLazyElement::setDiffuse(SoState * state, SoNode * node, int32_t numcolors,
                           const SbColor * colors, SoColorPacker * packer)
 {
   if (state->isElementEnabled(SoGLVBOElement::getClassStackIndex())) {
-    SoGLVBOElement::setColorVBO(state, NULL);
+    SoGLVBOElement::setColorVBO(state, nullptr);
   }
   SoLazyElement * elem = SoLazyElement::getInstance(state);
   if (numcolors && (elem->coinstate.diffusenodeid !=
@@ -251,7 +251,7 @@ SoLazyElement::setTransparency(SoState *state, SoNode *node, int32_t numvalues,
                                const float * transparency, SoColorPacker * packer)
 {
   if (state->isElementEnabled(SoGLVBOElement::getClassStackIndex())) {
-    SoGLVBOElement::setColorVBO(state, NULL);
+    SoGLVBOElement::setColorVBO(state, nullptr);
   }
   SoLazyElement * elem = SoLazyElement::getInstance(state);
   if (numvalues && (elem->coinstate.transpnodeid !=
@@ -274,7 +274,7 @@ SoLazyElement::setPacked(SoState * state, SoNode * node,
                          const bool packedtransparency)
 {
   if (state->isElementEnabled(SoGLVBOElement::getClassStackIndex())) {
-    SoGLVBOElement::setColorVBO(state, NULL);
+    SoGLVBOElement::setColorVBO(state, nullptr);
   }
   SoLazyElement * elem = SoLazyElement::getInstance(state);
   if (numcolors && elem->coinstate.diffusenodeid != node->getNodeId()) {
@@ -735,7 +735,7 @@ SoLazyElement::setMaterials(SoState * state, SoNode *node, uint32_t bitmask,
                             const bool istransparent)
 {
   if (state->isElementEnabled(SoGLVBOElement::getClassStackIndex())) {
-    SoGLVBOElement::setColorVBO(state, NULL);
+    SoGLVBOElement::setColorVBO(state, nullptr);
   }
   SoLazyElement * elem = SoLazyElement::getInstance(state);
 
@@ -772,7 +772,7 @@ SoLazyElement::setMaterials(SoState * state, SoNode *node, uint32_t bitmask,
     }
   }
 
-  SoLazyElement * welem = NULL;
+  SoLazyElement * welem = nullptr;
 
   if (eltbitmask) {
     welem = getWInstance(state);
@@ -901,7 +901,7 @@ const int32_t *
 SoLazyElement::getColorIndexPointer(void) const
 {
   assert(0 && "color index mode is not supported in Coin");
-  return NULL;
+  return nullptr;
 }
 
 // ! FIXME: write doc
diff --git a/coin4/src/elements/SoLightAttenuationElement.cpp b/coin4/src/elements/SoLightAttenuationElement.cpp
index 37dc241..3d4023c 100644
--- a/coin4/src/elements/SoLightAttenuationElement.cpp
+++ b/coin4/src/elements/SoLightAttenuationElement.cpp
@@ -39,7 +39,7 @@
 
 // Dynamically allocated to avoid problems on systems which doesn't
 // handle static constructors.
-static SbVec3f * defaultattenuation = NULL;
+static SbVec3f * defaultattenuation = nullptr;
 
 extern "C" {
 
diff --git a/coin4/src/elements/SoLightModelElement.cpp b/coin4/src/elements/SoLightModelElement.cpp
index 3aee678..1b7831b 100644
--- a/coin4/src/elements/SoLightModelElement.cpp
+++ b/coin4/src/elements/SoLightModelElement.cpp
@@ -109,7 +109,7 @@ const SoLightModelElement *
 SoLightModelElement::getInstance(SoState *state)
 {
   //FIXME: Can this function or any of the similar functions ever
-  //return NULL? BFG 20080916
+  //return nullptr? BFG 20080916
   return coin_assert_cast<const SoLightModelElement *>
     (
      state->getElementNoPush(classStackIndex)
diff --git a/coin4/src/elements/SoLinePatternElement.cpp b/coin4/src/elements/SoLinePatternElement.cpp
index 1e9934a..eb831f4 100644
--- a/coin4/src/elements/SoLinePatternElement.cpp
+++ b/coin4/src/elements/SoLinePatternElement.cpp
@@ -81,7 +81,7 @@ SoLinePatternElement::init(SoState * state)
 void
 SoLinePatternElement::set(SoState * const state, const int32_t pattern)
 {
-  set(state, NULL, pattern);
+  set(state, nullptr, pattern);
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoLineWidthElement.cpp b/coin4/src/elements/SoLineWidthElement.cpp
index 1cf859d..62bb9ce 100644
--- a/coin4/src/elements/SoLineWidthElement.cpp
+++ b/coin4/src/elements/SoLineWidthElement.cpp
@@ -79,7 +79,7 @@ SoLineWidthElement::set(SoState * const state, SoNode * const node,
 void
 SoLineWidthElement::set(SoState * const state, const float lineWidth)
 {
-  SoLineWidthElement::set(state, NULL, lineWidth);
+  SoLineWidthElement::set(state, nullptr, lineWidth);
 }
 
 /*!
diff --git a/coin4/src/elements/SoListenerGainElement.cpp b/coin4/src/elements/SoListenerGainElement.cpp
index 3e9fbf9..43674b0 100644
--- a/coin4/src/elements/SoListenerGainElement.cpp
+++ b/coin4/src/elements/SoListenerGainElement.cpp
@@ -82,7 +82,7 @@ SoListenerGainElement::set(SoState * const state, SoNode * const node,
 void
 SoListenerGainElement::set(SoState * const state, const float gain)
 {
-  SoListenerGainElement::set(state, NULL, gain);
+  SoListenerGainElement::set(state, nullptr, gain);
 }
 
 /*!
diff --git a/coin4/src/elements/SoLocalBBoxMatrixElement.cpp b/coin4/src/elements/SoLocalBBoxMatrixElement.cpp
index 31c8eaf..f6d25f7 100644
--- a/coin4/src/elements/SoLocalBBoxMatrixElement.cpp
+++ b/coin4/src/elements/SoLocalBBoxMatrixElement.cpp
@@ -117,7 +117,7 @@ SoLocalBBoxMatrixElement::copyMatchInfo(void) const
   SoDebugError::postInfo("SoLocalBBoxMatrixElement::copyMatchInfo",
                          "This method should never be called for this element.");
 #endif // COIN_DEBUG
-  return NULL;
+  return nullptr;
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoMaterialBindingElement.cpp b/coin4/src/elements/SoMaterialBindingElement.cpp
index 8e1bd49..7905a13 100644
--- a/coin4/src/elements/SoMaterialBindingElement.cpp
+++ b/coin4/src/elements/SoMaterialBindingElement.cpp
@@ -89,7 +89,7 @@ SoMaterialBindingElement::init(SoState * state)
 void
 SoMaterialBindingElement::set(SoState * const state, const Binding binding)
 {
-  set(state, NULL, binding);
+  set(state, nullptr, binding);
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoMultiTextureCoordinateElement.cpp b/coin4/src/elements/SoMultiTextureCoordinateElement.cpp
index 13ecf8c..e0d3dc5 100644
--- a/coin4/src/elements/SoMultiTextureCoordinateElement.cpp
+++ b/coin4/src/elements/SoMultiTextureCoordinateElement.cpp
@@ -48,12 +48,12 @@
 SoMultiTextureCoordinateElement::UnitData::UnitData()
   : nodeid(0),
     whatKind(DEFAULT),
-    funcCB(NULL),
-    funcCBData(NULL),
+    funcCB(nullptr),
+    funcCBData(nullptr),
     numCoords(0),
-    coords2(NULL),
-    coords3(NULL),
-    coords4(NULL),
+    coords2(nullptr),
+    coords3(nullptr),
+    coords4(nullptr),
     coordsDimension(2)
 {
 }
@@ -124,7 +124,7 @@ SoMultiTextureCoordinateElement::setDefault(SoState * const state,
                                             const int unit)
 {
   if (state->isElementEnabled(SoGLVBOElement::getClassStackIndex())) {
-    SoGLVBOElement::setTexCoordVBO(state, unit, NULL);
+    SoGLVBOElement::setTexCoordVBO(state, unit, nullptr);
   }
   SoMultiTextureCoordinateElement * element =
     coin_assert_cast<SoMultiTextureCoordinateElement *>
@@ -147,7 +147,7 @@ SoMultiTextureCoordinateElement::setFunction(SoState * const state,
                                              void * const userdata)
 {
   if (state->isElementEnabled(SoGLVBOElement::getClassStackIndex())) {
-    SoGLVBOElement::setTexCoordVBO(state, unit, NULL);
+    SoGLVBOElement::setTexCoordVBO(state, unit, nullptr);
   }
 
   SoMultiTextureCoordinateElement * element =
@@ -161,9 +161,9 @@ SoMultiTextureCoordinateElement::setFunction(SoState * const state,
   ud.funcCB = func;
   ud.funcCBData = userdata;
   ud.whatKind = FUNCTION;
-  ud.coords2 = NULL;
-  ud.coords3 = NULL;
-  ud.coords4 = NULL;
+  ud.coords2 = nullptr;
+  ud.coords3 = nullptr;
+  ud.coords4 = nullptr;
   ud.numCoords = 0;
 }
 
@@ -177,7 +177,7 @@ SoMultiTextureCoordinateElement::set2(SoState * const state,
                                       const SbVec2f * const coords)
 {
   if (state->isElementEnabled(SoGLVBOElement::getClassStackIndex())) {
-    SoGLVBOElement::setTexCoordVBO(state, unit, NULL);
+    SoGLVBOElement::setTexCoordVBO(state, unit, nullptr);
   }
   SoMultiTextureCoordinateElement * element = coin_assert_cast<SoMultiTextureCoordinateElement *>
     (
@@ -191,8 +191,8 @@ SoMultiTextureCoordinateElement::set2(SoState * const state,
   ud.coordsDimension = 2;
   ud.numCoords = numCoords;
   ud.coords2 = coords;
-  ud.coords3 = NULL;
-  ud.coords4 = NULL;
+  ud.coords3 = nullptr;
+  ud.coords4 = nullptr;
   ud.whatKind = EXPLICIT;
 }
 
@@ -207,7 +207,7 @@ SoMultiTextureCoordinateElement::set3(SoState * const state,
                                       const SbVec3f * const coords)
 {
   if (state->isElementEnabled(SoGLVBOElement::getClassStackIndex())) {
-    SoGLVBOElement::setTexCoordVBO(state, unit, NULL);
+    SoGLVBOElement::setTexCoordVBO(state, unit, nullptr);
   }
   SoMultiTextureCoordinateElement * element =
     coin_assert_cast<SoMultiTextureCoordinateElement *>
@@ -221,9 +221,9 @@ SoMultiTextureCoordinateElement::set3(SoState * const state,
   ud.nodeid = node->getNodeId();
   ud.coordsDimension = 3;
   ud.numCoords = numCoords;
-  ud.coords2 = NULL;
+  ud.coords2 = nullptr;
   ud.coords3 = coords;
-  ud.coords4 = NULL;
+  ud.coords4 = nullptr;
   ud.whatKind = EXPLICIT;
 }
 
@@ -237,7 +237,7 @@ SoMultiTextureCoordinateElement::set4(SoState * const state,
                                       const SbVec4f * const coords)
 {
   if (state->isElementEnabled(SoGLVBOElement::getClassStackIndex())) {
-    SoGLVBOElement::setTexCoordVBO(state, unit, NULL);
+    SoGLVBOElement::setTexCoordVBO(state, unit, nullptr);
   }
   SoMultiTextureCoordinateElement * element =
     coin_assert_cast<SoMultiTextureCoordinateElement *>
@@ -251,8 +251,8 @@ SoMultiTextureCoordinateElement::set4(SoState * const state,
   ud.nodeid = node->getNodeId();
   ud.coordsDimension = 4;
   ud.numCoords = numCoords;
-  ud.coords2 = NULL;
-  ud.coords3 = NULL;
+  ud.coords2 = nullptr;
+  ud.coords3 = nullptr;
   ud.coords4 = coords;
   ud.whatKind = EXPLICIT;
 }
diff --git a/coin4/src/elements/SoMultiTextureEnabledElement.cpp b/coin4/src/elements/SoMultiTextureEnabledElement.cpp
index d249487..ddb17ed 100644
--- a/coin4/src/elements/SoMultiTextureEnabledElement.cpp
+++ b/coin4/src/elements/SoMultiTextureEnabledElement.cpp
@@ -175,7 +175,7 @@ SoMultiTextureEnabledElement::getEnabledUnits(SoState * state,
     return PRIVATE(elem)->enabled.getArrayPtr();
   }
   lastenabled = -1;
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -250,7 +250,7 @@ SoMultiTextureEnabledElement::getActiveUnits(SoState * state, int & lastenabled)
     lastenabled = i;
     return PRIVATE(elem)->mode.getArrayPtr();
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
diff --git a/coin4/src/elements/SoMultiTextureImageElement.cpp b/coin4/src/elements/SoMultiTextureImageElement.cpp
index 20be0d0..7690c34 100644
--- a/coin4/src/elements/SoMultiTextureImageElement.cpp
+++ b/coin4/src/elements/SoMultiTextureImageElement.cpp
@@ -310,7 +310,7 @@ SoMultiTextureImageElement::getDefault(SbVec2s & size, int & numComponents)
 {
   size.setValue(0,0);
   numComponents = 0;
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -322,7 +322,7 @@ SoMultiTextureImageElement::getDefault(SbVec3s & size, int & numComponents)
 {
   size.setValue(0,0,0);
   numComponents = 0;
-  return NULL;
+  return nullptr;
 }
 
 void
diff --git a/coin4/src/elements/SoNormalBindingElement.cpp b/coin4/src/elements/SoNormalBindingElement.cpp
index 114463f..0f206ff 100644
--- a/coin4/src/elements/SoNormalBindingElement.cpp
+++ b/coin4/src/elements/SoNormalBindingElement.cpp
@@ -87,7 +87,7 @@ SoNormalBindingElement::init(SoState * state)
 void
 SoNormalBindingElement::set(SoState * const state, const Binding binding)
 {
-  set(state, NULL, binding);
+  set(state, nullptr, binding);
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoNormalElement.cpp b/coin4/src/elements/SoNormalElement.cpp
index 834d13e..1c12dd6 100644
--- a/coin4/src/elements/SoNormalElement.cpp
+++ b/coin4/src/elements/SoNormalElement.cpp
@@ -75,7 +75,7 @@ SoNormalElement::set(SoState * const state,
                      const bool unitLength)
 {
   if (state->isElementEnabled(SoGLVBOElement::getClassStackIndex())) {
-    SoGLVBOElement::setNormalVBO(state, NULL);
+    SoGLVBOElement::setNormalVBO(state, nullptr);
   }
   SoNormalElement * elem = coin_safe_cast<SoNormalElement *>
     (
@@ -94,7 +94,7 @@ void
 SoNormalElement::init(SoState *state)
 {
   inherited::init(state);
-  this->normals = NULL;
+  this->normals = nullptr;
   this->numNormals = 0;
   this->unitLength = false;
 }
diff --git a/coin4/src/elements/SoPickStyleElement.cpp b/coin4/src/elements/SoPickStyleElement.cpp
index 092db7b..8112b5d 100644
--- a/coin4/src/elements/SoPickStyleElement.cpp
+++ b/coin4/src/elements/SoPickStyleElement.cpp
@@ -86,7 +86,7 @@ SoPickStyleElement::init(SoState * state)
 void
 SoPickStyleElement::set(SoState * const state, const Style style)
 {
-  set(state, NULL, style);
+  set(state, nullptr, style);
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoPointSizeElement.cpp b/coin4/src/elements/SoPointSizeElement.cpp
index 0235a73..cb4d476 100644
--- a/coin4/src/elements/SoPointSizeElement.cpp
+++ b/coin4/src/elements/SoPointSizeElement.cpp
@@ -81,7 +81,7 @@ SoPointSizeElement::set(SoState * const state, SoNode * const node,
 void
 SoPointSizeElement::set(SoState * const state, const float pointSize)
 {
-  SoPointSizeElement::set(state, NULL, pointSize);
+  SoPointSizeElement::set(state, nullptr, pointSize);
 }
 
 /*!
diff --git a/coin4/src/elements/SoProfileCoordinateElement.cpp b/coin4/src/elements/SoProfileCoordinateElement.cpp
index b10364a..79c09a6 100644
--- a/coin4/src/elements/SoProfileCoordinateElement.cpp
+++ b/coin4/src/elements/SoProfileCoordinateElement.cpp
@@ -38,7 +38,7 @@
 
 #include <Inventor/nodes/SoNode.h>
 
-SbVec2f * SoProfileCoordinateElement::initdefaultcoords = NULL;
+SbVec2f * SoProfileCoordinateElement::initdefaultcoords = nullptr;
 
 /*!
   \var SoProfileCoordinateElement::numCoords
@@ -97,7 +97,7 @@ SoProfileCoordinateElement::init(SoState * state)
   inherited::init(state);
   this->numCoords = 1;
   this->coords2 = SoProfileCoordinateElement::initdefaultcoords;
-  this->coords3 = NULL;
+  this->coords3 = nullptr;
   this->coordsAre2D = true;
 }
 
@@ -114,11 +114,11 @@ SoProfileCoordinateElement::set2(SoState * const state,
   assert(numCoords >= 0);
   SoProfileCoordinateElement * element =
     coin_safe_cast<SoProfileCoordinateElement *>
-    (getElement(state, classStackIndex, NULL));
+    (getElement(state, classStackIndex, nullptr));
   if (element) {
     element->numCoords = numCoords;
     element->coords2 = coords;
-    element->coords3 = NULL;
+    element->coords3 = nullptr;
     element->coordsAre2D = true;
     element->nodeId = node->getNodeId();
   }
@@ -136,10 +136,10 @@ SoProfileCoordinateElement::set3(SoState * const state,
   assert(numCoords >= 0);
   SoProfileCoordinateElement * element =
     coin_safe_cast<SoProfileCoordinateElement *>
-    (getElement(state, classStackIndex, NULL));
+    (getElement(state, classStackIndex, nullptr));
   if (element) {
     element->numCoords = numCoords;
-    element->coords2 = NULL;
+    element->coords2 = nullptr;
     element->coords3 = coords;
     element->coordsAre2D = false;
     element->nodeId = node->getNodeId();
diff --git a/coin4/src/elements/SoReplacedElement.cpp b/coin4/src/elements/SoReplacedElement.cpp
index f594488..c6c6027 100644
--- a/coin4/src/elements/SoReplacedElement.cpp
+++ b/coin4/src/elements/SoReplacedElement.cpp
@@ -137,7 +137,7 @@ SoReplacedElement::getElement(SoState * const state, const int stackIndex,
     else { elem->nodeId = 0; }
     return elem;
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
diff --git a/coin4/src/elements/SoShapeHintsElement.cpp b/coin4/src/elements/SoShapeHintsElement.cpp
index 543c815..2e34466 100644
--- a/coin4/src/elements/SoShapeHintsElement.cpp
+++ b/coin4/src/elements/SoShapeHintsElement.cpp
@@ -221,7 +221,7 @@ void SoShapeHintsElement::set(SoState * const state,
                               const ShapeType shapeType,
                               const FaceType faceType)
 {
-  set(state, NULL, vertexOrdering, shapeType, faceType);
+  set(state, nullptr, vertexOrdering, shapeType, faceType);
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoSwitchElement.cpp b/coin4/src/elements/SoSwitchElement.cpp
index 0b24640..9287bef 100644
--- a/coin4/src/elements/SoSwitchElement.cpp
+++ b/coin4/src/elements/SoSwitchElement.cpp
@@ -79,7 +79,7 @@ SoSwitchElement::init(SoState * state)
 void
 SoSwitchElement::set(SoState * const state, const int32_t index)
 {
-  set(state, NULL, index);
+  set(state, nullptr, index);
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoTextOutlineEnabledElement.cpp b/coin4/src/elements/SoTextOutlineEnabledElement.cpp
index 8524407..b3794ec 100644
--- a/coin4/src/elements/SoTextOutlineEnabledElement.cpp
+++ b/coin4/src/elements/SoTextOutlineEnabledElement.cpp
@@ -74,7 +74,7 @@ SoTextOutlineEnabledElement::set(SoState * const state,
 void
 SoTextOutlineEnabledElement::set(SoState * const state, const bool enabled)
 {
-  set(state, NULL, enabled);
+  set(state, nullptr, enabled);
 }
 
 /*!
diff --git a/coin4/src/elements/SoTextureCoordinateBindingElement.cpp b/coin4/src/elements/SoTextureCoordinateBindingElement.cpp
index 7ff9a83..5eae45f 100644
--- a/coin4/src/elements/SoTextureCoordinateBindingElement.cpp
+++ b/coin4/src/elements/SoTextureCoordinateBindingElement.cpp
@@ -88,7 +88,7 @@ void
 SoTextureCoordinateBindingElement::set(SoState * const state,
                                        const Binding binding)
 {
-  set(state, NULL, binding);
+  set(state, nullptr, binding);
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoTextureQualityElement.cpp b/coin4/src/elements/SoTextureQualityElement.cpp
index 9c00b35..7da8fd4 100644
--- a/coin4/src/elements/SoTextureQualityElement.cpp
+++ b/coin4/src/elements/SoTextureQualityElement.cpp
@@ -78,7 +78,7 @@ SoTextureQualityElement::set(SoState * const state, SoNode * const node,
 void
 SoTextureQualityElement::set(SoState * const state, const float quality)
 {
-  set(state, NULL, quality);
+  set(state, nullptr, quality);
 }
 
 /*!
diff --git a/coin4/src/elements/SoTextureScalePolicyElement.cpp b/coin4/src/elements/SoTextureScalePolicyElement.cpp
index 1efb1e8..ceb423e 100644
--- a/coin4/src/elements/SoTextureScalePolicyElement.cpp
+++ b/coin4/src/elements/SoTextureScalePolicyElement.cpp
@@ -83,7 +83,7 @@ SoTextureScalePolicyElement::init(SoState * state)
 void
 SoTextureScalePolicyElement::set(SoState * const state, const Policy policy)
 {
-  SoTextureScalePolicyElement::set(state, NULL, policy);
+  SoTextureScalePolicyElement::set(state, nullptr, policy);
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoUnitsElement.cpp b/coin4/src/elements/SoUnitsElement.cpp
index b7bf7c2..4e578d5 100644
--- a/coin4/src/elements/SoUnitsElement.cpp
+++ b/coin4/src/elements/SoUnitsElement.cpp
@@ -87,7 +87,7 @@ SoUnitsElement::init(SoState * state)
 void
 SoUnitsElement::set(SoState * const state, const Units units)
 {
-  set(state, NULL, units);
+  set(state, nullptr, units);
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoVertexAttributeBindingElement.cpp b/coin4/src/elements/SoVertexAttributeBindingElement.cpp
index 3b154e4..8d94947 100644
--- a/coin4/src/elements/SoVertexAttributeBindingElement.cpp
+++ b/coin4/src/elements/SoVertexAttributeBindingElement.cpp
@@ -89,7 +89,7 @@ SoVertexAttributeBindingElement::init(SoState * state)
 void
 SoVertexAttributeBindingElement::set(SoState * const state, const Binding binding)
 {
-  set(state, NULL, binding);
+  set(state, nullptr, binding);
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/elements/SoWindowElement.cpp b/coin4/src/elements/SoWindowElement.cpp
index af1ba6d..674b348 100644
--- a/coin4/src/elements/SoWindowElement.cpp
+++ b/coin4/src/elements/SoWindowElement.cpp
@@ -85,9 +85,9 @@ SoWindowElement::init(SoState * state)
 {
   inherited::init(state);
   this->window = 0;
-  this->context = NULL;
-  this->display = NULL;
-  this->glRenderAction = NULL;
+  this->context = nullptr;
+  this->display = nullptr;
+  this->glRenderAction = nullptr;
 }
 
 // doc in parent
@@ -118,7 +118,7 @@ SoElement *
 SoWindowElement::copyMatchInfo(void) const
 {
   assert(0 && "should never be called.");
-  return NULL;
+  return nullptr;
 }
 
 /*!
diff --git a/coin4/src/engines/SoCalculator.cpp b/coin4/src/engines/SoCalculator.cpp
index 84da718..7f9ac23 100644
--- a/coin4/src/engines/SoCalculator.cpp
+++ b/coin4/src/engines/SoCalculator.cpp
@@ -410,7 +410,7 @@ SoCalculator::evaluate(void)
         }
 #endif // COIN_DEBUG
       }
-      else PRIVATE(this)->evaluatorList.append(NULL);
+      else PRIVATE(this)->evaluatorList.append(nullptr);
     }
   }
 
@@ -556,7 +556,7 @@ SoCalculator::evaluateExpression(struct so_eval_node *node, const int fieldidx)
 void
 SoCalculator::findUsed(struct so_eval_node *node, char *inused, char *outused)
 {
-  if (node == NULL) return;
+  if (node == nullptr) return;
 
   if (node->id == ID_ASSIGN_FLT || node->id == ID_ASSIGN_VEC) {
     this->findUsed(node->child2, inused, outused); // traverse rhs
diff --git a/coin4/src/engines/SoComputeBoundingBox.cpp b/coin4/src/engines/SoComputeBoundingBox.cpp
index 046e3f4..97e44d5 100644
--- a/coin4/src/engines/SoComputeBoundingBox.cpp
+++ b/coin4/src/engines/SoComputeBoundingBox.cpp
@@ -50,13 +50,13 @@ SO_ENGINE_SOURCE(SoComputeBoundingBox);
   \var SoSFNode SoComputeBoundingBox::node
 
   If this input field is set and SoComputeBoundingBox::path is \c
-  NULL, the resultant bounding box will be the box encompassing the
+  nullptr, the resultant bounding box will be the box encompassing the
   scene graph rooted at this node pointer.
 */
 /*!
   \var SoSFPath SoComputeBoundingBox::path
 
-  If this input field is not \c NULL, the bounding box values of the
+  If this input field is not \c nullptr, the bounding box values of the
   given path will be set on the outputs.
 */
 /*!
@@ -88,8 +88,8 @@ SoComputeBoundingBox::SoComputeBoundingBox(void)
 {
   SO_ENGINE_INTERNAL_CONSTRUCTOR(SoComputeBoundingBox);
 
-  SO_ENGINE_ADD_INPUT(node,(NULL));
-  SO_ENGINE_ADD_INPUT(path,(NULL));
+  SO_ENGINE_ADD_INPUT(node,(nullptr));
+  SO_ENGINE_ADD_INPUT(path,(nullptr));
 
   SO_ENGINE_ADD_OUTPUT(min, SoSFVec3f);
   SO_ENGINE_ADD_OUTPUT(max, SoSFVec3f);
@@ -125,7 +125,7 @@ SoComputeBoundingBox::evaluate(void)
   if (!bboxpath && !bboxnode) {
     // Nothing to see, move along.. (we "un-dirty" the fields to avoid
     // them being re-evaluated again and again while the engine inputs
-    // are NULL).
+    // are nullptr).
     SO_ENGINE_OUTPUT(min, SoSFVec3f, setDirty(false));
     SO_ENGINE_OUTPUT(max, SoSFVec3f, setDirty(false));
     SO_ENGINE_OUTPUT(boxCenter, SoSFVec3f, setDirty(false));
diff --git a/coin4/src/engines/SoConcatenate.cpp b/coin4/src/engines/SoConcatenate.cpp
index 4345908..6e19a06 100644
--- a/coin4/src/engines/SoConcatenate.cpp
+++ b/coin4/src/engines/SoConcatenate.cpp
@@ -96,10 +96,10 @@ SO_INTERNAL_ENGINE_SOURCE_DYNAMIC_IO(SoConcatenate);
 // used from import code or copy code.
 SoConcatenate::SoConcatenate(void)
 {
-  this->dynamicinput = NULL;
-  this->dynamicoutput = NULL;
-  for (int i=0; i < SoConcatenate::NUMINPUTS; i++) this->input[i] = NULL;
-  this->output = NULL;
+  this->dynamicinput = nullptr;
+  this->dynamicoutput = nullptr;
+  for (int i=0; i < SoConcatenate::NUMINPUTS; i++) this->input[i] = nullptr;
+  this->output = nullptr;
 }
 
 static bool
@@ -115,10 +115,10 @@ SoConcatenate_valid_type(SoType t)
 */
 SoConcatenate::SoConcatenate(SoType type)
 {
-  this->dynamicinput = NULL;
-  this->dynamicoutput = NULL;
-  for (int i=0; i < SoConcatenate::NUMINPUTS; i++) this->input[i] = NULL;
-  this->output = NULL;
+  this->dynamicinput = nullptr;
+  this->dynamicoutput = nullptr;
+  for (int i=0; i < SoConcatenate::NUMINPUTS; i++) this->input[i] = nullptr;
+  this->output = nullptr;
 
 #if COIN_DEBUG
   if (!SoConcatenate_valid_type(type)) {
@@ -147,7 +147,7 @@ SoConcatenate::initClass(void)
 void
 SoConcatenate::initialize(const SoType inputfieldtype)
 {
-  assert(this->input[0] == NULL);
+  assert(this->input[0] == nullptr);
   assert(SoConcatenate_valid_type(inputfieldtype));
 
   SO_ENGINE_INTERNAL_CONSTRUCTOR(SoConcatenate);
@@ -256,7 +256,7 @@ SoConcatenate::copyContents(const SoFieldContainer * from,
 static void _fieldtype_##_transfer(SoMField * output, int outidx, SoMField * input) \
 { \
   _fieldtype_ * in = coin_assert_cast<_fieldtype_ *>(input); \
-  assert(in != NULL); \
+  assert(in != nullptr); \
   coin_assert_cast<_fieldtype_ *>(output)->setValues(outidx, in->getNum(), in->getValues(0)); \
 }
 
diff --git a/coin4/src/engines/SoConvertAll.cpp b/coin4/src/engines/SoConvertAll.cpp
index 9630517..5c3c779 100644
--- a/coin4/src/engines/SoConvertAll.cpp
+++ b/coin4/src/engines/SoConvertAll.cpp
@@ -57,7 +57,7 @@
 typedef void convert_func(SoField * from, SoField * to);
 typedef SbHash<uint32_t, convert_func *> UInt32ToConverterFuncMap;
 
-static UInt32ToConverterFuncMap * convertfunc_dict = NULL;
+static UInt32ToConverterFuncMap * convertfunc_dict = nullptr;
 
 // *************************************************************************
 
@@ -69,8 +69,8 @@ static UInt32ToConverterFuncMap * convertfunc_dict = NULL;
 
 PRIVATE_ENGINE_TYPESYSTEM_SOURCE(SoConvertAll);
 unsigned int SoConvertAll::classinstances = 0;
-const SoFieldData ** SoConvertAll::parentinputdata = NULL;
-const SoEngineOutputData ** SoConvertAll::parentoutputdata = NULL;
+const SoFieldData ** SoConvertAll::parentinputdata = nullptr;
+const SoEngineOutputData ** SoConvertAll::parentoutputdata = nullptr;
 
 const SoFieldData *
 SoConvertAll::getFieldData(void) const
@@ -89,14 +89,14 @@ SoConvertAll::getOutputData(void) const
 // convenience.
 SoFieldData * SoConvertAll::inputdata = reinterpret_cast<SoFieldData *>(0x1);
 SoEngineOutputData * SoConvertAll::outputdata = reinterpret_cast<SoEngineOutputData *>(0x1);
-const SoFieldData ** SoConvertAll::getInputDataPtr(void) { return NULL; }
-const SoEngineOutputData ** SoConvertAll::getOutputDataPtr(void) { return NULL; }
+const SoFieldData ** SoConvertAll::getInputDataPtr(void) { return nullptr; }
+const SoEngineOutputData ** SoConvertAll::getOutputDataPtr(void) { return nullptr; }
 
 void
 SoConvertAll::atexit_cleanup(void)
 {
-  SoConvertAll::parentinputdata = NULL;
-  SoConvertAll::parentoutputdata = NULL;
+  SoConvertAll::parentinputdata = nullptr;
+  SoConvertAll::parentoutputdata = nullptr;
   SoConvertAll::classTypeId STATIC_SOTYPE_INIT;
   SoConvertAll::classinstances = 0;
 }
@@ -663,7 +663,7 @@ extern "C" {
 static void convertall_cleanup_dict(void)
 {
   delete convertfunc_dict;
-  convertfunc_dict = NULL;
+  convertfunc_dict = nullptr;
 }
 
 } // extern "C"
@@ -1111,11 +1111,11 @@ SoConvertAll::SoConvertAll(const SoType from, const SoType to)
 
     this->inputdata_instance =
       new SoFieldData(SoConvertAll::parentinputdata ?
-                      *SoConvertAll::parentinputdata : NULL);
+                      *SoConvertAll::parentinputdata : nullptr);
 
     this->outputdata_instance =
       new SoEngineOutputData(SoConvertAll::parentoutputdata ?
-                             *SoConvertAll::parentoutputdata : NULL);
+                             *SoConvertAll::parentoutputdata : nullptr);
 
     /* SoConvertAll is not considered native (doesn't really matter
        one way or the other). */
@@ -1196,7 +1196,7 @@ SoConvertAll::evaluate(void)
         // to behave properly on enum fields (the this->input instance
         // doesn't contain the name<->value mappings in the case that
         // the master field is of type So[SM]FEnum or So[SM]FBitMask).
-        SoField * masterfield = NULL;
+        SoField * masterfield = nullptr;
         if (this->input->getConnectedField(masterfield))
           this->convertvalue(masterfield, f);
         // Couldn't get master field, this means we are connected to
diff --git a/coin4/src/engines/SoElapsedTime.cpp b/coin4/src/engines/SoElapsedTime.cpp
index 7972dbd..04d2844 100644
--- a/coin4/src/engines/SoElapsedTime.cpp
+++ b/coin4/src/engines/SoElapsedTime.cpp
@@ -209,7 +209,7 @@ SoElapsedTime::writeInstance(SoOutput * out)
   // pass on the updates.
 
   // Disconnect from realTime field.
-  SoField * connectfield = NULL;
+  SoField * connectfield = nullptr;
   bool connectfromrealTime =
     this->timeIn.getConnectedField(connectfield) &&
     connectfield == SoDB::getGlobalField("realTime");
diff --git a/coin4/src/engines/SoEngine.cpp b/coin4/src/engines/SoEngine.cpp
index 80dc8ce..20aa0dd 100644
--- a/coin4/src/engines/SoEngine.cpp
+++ b/coin4/src/engines/SoEngine.cpp
@@ -213,7 +213,7 @@ int
 SoEngine::getOutputs(SoEngineOutputList & l) const
 {
   const SoEngineOutputData * outputs = this->getOutputData();
-  if (outputs == NULL) return 0;
+  if (outputs == nullptr) return 0;
 
   int n = outputs->getNumOutputs();
   for (int i = 0; i < n; i++) {
@@ -223,20 +223,20 @@ SoEngine::getOutputs(SoEngineOutputList & l) const
 }
 
 /*!
-  Returns the output with name \a outputname, or \c NULL if no such
+  Returns the output with name \a outputname, or \c nullptr if no such
   output exists.
 */
 SoEngineOutput *
 SoEngine::getOutput(const SbName & outputname) const
 {
   const SoEngineOutputData * outputs = this->getOutputData();
-  if (outputs == NULL) return NULL;
+  if (outputs == nullptr) return nullptr;
   int n = outputs->getNumOutputs();
   for (int i = 0; i < n; i++) {
     if (outputs->getOutputName(i) == outputname)
       return outputs->getOutput(this, i);
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -248,7 +248,7 @@ SoEngine::getOutputName(const SoEngineOutput * output,
                         SbName & outputname) const
 {
   const SoEngineOutputData * outputs = this->getOutputData();
-  if (outputs == NULL) return false;
+  if (outputs == nullptr) return false;
 
   int n = outputs->getNumOutputs();
   for (int i = 0; i < n; i++) {
@@ -261,7 +261,7 @@ SoEngine::getOutputName(const SoEngineOutput * output,
 }
 
 /*!
-  Returns the engine named \a name, or \c NULL if no such engine
+  Returns the engine named \a name, or \c nullptr if no such engine
   exists.  If several engines have been registered under the same
   name, returns the \e last one which was registered.
 */
@@ -349,7 +349,7 @@ SoEngine::evaluateWrapper(void)
   // For the engines which dynamically allocates input fields and
   // outputs [*], they can be destructed before there's any
   // SoEngineOutputData set up -- for instance upon an error on
-  // import. So we need to check for a NULL value here.
+  // import. So we need to check for a nullptr value here.
   //
   // [*] (So far, that is: SoGate, SoConcatenate, SoSelectOne,
   //     SoConvertAll.)
@@ -376,7 +376,7 @@ SoEngine::evaluateWrapper(void)
 const SoFieldData **
 SoEngine::getInputDataPtr(void)
 {
-  return NULL; // base class has no output
+  return nullptr; // base class has no output
 }
 
 /*!
@@ -386,7 +386,7 @@ SoEngine::getInputDataPtr(void)
 const SoEngineOutputData **
 SoEngine::getOutputDataPtr(void)
 {
-  return NULL; // base class has no input
+  return nullptr; // base class has no input
 }
 
 // Documented in superclass.
diff --git a/coin4/src/engines/SoEngineOutput.cpp b/coin4/src/engines/SoEngineOutput.cpp
index c908399..bdcacaf 100644
--- a/coin4/src/engines/SoEngineOutput.cpp
+++ b/coin4/src/engines/SoEngineOutput.cpp
@@ -56,7 +56,7 @@
 SoEngineOutput::SoEngineOutput(void)
 {
   this->enabled = true;
-  this->container = NULL;
+  this->container = nullptr;
 }
 
 /*!
@@ -90,7 +90,7 @@ SoEngineOutput::~SoEngineOutput()
 SoType
 SoEngineOutput::getConnectionType(void) const
 {
-  assert(this->container != NULL);
+  assert(this->container != nullptr);
   const SoEngineOutputData * outputs =
     this->isNodeEngineOutput() ?
     this->getNodeContainer()->getOutputData() :
@@ -139,7 +139,7 @@ void
 SoEngineOutput::enable(const bool flag)
 {
   this->enabled = flag;
-  if (flag) this->touchSlaves(NULL, false);
+  if (flag) this->touchSlaves(nullptr, false);
 }
 
 /*!
@@ -155,7 +155,7 @@ SoEngineOutput::isEnabled(void) const
 
 /*!
   Returns the engine containing this output. If the engine
-  containing this output is a NodeEngine, this method returns NULL.
+  containing this output is a NodeEngine, this method returns nullptr.
 
   \sa setContainer(), getNodeContainer()
 */
@@ -167,7 +167,7 @@ SoEngineOutput::getContainer(void) const
     SoDebugError::postWarning("SoEngineOutput::getContainer",
                               "Container is not an Engine");
 #endif // COIN_DEBUG
-    return NULL;
+    return nullptr;
   }
   return this->container;
 }
@@ -175,7 +175,7 @@ SoEngineOutput::getContainer(void) const
 /*!
 
   Returns the node engine containing this output. If the engine
-  containing this output is not a NodeEgine, this method returns NULL.
+  containing this output is not a NodeEgine, this method returns nullptr.
 
   \COIN_FUNCTION_EXTENSION
 
@@ -191,7 +191,7 @@ SoEngineOutput::getNodeContainer(void) const
     SoDebugError::postWarning("SoEngineOutput::getContainer",
                               "Container is not a NodeEngine");
 #endif // COIN_DEBUG
-    return NULL;
+    return nullptr;
   }
   return coin_assert_cast<SoNodeEngine*>(this->container);
 }
diff --git a/coin4/src/engines/SoFieldConverter.cpp b/coin4/src/engines/SoFieldConverter.cpp
index 715f063..072b5ba 100644
--- a/coin4/src/engines/SoFieldConverter.cpp
+++ b/coin4/src/engines/SoFieldConverter.cpp
@@ -121,7 +121,7 @@ SoField *
 SoFieldConverter::getConnectedInput(void)
 {
   COIN_OBSOLETED();
-  return NULL;
+  return nullptr;
 }
 
 /*!
diff --git a/coin4/src/engines/SoGate.cpp b/coin4/src/engines/SoGate.cpp
index ebc0df5..8036082 100644
--- a/coin4/src/engines/SoGate.cpp
+++ b/coin4/src/engines/SoGate.cpp
@@ -106,10 +106,10 @@ SO_INTERNAL_ENGINE_SOURCE_DYNAMIC_IO(SoGate);
 // used from import code or copy code.
 SoGate::SoGate(void)
 {
-  this->dynamicinput = NULL;
-  this->dynamicoutput = NULL;
-  this->input = NULL;
-  this->output = NULL;
+  this->dynamicinput = nullptr;
+  this->dynamicoutput = nullptr;
+  this->input = nullptr;
+  this->output = nullptr;
 }
 
 static bool
@@ -124,10 +124,10 @@ SoGate_valid_type(SoType t)
 */
 SoGate::SoGate(SoType type)
 {
-  this->dynamicinput = NULL;
-  this->dynamicoutput = NULL;
-  this->input = NULL;
-  this->output = NULL;
+  this->dynamicinput = nullptr;
+  this->dynamicoutput = nullptr;
+  this->input = nullptr;
+  this->output = nullptr;
 
 #if COIN_DEBUG
   if (!SoGate_valid_type(type)) {
@@ -156,7 +156,7 @@ SoGate::initClass(void)
 void
 SoGate::initialize(const SoType inputfieldtype)
 {
-  assert(this->input == NULL);
+  assert(this->input == nullptr);
   assert(SoGate_valid_type(inputfieldtype));
 
   SO_ENGINE_INTERNAL_CONSTRUCTOR(SoGate);
diff --git a/coin4/src/engines/SoInterpolate.cpp b/coin4/src/engines/SoInterpolate.cpp
index dc46150..6ec23de 100644
--- a/coin4/src/engines/SoInterpolate.cpp
+++ b/coin4/src/engines/SoInterpolate.cpp
@@ -78,10 +78,10 @@ SoInterpolate::SoInterpolate(void)
     // FIXME: is this really necessary for SoInterpolate? 20000505 mortene.
     SoInterpolate::inputdata =
       new SoFieldData(SoInterpolate::parentinputdata ?
-                      *SoInterpolate::parentinputdata : NULL);
+                      *SoInterpolate::parentinputdata : nullptr);
     SoInterpolate::outputdata =
       new SoEngineOutputData(SoInterpolate::parentoutputdata ?
-                             *SoInterpolate::parentoutputdata : NULL);
+                             *SoInterpolate::parentoutputdata : nullptr);
   }
 
   SO_ENGINE_ADD_INPUT(alpha, (0.0f));
@@ -111,6 +111,6 @@ SoInterpolate::~SoInterpolate()
 #if COIN_DEBUG && 0 // debug
   SoDebugError::postInfo("SoInterpolate::~SoInterpolate", "%p", this);
 #endif // debug
-  delete this->inputdata; this->inputdata = NULL;
-  delete this->outputdata; this->outputdata = NULL;
+  delete this->inputdata; this->inputdata = nullptr;
+  delete this->outputdata; this->outputdata = nullptr;
 }
diff --git a/coin4/src/engines/SoNodeEngine.cpp b/coin4/src/engines/SoNodeEngine.cpp
index 853eb32..df1f7eb 100644
--- a/coin4/src/engines/SoNodeEngine.cpp
+++ b/coin4/src/engines/SoNodeEngine.cpp
@@ -150,7 +150,7 @@ int
 SoNodeEngine::getOutputs(SoEngineOutputList & l) const
 {
   const SoEngineOutputData * outputs = this->getOutputData();
-  if (outputs == NULL) return 0;
+  if (outputs == nullptr) return 0;
 
   int n = outputs->getNumOutputs();
   for (int i = 0; i < n; i++) {
@@ -160,20 +160,20 @@ SoNodeEngine::getOutputs(SoEngineOutputList & l) const
 }
 
 /*!
-  Returns the output with name \a outputname, or \c NULL if no such
+  Returns the output with name \a outputname, or \c nullptr if no such
   output exists.
 */
 SoEngineOutput *
 SoNodeEngine::getOutput(const SbName & outputname) const
 {
   const SoEngineOutputData * outputs = this->getOutputData();
-  if (outputs == NULL) return NULL;
+  if (outputs == nullptr) return nullptr;
   int n = outputs->getNumOutputs();
   for (int i = 0; i < n; i++) {
     if (outputs->getOutputName(i) == outputname)
       return outputs->getOutput(this, i);
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -185,7 +185,7 @@ SoNodeEngine::getOutputName(const SoEngineOutput * output,
                         SbName & outputname) const
 {
   const SoEngineOutputData * outputs = this->getOutputData();
-  if (outputs == NULL) return false;
+  if (outputs == nullptr) return false;
 
   int n = outputs->getNumOutputs();
   for (int i = 0; i < n; i++) {
@@ -274,7 +274,7 @@ SoNodeEngine::evaluateWrapper(void)
 const SoFieldData **
 SoNodeEngine::getFieldDataPtr(void)
 {
-  return NULL; // base class has no input
+  return nullptr; // base class has no input
 }
 
 /*!
@@ -284,7 +284,7 @@ SoNodeEngine::getFieldDataPtr(void)
 const SoEngineOutputData **
 SoNodeEngine::getOutputDataPtr(void)
 {
-  return NULL; // base class has no output
+  return nullptr; // base class has no output
 }
 
 // Documented in superclass.
diff --git a/coin4/src/engines/SoOneShot.cpp b/coin4/src/engines/SoOneShot.cpp
index 8867ce3..da56dfc 100644
--- a/coin4/src/engines/SoOneShot.cpp
+++ b/coin4/src/engines/SoOneShot.cpp
@@ -235,7 +235,7 @@ SoOneShot::writeInstance(SoOutput * out)
   // to pass on the updates.
 
   // Disconnect from realTime field.
-  SoField * connectfield = NULL;
+  SoField * connectfield = nullptr;
   bool connectfromrealTime =
     this->timeIn.getConnectedField(connectfield) &&
     connectfield == SoDB::getGlobalField("realTime");
diff --git a/coin4/src/engines/SoSelectOne.cpp b/coin4/src/engines/SoSelectOne.cpp
index 9b41d1b..689b069 100644
--- a/coin4/src/engines/SoSelectOne.cpp
+++ b/coin4/src/engines/SoSelectOne.cpp
@@ -113,10 +113,10 @@ SoSelectOne_valid_type(SoType t)
 */
 SoSelectOne::SoSelectOne(SoType inputtype)
 {
-  this->dynamicinput = NULL;
-  this->dynamicoutput = NULL;
-  this->input = NULL;
-  this->output = NULL;
+  this->dynamicinput = nullptr;
+  this->dynamicoutput = nullptr;
+  this->input = nullptr;
+  this->output = nullptr;
 
 #if COIN_DEBUG
   if (!SoSelectOne_valid_type(inputtype)) {
@@ -135,10 +135,10 @@ SoSelectOne::SoSelectOne(SoType inputtype)
 // used from import code or copy code.
 SoSelectOne::SoSelectOne(void)
 {
-  this->dynamicinput = NULL;
-  this->dynamicoutput = NULL;
-  this->input = NULL;
-  this->output = NULL;
+  this->dynamicinput = nullptr;
+  this->dynamicoutput = nullptr;
+  this->input = nullptr;
+  this->output = nullptr;
 }
 
 // Set up the input and output fields of the engine. This is done from
@@ -147,7 +147,7 @@ SoSelectOne::SoSelectOne(void)
 void
 SoSelectOne::initialize(const SoType inputfieldtype)
 {
-  assert(this->input == NULL);
+  assert(this->input == nullptr);
   assert(SoSelectOne_valid_type(inputfieldtype));
 
   SO_ENGINE_INTERNAL_CONSTRUCTOR(SoSelectOne);
@@ -164,7 +164,7 @@ SoSelectOne::initialize(const SoType inputfieldtype)
   // Built-in fields always start with the "MF", but we try to handle
   // user-defined fields aswell.
   const char * ptr = strstr(multiname.getString(), "MF");
-  assert(ptr != NULL && "invalid input field type");
+  assert(ptr != nullptr && "invalid input field type");
   const ptrdiff_t offset = ptr - multiname.getString();
   SbString singlename = (offset == 0) ? SbString("") : multiname.getSubString(0, int(offset - 1));
   singlename += 'S';
diff --git a/coin4/src/engines/SoSubEngineP.h b/coin4/src/engines/SoSubEngineP.h
index 3432b7b..303aa73 100644
--- a/coin4/src/engines/SoSubEngineP.h
+++ b/coin4/src/engines/SoSubEngineP.h
@@ -63,7 +63,7 @@
 #define SO_ENGINE_INTERNAL_INIT_ABSTRACT_CLASS(_class_) \
   do { \
     const char * classname = SO__QUOTE(_class_); \
-    PRIVATE_COMMON_ENGINE_INIT_CODE(_class_, &classname[2], NULL, inherited); \
+    PRIVATE_COMMON_ENGINE_INIT_CODE(_class_, &classname[2], nullptr, inherited); \
   } while (0)
 
 
@@ -93,15 +93,15 @@ PRIVATE_SO_INTERPOLATE_EVALUATE(_class_, _type_, _valtype_, _interpexp_)
 #define SO_INTERNAL_ENGINE_SOURCE_DYNAMIC_IO(_class_) \
 PRIVATE_ENGINE_TYPESYSTEM_SOURCE(_class_); \
 unsigned int _class_::classinstances = 0; \
-SoFieldData * _class_::inputdata = NULL; \
-const SoFieldData ** _class_::parentinputdata = NULL; \
-SoEngineOutputData * _class_::outputdata = NULL; \
-const SoEngineOutputData ** _class_::parentoutputdata = NULL; \
+SoFieldData * _class_::inputdata = nullptr; \
+const SoFieldData ** _class_::parentinputdata = nullptr; \
+SoEngineOutputData * _class_::outputdata = nullptr; \
+const SoEngineOutputData ** _class_::parentoutputdata = nullptr; \
  \
 const SoFieldData ** _class_::getInputDataPtr(void) \
 { \
   assert(0 && "function not in use for _class_"); \
-  return NULL; \
+  return nullptr; \
 } \
  \
 const SoFieldData * _class_::getFieldData(void) const \
@@ -112,7 +112,7 @@ const SoFieldData * _class_::getFieldData(void) const \
 const SoEngineOutputData ** _class_::getOutputDataPtr(void) \
 { \
   assert(0 && "function not in use for _class_"); \
-  return NULL; \
+  return nullptr; \
 } \
  \
 const SoEngineOutputData * _class_::getOutputData(void) const \
@@ -130,10 +130,10 @@ _class_::atexit_cleanup(void) \
 { \
   delete _class_::inputdata; \
   delete _class_::outputdata; \
-  _class_::inputdata = NULL; \
-  _class_::outputdata = NULL; \
-  _class_::parentinputdata = NULL; \
-  _class_::parentoutputdata = NULL; \
+  _class_::inputdata = nullptr; \
+  _class_::outputdata = nullptr; \
+  _class_::parentinputdata = nullptr; \
+  _class_::parentoutputdata = nullptr; \
   _class_::classTypeId STATIC_SOTYPE_INIT; \
   _class_::classinstances = 0; \
 }
diff --git a/coin4/src/engines/SoSubNodeEngineP.h b/coin4/src/engines/SoSubNodeEngineP.h
index 36f6d0d..8d1ec4c 100644
--- a/coin4/src/engines/SoSubNodeEngineP.h
+++ b/coin4/src/engines/SoSubNodeEngineP.h
@@ -72,7 +72,7 @@
 #define SO_NODEENGINE_INTERNAL_INIT_ABSTRACT_CLASS(_class_) \
   do { \
     const char * classname = SO__QUOTE(_class_); \
-    PRIVATE_COMMON_NODEENGINE_INIT_CODE(_class_, &classname[2], NULL, inherited); \
+    PRIVATE_COMMON_NODEENGINE_INIT_CODE(_class_, &classname[2], nullptr, inherited); \
     SoNode::setCompatibilityTypes(_class_::getClassTypeId(), SO_VRML97_NODE_TYPE); \
     coin_atexit((coin_atexit_f*)_class_::atexit_cleanupnodeengine, CC_ATEXIT_NORMAL); \
     coin_atexit((coin_atexit_f*)_class_::atexit_cleanup, CC_ATEXIT_NORMAL); \
diff --git a/coin4/src/engines/SoTexture2Convert.cpp b/coin4/src/engines/SoTexture2Convert.cpp
index a4eea3b..963d3c7 100644
--- a/coin4/src/engines/SoTexture2Convert.cpp
+++ b/coin4/src/engines/SoTexture2Convert.cpp
@@ -45,7 +45,7 @@ SoTexture2Convert::SoTexture2Convert(void)
 {
   SO_ENGINE_INTERNAL_CONSTRUCTOR(SoTexture2Convert);
 
-  SO_ENGINE_ADD_INPUT(sourceImage, (SbVec2s(0,0), 1, NULL));
+  SO_ENGINE_ADD_INPUT(sourceImage, (SbVec2s(0,0), 1, nullptr));
 
   SO_ENGINE_ADD_OUTPUT(image, SoSFImage);
 }
diff --git a/coin4/src/engines/SoTimeCounter.cpp b/coin4/src/engines/SoTimeCounter.cpp
index f69e0c0..302ff71 100644
--- a/coin4/src/engines/SoTimeCounter.cpp
+++ b/coin4/src/engines/SoTimeCounter.cpp
@@ -176,7 +176,7 @@ SoTimeCounter::writeInstance(SoOutput * out)
   // pass on the updates.
 
   // Disconnect from realTime field.
-  SoField * connectfield = NULL;
+  SoField * connectfield = nullptr;
   bool connectfromrealTime =
     this->timeIn.getConnectedField(connectfield) &&
     connectfield == SoDB::getGlobalField("realTime");
diff --git a/coin4/src/engines/evaluator.h b/coin4/src/engines/evaluator.h
index 8f40b50..02b7cbd 100644
--- a/coin4/src/engines/evaluator.h
+++ b/coin4/src/engines/evaluator.h
@@ -41,7 +41,7 @@
  * think this is better than parsing the expression every time.
  *
  * Call so_eval_parse() to build the tree structure. This method
- * returns NULL if an error occured. The actual error message
+ * returns nullptr if an error occured. The actual error message
  * can be found by using so_eval_error().
  *
  * Call so_eval_evaluate() to evaluate the expression. You should
@@ -86,7 +86,7 @@ extern "C" {
   /* evaluates the tree structure */
   void so_eval_evaluate(so_eval_node *node, const so_eval_cbdata *cbdata);
 
-  /* returns current error message, or NULL if none.
+  /* returns current error message, or nullptr if none.
      check this after calling so_eval_parse() */
   char * so_eval_error(void); /* defined in epsilon.y */
 
diff --git a/coin4/src/engines/evaluator.y b/coin4/src/engines/evaluator.y
index b8e2e31..744112d 100644
--- a/coin4/src/engines/evaluator.y
+++ b/coin4/src/engines/evaluator.y
@@ -107,7 +107,7 @@ expression    : expression ';' subexpression
               | subexpression { root_node = $1; $$ = $1; }
               ;
 
-subexpression : { $$ = NULL }
+subexpression : { $$ = nullptr }
               | fltlhs '=' fltstatement { $$ = so_eval_create_binary(ID_ASSIGN_FLT, $1, $3); }
               | veclhs '=' vecstatement { $$ = so_eval_create_binary(ID_ASSIGN_VEC, $1, $3); }
               ;
@@ -242,17 +242,17 @@ so_eval_parse(const char *buffer)
 {
   /* FIXME: better error handling is obviously needed */
   YY_BUFFER_STATE state;
-  myerrorptr = NULL;
-  root_node = NULL;
+  myerrorptr = nullptr;
+  root_node = nullptr;
   state = so_eval_scan_string(buffer); /* flex routine */
   so_evalparse(); /* start parsing */
   so_eval_delete_buffer(state); /* flex routine */
-  if (myerrorptr) return NULL;
+  if (myerrorptr) return nullptr;
   return root_node;
 }
 
 /*
- * Returns current error message or NULL if none.
+ * Returns current error message or nullptr if none.
  *
  * Note: don't "const" the return type, as that will trigger a bug in
  * Microsoft Visual C++ v6.0. 20000606 mortene.
@@ -273,6 +273,6 @@ so_evalerror(char *myerr)
   myerrorbuf[511] = 0; /* just in case string was too long */
   myerrorptr = myerrorbuf; /* signal error */
   so_eval_delete(root_node); /* free memory used */
-  root_node = NULL;
+  root_node = nullptr;
   return 0;
 }
diff --git a/coin4/src/errors/SoDebugError.cpp b/coin4/src/errors/SoDebugError.cpp
index bdbd2fc..b618df5 100644
--- a/coin4/src/errors/SoDebugError.cpp
+++ b/coin4/src/errors/SoDebugError.cpp
@@ -119,7 +119,7 @@ using std::memcpy;
 
 SoType SoDebugError::classTypeId STATIC_SOTYPE_INIT;
 SoErrorCB * SoDebugError::callback = SoError::defaultHandlerCB;
-void * SoDebugError::callbackData = NULL;
+void * SoDebugError::callbackData = nullptr;
 
 // *************************************************************************
 
@@ -127,7 +127,7 @@ void * SoDebugError::callbackData = NULL;
 
 // variables for run-time breakpoints
 static int num_breakpoints = 0;
-static char ** breakpoints = NULL;
+static char ** breakpoints = nullptr;
 
 extern "C" {
 
@@ -138,7 +138,7 @@ debug_break_cleanup(void)
     delete[] breakpoints[i];
   }
   delete[] breakpoints;
-  breakpoints = NULL;
+  breakpoints = nullptr;
   num_breakpoints = 0;
 }
 
@@ -158,7 +158,7 @@ void
 SoDebugError::initClass(void)
 {
   SoDebugError::callback = SoError::defaultHandlerCB;
-  SoDebugError::callbackData = NULL;
+  SoDebugError::callbackData = nullptr;
   SoDebugError::classTypeId =
     SoType::createType(SoError::getClassTypeId(), "DebugError");
 
@@ -182,8 +182,8 @@ SoDebugError::initClass(void)
     ptr = cpy;
     const char * end = strchr(ptr, ' ');
     const char * tst = strchr(ptr, ',');
-    if (end == NULL || (tst && tst < end)) end = tst;
-    if (end == NULL) end = strchr(ptr, '\0');
+    if (end == nullptr || (tst && tst < end)) end = tst;
+    if (end == nullptr) end = strchr(ptr, '\0');
     int i = 0;
     while (end && i < num_breakpoints) {
       const ptrdiff_t len = end - ptr;
@@ -195,8 +195,8 @@ SoDebugError::initClass(void)
       if (ptr < (cpy + envstrlen)) {
         end = strchr(ptr, ' ');
         tst = strchr(ptr, ',');
-        if (end == NULL || (tst && tst < end)) end = tst;
-        if (end == NULL) end = strchr(ptr, 0);
+        if (end == nullptr || (tst && tst < end)) end = tst;
+        if (end == nullptr) end = strchr(ptr, 0);
       }
     }
     num_breakpoints = i; // just in case parsing failed for some reason
@@ -232,7 +232,7 @@ SoDebugError::callbackForwarder(const struct cc_debugerror * error,
   const char * dbgstrc = cc_string_get_text(dbgstr);
   wrappederr.setDebugString(dbgstrc);
 
-  assert(SoDebugError::callback != NULL);
+  assert(SoDebugError::callback != nullptr);
   SoDebugError::callback(&wrappederr, SoDebugError::callbackData);
 }
 
@@ -246,7 +246,7 @@ SoDebugError::setHandlerCallback(SoErrorCB * const function, void * const data)
     // an cc_debugerror and forwards control to the callback function
     // given as an argument to setHandlerCallback().
     cc_debugerror_set_handler_callback(
-       reinterpret_cast<cc_debugerror_cb *>(SoDebugError::callbackForwarder), NULL);
+       reinterpret_cast<cc_debugerror_cb *>(SoDebugError::callbackForwarder), nullptr);
   }
 
   SoDebugError::callback = function;
diff --git a/coin4/src/errors/SoError.cpp b/coin4/src/errors/SoError.cpp
index 74f2d3a..412b66c 100644
--- a/coin4/src/errors/SoError.cpp
+++ b/coin4/src/errors/SoError.cpp
@@ -64,8 +64,8 @@
 // *************************************************************************
 
 SoType SoError::classTypeId STATIC_SOTYPE_INIT;
-SoErrorCB * SoError::callback = NULL; // make use of default cc_error handler
-void * SoError::callbackData = NULL;
+SoErrorCB * SoError::callback = nullptr; // make use of default cc_error handler
+void * SoError::callbackData = nullptr;
 
 // *************************************************************************
 
@@ -81,7 +81,7 @@ SoError::callbackForwarder(const cc_error * error, void * COIN_UNUSED_ARG(data))
 {
   SoError wrappederr(error);
 
-  assert(SoError::callback != NULL);
+  assert(SoError::callback != nullptr);
   (*SoError::callback)(&wrappederr, SoError::callbackData);
 }
 
@@ -100,7 +100,7 @@ void
 SoError::initClass(void)
 {
   SoError::callback = defaultHandlerCB;
-  SoError::callbackData = NULL;
+  SoError::callbackData = nullptr;
   SoError::classTypeId =
     SoType::createType(SoType::badType(), SbName("Error"));
 }
@@ -166,14 +166,14 @@ void
 SoError::setHandlerCallback(SoErrorCB * const function, void * const data)
 {
   if (SoError::callback == SoError::defaultHandlerCB ||
-      SoError::callback == NULL) {
+      SoError::callback == nullptr) {
     // The user is overriding the default handler, so set up a
     // "converter" callback function that makes an SoError out of an
     // cc_error and forwards control to the callback function given as
     // an argument to setHandlerCallback().
     cc_error_set_handler_callback(
        reinterpret_cast<cc_error_cb *>(SoError::callbackForwarder),
-       NULL);
+       nullptr);
   }
 
   SoError::callback = function;
diff --git a/coin4/src/errors/SoMemoryError.cpp b/coin4/src/errors/SoMemoryError.cpp
index 0c653c8..0482855 100644
--- a/coin4/src/errors/SoMemoryError.cpp
+++ b/coin4/src/errors/SoMemoryError.cpp
@@ -68,7 +68,7 @@
 
 SoType SoMemoryError::classTypeId STATIC_SOTYPE_INIT;
 SoErrorCB * SoMemoryError::callback = SoError::defaultHandlerCB;
-void * SoMemoryError::callbackData = NULL;
+void * SoMemoryError::callbackData = nullptr;
 
 // *************************************************************************
 
@@ -77,7 +77,7 @@ void
 SoMemoryError::initClass(void)
 {
   SoMemoryError::callback = SoError::defaultHandlerCB;
-  SoMemoryError::callbackData = NULL;
+  SoMemoryError::callbackData = nullptr;
   SoMemoryError::classTypeId =
     SoType::createType(SoError::getClassTypeId(), "MemoryError");
 }
diff --git a/coin4/src/errors/SoReadError.cpp b/coin4/src/errors/SoReadError.cpp
index f11e9fe..5787e64 100644
--- a/coin4/src/errors/SoReadError.cpp
+++ b/coin4/src/errors/SoReadError.cpp
@@ -49,7 +49,7 @@
 
 SoType SoReadError::classTypeId STATIC_SOTYPE_INIT;
 SoErrorCB * SoReadError::callback = SoError::defaultHandlerCB;
-void * SoReadError::callbackData = NULL;
+void * SoReadError::callbackData = nullptr;
 
 // *************************************************************************
 
@@ -58,7 +58,7 @@ void
 SoReadError::initClass(void)
 {
   SoReadError::callback = SoError::defaultHandlerCB;
-  SoReadError::callbackData = NULL;
+  SoReadError::callbackData = nullptr;
   SoReadError::classTypeId =
     SoType::createType(SoError::getClassTypeId(), "ReadError");
 }
diff --git a/coin4/src/errors/debugerror.cpp b/coin4/src/errors/debugerror.cpp
index 2e61aca..522a74e 100644
--- a/coin4/src/errors/debugerror.cpp
+++ b/coin4/src/errors/debugerror.cpp
@@ -34,7 +34,7 @@
 
 static cc_debugerror_cb * dbgerr_callback =
   reinterpret_cast<cc_debugerror_cb *>(cc_error_default_handler_cb);
-static void * dbgerr_callback_data = NULL;
+static void * dbgerr_callback_data = nullptr;
 static bool dbgerr_cleanup_function_set = false;
 
 extern "C" {
@@ -43,7 +43,7 @@ static void
 debugerror_cleanup(void)
 {
   dbgerr_callback = reinterpret_cast<cc_debugerror_cb *>(cc_error_default_handler_cb);
-  dbgerr_callback_data = NULL;
+  dbgerr_callback_data = nullptr;
   dbgerr_cleanup_function_set = false;
 }
 
diff --git a/coin4/src/errors/error.cpp b/coin4/src/errors/error.cpp
index 85f9373..e9c8d40 100644
--- a/coin4/src/errors/error.cpp
+++ b/coin4/src/errors/error.cpp
@@ -49,11 +49,11 @@ extern "C" {
 #endif /* __cplusplus */
 
 #ifdef COIN_THREADSAFE
-static cc_mutex * cc_error_mutex = NULL;
+static cc_mutex * cc_error_mutex = nullptr;
 static void cc_error_mutex_cleanup(void) {
   if (cc_error_mutex) {
     cc_mutex_destruct(cc_error_mutex);
-    cc_error_mutex = NULL;
+    cc_error_mutex = nullptr;
   }
 }
 #endif /* COIN_THREADSAFE */
@@ -78,14 +78,14 @@ cc_error_default_handler_cb(const cc_error * err, void * COIN_UNUSED_ARG(data))
 }
 
 static cc_error_cb * cc_error_callback = cc_error_default_handler_cb;
-static void * cc_error_callback_data = NULL;
+static void * cc_error_callback_data = nullptr;
 static bool cc_error_cleanup_function_set = false;
 
 static void
 cc_error_cleanup(void)
 {
   cc_error_callback = cc_error_default_handler_cb;
-  cc_error_callback_data = NULL;
+  cc_error_callback_data = nullptr;
   cc_error_cleanup_function_set = false;
 }
 
@@ -122,10 +122,10 @@ cc_error_append_to_debug_string(cc_error * me, const char * str)
 void
 cc_error_handle(cc_error * me)
 {
-  void * arg = NULL;
+  void * arg = nullptr;
 
   cc_error_cb * function = cc_error_get_handler(&arg);
-  assert(function != NULL);
+  assert(function != nullptr);
 
 #ifdef COIN_THREADSAFE
   if (!cc_error_mutex) {
@@ -134,7 +134,7 @@ cc_error_handle(cc_error * me)
        e.g. SoDebugError::post*() will hang if it happens within a
        region where the global lock is already taken. 20050708 mortene.*/
     cc_mutex_global_lock();
-    if (cc_error_mutex == NULL) {
+    if (cc_error_mutex == nullptr) {
       cc_error_mutex = cc_mutex_construct();
       coin_atexit(cc_error_mutex_cleanup, CC_ATEXIT_MSG_SUBSYSTEM);
     }
diff --git a/coin4/src/events/SoKeyboardEvent.cpp b/coin4/src/events/SoKeyboardEvent.cpp
index 551fde1..c00bf20 100644
--- a/coin4/src/events/SoKeyboardEvent.cpp
+++ b/coin4/src/events/SoKeyboardEvent.cpp
@@ -78,8 +78,8 @@
   given \c KEY.
 */
 
-static SbHash<int, char> * converttoprintable = NULL;
-static SbHash<int, char> * converttoprintable_shift = NULL;
+static SbHash<int, char> * converttoprintable = nullptr;
+static SbHash<int, char> * converttoprintable_shift = nullptr;
 
 extern "C" {
 
@@ -87,9 +87,9 @@ static void
 sokeyboardevent_cleanup(void)
 {
   delete converttoprintable;
-  converttoprintable = NULL;
+  converttoprintable = nullptr;
   delete converttoprintable_shift;
-  converttoprintable_shift = NULL;
+  converttoprintable_shift = nullptr;
 }
 
 } // extern "C"
@@ -344,7 +344,7 @@ SoKeyboardEvent::getPrintableCharacter(void) const
 {
   if (this->isprintableset) return this->printable;
 
-  if (converttoprintable == NULL) {
+  if (converttoprintable == nullptr) {
     build_convert_dicts();
   }
 
diff --git a/coin4/src/fields/MFNodeEnginePath.tpl b/coin4/src/fields/MFNodeEnginePath.tpl
index 132251a..c5441f8 100644
--- a/coin4/src/fields/MFNodeEnginePath.tpl
+++ b/coin4/src/fields/MFNodeEnginePath.tpl
@@ -10,7 +10,7 @@
   export operations.
 
   Note that _typename_ pointers stored in field instances of this type may
-  be \c NULL pointers.
+  be \c nullptr pointers.
 
   \sa So_Typename_, SoSF_Typename_
 
@@ -137,7 +137,7 @@ SoMF_Typename_::set1Value(const int idx, So_Typename_ * newval)
   // Expand array if necessary.
   if (idx >= this->num) {
 #ifdef COIN_INTERNAL_SOMFPATH
-    for (int i = this->num; i <= idx; i++) this->pathheads.append(NULL);
+    for (int i = this->num; i <= idx; i++) this->pathheads.append(nullptr);
 #endif // COIN_INTERNAL_SOMFPATH
     this->setNum(idx + 1);
   }
@@ -174,7 +174,7 @@ SoMF_Typename_::set1Value(const int idx, So_Typename_ * newval)
 
     this->values[idx] = newval;
 #ifdef COIN_INTERNAL_SOMFPATH
-    this->pathheads[idx] = newval ? newval->getHead() : NULL;
+    this->pathheads[idx] = newval ? newval->getHead() : nullptr;
 #endif // COIN_INTERNAL_SOMFPATH
   }
 
@@ -242,7 +242,7 @@ SoMF_Typename_::deleteValues(int start, int num)
   inherited::deleteValues(start, num);
 }
 
-// Overridden to insert NULL pointers in new array slots.
+// Overridden to insert nullptr pointers in new array slots.
 void
 SoMF_Typename_::insertSpace(int start, int num)
 {
@@ -255,9 +255,9 @@ SoMF_Typename_::insertSpace(int start, int num)
   inherited::insertSpace(start, num);
   for (int i=start; i < start+num; i++) {
 #ifdef COIN_INTERNAL_SOMFPATH
-    this->pathheads.insert(NULL, start);
+    this->pathheads.insert(nullptr, start);
 #endif // COIN_INTERNAL_SOMFPATH
-    this->values[i] = NULL;
+    this->values[i] = nullptr;
   }
 
   // Initialization done, now send notification.
diff --git a/coin4/src/fields/SFNodeEnginePath.tpl b/coin4/src/fields/SFNodeEnginePath.tpl
index 5d6129b..06f8d35 100644
--- a/coin4/src/fields/SFNodeEnginePath.tpl
+++ b/coin4/src/fields/SFNodeEnginePath.tpl
@@ -10,7 +10,7 @@
   operations.
 
   Note that the _typename_ pointer stored in a field instance of this type
-  may be a \c NULL pointer.
+  may be a \c nullptr pointer.
 
   \sa So_Typename_, SoMF_Typename_
 
@@ -52,12 +52,12 @@ SoSF_Typename_::initClass(void)
 // so don't use Doxygen commenting.)
 #ifndef DOXYGEN_SKIP_THIS
 
-/* Constructor, sets initial _typename_ pointer to a \c NULL pointer. */
+/* Constructor, sets initial _typename_ pointer to a \c nullptr pointer. */
 SoSF_Typename_::SoSF_Typename_(void)
 {
-  this->value = NULL;
+  this->value = nullptr;
 #ifdef COIN_INTERNAL_SOSFPATH
-  this->head = NULL;
+  this->head = nullptr;
 #endif // COIN_INTERNAL_SOSFPATH
 }
 
@@ -65,7 +65,7 @@ SoSF_Typename_::SoSF_Typename_(void)
 SoSF_Typename_::~SoSF_Typename_(void)
 {
   this->enableNotify(false);
-  this->setValue(NULL);
+  this->setValue(nullptr);
 }
 
 #endif // DOXYGEN_SKIP_THIS
@@ -77,7 +77,7 @@ SoSF_Typename_::~SoSF_Typename_(void)
 #ifndef DOXYGEN_SKIP_THIS
 
 // Store the \a newval _typename_ pointer in this field. If \a newval is not
-// \c NULL, will add 1 to the reference count of the _typename_.
+// \c nullptr, will add 1 to the reference count of the _typename_.
 void
 SoSF_Typename_::setValue(So_Typename_ * newval)
 {
@@ -184,7 +184,7 @@ SoSF_Typename_::countWriteRefs(SoOutput * out) const
   inherited::countWriteRefs(out);
 
   SoBase * base = this->getValue();
-  if (base == NULL) return;
+  if (base == nullptr) return;
 
   // NB: This code is common for SoSFNode, SoSFPath and SoSFEngine.
   // That's why we check the base type before writing/counting
@@ -260,7 +260,7 @@ SoSF_Typename_::referencesCopy(void) const
   }
   else if (n->isOfType(SoPath::getClassTypeId())) {
     SoPath * p = (SoPath *)n;
-    if (p->getHead() == NULL) return false;
+    if (p->getHead() == nullptr) return false;
     if (SoFieldContainer::checkCopy(p->getHead())) return true;
   }
   else {
diff --git a/coin4/src/fields/SoField.cpp b/coin4/src/fields/SoField.cpp
index f33481f..1288a69 100644
--- a/coin4/src/fields/SoField.cpp
+++ b/coin4/src/fields/SoField.cpp
@@ -149,7 +149,7 @@ inline unsigned int SbHashFunc(const void * key)
 
 static const int SOFIELD_GET_STACKBUFFER_SIZE = 1024;
 // need one static mutex for field_buffer in SoField::get(SbString &)
-static void * sofield_mutex = NULL;
+static void * sofield_mutex = nullptr;
 
 // flags for this->statusbits
 
@@ -170,7 +170,7 @@ class SoConnectStorage {
 public:
   SoConnectStorage(SoFieldContainer * c, SoType t)
     : container(c),
-    lastnotify(NULL),
+    lastnotify(nullptr),
     fieldtype(t),
     maptoconverter(13) // save about ~1kB vs default nr of buckets
     {
@@ -227,7 +227,7 @@ public:
   SoFieldConverter * findConverter(const void * item)
   {
     SoFieldConverter * val;
-    if (!this->maptoconverter.get(item, val)) { return NULL; }
+    if (!this->maptoconverter.get(item, val)) { return nullptr; }
     return val;
   }
 
@@ -367,7 +367,7 @@ public:
   static SbHash<char *, char **> * ptrhash;
 };
 
-SbHash<char *, char **> * SoFieldP::ptrhash = NULL;
+SbHash<char *, char **> * SoFieldP::ptrhash = nullptr;
 
 extern "C" {
 // atexit callbacks
@@ -380,7 +380,7 @@ SbHash<char *, char **> *
 SoFieldP::getReallocHash(void)
 {
   // FIXME: protect with mutex?
-  if (SoFieldP::ptrhash == NULL) {
+  if (SoFieldP::ptrhash == nullptr) {
     SoFieldP::ptrhash = new SbHash<char *, char **>;
     coin_atexit(hashExitCleanup, CC_ATEXIT_NORMAL);
   }
@@ -392,7 +392,7 @@ hashExitCleanup(void)
 {
   assert(SoFieldP::ptrhash->getNumElements() == 0);
   delete SoFieldP::ptrhash;
-  SoFieldP::ptrhash = NULL;
+  SoFieldP::ptrhash = nullptr;
 }
 
 void *
@@ -400,14 +400,14 @@ SoFieldP::hashRealloc(void * bufptr, size_t size)
 {
   CC_MUTEX_LOCK(sofield_mutex);
 
-  char ** bufptrptr = NULL;
+  char ** bufptrptr = nullptr;
   int ok = SoFieldP::ptrhash->get(static_cast<char *>(bufptr), bufptrptr);
   assert(ok);
 
-  // If *bufptrptr contains a NULL pointer, this is the first
+  // If *bufptrptr contains a nullptr pointer, this is the first
   // invocation and the initial memory buffer was on the stack.
   char * newbuf;
-  if (*bufptrptr == NULL) {
+  if (*bufptrptr == nullptr) {
     // if initial buffer was on the stack, we need to manually copy
     // the data into the new buffer.
     newbuf = static_cast<char *>(malloc(size));
@@ -527,7 +527,7 @@ SoField::hasExtendedStorage(void) const
   doing the common parts of data initialization in fields.
 */
 SoField::SoField(void)
-  : container(NULL)
+  : container(nullptr)
 {
   this->statusbits = 0;
   this->setStatusBits(FLAG_DONOTIFY |
@@ -1339,7 +1339,7 @@ SoField::get(SbString & valuestring)
   // Initial buffer setup.
   SoOutput out;
   char initbuffer[SOFIELD_GET_STACKBUFFER_SIZE];
-  char * bufferptr = NULL; // indicates that initial buffer is on the stack
+  char * bufferptr = nullptr; // indicates that initial buffer is on the stack
 
   CC_MUTEX_LOCK(sofield_mutex);
   int ok = SoFieldP::getReallocHash()->put(initbuffer, &bufferptr);
@@ -1645,7 +1645,7 @@ SoField::shouldWrite(void) const
     // fields should be written even if they have the default value
     // (just like any other field). pederb, 2005-12-20
     SoFieldContainer * thecontainer = this->getContainer();
-    if ( thecontainer != NULL &&
+    if ( thecontainer != nullptr &&
          thecontainer->isOfType(SoProtoInstance::getClassTypeId()) ) {
       // PROTO instance fields are usually connected, but we don't want to
       // write out PROTO instance fields that contain default values - they
@@ -1788,7 +1788,7 @@ SoField::copyConnection(const SoField * fromfield)
   }
   for (i = 0; i < fromfield->storage->masterengineouts.getLength(); i++) {
     SoEngineOutput * master = fromfield->storage->masterengineouts[i];
-    SoEngineOutput * copyeo = NULL;
+    SoEngineOutput * copyeo = nullptr;
 
     if (master->isNodeEngineOutput()) {
       SbName name;
@@ -2123,7 +2123,7 @@ SoField::evaluateField(void) const
 
   if (!this->isConnected()) return;
 
-  assert(this->storage != NULL);
+  assert(this->storage != nullptr);
 
   // lock _before_ testing FLAG_ISEVALUATING to be thread safe
   SOFIELD_RECLOCK;
@@ -2214,7 +2214,7 @@ SoField::appendConnection(SoField * master, bool notnotify)
 }
 
 // Make a converter from value(s) of the given field type and the
-// value(s) of this type. Returns NULL if no value conversion between
+// value(s) of this type. Returns nullptr if no value conversion between
 // types is possible.
 SoFieldConverter *
 SoField::createConverter(SoType from) const
@@ -2229,7 +2229,7 @@ SoField::createConverter(SoType from) const
                               from.getName().getString(),
                               thistype.getName().getString());
 #endif // COIN_DEBUG
-    return NULL;
+    return nullptr;
   }
 
   SoFieldConverter * fc;
@@ -2317,18 +2317,18 @@ SoField::readConnection(SoInput * in)
 
   // Get pointer to master field or engine output and connect.
 
-  SoEngineOutput * masteroutput = NULL;
+  SoEngineOutput * masteroutput = nullptr;
   SoField * masterfield = fc->getField(mastername);
 
   if (!masterfield) {
     masteroutput =
       fc->isOfType(SoEngine::getClassTypeId()) ?
-      coin_safe_cast<SoEngine*>(fc)->getOutput(mastername) : NULL;
+      coin_safe_cast<SoEngine*>(fc)->getOutput(mastername) : nullptr;
 
     if (!masteroutput) {
       masteroutput =
         fc->isOfType(SoNodeEngine::getClassTypeId()) ?
-        coin_safe_cast<SoNodeEngine *>(fc)->getOutput(mastername) : NULL;
+        coin_safe_cast<SoNodeEngine *>(fc)->getOutput(mastername) : nullptr;
     }
   }
 
@@ -2394,15 +2394,15 @@ SoField::writeConnection(SoOutput * out) const
 
 // Check if this field should write a connection upon export. Returns
 // a pointer to the fieldcontainer with the master field we're
-// connected to (or NULL if none, or if the master field's container
-// is not within the scenegraph). If the return value is non-NULL, the
+// connected to (or nullptr if none, or if the master field's container
+// is not within the scenegraph). If the return value is non-nullptr, the
 // name of the master field is copied to the mastername argument.
 SoFieldContainer *
 SoField::resolveWriteConnection(SbName & mastername) const
 {
-  if (!this->isConnected()) return NULL;
+  if (!this->isConnected()) return nullptr;
 
-  SoFieldContainer * fc = NULL;
+  SoFieldContainer * fc = nullptr;
   SoField * fieldmaster;
   SoEngineOutput * enginemaster;
 
diff --git a/coin4/src/fields/SoFieldContainer.cpp b/coin4/src/fields/SoFieldContainer.cpp
index eabe222..8c79abf 100644
--- a/coin4/src/fields/SoFieldContainer.cpp
+++ b/coin4/src/fields/SoFieldContainer.cpp
@@ -101,13 +101,13 @@ SoType SoFieldContainer::classTypeId STATIC_SOTYPE_INIT;
 
 // used by setUserData() and getUserData()
 typedef SbHash<const SoFieldContainer *, void *> UserDataMap;
-static UserDataMap * sofieldcontainer_userdata_dict = NULL;
+static UserDataMap * sofieldcontainer_userdata_dict = nullptr;
 
 void
 sofieldcontainer_userdata_cleanup(void)
 {
   delete sofieldcontainer_userdata_dict;
-  sofieldcontainer_userdata_dict = NULL;
+  sofieldcontainer_userdata_dict = nullptr;
 }
 
 // *************************************************************************
@@ -233,7 +233,7 @@ SoFieldContainer::initClass(void)
   assert(inherited::getClassTypeId() != SoType::badType());
 
   SoFieldContainer::classTypeId =
-    SoType::createType(inherited::getClassTypeId(), "FieldContainer", NULL);
+    SoType::createType(inherited::getClassTypeId(), "FieldContainer", nullptr);
 
   sofieldcontainer_userdata_dict = new UserDataMap;
   coin_atexit(sofieldcontainer_userdata_cleanup, CC_ATEXIT_NORMAL);
@@ -317,8 +317,8 @@ SoFieldContainer::fieldsAreEqual(const SoFieldContainer * container) const
 {
   const SoFieldData * fd0 = this->getFieldData();
 
-  if (fd0 == NULL) {
-    if (container->getFieldData() == NULL) return true;
+  if (fd0 == nullptr) {
+    if (container->getFieldData() == nullptr) return true;
     return false;
   }
 
@@ -339,8 +339,8 @@ SoFieldContainer::copyFieldValues(const SoFieldContainer * container,
 {
   const SoFieldData * fd0 = this->getFieldData();
 
-  if (fd0 == NULL) {
-    if (container->getFieldData() == NULL) return;
+  if (fd0 == nullptr) {
+    if (container->getFieldData() == nullptr) return;
 #if COIN_DEBUG
     SoDebugError::postInfo("SoFieldContainer::copyFieldValues",
                            "tried to copy from fieldcontainer of wrong type");
@@ -364,7 +364,7 @@ SoFieldContainer::copyFieldValues(const SoFieldContainer * container,
 bool
 SoFieldContainer::set(const char * const fielddata)
 {
-  return this->set(fielddata, NULL);
+  return this->set(fielddata, nullptr);
 }
 
 /*!
@@ -377,7 +377,7 @@ SoFieldContainer::set(const char * const fielddata)
 void
 SoFieldContainer::get(SbString & fielddata)
 {
-  this->get(fielddata, NULL);
+  this->get(fielddata, nullptr);
 }
 
 
@@ -392,12 +392,12 @@ int
 SoFieldContainer::getFields(SoFieldList & fields) const
 {
   const SoFieldData * fielddata = this->getFieldData();
-  if ( fielddata == NULL ) return 0;
+  if ( fielddata == nullptr ) return 0;
   const int numfields = fielddata->getNumFields();
   int fieldsadded = 0;
   for ( int i = 0; i < numfields; i++ ) {
     SoField * field = fielddata->getField(this, i);
-    assert(field != NULL);
+    assert(field != nullptr);
     switch ( field->getFieldType() ) {
     // these field types are ignored
     case SoField::EVENTIN_FIELD:
@@ -423,7 +423,7 @@ int
 SoFieldContainer::getAllFields(SoFieldList & fields) const
 {
   const SoFieldData * fielddata = this->getFieldData();
-  if ( fielddata == NULL ) return 0;
+  if ( fielddata == nullptr ) return 0;
   int numfields = fielddata->getNumFields();
   for ( int i=0; i < numfields; i++ )
     fields.append(fielddata->getField(this, i));
@@ -432,13 +432,13 @@ SoFieldContainer::getAllFields(SoFieldList & fields) const
 
 /*!
   This method returns a pointer to the field with \a name, or
-  \c NULL if no such field exists.
+  \c nullptr if no such field exists.
 */
 SoField *
 SoFieldContainer::getField(const SbName & name) const
 {
   const SoFieldData * fields = this->getFieldData();
-  if (!fields) return NULL;
+  if (!fields) return nullptr;
 
   const int numfields = fields->getNumFields();
   for (int i = 0; i < numfields; i++) {
@@ -446,29 +446,29 @@ SoFieldContainer::getField(const SbName & name) const
       return fields->getField(this, i);
   }
 
-  return NULL;
+  return nullptr;
 }
 
 /*!
   This method returns a pointer to the eventIn with name \a name,
-  or \c NULL if no such eventIn exists.
+  or \c nullptr if no such eventIn exists.
 */
 SoField *
 SoFieldContainer::getEventIn(const SbName & name) const
 {
   SoField * f = this->getField(name);
-  return (f && (f->getFieldType() == SoField::EVENTIN_FIELD)) ? f : NULL;
+  return (f && (f->getFieldType() == SoField::EVENTIN_FIELD)) ? f : nullptr;
 }
 
 /*!
   This method returns a pointer to the eventOut with name \a name,
-  or \c NULL if no such eventOut exists.
+  or \c nullptr if no such eventOut exists.
 */
 SoField *
 SoFieldContainer::getEventOut(const SbName & name) const
 {
   SoField * f = this->getField(name);
-  return (f && (f->getFieldType() == SoField::EVENTOUT_FIELD)) ? f : NULL;
+  return (f && (f->getFieldType() == SoField::EVENTOUT_FIELD)) ? f : nullptr;
 }
 
 
@@ -624,7 +624,7 @@ SoFieldContainer::get(SbString & fielddata, SoOutput * out)
   if (size > 0) {
     // Strip off header.
     char * start = strstr(static_cast<char *>(buffer), "\n\n");
-    if (start != NULL) {
+    if (start != nullptr) {
       start += 2;
       fielddata = start;
     }
@@ -736,12 +736,12 @@ SoFieldContainer::getIsBuiltIn(void) const
 
 /*!
   Returns a pointer to the class-wide field data storage object
-  for this instance. If no fields are present, returns \c NULL.
+  for this instance. If no fields are present, returns \c nullptr.
  */
 const SoFieldData *
 SoFieldContainer::getFieldData(void) const
 {
-  return NULL;
+  return nullptr;
 }
 
 
@@ -871,7 +871,7 @@ SoFieldContainer::addCopy(const SoFieldContainer * orig,
 
 /*!
   Returns the copy of \a orig, if any. If no copy exists, we return a
-  \c NULL pointer.
+  \c nullptr pointer.
  */
 SoFieldContainer *
 SoFieldContainer::checkCopy(const SoFieldContainer * orig)
@@ -886,7 +886,7 @@ SoFieldContainer::checkCopy(const SoFieldContainer * orig)
   // FIXME: ugly constness cast. 20050520 mortene.
   return const_cast<SoFieldContainer *>
     (
-     copiedinstances->get(orig, fccopy) ? fccopy : NULL
+     copiedinstances->get(orig, fccopy) ? fccopy : nullptr
      );
 }
 
@@ -905,7 +905,7 @@ SoFieldContainer::checkCopy(const SoFieldContainer * orig)
 
   If copyContents() is called directly (instead of using copy()), it's
   assumed that the user only wants to copy the field values, and we
-  just return NULL here. This is done to match how it's done in SGI
+  just return nullptr here. This is done to match how it's done in SGI
   Inventor.
 
   \sa checkCopy()
@@ -919,9 +919,9 @@ SoFieldContainer::findCopy(const SoFieldContainer * orig,
 
   // Sometimes copyContents() is called directly (initCopyDict() is
   // not called first) to just copy the fields of a single node. This
-  // is often done in SGI example code. We should just return NULL
+  // is often done in SGI example code. We should just return nullptr
   // here in those cases to be compatible with SGI Inventor.
-  if (copydict->copiedinstancestack->getLength() == 0) return NULL;
+  if (copydict->copiedinstancestack->getLength() == 0) return nullptr;
 
   SoFieldContainerCopyMap * copiedinstances = (*(copydict->copiedinstancestack))[0];
   ContentsCopiedMap * contentscopied  = (*(copydict->contentscopiedstack))[0];
@@ -931,7 +931,7 @@ SoFieldContainer::findCopy(const SoFieldContainer * orig,
 
   const SoNode * protonode = coin_safe_cast<const SoNode *>(orig);
   SoProtoInstance * protoinst = protonode ?
-    SoProtoInstance::findProtoInstance(protonode) : NULL;
+    SoProtoInstance::findProtoInstance(protonode) : nullptr;
 
   SoFieldContainer * cp = SoFieldContainer::checkCopy(orig);
   if (!cp) {
@@ -951,7 +951,7 @@ SoFieldContainer::findCopy(const SoFieldContainer * orig,
       newinst->copyContents(protoinst, false);
     }
     else {
-      const SoFieldContainer * ccp = NULL;
+      const SoFieldContainer * ccp = nullptr;
       if (orig->isOfType(SoProto::getClassTypeId())) {
         // just copy the pointer. A PROTO definition is
         // read-only. It's not possible to change it after it has been
@@ -1265,7 +1265,7 @@ SoFieldContainer::setUserData(void * userdata) const
 
 /*!
   Return the generic user data pointer for this field container, or
-  NULL if no user data has been set.
+  nullptr if no user data has been set.
 
   \sa setUserData()
   \since Coin 2.0
@@ -1273,11 +1273,11 @@ SoFieldContainer::setUserData(void * userdata) const
 void *
 SoFieldContainer::getUserData(void) const
 {
-  void * tmp = NULL;
+  void * tmp = nullptr;
   if (sofieldcontainer_userdata_dict->get(this, tmp)) {
     return tmp;
   }
-  return NULL;
+  return nullptr;
 }
 
 #undef FLAG_DONOTIFY
diff --git a/coin4/src/fields/SoFieldData.cpp b/coin4/src/fields/SoFieldData.cpp
index 85ea35d..1a6cc4c 100644
--- a/coin4/src/fields/SoFieldData.cpp
+++ b/coin4/src/fields/SoFieldData.cpp
@@ -151,7 +151,7 @@ SoFieldData::SoFieldData(const SoFieldData & fd)
 
 /*!
   Copy constructor taking a pointer value as an argument. Handles \c
-  NULL pointers by behaving like the default constructor.
+  nullptr pointers by behaving like the default constructor.
 */
 SoFieldData::SoFieldData(const SoFieldData * fd)
 {
@@ -353,13 +353,13 @@ SoFieldData::addEnumValue(const char * enumname, const char * valuename,
 {
   CC_GLOBAL_LOCK;
   if (!this->hasEnumValue(enumname, valuename)) {
-    SoEnumEntry * e = NULL;
+    SoEnumEntry * e = nullptr;
 
     for (int i=0; !e && (i < this->enums.getLength()); i++) {
       if (this->enums[i]->nameoftype == enumname) e = this->enums[i];
     }
 
-    if (e == NULL) {
+    if (e == nullptr) {
       e = new SoEnumEntry(enumname);
       this->enums.append(e);
     }
@@ -389,8 +389,8 @@ SoFieldData::getEnumData(const char * enumname, int & num,
                          const int *& values, const SbName *& names)
 {
   num = 0;
-  values = NULL;
-  names = NULL;
+  values = nullptr;
+  names = nullptr;
 
   for (int i=0; i < this->enums.getLength(); i++) {
     SoEnumEntry * e = this->enums[i];
@@ -841,7 +841,7 @@ SoFieldData::readFieldDescriptions(SoInput * in, SoFieldContainer * object,
                            fieldtypename.getString(), fieldname.getString());
 #endif // debug
 
-    SoField * newfield = NULL;
+    SoField * newfield = nullptr;
     for (int i=0; !newfield && (i < this->fields.getLength()); i++) {
       if (this->fields[i]->name == fieldname) {
         newfield = this->getField(object, i);
@@ -973,11 +973,11 @@ SoFieldData::hasField(const char * name) const
 bool
 SoFieldData::hasEnumValue(const char * enumname, const char * valuename)
 {
-  SoEnumEntry * e = NULL;
+  SoEnumEntry * e = nullptr;
 
   for (int i=0; !e && (i < this->enums.getLength()); i++) {
     if (this->enums[i]->nameoftype == enumname) e = this->enums[i];
   }
-  if (e == NULL) return false;
+  if (e == nullptr) return false;
   return e->names.find(valuename) != -1;
 }
diff --git a/coin4/src/fields/SoGlobalField.cpp b/coin4/src/fields/SoGlobalField.cpp
index d81df97..ca15675 100644
--- a/coin4/src/fields/SoGlobalField.cpp
+++ b/coin4/src/fields/SoGlobalField.cpp
@@ -62,11 +62,11 @@
 
 SoType SoGlobalField::classTypeId STATIC_SOTYPE_INIT;
 
-SoBaseList * SoGlobalField::allcontainers = NULL;
+SoBaseList * SoGlobalField::allcontainers = nullptr;
 
 // *************************************************************************
 
-// Constructor. Pass NULL for the field pointer to construct an empty
+// Constructor. Pass nullptr for the field pointer to construct an empty
 // SoGlobalField instance.
 SoGlobalField::SoGlobalField(const SbName & name, SoField * field)
 {
@@ -86,7 +86,7 @@ SoGlobalField::SoGlobalField(const SbName & name, SoField * field)
     this->classfielddata->addField(this, name, field);
   }
   else {
-    this->classfielddata = NULL;
+    this->classfielddata = nullptr;
   }
 
   this->setName(name);
@@ -115,7 +115,7 @@ SoGlobalField::~SoGlobalField()
 void *
 SoGlobalField::createInstance(void)
 {
-  return new SoGlobalField(SbName::empty(), NULL);
+  return new SoGlobalField(SbName::empty(), nullptr);
 }
 
 // Do common initializations.
@@ -164,7 +164,7 @@ SoGlobalField::clean(void)
 #endif // COIN_DEBUG
 
   delete SoGlobalField::allcontainers;
-  SoGlobalField::allcontainers = NULL;
+  SoGlobalField::allcontainers = nullptr;
   SoGlobalField::classTypeId STATIC_SOTYPE_INIT;
 }
 
@@ -204,7 +204,7 @@ SoGlobalField::getGlobalFieldContainer(const SbName & name)
 {
   int idx = SoGlobalField::getGlobalFieldIndex(name);
   return
-    (idx == -1) ? NULL : coin_assert_cast<SoGlobalField *>((*SoGlobalField::allcontainers)[idx]);
+    (idx == -1) ? nullptr : coin_assert_cast<SoGlobalField *>((*SoGlobalField::allcontainers)[idx]);
 }
 
 // Returns the complete set of SoGlobalField instances.
@@ -234,7 +234,7 @@ SoGlobalField::getTypeId(void) const
 SoField *
 SoGlobalField::getGlobalField(void) const
 {
-  return this->classfielddata ? this->classfielddata->getField(this, 0) : NULL;
+  return this->classfielddata ? this->classfielddata->getField(this, 0) : nullptr;
 }
 
 // Overridden to also set field name.
@@ -260,7 +260,7 @@ SoGlobalField::readInstance(SoInput * in, unsigned short COIN_UNUSED_ARG(flags))
   // A bit more coding and we could let the readInstance() method be
   // called on already initialized SoGlobalField instances, but I
   // don't think there's any point. mortene.
-  assert(this->classfielddata == NULL);
+  assert(this->classfielddata == nullptr);
 
   // This macro is convenient for reading with error detection.
 #define READ_VAL(val) \
diff --git a/coin4/src/fields/SoMFEngine.cpp b/coin4/src/fields/SoMFEngine.cpp
index 0f431d8..459e7c7 100644
--- a/coin4/src/fields/SoMFEngine.cpp
+++ b/coin4/src/fields/SoMFEngine.cpp
@@ -36,7 +36,7 @@
   export operations.
 
   Note that engine pointers stored in field instances of this type may
-  be \c NULL pointers.
+  be \c nullptr pointers.
 
   \sa SoEngine, SoSFEngine
 
@@ -169,7 +169,7 @@ SoMFEngine::set1Value(const int idx, SoEngine * newval)
   // Expand array if necessary.
   if (idx >= this->num) {
 #ifdef COIN_INTERNAL_SOMFPATH
-    for (int i = this->num; i <= idx; i++) this->pathheads.append(NULL);
+    for (int i = this->num; i <= idx; i++) this->pathheads.append(nullptr);
 #endif // COIN_INTERNAL_SOMFPATH
     this->setNum(idx + 1);
   }
@@ -207,7 +207,7 @@ SoMFEngine::set1Value(const int idx, SoEngine * newval)
     this->setChangedIndex(idx);
     this->values[idx] = newval;
 #ifdef COIN_INTERNAL_SOMFPATH
-    this->pathheads[idx] = newval ? newval->getHead() : NULL;
+    this->pathheads[idx] = newval ? newval->getHead() : nullptr;
 #endif // COIN_INTERNAL_SOMFPATH
   }
 
@@ -276,7 +276,7 @@ SoMFEngine::deleteValues(int start, int numarg)
   inherited::deleteValues(start, numarg);
 }
 
-// Overridden to insert NULL pointers in new array slots.
+// Overridden to insert nullptr pointers in new array slots.
 void
 SoMFEngine::insertSpace(int start, int numarg)
 {
@@ -289,9 +289,9 @@ SoMFEngine::insertSpace(int start, int numarg)
   inherited::insertSpace(start, numarg);
   for (int i=start; i < start+numarg; i++) {
 #ifdef COIN_INTERNAL_SOMFPATH
-    this->pathheads.insert(NULL, start);
+    this->pathheads.insert(nullptr, start);
 #endif // COIN_INTERNAL_SOMFPATH
-    this->values[i] = NULL;
+    this->values[i] = nullptr;
   }
 
   // Initialization done, now send notification.
diff --git a/coin4/src/fields/SoMFEnum.cpp b/coin4/src/fields/SoMFEnum.cpp
index 500fbb5..740aa52 100644
--- a/coin4/src/fields/SoMFEnum.cpp
+++ b/coin4/src/fields/SoMFEnum.cpp
@@ -83,11 +83,11 @@ SO_MFIELD_VALUE_SOURCE(SoMFEnum, int, int);
 /* Constructor. */
 SoMFEnum::SoMFEnum(void)
 {
-  this->values = NULL;
+  this->values = nullptr;
   this->legalValuesSet = false;
   this->numEnums = 0;
-  this->enumValues = NULL;
-  this->enumNames = NULL;
+  this->enumValues = nullptr;
+  this->enumNames = nullptr;
 }
 
 /* Destructor. */
diff --git a/coin4/src/fields/SoMFNode.cpp b/coin4/src/fields/SoMFNode.cpp
index 7a532b3..7f8b99c 100644
--- a/coin4/src/fields/SoMFNode.cpp
+++ b/coin4/src/fields/SoMFNode.cpp
@@ -38,7 +38,7 @@
   export operations.
 
   Note that node pointers stored in field instances of this type may
-  be \c NULL pointers.
+  be \c nullptr pointers.
 
   \sa SoNode, SoSFNode
 
@@ -173,7 +173,7 @@ SoMFNode::set1Value(const int idx, SoNode * newval)
   // Expand array if necessary.
   if (idx >= this->num) {
 #ifdef COIN_INTERNAL_SOMFPATH
-    for (int i = this->num; i <= idx; i++) this->pathheads.append(NULL);
+    for (int i = this->num; i <= idx; i++) this->pathheads.append(nullptr);
 #endif // COIN_INTERNAL_SOMFPATH
     this->setNum(idx + 1);
   }
@@ -211,7 +211,7 @@ SoMFNode::set1Value(const int idx, SoNode * newval)
     this->setChangedIndex(idx);
     this->values[idx] = newval;
 #ifdef COIN_INTERNAL_SOMFPATH
-    this->pathheads[idx] = newval ? newval->getHead() : NULL;
+    this->pathheads[idx] = newval ? newval->getHead() : nullptr;
 #endif // COIN_INTERNAL_SOMFPATH
   }
 
@@ -280,7 +280,7 @@ SoMFNode::deleteValues(int start, int numarg)
   inherited::deleteValues(start, numarg);
 }
 
-// Overridden to insert NULL pointers in new array slots.
+// Overridden to insert nullptr pointers in new array slots.
 void
 SoMFNode::insertSpace(int start, int numarg)
 {
@@ -293,9 +293,9 @@ SoMFNode::insertSpace(int start, int numarg)
   inherited::insertSpace(start, numarg);
   for (int i=start; i < start+numarg; i++) {
 #ifdef COIN_INTERNAL_SOMFPATH
-    this->pathheads.insert(NULL, start);
+    this->pathheads.insert(nullptr, start);
 #endif // COIN_INTERNAL_SOMFPATH
-    this->values[i] = NULL;
+    this->values[i] = nullptr;
   }
 
   // Initialization done, now send notification.
@@ -642,7 +642,7 @@ BOOST_AUTO_TEST_CASE(NULLreading)
   // FIXME: We are forced to restore the global state before terminating,
   // or independent tests could fail. (sveinung 20071108)
   SoErrorCB * prevErrorCB = SoReadError::getHandlerCallback();
-  SoReadError::setHandlerCallback(readErrorHandler, NULL);
+  SoReadError::setHandlerCallback(readErrorHandler, nullptr);
 
   const char file[] =
     "[ DEF mycube Cube {} USE mycube ]";
@@ -652,7 +652,7 @@ BOOST_AUTO_TEST_CASE(NULLreading)
   BOOST_CHECK_MESSAGE(field.read(&in, SbName("test")),
                       "DEF/USE reading in SoMFNode is broken");
 
-  SoReadError::setHandlerCallback(prevErrorCB, NULL);
+  SoReadError::setHandlerCallback(prevErrorCB, nullptr);
 }
 
 #endif // COIN_TEST_SUITE
diff --git a/coin4/src/fields/SoMFPath.cpp b/coin4/src/fields/SoMFPath.cpp
index 99008af..dd327cc 100644
--- a/coin4/src/fields/SoMFPath.cpp
+++ b/coin4/src/fields/SoMFPath.cpp
@@ -37,7 +37,7 @@
   export operations.
 
   Note that path pointers stored in field instances of this type may
-  be \c NULL pointers.
+  be \c nullptr pointers.
 
   \sa SoPath, SoSFPath
 
@@ -171,7 +171,7 @@ SoMFPath::set1Value(const int idx, SoPath * newval)
   // Expand array if necessary.
   if (idx >= this->num) {
 #ifdef COIN_INTERNAL_SOMFPATH
-    for (int i = this->num; i <= idx; i++) this->pathheads.append(NULL);
+    for (int i = this->num; i <= idx; i++) this->pathheads.append(nullptr);
 #endif // COIN_INTERNAL_SOMFPATH
     this->setNum(idx + 1);
   }
@@ -209,7 +209,7 @@ SoMFPath::set1Value(const int idx, SoPath * newval)
     this->setChangedIndex(idx);
     this->values[idx] = newval;
 #ifdef COIN_INTERNAL_SOMFPATH
-    this->pathheads[idx] = newval ? newval->getHead() : NULL;
+    this->pathheads[idx] = newval ? newval->getHead() : nullptr;
 #endif // COIN_INTERNAL_SOMFPATH
   }
 
@@ -278,7 +278,7 @@ SoMFPath::deleteValues(int start, int numarg)
   inherited::deleteValues(start, numarg);
 }
 
-// Overridden to insert NULL pointers in new array slots.
+// Overridden to insert nullptr pointers in new array slots.
 void
 SoMFPath::insertSpace(int start, int numarg)
 {
@@ -291,9 +291,9 @@ SoMFPath::insertSpace(int start, int numarg)
   inherited::insertSpace(start, numarg);
   for (int i=start; i < start+numarg; i++) {
 #ifdef COIN_INTERNAL_SOMFPATH
-    this->pathheads.insert(NULL, start);
+    this->pathheads.insert(nullptr, start);
 #endif // COIN_INTERNAL_SOMFPATH
-    this->values[i] = NULL;
+    this->values[i] = nullptr;
   }
 
   // Initialization done, now send notification.
diff --git a/coin4/src/fields/SoMFVec2b.cpp b/coin4/src/fields/SoMFVec2b.cpp
index f394f0f..26f080b 100644
--- a/coin4/src/fields/SoMFVec2b.cpp
+++ b/coin4/src/fields/SoMFVec2b.cpp
@@ -141,7 +141,7 @@ SoMFVec2b::setValue(int8_t x, int8_t y)
 void
 SoMFVec2b::setValue(const int8_t xy[2])
 {
-  if (xy == NULL) this->setNum(0);
+  if (xy == nullptr) this->setNum(0);
   else this->setValue(SbVec2b(xy));
 }
 
diff --git a/coin4/src/fields/SoMFVec2d.cpp b/coin4/src/fields/SoMFVec2d.cpp
index 78eafdf..64461d0 100644
--- a/coin4/src/fields/SoMFVec2d.cpp
+++ b/coin4/src/fields/SoMFVec2d.cpp
@@ -141,7 +141,7 @@ SoMFVec2d::setValue(double x, double y)
 void
 SoMFVec2d::setValue(const double xy[2])
 {
-  if (xy == NULL) this->setNum(0);
+  if (xy == nullptr) this->setNum(0);
   else this->setValue(SbVec2d(xy));
 }
 
diff --git a/coin4/src/fields/SoMFVec2f.cpp b/coin4/src/fields/SoMFVec2f.cpp
index 61ca0a5..5b573bd 100644
--- a/coin4/src/fields/SoMFVec2f.cpp
+++ b/coin4/src/fields/SoMFVec2f.cpp
@@ -139,7 +139,7 @@ SoMFVec2f::setValue(float x, float y)
 void
 SoMFVec2f::setValue(const float xy[2])
 {
-  if (xy == NULL) this->setNum(0);
+  if (xy == nullptr) this->setNum(0);
   else this->setValue(SbVec2f(xy));
 }
 
diff --git a/coin4/src/fields/SoMFVec2i32.cpp b/coin4/src/fields/SoMFVec2i32.cpp
index 9da5f73..89acfe4 100644
--- a/coin4/src/fields/SoMFVec2i32.cpp
+++ b/coin4/src/fields/SoMFVec2i32.cpp
@@ -141,7 +141,7 @@ SoMFVec2i32::setValue(int32_t x, int32_t y)
 void
 SoMFVec2i32::setValue(const int32_t xy[2])
 {
-  if (xy == NULL) this->setNum(0);
+  if (xy == nullptr) this->setNum(0);
   else this->setValue(SbVec2i32(xy));
 }
 
diff --git a/coin4/src/fields/SoMFVec2s.cpp b/coin4/src/fields/SoMFVec2s.cpp
index f758a4a..c4ec49b 100644
--- a/coin4/src/fields/SoMFVec2s.cpp
+++ b/coin4/src/fields/SoMFVec2s.cpp
@@ -141,7 +141,7 @@ SoMFVec2s::setValue(short x, short y)
 void
 SoMFVec2s::setValue(const short xy[2])
 {
-  if (xy == NULL) this->setNum(0);
+  if (xy == nullptr) this->setNum(0);
   else this->setValue(SbVec2s(xy));
 }
 
diff --git a/coin4/src/fields/SoMFVec3b.cpp b/coin4/src/fields/SoMFVec3b.cpp
index d4835ad..92e243e 100644
--- a/coin4/src/fields/SoMFVec3b.cpp
+++ b/coin4/src/fields/SoMFVec3b.cpp
@@ -152,7 +152,7 @@ SoMFVec3b::setValue(int8_t x, int8_t y, int8_t z)
 void
 SoMFVec3b::setValue(const int8_t xyz[3])
 {
-  if (xyz == NULL) this->setNum(0);
+  if (xyz == nullptr) this->setNum(0);
   else this->setValue(SbVec3b(xyz));
 }
 
diff --git a/coin4/src/fields/SoMFVec3d.cpp b/coin4/src/fields/SoMFVec3d.cpp
index 685adb0..b24aad1 100644
--- a/coin4/src/fields/SoMFVec3d.cpp
+++ b/coin4/src/fields/SoMFVec3d.cpp
@@ -137,7 +137,7 @@ SoMFVec3d::setValue(double x, double y, double z)
 void
 SoMFVec3d::setValue(const double xyz[3])
 {
-  if (xyz == NULL) this->setNum(0);
+  if (xyz == nullptr) this->setNum(0);
   else this->setValue(SbVec3d(xyz));
 }
 
diff --git a/coin4/src/fields/SoMFVec3f.cpp b/coin4/src/fields/SoMFVec3f.cpp
index ae36538..fe04f1b 100644
--- a/coin4/src/fields/SoMFVec3f.cpp
+++ b/coin4/src/fields/SoMFVec3f.cpp
@@ -150,7 +150,7 @@ SoMFVec3f::setValue(float x, float y, float z)
 void
 SoMFVec3f::setValue(const float xyz[3])
 {
-  if (xyz == NULL) this->setNum(0);
+  if (xyz == nullptr) this->setNum(0);
   else this->setValue(SbVec3f(xyz));
 }
 
diff --git a/coin4/src/fields/SoMFVec3i32.cpp b/coin4/src/fields/SoMFVec3i32.cpp
index 3176ad7..30dd9e0 100644
--- a/coin4/src/fields/SoMFVec3i32.cpp
+++ b/coin4/src/fields/SoMFVec3i32.cpp
@@ -152,7 +152,7 @@ SoMFVec3i32::setValue(int32_t x, int32_t y, int32_t z)
 void
 SoMFVec3i32::setValue(const int32_t xyz[3])
 {
-  if (xyz == NULL) this->setNum(0);
+  if (xyz == nullptr) this->setNum(0);
   else this->setValue(SbVec3i32(xyz));
 }
 
diff --git a/coin4/src/fields/SoMFVec3s.cpp b/coin4/src/fields/SoMFVec3s.cpp
index 0a9066e..d3fe0c8 100644
--- a/coin4/src/fields/SoMFVec3s.cpp
+++ b/coin4/src/fields/SoMFVec3s.cpp
@@ -152,7 +152,7 @@ SoMFVec3s::setValue(short x, short y, short z)
 void
 SoMFVec3s::setValue(const short xyz[3])
 {
-  if (xyz == NULL) this->setNum(0);
+  if (xyz == nullptr) this->setNum(0);
   else this->setValue(SbVec3s(xyz));
 }
 
diff --git a/coin4/src/fields/SoMFVec4b.cpp b/coin4/src/fields/SoMFVec4b.cpp
index 8963b08..5e4f6d8 100644
--- a/coin4/src/fields/SoMFVec4b.cpp
+++ b/coin4/src/fields/SoMFVec4b.cpp
@@ -143,7 +143,7 @@ SoMFVec4b::setValue(int8_t x, int8_t y, int8_t z, int8_t w)
 void
 SoMFVec4b::setValue(const int8_t xyzw[4])
 {
-  if (xyzw == NULL) this->setNum(0);
+  if (xyzw == nullptr) this->setNum(0);
   else this->setValue(SbVec4b(xyzw));
 }
 
diff --git a/coin4/src/fields/SoMFVec4d.cpp b/coin4/src/fields/SoMFVec4d.cpp
index 8056341..0124573 100644
--- a/coin4/src/fields/SoMFVec4d.cpp
+++ b/coin4/src/fields/SoMFVec4d.cpp
@@ -143,7 +143,7 @@ SoMFVec4d::setValue(double x, double y, double z, double w)
 void
 SoMFVec4d::setValue(const double xyzw[4])
 {
-  if (xyzw == NULL) this->setNum(0);
+  if (xyzw == nullptr) this->setNum(0);
   else this->setValue(SbVec4d(xyzw));
 }
 
diff --git a/coin4/src/fields/SoMFVec4f.cpp b/coin4/src/fields/SoMFVec4f.cpp
index 2859e46..43d94eb 100644
--- a/coin4/src/fields/SoMFVec4f.cpp
+++ b/coin4/src/fields/SoMFVec4f.cpp
@@ -141,7 +141,7 @@ SoMFVec4f::setValue(float x, float y, float z, float w)
 void
 SoMFVec4f::setValue(const float xyzw[4])
 {
-  if (xyzw == NULL) this->setNum(0);
+  if (xyzw == nullptr) this->setNum(0);
   else this->setValue(SbVec4f(xyzw));
 }
 
diff --git a/coin4/src/fields/SoMFVec4i32.cpp b/coin4/src/fields/SoMFVec4i32.cpp
index 1801a84..c33eafe 100644
--- a/coin4/src/fields/SoMFVec4i32.cpp
+++ b/coin4/src/fields/SoMFVec4i32.cpp
@@ -143,7 +143,7 @@ SoMFVec4i32::setValue(int32_t x, int32_t y, int32_t z, int32_t w)
 void
 SoMFVec4i32::setValue(const int32_t xyzw[4])
 {
-  if (xyzw == NULL) this->setNum(0);
+  if (xyzw == nullptr) this->setNum(0);
   else this->setValue(SbVec4i32(xyzw));
 }
 
diff --git a/coin4/src/fields/SoMFVec4s.cpp b/coin4/src/fields/SoMFVec4s.cpp
index 42b5cd4..bccf381 100644
--- a/coin4/src/fields/SoMFVec4s.cpp
+++ b/coin4/src/fields/SoMFVec4s.cpp
@@ -143,7 +143,7 @@ SoMFVec4s::setValue(short x, short y, short z, short w)
 void
 SoMFVec4s::setValue(const short xyzw[4])
 {
-  if (xyzw == NULL) this->setNum(0);
+  if (xyzw == nullptr) this->setNum(0);
   else this->setValue(SbVec4s(xyzw));
 }
 
diff --git a/coin4/src/fields/SoMFVec4ub.cpp b/coin4/src/fields/SoMFVec4ub.cpp
index 10753e9..6a461f3 100644
--- a/coin4/src/fields/SoMFVec4ub.cpp
+++ b/coin4/src/fields/SoMFVec4ub.cpp
@@ -143,7 +143,7 @@ SoMFVec4ub::setValue(uint8_t x, uint8_t y, uint8_t z, uint8_t w)
 void
 SoMFVec4ub::setValue(const uint8_t xyzw[4])
 {
-  if (xyzw == NULL) this->setNum(0);
+  if (xyzw == nullptr) this->setNum(0);
   else this->setValue(SbVec4ub(xyzw));
 }
 
diff --git a/coin4/src/fields/SoMFVec4ui32.cpp b/coin4/src/fields/SoMFVec4ui32.cpp
index 7f772e9..764e08b 100644
--- a/coin4/src/fields/SoMFVec4ui32.cpp
+++ b/coin4/src/fields/SoMFVec4ui32.cpp
@@ -143,7 +143,7 @@ SoMFVec4ui32::setValue(uint32_t x, uint32_t y, uint32_t z, uint32_t w)
 void
 SoMFVec4ui32::setValue(const uint32_t xyzw[4])
 {
-  if (xyzw == NULL) this->setNum(0);
+  if (xyzw == nullptr) this->setNum(0);
   else this->setValue(SbVec4ui32(xyzw));
 }
 
diff --git a/coin4/src/fields/SoMFVec4us.cpp b/coin4/src/fields/SoMFVec4us.cpp
index 7c82206..a22f7af 100644
--- a/coin4/src/fields/SoMFVec4us.cpp
+++ b/coin4/src/fields/SoMFVec4us.cpp
@@ -143,7 +143,7 @@ SoMFVec4us::setValue(unsigned short x, unsigned short y, unsigned short z, unsig
 void
 SoMFVec4us::setValue(const unsigned short xyzw[4])
 {
-  if (xyzw == NULL) this->setNum(0);
+  if (xyzw == nullptr) this->setNum(0);
   else this->setValue(SbVec4us(xyzw));
 }
 
diff --git a/coin4/src/fields/SoMField.cpp b/coin4/src/fields/SoMField.cpp
index e4ed7d8..c982d20 100644
--- a/coin4/src/fields/SoMField.cpp
+++ b/coin4/src/fields/SoMField.cpp
@@ -280,7 +280,7 @@ using std::strlen;
 SoType SoMField::classTypeId STATIC_SOTYPE_INIT;
 
 // need one static mutex for field_buffer in SoMField::get1(SbString &)
-static void * somfield_mutex = NULL;
+static void * somfield_mutex = nullptr;
 
 static void
 somfield_mutex_cleanup(void)
@@ -301,7 +301,7 @@ SoMField::getClassTypeId(void)
 void
 SoMField::initClass(void)
 {
-  PRIVATE_FIELD_INIT_CLASS(SoMField, "MField", inherited, NULL);
+  PRIVATE_FIELD_INIT_CLASS(SoMField, "MField", inherited, nullptr);
 
   CC_MUTEX_CONSTRUCT(somfield_mutex);
   coin_atexit(somfield_mutex_cleanup, CC_ATEXIT_NORMAL);
@@ -370,7 +370,7 @@ SoMField::set1(const int index, const char * const valuestring)
   return true;
 }
 
-static void * mfield_buffer = NULL;
+static void * mfield_buffer = nullptr;
 static size_t mfield_buffer_size = 0;
 
 static void
@@ -378,7 +378,7 @@ mfield_buffer_cleanup(void)
 {
   if (mfield_buffer) {
     free(mfield_buffer);
-    mfield_buffer = NULL;
+    mfield_buffer = nullptr;
     mfield_buffer_size = 0;
   }
 }
@@ -784,7 +784,7 @@ SoMField::allocValues(int newnum)
     if (!this->userDataIsUsed) {
       delete[] static_cast<unsigned char *>(this->valuesPtr());
     }
-    this->setValuesPtr(NULL);
+    this->setValuesPtr(nullptr);
     this->userDataIsUsed = false;
     this->maxNum = 0;
   }
@@ -819,7 +819,7 @@ SoMField::allocValues(int newnum)
         (void) memcpy(newblock, this->valuesPtr(), copysize);
         // we have to dereference old values in SoMFNode, SoMFPath and
         // SoMFEngine, so we just initialize the part of the array
-        // with no defined values to NULL.
+        // with no defined values to nullptr.
         int rest = this->maxNum*fsize - copysize;
         if (rest > 0) {
           (void)memset(newblock + copysize, 0, rest);
@@ -834,7 +834,7 @@ SoMField::allocValues(int newnum)
     else {
       unsigned char * data = new unsigned char[newnum * fsize];
       // we have to dereference old values in SoMFNode, SoMFPath and
-      // SoMFEngine, so we just initialize the array to NULL.
+      // SoMFEngine, so we just initialize the array to nullptr.
       (void)memset(data, 0, newnum * fsize);
       this->setValuesPtr(data);
       this->userDataIsUsed = false;
diff --git a/coin4/src/fields/SoSFBitMask.cpp b/coin4/src/fields/SoSFBitMask.cpp
index b08daa9..e66a988 100644
--- a/coin4/src/fields/SoSFBitMask.cpp
+++ b/coin4/src/fields/SoSFBitMask.cpp
@@ -255,7 +255,7 @@ BOOST_AUTO_TEST_CASE(textinput)
   field3.setEnums(3, values2, names2);
 
   TestSuite::ResetReadErrorCount();
-  static const char * filters[] = { "Unknown SoSFBitMask bit mask value", NULL };
+  static const char * filters[] = { "Unknown SoSFBitMask bit mask value", nullptr };
   TestSuite::PushMessageSuppressFilters(filters);
   ok = field1.set("OTHER1"); // should output error
   BOOST_CHECK_MESSAGE(ok == false, "accepted 'OTHER1' erroneously");
diff --git a/coin4/src/fields/SoSFBool.cpp b/coin4/src/fields/SoSFBool.cpp
index ad2b1b0..26a004d 100644
--- a/coin4/src/fields/SoSFBool.cpp
+++ b/coin4/src/fields/SoSFBool.cpp
@@ -107,7 +107,7 @@ BOOST_AUTO_TEST_CASE(textinput)
   BOOST_CHECK_EQUAL(field.getValue(), false);
 
   TestSuite::ResetReadErrorCount();
-  static const char * filters[] = { "Invalid value", NULL };
+  static const char * filters[] = { "Invalid value", nullptr };
   TestSuite::PushMessageSuppressFilters(filters);
   ok = field.set("MAYBE"); // emits two error messages
   BOOST_CHECK_MESSAGE(ok == false, "did accept 'MAYBE'");
@@ -122,7 +122,7 @@ BOOST_AUTO_TEST_CASE(textinput)
   BOOST_CHECK_MESSAGE(ok == true, "did not accept '1'");
   BOOST_CHECK_EQUAL(field.getValue(), true);
 
-  static const char * filters2[] = { "Illegal value", NULL };
+  static const char * filters2[] = { "Illegal value", nullptr };
   TestSuite::PushMessageSuppressFilters(filters2);
   ok = field.set("2");
   BOOST_CHECK_MESSAGE(ok == false, "did accept '2'");
diff --git a/coin4/src/fields/SoSFEngine.cpp b/coin4/src/fields/SoSFEngine.cpp
index 399b081..7ccd55c 100644
--- a/coin4/src/fields/SoSFEngine.cpp
+++ b/coin4/src/fields/SoSFEngine.cpp
@@ -39,7 +39,7 @@
   operations.
 
   Note that the engine pointer stored in a field instance of this type
-  may be a \c NULL pointer.
+  may be a \c nullptr pointer.
 
   \sa SoEngine, SoMFEngine
 
@@ -83,12 +83,12 @@ SoSFEngine::initClass(void)
 // so don't use Doxygen commenting.)
 #ifndef DOXYGEN_SKIP_THIS
 
-/* Constructor, sets initial engine pointer to a \c NULL pointer. */
+/* Constructor, sets initial engine pointer to a \c nullptr pointer. */
 SoSFEngine::SoSFEngine(void)
 {
-  this->value = NULL;
+  this->value = nullptr;
 #ifdef COIN_INTERNAL_SOSFPATH
-  this->head = NULL;
+  this->head = nullptr;
 #endif // COIN_INTERNAL_SOSFPATH
 }
 
@@ -96,7 +96,7 @@ SoSFEngine::SoSFEngine(void)
 SoSFEngine::~SoSFEngine(void)
 {
   this->enableNotify(false);
-  this->setValue(NULL);
+  this->setValue(nullptr);
 }
 
 #endif // DOXYGEN_SKIP_THIS
@@ -108,7 +108,7 @@ SoSFEngine::~SoSFEngine(void)
 #ifndef DOXYGEN_SKIP_THIS
 
 // Store the \a newval engine pointer in this field. If \a newval is not
-// \c NULL, will add 1 to the reference count of the engine.
+// \c nullptr, will add 1 to the reference count of the engine.
 void
 SoSFEngine::setValue(SoEngine * newval)
 {
@@ -215,7 +215,7 @@ SoSFEngine::countWriteRefs(SoOutput * out) const
   inherited::countWriteRefs(out);
 
   SoBase * base = this->getValue();
-  if (base == NULL) return;
+  if (base == nullptr) return;
 
   // NB: This code is common for SoSFNode, SoSFPath and SoSFEngine.
   // That's why we check the base type before writing/counting
@@ -291,7 +291,7 @@ SoSFEngine::referencesCopy(void) const
   }
   else if (n->isOfType(SoPath::getClassTypeId())) {
     SoPath * p = coin_assert_cast<SoPath *>(n);
-    if (p->getHead() == NULL) return false;
+    if (p->getHead() == nullptr) return false;
     if (SoFieldContainer::checkCopy(p->getHead())) return true;
   }
   else {
diff --git a/coin4/src/fields/SoSFEnum.cpp b/coin4/src/fields/SoSFEnum.cpp
index 825a43e..34ba8b6 100644
--- a/coin4/src/fields/SoSFEnum.cpp
+++ b/coin4/src/fields/SoSFEnum.cpp
@@ -94,8 +94,8 @@ PRIVATE_EQUALITY_SOURCE(SoSFEnum);
 /* Constructor. */
 SoSFEnum::SoSFEnum(void)
 {
-  this->enumValues = NULL;
-  this->enumNames  = NULL;
+  this->enumValues = nullptr;
+  this->enumNames  = nullptr;
   this->numEnums = 0;
   this->legalValuesSet = false;
 }
diff --git a/coin4/src/fields/SoSFImage.cpp b/coin4/src/fields/SoSFImage.cpp
index 245f1f3..194e5b9 100644
--- a/coin4/src/fields/SoSFImage.cpp
+++ b/coin4/src/fields/SoSFImage.cpp
@@ -125,8 +125,8 @@ class SoSFImageP {
 public:
   SoSFImageP(void) {
     this->image = new SbImage;
-    this->freeimage = NULL;
-    this->deleteimage = NULL;
+    this->freeimage = nullptr;
+    this->deleteimage = nullptr;
   }
   ~SoSFImageP() {
     delete this->image;
@@ -219,12 +219,12 @@ SoSFImage::readValue(SoInput * in)
 #endif // debug
 
   if (!buffersize) {
-    PRIVATE(this)->image->setValue(SbVec2s(0,0), 0, NULL);
+    PRIVATE(this)->image->setValue(SbVec2s(0,0), 0, nullptr);
     return true;
   }
 
   // allocate image data and get new pointer back
-  PRIVATE(this)->image->setValue(size, nc, NULL);
+  PRIVATE(this)->image->setValue(size, nc, nullptr);
   unsigned char * pixblock = PRIVATE(this)->image->getValue(size, nc);
 
   // The binary image format of 2.1 and later tries to be less
@@ -351,10 +351,10 @@ SoSFImage::getValue() const
 /*!
   Initialize this field to \a size and \a nc.
 
-  If \a pixels is not \c NULL, the image data is copied from \a pixels
-  into this field.  If \a pixels is \c NULL, the image data is cleared
+  If \a pixels is not \c nullptr, the image data is copied from \a pixels
+  into this field.  If \a pixels is \c nullptr, the image data is cleared
   by setting all bytes to 0 (note that the behavior on passing a \c
-  NULL pointer is specific for Coin, Open Inventor will crash if you
+  nullptr pointer is specific for Coin, Open Inventor will crash if you
   try it).
 
   The image dimensions is given by the \a size argument, and the \a nc
@@ -389,11 +389,11 @@ SoSFImage::setValue(const SbVec2s & size, const int nc,
   // free old data
   if (PRIVATE(this)->freeimage) {
     free(PRIVATE(this)->freeimage);
-    PRIVATE(this)->freeimage = NULL;
+    PRIVATE(this)->freeimage = nullptr;
   }
   if (PRIVATE(this)->deleteimage) {
     delete[] PRIVATE(this)->deleteimage;
-    PRIVATE(this)->deleteimage = NULL;
+    PRIVATE(this)->deleteimage = nullptr;
   }
   // set new data
   switch (copypolicy) {
@@ -511,7 +511,7 @@ SoSFImage::getSubTexture(
   SoDebugError::postWarning("SoSFImage::getSubTexture",
                             "Not yet implemented for Coin. "
                             "Get in touch if you need this functionality.");
-  return NULL;
+  return nullptr;
 }
 
 /*!
diff --git a/coin4/src/fields/SoSFImage3.cpp b/coin4/src/fields/SoSFImage3.cpp
index 6a20f84..a81e96a 100644
--- a/coin4/src/fields/SoSFImage3.cpp
+++ b/coin4/src/fields/SoSFImage3.cpp
@@ -191,12 +191,12 @@ SoSFImage3::readValue(SoInput * in)
 #endif // debug
 
   if (!buffersize) {
-    this->image->setValue(SbVec3s(0,0,0), 0, NULL);
+    this->image->setValue(SbVec3s(0,0,0), 0, nullptr);
     return true;
   }
 
   // allocate image data and get new pointer back
-  this->image->setValue(size, nc, NULL);
+  this->image->setValue(size, nc, nullptr);
   unsigned char * pixblock = this->image->getValue(size, nc);
 
   // The binary image format of 2.1 and later tries to be less
@@ -304,10 +304,10 @@ SoSFImage3::getValue(SbVec3s & size, int & nc) const
 /*!
   Initialize this field to \a size and \a nc.
 
-  If \a bytes is not \c NULL, the image data is copied from \a bytes
-  into this field.  If \a bytes is \c NULL, the image data is cleared
+  If \a bytes is not \c nullptr, the image data is copied from \a bytes
+  into this field.  If \a bytes is \c nullptr, the image data is cleared
   by setting all bytes to 0 (note that the behavior on passing a \c
-  NULL pointer is specific for Coin, Open Inventor will crash if you
+  nullptr pointer is specific for Coin, Open Inventor will crash if you
   try it).
 */
 void
diff --git a/coin4/src/fields/SoSFNode.cpp b/coin4/src/fields/SoSFNode.cpp
index a613b5a..c1647bd 100644
--- a/coin4/src/fields/SoSFNode.cpp
+++ b/coin4/src/fields/SoSFNode.cpp
@@ -40,7 +40,7 @@
   operations.
 
   Note that the node pointer stored in a field instance of this type
-  may be a \c NULL pointer.
+  may be a \c nullptr pointer.
 
   \sa SoNode, SoMFNode
 
@@ -84,12 +84,12 @@ SoSFNode::initClass(void)
 // so don't use Doxygen commenting.)
 #ifndef DOXYGEN_SKIP_THIS
 
-/* Constructor, sets initial node pointer to a \c NULL pointer. */
+/* Constructor, sets initial node pointer to a \c nullptr pointer. */
 SoSFNode::SoSFNode(void)
 {
-  this->value = NULL;
+  this->value = nullptr;
 #ifdef COIN_INTERNAL_SOSFPATH
-  this->head = NULL;
+  this->head = nullptr;
 #endif // COIN_INTERNAL_SOSFPATH
 }
 
@@ -97,7 +97,7 @@ SoSFNode::SoSFNode(void)
 SoSFNode::~SoSFNode(void)
 {
   this->enableNotify(false);
-  this->setValue(NULL);
+  this->setValue(nullptr);
 }
 
 #endif // DOXYGEN_SKIP_THIS
@@ -109,7 +109,7 @@ SoSFNode::~SoSFNode(void)
 #ifndef DOXYGEN_SKIP_THIS
 
 // Store the \a newval node pointer in this field. If \a newval is not
-// \c NULL, will add 1 to the reference count of the node.
+// \c nullptr, will add 1 to the reference count of the node.
 void
 SoSFNode::setValue(SoNode * newval)
 {
@@ -168,15 +168,15 @@ SoSFNode::readValue(SoInput * in)
   SoBase * baseptr;
   bool isVRMLspecialCase = false;
 
-  // Note: do *not* simply check for baseptr==NULL here, as that is a
+  // Note: do *not* simply check for baseptr==nullptr here, as that is a
   // valid condition for VRML97 files, where nodes can indeed be
-  // explicitly given as a NULL value. See the 'vrml97nullchild' test
+  // explicitly given as a nullptr value. See the 'vrml97nullchild' test
   // case near the end of this file for a valid case that would fail.
   if(in->isFileVRML1() || in->isFileVRML2()) {
     SbName name;
     in->read(name, true);
     if (name == "NULL") {
-      baseptr = NULL;
+      baseptr = nullptr;
       isVRMLspecialCase = true;
     }
     else {
@@ -186,7 +186,7 @@ SoSFNode::readValue(SoInput * in)
 
   if (!isVRMLspecialCase) {
     if (!SoBase::read(in, baseptr, SoNode::getClassTypeId())) return false;
-    if (baseptr == NULL) {
+    if (baseptr == nullptr) {
       SoReadError::post(in, "Invalid node specification");
       return false;
     }
@@ -197,7 +197,7 @@ SoSFNode::readValue(SoInput * in)
     return false;
   }
 
-  if (baseptr != NULL) {
+  if (baseptr != nullptr) {
     this->setValue(coin_safe_cast<SoNode *>(baseptr));
   }
   return true;
diff --git a/coin4/src/fields/SoSFPath.cpp b/coin4/src/fields/SoSFPath.cpp
index 75ef2d5..f7a1572 100644
--- a/coin4/src/fields/SoSFPath.cpp
+++ b/coin4/src/fields/SoSFPath.cpp
@@ -41,7 +41,7 @@
   operations.
 
   Note that the path pointer stored in a field instance of this type
-  may be a \c NULL pointer.
+  may be a \c nullptr pointer.
 
   \sa SoPath, SoMFPath
 
@@ -86,12 +86,12 @@ SoSFPath::initClass(void)
 // so don't use Doxygen commenting.)
 #ifndef DOXYGEN_SKIP_THIS
 
-/* Constructor, sets initial path pointer to a \c NULL pointer. */
+/* Constructor, sets initial path pointer to a \c nullptr pointer. */
 SoSFPath::SoSFPath(void)
 {
-  this->value = NULL;
+  this->value = nullptr;
 #ifdef COIN_INTERNAL_SOSFPATH
-  this->head = NULL;
+  this->head = nullptr;
 #endif // COIN_INTERNAL_SOSFPATH
 }
 
@@ -99,7 +99,7 @@ SoSFPath::SoSFPath(void)
 SoSFPath::~SoSFPath(void)
 {
   this->enableNotify(false);
-  this->setValue(NULL);
+  this->setValue(nullptr);
 }
 
 #endif // DOXYGEN_SKIP_THIS
@@ -111,7 +111,7 @@ SoSFPath::~SoSFPath(void)
 #ifndef DOXYGEN_SKIP_THIS
 
 // Store the \a newval path pointer in this field. If \a newval is not
-// \c NULL, will add 1 to the reference count of the path.
+// \c nullptr, will add 1 to the reference count of the path.
 void
 SoSFPath::setValue(SoPath * newval)
 {
@@ -169,13 +169,13 @@ SoSFPath::readValue(SoInput * in)
 {
   SoBase * baseptr;
 
-  //Handle when the path is set to NULL
+  //Handle when the path is set to nullptr
   SbName keyword;
   if (in)
     if (!in->read(keyword)) return false;
   
   if(keyword=="NULL") {
-    this->setValue(NULL);
+    this->setValue(nullptr);
     return true;
   }
   else
@@ -235,7 +235,7 @@ SoSFPath::countWriteRefs(SoOutput * out) const
   inherited::countWriteRefs(out);
 
   SoBase * base = this->getValue();
-  if (base == NULL) return;
+  if (base == nullptr) return;
 
   // NB: This code is common for SoSFNode, SoSFPath and SoSFEngine.
   // That's why we check the base type before writing/counting
@@ -311,7 +311,7 @@ SoSFPath::referencesCopy(void) const
   }
   else if (n->isOfType(SoPath::getClassTypeId())) {
     SoPath * p = coin_assert_cast<SoPath *>(n);
-    if (p->getHead() == NULL) return false;
+    if (p->getHead() == nullptr) return false;
     if (SoFieldContainer::checkCopy(p->getHead())) return true;
   }
   else {
diff --git a/coin4/src/fields/SoSFVec4us.cpp b/coin4/src/fields/SoSFVec4us.cpp
index 432c6a9..8295d17 100644
--- a/coin4/src/fields/SoSFVec4us.cpp
+++ b/coin4/src/fields/SoSFVec4us.cpp
@@ -119,7 +119,7 @@ BOOST_AUTO_TEST_CASE(textinput)
   SoSFVec4us field;
   field.set("1 2 3 4");
   BOOST_CHECK_EQUAL(field.getValue(), SbVec4us(1, 2, 3, 4));
-  const char * filters[] = { "read error", NULL }; // all read error messages
+  const char * filters[] = { "read error", nullptr }; // all read error messages
   TestSuite::ResetReadErrorCount();
   // TestSuite::PushMessageSuppressFilters(filters);
   bool ok;
diff --git a/coin4/src/fields/SoSField.cpp b/coin4/src/fields/SoSField.cpp
index 527f314..d8c16ae 100644
--- a/coin4/src/fields/SoSField.cpp
+++ b/coin4/src/fields/SoSField.cpp
@@ -122,7 +122,7 @@ SoSField::~SoSField()
 void
 SoSField::initClass(void)
 {
-  PRIVATE_FIELD_INIT_CLASS(SoSField, "SField", inherited, NULL);
+  PRIVATE_FIELD_INIT_CLASS(SoSField, "SField", inherited, nullptr);
 }
 
 void
diff --git a/coin4/src/fonts/coretext.cpp b/coin4/src/fonts/coretext.cpp
index 1a9c300..d5c92fe 100644
--- a/coin4/src/fonts/coretext.cpp
+++ b/coin4/src/fonts/coretext.cpp
@@ -58,7 +58,7 @@ cc_flwct_exit(void)
 void *
 cc_flwct_get_font(const char * fontname, unsigned int pixelsize)
 {
-  return NULL;
+  return nullptr;
 }
 
 void
@@ -121,13 +121,13 @@ cc_flwct_done_glyph(void * font, int glyph)
 struct cc_font_bitmap *
 cc_flwct_get_bitmap(void * font, unsigned int glyph)
 {
-  return NULL;
+  return nullptr;
 }
 
 struct cc_font_vector_glyph *
 cc_flwct_get_vector_glyph(void * font, unsigned int glyphindex, float complexity)
 {
-  return NULL;
+  return nullptr;
 }
 
 #endif /* HAVE_CORETEXT */
diff --git a/coin4/src/fonts/extractfont.cpp b/coin4/src/fonts/extractfont.cpp
index 47154ba..77e3190 100644
--- a/coin4/src/fonts/extractfont.cpp
+++ b/coin4/src/fonts/extractfont.cpp
@@ -26,8 +26,8 @@
 int
 main(int argc, char ** argv)
 {
-  setbuf(stdout, NULL);
-  setbuf(stderr, NULL);
+  setbuf(stdout, nullptr);
+  setbuf(stderr, nullptr);
 
   static unsigned char charset[256];
   int c;
@@ -84,7 +84,7 @@ main(int argc, char ** argv)
   fprintf(stderr, "chars/line:  %d\n", charsperline);
 
 
-  s_image * image = s_image_load(imgfile, NULL);
+  s_image * image = s_image_load(imgfile, nullptr);
 
   if ( !image ) {
     printf("error: could not open file %s\n", imgfile);
diff --git a/coin4/src/fonts/fontlib_wrapper.cpp b/coin4/src/fonts/fontlib_wrapper.cpp
index ccd1315..9c5bd31 100644
--- a/coin4/src/fonts/fontlib_wrapper.cpp
+++ b/coin4/src/fonts/fontlib_wrapper.cpp
@@ -56,7 +56,7 @@
   modules (as they won't have to be made reentrant in any way).
 */
 
-static void * flw_global_lock = NULL;
+static void * flw_global_lock = nullptr;
 static int flw_global_font_index = 0;
 static bool initialized = false;
 static bool tried_init_freetype_fontlib = false;
@@ -126,7 +126,7 @@ struct cc_flw_font {
   int refcount;
 };
 
-static cc_dynarray * fontarray = NULL;
+static cc_dynarray * fontarray = nullptr;
 
 /* ********************************************************************** */
 
@@ -261,14 +261,14 @@ get_default_bitmap(unsigned int character, float wantedsize)
     bm->mono = 1;
     return bm;
   }
-  return NULL;
+  return nullptr;
 }
 
 static struct cc_flw_glyph *
 flw_glyphidx2glyphptr(struct cc_flw_font * fs, unsigned int glyphidx)
 {
   void * tmp;
-  struct cc_flw_glyph * gs = NULL;
+  struct cc_flw_glyph * gs = nullptr;
 
   if (cc_dict_get(fs->glyphdict, glyphidx, &tmp)) {
     gs = (struct cc_flw_glyph *) tmp;
@@ -313,7 +313,7 @@ fontstruct_rmfont(int font)
 {
   int i, n;
   int arrayindex;
-  struct cc_flw_font * fs = NULL;
+  struct cc_flw_font * fs = nullptr;
 
   n = cc_dynarray_length(fontarray);
   for (i = 0; i < n; i++) {
@@ -335,7 +335,7 @@ fontstruct_rmfont(int font)
 static struct cc_flw_font *
 flw_fontidx2fontptr(int fontidx)
 {
-  struct cc_flw_font * fs = NULL;
+  struct cc_flw_font * fs = nullptr;
   int i, n;
 
   n = (int) cc_dynarray_length(fontarray);
@@ -379,7 +379,7 @@ flw_exit(void)
 
   cc_dynarray_destruct(fontarray);
 
-  fontarray = NULL;
+  fontarray = nullptr;
   initialized = false;
 
   tried_init_freetype_fontlib = tried_init_win32_fontlib = false;
@@ -437,7 +437,7 @@ flw_find_font(const char * fontname, const unsigned int sizey,
      flw_initialize() is re-entrant, so this should be safe in a
      multithreaded environment.
   */
-  if (flw_global_lock == NULL) { flw_initialize(); }
+  if (flw_global_lock == nullptr) { flw_initialize(); }
 
   FLW_MUTEX_LOCK(flw_global_lock);
 
@@ -537,7 +537,7 @@ cc_flw_get_font_id(const char * fontname, unsigned int sizey,
 
   if (idx != -1) { return idx; }
 
-  font = NULL;
+  font = nullptr;
 
   FLW_MUTEX_LOCK(flw_global_lock);
 
@@ -626,12 +626,12 @@ cc_flw_get_glyph(int font, unsigned int character)
   gs = flw_glyphidx2glyphptr(fs, character);
 
   /* FIXME: should this perhaps rather be an assert()? 20050623 mortene. */
-  if (gs == NULL) {
+  if (gs == nullptr) {
 
     gs = (struct cc_flw_glyph *)malloc(sizeof(struct cc_flw_glyph));
     gs->character = character;
-    gs->bitmap = NULL;
-    gs->vector = NULL;
+    gs->bitmap = nullptr;
+    gs->vector = nullptr;
     /* These will be changed below if the glyph is found in a
        non-default font: */
     gs->nativeglyphidx = character;
@@ -848,7 +848,7 @@ cc_flw_get_bitmap(int font, unsigned int glyph)
   unsigned char * buf;
   struct cc_flw_font * fs;
   struct cc_flw_glyph * gs;
-  struct cc_font_bitmap * bm = NULL;
+  struct cc_font_bitmap * bm = nullptr;
   unsigned int i;
 
   FLW_MUTEX_LOCK(flw_global_lock);
@@ -857,7 +857,7 @@ cc_flw_get_bitmap(int font, unsigned int glyph)
   gs = flw_glyphidx2glyphptr(fs, glyph);
   assert(gs);
 
-  if (gs->bitmap == NULL) {
+  if (gs->bitmap == nullptr) {
 
     if (!gs->fromdefaultfont) {
       if (using_win32api()) {
@@ -905,8 +905,8 @@ cc_flw_get_vector_glyph(int font, unsigned int glyph)
   gs = flw_glyphidx2glyphptr(fs, glyph);
   assert(gs);
 
-  if (gs->vector == NULL && !gs->fromdefaultfont) {
-    struct cc_font_vector_glyph * vector_glyph = NULL;
+  if (gs->vector == nullptr && !gs->fromdefaultfont) {
+    struct cc_font_vector_glyph * vector_glyph = nullptr;
 
     if (using_freetype()) {
       vector_glyph = cc_flwft_get_vector_glyph(fs->nativefonthandle,
diff --git a/coin4/src/fonts/freetype.cpp b/coin4/src/fonts/freetype.cpp
index 4b5533d..5649425 100644
--- a/coin4/src/fonts/freetype.cpp
+++ b/coin4/src/fonts/freetype.cpp
@@ -68,13 +68,13 @@ extern "C" {
 bool cc_flwft_initialize(void) { return false; }
 void cc_flwft_exit(void) { }
 
-void * cc_flwft_get_font(const char * fontname, const unsigned int pixelsize) { assert(false); return NULL; }
+void * cc_flwft_get_font(const char * fontname, const unsigned int pixelsize) { assert(false); return nullptr; }
 void cc_flwft_get_font_name(void * font, cc_string * str) { assert(false); }
 void cc_flwft_done_font(void * font) { assert(false); }
 
 
 int cc_flwft_get_num_charmaps(void * font) { assert(false); return 0; }
-const char * cc_flwft_get_charmap_name(void * font, int charmap) { assert(false); return NULL; }
+const char * cc_flwft_get_charmap_name(void * font, int charmap) { assert(false); return nullptr; }
 void cc_flwft_set_charmap(void * font, int charmap) { assert(false); }
 void cc_flwft_set_char_size(void * font, int height) { assert(false); }
 
@@ -87,8 +87,8 @@ void cc_flwft_get_vector_kerning(void * font, int glyph1, int glyph2, float *x,
 void cc_flwft_get_bitmap_kerning(void * font, int glyph1, int glyph2, int *x, int *y) { assert(false); }
 void cc_flwft_done_glyph(void * font, int glyph) { assert(false); }
 
-struct cc_font_bitmap * cc_flwft_get_bitmap(void * font, unsigned int glyph) { assert(false); return NULL; }
-struct cc_font_vector_glyph * cc_flwft_get_vector_glyph(void * font, unsigned int glyph, float complexity) { assert(false); return NULL; }
+struct cc_font_bitmap * cc_flwft_get_bitmap(void * font, unsigned int glyph) { assert(false); return nullptr; }
+struct cc_font_vector_glyph * cc_flwft_get_vector_glyph(void * font, unsigned int glyph, float complexity) { assert(false); return nullptr; }
 
 void cc_flwft_scale_vector_glyph_coords(struct cc_font_vector_glyph * vecglyph, float factor){ assert(false); }
 
@@ -254,7 +254,7 @@ static FT_Library library;
 /* Built-in mappings from font names to font file names.
 
    First item is a generic font name, then comes a list of possible
-   file names (in sorted order of priority), then a NULL pointer, then
+   file names (in sorted order of priority), then a nullptr pointer, then
    a new generic font name, etc.
 */
 static const char * fontfilenames[] = {
@@ -277,64 +277,64 @@ static const char * fontfilenames[] = {
     20030901 mortene.
    */
 
-  "Arial", "arial.ttf", NULL,
-  "Arial Bold", "arialbd.ttf", NULL,
-  "Arial Bold Italic", "arialbi.ttf", NULL,
-  "Arial Italic", "ariali.ttf", NULL,
-  "Century Gothic", "gothic.ttf", NULL,
-  "Century Gothic Bold", "gothicb.ttf", NULL,
-  "Century Gothic Bold Italic", "gothicbi.ttf", NULL,
-  "Century Gothic Italic", "gothici.ttf", NULL,
-  "Courier", "cour.ttf", NULL,
-  "Courier Bold", "courbd.ttf", NULL,
-  "Courier Bold Italic", "courbi.ttf", NULL,
-  "Courier Italic", "couri.ttf", NULL,
-  "Simian", "simtoran.ttf", "simtgori.ttf", "simtchimp.ttf", NULL,
-  "Times New Roman", "times.ttf", NULL,
-  "Times New Roman Bold", "timesbd.ttf", NULL,
-  "Times New Roman Bold Italic", "timesbi.ttf", NULL,
-  "Times New Roman Italic", "timesi.ttf", NULL,
-  "Verdana", "verdana.ttf", NULL,
-  "Verdana Bold", "verdanab.ttf", NULL,
-  "Verdana Bold Italic", "verdanaz.ttf", NULL,
-  "Verdana Italic", "verdanai.ttf", NULL,
-  "OpenSymbol", "opens___.ttf", NULL,
-  "Small", "smalle.fon", NULL,
+  "Arial", "arial.ttf", nullptr,
+  "Arial Bold", "arialbd.ttf", nullptr,
+  "Arial Bold Italic", "arialbi.ttf", nullptr,
+  "Arial Italic", "ariali.ttf", nullptr,
+  "Century Gothic", "gothic.ttf", nullptr,
+  "Century Gothic Bold", "gothicb.ttf", nullptr,
+  "Century Gothic Bold Italic", "gothicbi.ttf", nullptr,
+  "Century Gothic Italic", "gothici.ttf", nullptr,
+  "Courier", "cour.ttf", nullptr,
+  "Courier Bold", "courbd.ttf", nullptr,
+  "Courier Bold Italic", "courbi.ttf", nullptr,
+  "Courier Italic", "couri.ttf", nullptr,
+  "Simian", "simtoran.ttf", "simtgori.ttf", "simtchimp.ttf", nullptr,
+  "Times New Roman", "times.ttf", nullptr,
+  "Times New Roman Bold", "timesbd.ttf", nullptr,
+  "Times New Roman Bold Italic", "timesbi.ttf", nullptr,
+  "Times New Roman Italic", "timesi.ttf", nullptr,
+  "Verdana", "verdana.ttf", nullptr,
+  "Verdana Bold", "verdanab.ttf", nullptr,
+  "Verdana Bold Italic", "verdanaz.ttf", nullptr,
+  "Verdana Italic", "verdanai.ttf", nullptr,
+  "OpenSymbol", "opens___.ttf", nullptr,
+  "Small", "smalle.fon", nullptr,
 
   /* These are the TrueType fonts installed from the Debian Linux
      "msttcorefonts" package, as of version 1.1.2. */
-  "Andale Mono", "Andale_Mono.ttf", NULL,
-  "Arial", "Arial.ttf", NULL,
-  "Arial Black", "Arial_Black.ttf", NULL,
-  "Arial Bold", "Arial_Bold.ttf", NULL,
-  "Arial Bold Italic", "Arial_Bold_Italic.ttf", NULL,
-  "Arial Italic", "Arial_Italic.ttf", NULL,
-  "Comic Sans MS", "Comic_Sans_MS.ttf", NULL,
-  "Comic Sans MS Bold", "Comic_Sans_MS_Bold.ttf", NULL,
-  "Courier", "Courier_New.ttf", NULL,
-  "Courier New", "Courier_New.ttf", NULL,
-  "Courier New Bold", "Courier_New_Bold.ttf", NULL,
-  "Courier New Bold Italic", "Courier_New_Bold_Italic.ttf", NULL,
-  "Courier New Italic", "Courier_New_Italic.ttf", NULL,
-  "Georgia", "Georgia.ttf", NULL,
-  "Georgia Bold", "Georgia_Bold.ttf", NULL,
-  "Georgia Bold Italic", "Georgia_Bold_Italic.ttf", NULL,
-  "Georgia Italic", "Georgia_Italic.ttf", NULL,
-  "Impact", "Impact.ttf", NULL,
-  "Times", "Times_New_Roman.ttf", NULL,
-  "Times New Roman", "Times_New_Roman.ttf", NULL,
-  "Times New Roman Bold", "Times_New_Roman_Bold.ttf", NULL,
-  "Times New Roman Bold Italic", "Times_New_Roman_Bold_Italic.ttf", NULL,
-  "Times New Roman Italic", "Times_New_Roman_Italic.ttf", NULL,
-  "Trebuchet MS", "Trebuchet_MS.ttf", NULL,
-  "Trebuchet MS Bold", "Trebuchet_MS_Bold.ttf", NULL,
-  "Trebuchet MS Bold Italic", "Trebuchet_MS_Bold_Italic.ttf", NULL,
-  "Trebuchet MS Italic", "Trebuchet_MS_Italic.ttf", NULL,
-  "Verdana", "Verdana.ttf", NULL,
-  "Verdana Bold", "Verdana_Bold.ttf", NULL,
-  "Verdana Bold Italic", "Verdana_Bold_Italic.ttf", NULL,
-  "Verdana Italic", "Verdana_Italic.ttf", NULL,
-  "Webdings", "Webdings.ttf", NULL
+  "Andale Mono", "Andale_Mono.ttf", nullptr,
+  "Arial", "Arial.ttf", nullptr,
+  "Arial Black", "Arial_Black.ttf", nullptr,
+  "Arial Bold", "Arial_Bold.ttf", nullptr,
+  "Arial Bold Italic", "Arial_Bold_Italic.ttf", nullptr,
+  "Arial Italic", "Arial_Italic.ttf", nullptr,
+  "Comic Sans MS", "Comic_Sans_MS.ttf", nullptr,
+  "Comic Sans MS Bold", "Comic_Sans_MS_Bold.ttf", nullptr,
+  "Courier", "Courier_New.ttf", nullptr,
+  "Courier New", "Courier_New.ttf", nullptr,
+  "Courier New Bold", "Courier_New_Bold.ttf", nullptr,
+  "Courier New Bold Italic", "Courier_New_Bold_Italic.ttf", nullptr,
+  "Courier New Italic", "Courier_New_Italic.ttf", nullptr,
+  "Georgia", "Georgia.ttf", nullptr,
+  "Georgia Bold", "Georgia_Bold.ttf", nullptr,
+  "Georgia Bold Italic", "Georgia_Bold_Italic.ttf", nullptr,
+  "Georgia Italic", "Georgia_Italic.ttf", nullptr,
+  "Impact", "Impact.ttf", nullptr,
+  "Times", "Times_New_Roman.ttf", nullptr,
+  "Times New Roman", "Times_New_Roman.ttf", nullptr,
+  "Times New Roman Bold", "Times_New_Roman_Bold.ttf", nullptr,
+  "Times New Roman Bold Italic", "Times_New_Roman_Bold_Italic.ttf", nullptr,
+  "Times New Roman Italic", "Times_New_Roman_Italic.ttf", nullptr,
+  "Trebuchet MS", "Trebuchet_MS.ttf", nullptr,
+  "Trebuchet MS Bold", "Trebuchet_MS_Bold.ttf", nullptr,
+  "Trebuchet MS Bold Italic", "Trebuchet_MS_Bold_Italic.ttf", nullptr,
+  "Trebuchet MS Italic", "Trebuchet_MS_Italic.ttf", nullptr,
+  "Verdana", "Verdana.ttf", nullptr,
+  "Verdana Bold", "Verdana_Bold.ttf", nullptr,
+  "Verdana Bold Italic", "Verdana_Bold_Italic.ttf", nullptr,
+  "Verdana Italic", "Verdana_Italic.ttf", nullptr,
+  "Webdings", "Webdings.ttf", nullptr
 };
 
   struct cc_flwft_globals {
@@ -343,7 +343,7 @@ static const char * fontfilenames[] = {
   };
 
   static struct cc_flwft_globals cc_flwft_globals = {
-    NULL, NULL
+    nullptr, nullptr
   };
 
 /* ************************************************************************* */
@@ -360,7 +360,7 @@ cc_flwft_initialize(void)
   error = cc_ftglue_FT_Init_FreeType(&library);
   if (error) {
     if (cc_font_debug()) cc_debugerror_post("cc_flwft_initialize", "error %d", error);
-    library = NULL;
+    library = nullptr;
     return false;
   }
 
@@ -375,10 +375,10 @@ cc_flwft_initialize(void)
                        "Version of Freetype 2 library is < 2.1 "
                        "Font rendering is disabled.");
     cc_ftglue_FT_Done_FreeType(library);
-    library = NULL;
+    library = nullptr;
     return false;
   }
-  assert((cc_flwft_globals.fontname2filename == NULL) && "call cc_flwft_initialize only once!");
+  assert((cc_flwft_globals.fontname2filename == nullptr) && "call cc_flwft_initialize only once!");
 
   /* Set up hash of font name to array of file name mappings. */
   cc_flwft_globals.fontname2filename = cc_dict_construct(50, 0.75);
@@ -400,7 +400,7 @@ cc_flwft_initialize(void)
         assert(unused);
       }
 
-      while (fontfilenames[++i] != NULL) {
+      while (fontfilenames[++i] != nullptr) {
         cc_dynarray_append(array, (void *)fontfilenames[i]);
       }
 
@@ -414,14 +414,14 @@ cc_flwft_initialize(void)
     char * str;
     cc_flwft_globals.fontfiledirs = cc_dynarray_new();
 
-    if ((env = coin_getenv("COIN_FONT_PATH")) != NULL) {
+    if ((env = coin_getenv("COIN_FONT_PATH")) != nullptr) {
       str = strdup(env);
       assert(str);
       cc_dynarray_append(cc_flwft_globals.fontfiledirs, str);
     }
 
 #ifdef _WIN32
-    if ((env = coin_getenv("WINDIR")) != NULL) {
+    if ((env = coin_getenv("WINDIR")) != nullptr) {
       cc_string fullpath;
       cc_string_construct(&fullpath);
 
@@ -443,10 +443,10 @@ cc_flwft_initialize(void)
   }
 
   /* Setup temporary glyph-struct used during tessellation */
-  flwft_tessellator.vertexlist = NULL;
-  flwft_tessellator.faceindexlist = NULL;
-  flwft_tessellator.edgeindexlist = NULL;
-  flwft_tessellator.malloclist = NULL;
+  flwft_tessellator.vertexlist = nullptr;
+  flwft_tessellator.faceindexlist = nullptr;
+  flwft_tessellator.edgeindexlist = nullptr;
+  flwft_tessellator.malloclist = nullptr;
 
   return true;
 }
@@ -468,26 +468,26 @@ cc_flwft_exit(void)
     free(cc_dynarray_get(cc_flwft_globals.fontfiledirs, i));
   }
   cc_dynarray_destruct(cc_flwft_globals.fontfiledirs);
-  cc_flwft_globals.fontfiledirs = NULL;
+  cc_flwft_globals.fontfiledirs = nullptr;
 
-  cc_dict_apply(cc_flwft_globals.fontname2filename, clean_fontmap_hash, NULL);
+  cc_dict_apply(cc_flwft_globals.fontname2filename, clean_fontmap_hash, nullptr);
   cc_dict_destruct(cc_flwft_globals.fontname2filename);
-  cc_flwft_globals.fontname2filename = NULL;
+  cc_flwft_globals.fontname2filename = nullptr;
 
   cc_ftglue_FT_Done_FreeType(library);
-  library = NULL;
+  library = nullptr;
 }
 
 static const char *
 find_font_file(const char * fontname, unsigned int pixelsize)
 {
-  const char * foundfile = NULL;
+  const char * foundfile = nullptr;
 
   /* use fontconfig to locate fonts if available */
   if (cc_fcglue_available()) {
-    unsigned char * filename = NULL;
-    FcPattern * font_pattern = NULL;
-    FcPattern * matched_pattern = NULL;
+    unsigned char * filename = nullptr;
+    FcPattern * font_pattern = nullptr;
+    FcPattern * matched_pattern = nullptr;
     FcResult result;
 
     /* parse the fontname string to create a fontconfig pattern instance */
@@ -495,7 +495,7 @@ find_font_file(const char * fontname, unsigned int pixelsize)
       cc_debugerror_postinfo("find_font_file",
                              "fontname '%s' could not be parsed by fontconfig",
                              fontname);
-      return NULL;
+      return nullptr;
     }
 
     /* add the requested size to the pattern in order to pick up the correct font
@@ -503,7 +503,7 @@ find_font_file(const char * fontname, unsigned int pixelsize)
     if (!cc_fcglue_FcPatternAddDouble(font_pattern, FC_PIXEL_SIZE, pixelsize)) {
       cc_debugerror_postinfo("find_font_file",
                              "cc_fcglue_FcPatternAddDouble failed");
-      return NULL;
+      return nullptr;
     }
 
     /* next two steps mandatory for fontconfig's FcFontMatch call
@@ -512,10 +512,10 @@ find_font_file(const char * fontname, unsigned int pixelsize)
      * given by the user not taken out. */
 
     /* apply pattern modification operations for those tagged as such */
-    if (!cc_fcglue_FcConfigSubstitute(NULL, font_pattern, FcMatchPattern)) {
+    if (!cc_fcglue_FcConfigSubstitute(nullptr, font_pattern, FcMatchPattern)) {
       cc_debugerror_postinfo("find_font_file",
                              "cc_fcglue_FcConfigSubstitute failed");
-      return NULL;
+      return nullptr;
     }
 
     /* supply default values for underspecified font patterns */
@@ -529,17 +529,17 @@ find_font_file(const char * fontname, unsigned int pixelsize)
      * visually impaired (like me...). 20040410 tamer. */
 
     /* return the font most close matching the provided pattern */
-    if (!(matched_pattern = cc_fcglue_FcFontMatch(NULL, font_pattern, &result))) {
+    if (!(matched_pattern = cc_fcglue_FcFontMatch(nullptr, font_pattern, &result))) {
       cc_debugerror_postinfo("cc_fcglue_find_font_file",
                              "cc_fcglue_FcFontMatch failed");
-      return NULL;
+      return nullptr;
     }
 
     /* get the filename entry out of the pattern */
     if (cc_fcglue_FcPatternGetString(matched_pattern, "file", 0, &filename) != FcResultMatch) {
       cc_debugerror_postinfo("find_font_file",
                              "cc_fcglue_FcPatternGetString failed to get the fontfile");
-      return NULL;
+      return nullptr;
     }
 
     if (cc_font_debug()) {
@@ -567,7 +567,7 @@ find_font_file(const char * fontname, unsigned int pixelsize)
     const uintptr_t key = (uintptr_t)cc_namemap_get_address(fontname);
     found_in_hash = cc_dict_get(cc_flwft_globals.fontname2filename, key, &val);
     if (!found_in_hash) {
-      const char * c = NULL;
+      const char * c = nullptr;
       if (cc_font_debug()) {
         cc_debugerror_postinfo("find_font_file",
                                "fontname '%s' not found in name hash",
@@ -575,7 +575,7 @@ find_font_file(const char * fontname, unsigned int pixelsize)
       }
       /* If name ends in ".ttf", we interpret it as filename. */
       c = strrchr(fontname, '.');
-      if (!(c && strlen(c) == 4 && strstr(c, ".ttf"))) return NULL;
+      if (!(c && strlen(c) == 4 && strstr(c, ".ttf"))) return nullptr;
     }
 
     possiblefilenames = (cc_dynarray *)val;
@@ -627,7 +627,7 @@ cc_flwft_get_font(const char * fontname, unsigned int pixelsize)
   FT_Face face;
   FT_Error error;
   const char * fontfilename = find_font_file(fontname, pixelsize);
-  static const int disable_utf8 = (coin_getenv("COIN_DISABLE_UTF8") != NULL);
+  static const int disable_utf8 = (coin_getenv("COIN_DISABLE_UTF8") != nullptr);
 
   error = cc_ftglue_FT_New_Face(library, fontfilename ? fontfilename : fontname, 0, &face);
 
@@ -638,7 +638,7 @@ cc_flwft_get_font(const char * fontname, unsigned int pixelsize)
                                 error, fontname,
                                 fontfilename ? fontfilename : "(null)");
     }
-    return NULL;
+    return nullptr;
   }
 
   if (cc_font_debug()) {
@@ -904,14 +904,14 @@ cc_flwft_get_bitmap(void * font, unsigned int glyph)
     if (cc_font_debug()) cc_debugerror_post("cc_flwft_get_bitmap",
 					    "FT_Load_Glyph() => error %d",
 					    error);
-    return NULL;
+    return nullptr;
   }
   error = cc_ftglue_FT_Get_Glyph(face->glyph, &g);
   if (error) {
     if (cc_font_debug()) cc_debugerror_post("cc_flwft_get_bitmap",
 					    "FT_Get_Glyph() => error %d",
 					    error);
-    return NULL;
+    return nullptr;
   }
 
   /* render a glyph only if it's in outline format. this won't be the
@@ -926,7 +926,7 @@ cc_flwft_get_bitmap(void * font, unsigned int glyph)
       if (cc_font_debug()) cc_debugerror_post("cc_flwft_get_bitmap",
 					      "FT_Glyph_To_Bitmap() => error %d",
 					      error);
-      return NULL;
+      return nullptr;
     }
   }
 
@@ -964,35 +964,35 @@ cc_flwft_get_vector_glyph(void * font, unsigned int glyphindex, float complexity
   if (!GLUWrapper()->available) {
     cc_debugerror_post("cc_flwft_get_vector_glyph",
                        "GLU library could not be loaded.");
-    return NULL;
+    return nullptr;
   }
 
-  if ((GLUWrapper()->gluNewTess == NULL) ||
-      (GLUWrapper()->gluTessCallback == NULL) ||
-      (GLUWrapper()->gluTessBeginPolygon == NULL) ||
-      (GLUWrapper()->gluTessEndContour == NULL) ||
-      (GLUWrapper()->gluTessEndPolygon == NULL) ||
-      (GLUWrapper()->gluDeleteTess == NULL) ||
-      (GLUWrapper()->gluTessVertex == NULL) ||
-      (GLUWrapper()->gluTessBeginContour == NULL)) {
+  if ((GLUWrapper()->gluNewTess == nullptr) ||
+      (GLUWrapper()->gluTessCallback == nullptr) ||
+      (GLUWrapper()->gluTessBeginPolygon == nullptr) ||
+      (GLUWrapper()->gluTessEndContour == nullptr) ||
+      (GLUWrapper()->gluTessEndPolygon == nullptr) ||
+      (GLUWrapper()->gluDeleteTess == nullptr) ||
+      (GLUWrapper()->gluTessVertex == nullptr) ||
+      (GLUWrapper()->gluTessBeginContour == nullptr)) {
     cc_debugerror_post("cc_flwft_get_vector_glyph",
                        "Unable to bind required GLU tessellation "
                        "functions for 3D FreeType font support.");
-    return NULL;
+    return nullptr;
   }
 
   face = (FT_Face) font;
 
   error = cc_ftglue_FT_Set_Char_Size(face, 0, (flwft_3dfontsize<<6), 0, 0);
   if (error != 0) {
-    /* FIXME: No message is printed here because returning NULL will
+    /* FIXME: No message is printed here because returning nullptr will
        force glyph3d.c to use the builtin font. This happens whenever
        the system cannot find the requested font. This cannot be
        detected because 'fontlib_wrapper.c:cc_flw_get_font()' will
        always return the builtin font on failure instead of an error.
        A better and more elegant workaround should be
        made... (handegar). */
-    return NULL;
+    return nullptr;
   }
 
   error = cc_ftglue_FT_Load_Glyph(face, glyphindex, FT_LOAD_DEFAULT);
@@ -1002,7 +1002,7 @@ cc_flwft_get_vector_glyph(void * font, unsigned int glyphindex, float complexity
                          "Error loading glyph (glyphindex==%d). "
                          "(FT_Load_Glyph() error => %d)", glyphindex, error);
     }
-    return NULL;
+    return nullptr;
   }
 
   error = cc_ftglue_FT_Get_Glyph(face->glyph, &tmp);
@@ -1010,13 +1010,13 @@ cc_flwft_get_vector_glyph(void * font, unsigned int glyphindex, float complexity
     cc_debugerror_post("cc_flwft_get_vector_glyph",
                        "Error fetching glyph. Font is not properly initialized. "
                        "(FT_Get_Glyph() error => %d)", error);
-    return NULL;
+    return nullptr;
   }
 
   /* FIXME: investigate if there is a simple way to gather the outline
      from a bitmapped font? 20040925 tamer. */
   /* in case of a bitmap font fall back to the default font. commonly
-     it will already fail and return NULL due to not being able to set
+     it will already fail and return nullptr due to not being able to set
      another character size for fixed sized fonts. still, rather be
      robust and catch the unprobable case where the provided bitmap
      font could match the flwt_3dfontsize. */
@@ -1027,19 +1027,19 @@ cc_flwft_get_vector_glyph(void * font, unsigned int glyphindex, float complexity
     }
     /* cleanup temporary glyph */
     cc_ftglue_FT_Done_Glyph(tmp);
-    return NULL;
+    return nullptr;
   }
 
   g = (FT_OutlineGlyph)tmp;
   outline = g->outline;
 
-  if (flwft_tessellator.vertexlist == NULL)
+  if (flwft_tessellator.vertexlist == nullptr)
      flwft_tessellator.vertexlist = cc_list_construct();
-  if (flwft_tessellator.faceindexlist == NULL)
+  if (flwft_tessellator.faceindexlist == nullptr)
      flwft_tessellator.faceindexlist = cc_list_construct();
-  if (flwft_tessellator.edgeindexlist == NULL)
+  if (flwft_tessellator.edgeindexlist == nullptr)
      flwft_tessellator.edgeindexlist = cc_list_construct();
-  if (flwft_tessellator.malloclist == NULL) {
+  if (flwft_tessellator.malloclist == nullptr) {
     flwft_tessellator.malloclist = cc_list_construct();
   }
 
@@ -1068,11 +1068,11 @@ cc_flwft_get_vector_glyph(void * font, unsigned int glyphindex, float complexity
   GLUWrapper()->gluTessCallback(flwft_tessellator.tessellator_object, GLU_TESS_COMBINE, (gluTessCallback_cb_t) flwft_combineCallback);
   GLUWrapper()->gluTessCallback(flwft_tessellator.tessellator_object, GLU_TESS_ERROR, (gluTessCallback_cb_t) flwft_errorCallback);
 
-  GLUWrapper()->gluTessBeginPolygon(flwft_tessellator.tessellator_object, NULL);
+  GLUWrapper()->gluTessBeginPolygon(flwft_tessellator.tessellator_object, nullptr);
   /* According to the SGI doc for GLU, specifying the triangle normal
      will speed up the tessellation process. */
   GLUWrapper()->gluTessNormal(flwft_tessellator.tessellator_object, 0.0f, 0.0f, -1.0f);
-  error = cc_ftglue_FT_Outline_Decompose(&outline, &outline_funcs, NULL);
+  error = cc_ftglue_FT_Outline_Decompose(&outline, &outline_funcs, nullptr);
   if (flwft_tessellator.contour_open) {
     GLUWrapper()->gluTessEndContour(flwft_tessellator.tessellator_object);
 
@@ -1429,7 +1429,7 @@ flwft_cleanupMallocList(void)
       free(cc_list_get(flwft_tessellator.malloclist, i));
     }
     cc_list_destruct(flwft_tessellator.malloclist);
-    flwft_tessellator.malloclist = NULL;
+    flwft_tessellator.malloclist = nullptr;
   }
 }
 
@@ -1452,7 +1452,7 @@ flwft_buildVertexList(struct cc_font_vector_glyph * newglyph)
   }
 
   cc_list_destruct(flwft_tessellator.vertexlist);
-  flwft_tessellator.vertexlist = NULL;
+  flwft_tessellator.vertexlist = nullptr;
 }
 
 static void
@@ -1469,7 +1469,7 @@ flwft_buildEdgeIndexList(struct cc_font_vector_glyph * newglyph)
     newglyph->edgeindices[i] = (int) ((intptr_t) cc_list_get(flwft_tessellator.edgeindexlist, i));
 
   cc_list_destruct(flwft_tessellator.edgeindexlist);
-  flwft_tessellator.edgeindexlist = NULL;
+  flwft_tessellator.edgeindexlist = nullptr;
 }
 
 static void
@@ -1486,7 +1486,7 @@ flwft_buildFaceIndexList(struct cc_font_vector_glyph * newglyph)
     newglyph->faceindices[i] = (int) ((intptr_t) cc_list_get(flwft_tessellator.faceindexlist, i));
 
   cc_list_destruct(flwft_tessellator.faceindexlist);
-  flwft_tessellator.faceindexlist = NULL;
+  flwft_tessellator.faceindexlist = nullptr;
 }
 
 static int
diff --git a/coin4/src/fonts/glyph2d.cpp b/coin4/src/fonts/glyph2d.cpp
index 39ec3b6..f478ab0 100644
--- a/coin4/src/fonts/glyph2d.cpp
+++ b/coin4/src/fonts/glyph2d.cpp
@@ -57,13 +57,13 @@ struct cc_glyph2d {
   bool mono;
 };
 
-static cc_dict * glyph2d_fonthash = NULL;
+static cc_dict * glyph2d_fonthash = nullptr;
 static bool glyph2d_initialized = false;
 
 /*
   Mutex lock for the static ang global font hash
 */
-static void * glyph2d_fonthash_lock = NULL;
+static void * glyph2d_fonthash_lock = nullptr;
 
 /* Set '#if 1' to enable debug output to stderr for tracking mutex locking. */
 #if 0
@@ -87,7 +87,7 @@ cc_glyph2d_cleanup(void)
 {
   CC_MUTEX_DESTRUCT(glyph2d_fonthash_lock);
   cc_dict_destruct(glyph2d_fonthash);
-  glyph2d_fonthash = NULL;
+  glyph2d_fonthash = nullptr;
   glyph2d_initialized = false;
 }
 
@@ -128,7 +128,7 @@ cc_glyph2d_ref(uint32_t character, const cc_font_specification * spec, float ang
 
   /* Beacuse this function is the entry point for glyph2d, the mutex
      is initialized here. */
-  if (glyph2d_fonthash_lock == NULL) 
+  if (glyph2d_fonthash_lock == nullptr) 
     cc_glyph2d_initialize();
   
   assert(spec);
@@ -231,7 +231,7 @@ cc_glyph2d_ref(uint32_t character, const cc_font_specification * spec, float ang
 void
 cc_glyph2d_unref(cc_glyph2d * glyph)
 {
-  cc_glyph_unref(glyph2d_fonthash, &(glyph->c), NULL);
+  cc_glyph_unref(glyph2d_fonthash, &(glyph->c), nullptr);
 }
 
 static bool 
diff --git a/coin4/src/fonts/glyph3d.cpp b/coin4/src/fonts/glyph3d.cpp
index d29545d..b49518f 100644
--- a/coin4/src/fonts/glyph3d.cpp
+++ b/coin4/src/fonts/glyph3d.cpp
@@ -62,13 +62,13 @@ struct cc_glyph3d {
 
 /* ********************************************************************** */
 
-static cc_dict * glyph3d_fonthash = NULL;
+static cc_dict * glyph3d_fonthash = nullptr;
 static int glyph3d_spaceglyphindices[] = { -1, -1 };
 static float glyph3d_spaceglyphvertices[] = { 0, 0 };
 static bool glyph3d_initialized = false;
 
 /* Mutex lock for the static ang global font hash */
-static void * glyph3d_fonthash_lock = NULL;
+static void * glyph3d_fonthash_lock = nullptr;
 
 /* Because the 3D glyphs are normalized when generated, a standard
    fontsize is used for all glyphs. This also prevent Windows from
@@ -101,7 +101,7 @@ cc_glyph3d_cleanup(void)
 {
   CC_MUTEX_DESTRUCT(glyph3d_fonthash_lock);
   cc_dict_destruct(glyph3d_fonthash);
-  glyph3d_fonthash = NULL;
+  glyph3d_fonthash = nullptr;
   glyph3d_initialized = false;
 }
 
@@ -135,11 +135,11 @@ cc_glyph3d_ref(uint32_t character, const cc_font_specification * spec)
   void * val;
   cc_font_specification * newspec;
   cc_string * fonttoload;
-  cc_list * glyphlist = NULL;
+  cc_list * glyphlist = nullptr;
 
   /* Beacuse this function is the entry point for glyph3d, the mutex
      is initialized here. */
-  if (glyph3d_fonthash_lock == NULL) 
+  if (glyph3d_fonthash_lock == nullptr) 
     cc_glyph3d_initialize();
   
   assert(spec);
@@ -214,7 +214,7 @@ cc_glyph3d_ref(uint32_t character, const cc_font_specification * spec)
 
   /* Setup builtin default font if no character was found */
   /* FIXME: this should be moved to fontlib_wrapper.c. 20050623 mortene. */
-  if (glyph->vectorglyph == NULL) {
+  if (glyph->vectorglyph == nullptr) {
     glyph->vectorglyph = (struct cc_font_vector_glyph *) malloc(sizeof(struct cc_font_vector_glyph));
     glyph->didallocvectorglyph = true;
 
@@ -262,7 +262,7 @@ const float *
 cc_glyph3d_getcoords(const cc_glyph3d * g)
 {
   const float * ptr = cc_flw_get_vector_glyph_coords(g->vectorglyph);
-  if (ptr == NULL) {    
+  if (ptr == nullptr) {    
     assert(g->vectorglyph->vertices && "Default vertices has not been initialized as expected!");
     return g->vectorglyph->vertices;
   }
@@ -273,7 +273,7 @@ const int *
 cc_glyph3d_getfaceindices(const cc_glyph3d * g)
 {
   const int * ptr = cc_flw_get_vector_glyph_faceidx(g->vectorglyph);
-  if (ptr == NULL) {      
+  if (ptr == nullptr) {      
     assert(g->vectorglyph->faceindices && "Default face indices has not been initialized as expected!");
     return g->vectorglyph->faceindices; 
   }
@@ -284,7 +284,7 @@ const int *
 cc_glyph3d_getedgeindices(const cc_glyph3d * g)
 {
   const int * ptr = cc_flw_get_vector_glyph_edgeidx(g->vectorglyph);
-  if (ptr == NULL) {    
+  if (ptr == nullptr) {    
     assert(g->vectorglyph->edgeindices && "Default edge indices has not been initialized as expected!");
     return g->vectorglyph->edgeindices; 
   }
@@ -315,7 +315,7 @@ cc_glyph3d_getnextcwedge(const cc_glyph3d * g, int edgeidx)
     ptr += 2;
   }
 
-  return NULL;
+  return nullptr;
 }
 
 const int *
@@ -341,7 +341,7 @@ cc_glyph3d_getnextccwedge(const cc_glyph3d * g, int edgeidx)
     ptr += 2;
   }
 
-  return NULL;
+  return nullptr;
 
 }
 
diff --git a/coin4/src/fonts/win32.cpp b/coin4/src/fonts/win32.cpp
index ef3d2b9..4f6dd74 100644
--- a/coin4/src/fonts/win32.cpp
+++ b/coin4/src/fonts/win32.cpp
@@ -61,7 +61,7 @@
 bool cc_flww32_initialize(void) { return false; }
 void cc_flww32_exit(void) { }
 
-void * cc_flww32_get_font(const char * COIN_UNUSED_ARG(fontname), int COIN_UNUSED_ARG(sizey), float COIN_UNUSED_ARG(angle), float COIN_UNUSED_ARG(complexity)) { assert(false); return NULL; }
+void * cc_flww32_get_font(const char * COIN_UNUSED_ARG(fontname), int COIN_UNUSED_ARG(sizey), float COIN_UNUSED_ARG(angle), float COIN_UNUSED_ARG(complexity)) { assert(false); return nullptr; }
 void cc_flww32_get_font_name(void * COIN_UNUSED_ARG(font), cc_string * COIN_UNUSED_ARG(str)) { assert(false); }
 void cc_flww32_done_font(void * COIN_UNUSED_ARG(font)) { assert(false); }
 
@@ -71,8 +71,8 @@ void cc_flww32_get_bitmap_kerning(void * COIN_UNUSED_ARG(font), int COIN_UNUSED_
 void cc_flww32_get_vector_kerning(void * COIN_UNUSED_ARG(font), int COIN_UNUSED_ARG(glyph1), int COIN_UNUSED_ARG(glyph2), float * COIN_UNUSED_ARG(x), float * COIN_UNUSED_ARG(y)) { assert(false); }
 void cc_flww32_done_glyph(void * COIN_UNUSED_ARG(font), int COIN_UNUSED_ARG(glyph)) { assert(false); }
 
-struct cc_font_bitmap * cc_flww32_get_bitmap(void * COIN_UNUSED_ARG(font), int COIN_UNUSED_ARG(glyph)) { assert(false); return NULL; }
-struct cc_font_vector_glyph * cc_flww32_get_vector_glyph(void * COIN_UNUSED_ARG(font), unsigned int COIN_UNUSED_ARG(glyph), float COIN_UNUSED_ARG(complexity)){ assert(false); return NULL; }
+struct cc_font_bitmap * cc_flww32_get_bitmap(void * COIN_UNUSED_ARG(font), int COIN_UNUSED_ARG(glyph)) { assert(false); return nullptr; }
+struct cc_font_vector_glyph * cc_flww32_get_vector_glyph(void * COIN_UNUSED_ARG(font), unsigned int COIN_UNUSED_ARG(glyph), float COIN_UNUSED_ARG(complexity)){ assert(false); return nullptr; }
 
 
 #else /* HAVE_WIN32_API */
@@ -154,9 +154,9 @@ struct cc_flww32_globals_s {
 };
 
 static struct cc_flww32_globals_s cc_flww32_globals = {
-  NULL, /* devctx */
-  NULL,
-  NULL
+  nullptr, /* devctx */
+  nullptr,
+  nullptr
 };
 
 /* Callback functions for cleaning up kerninghash table */
@@ -204,8 +204,8 @@ cc_flww32_initialize(void)
   OSVERSIONINFO osvi;
   UINT previous;
 
-  cc_flww32_globals.devctx = CreateDC("DISPLAY", NULL, NULL, NULL);
-  if (cc_flww32_globals.devctx == NULL) {
+  cc_flww32_globals.devctx = CreateDC("DISPLAY", nullptr, nullptr, nullptr);
+  if (cc_flww32_globals.devctx == nullptr) {
     cc_win32_print_error("cc_flww32_initialize", "CreateDC()", GetLastError());
     return false;
   }
@@ -236,10 +236,10 @@ cc_flww32_initialize(void)
   cc_flww32_globals.fontsizehash = cc_dict_construct(17, 0.75f);
 
   /* Setup temporary glyph-struct used during for tessellation */
-  flww32_tessellator.vertexlist = NULL;
-  flww32_tessellator.faceindexlist = NULL;
-  flww32_tessellator.edgeindexlist = NULL;
-  flww32_tessellator.malloclist = NULL;
+  flww32_tessellator.vertexlist = nullptr;
+  flww32_tessellator.faceindexlist = nullptr;
+  flww32_tessellator.edgeindexlist = nullptr;
+  flww32_tessellator.malloclist = nullptr;
 
   /* Are we running Windows 95/98/Me? */
   ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
@@ -273,7 +273,7 @@ cc_flww32_kerninghash_deleteCB1(uintptr_t key, void * val, void * closure)
 {
   cc_dict * khash;
   khash = (cc_dict *) val;
-  cc_dict_apply(khash, cc_flww32_kerninghash_deleteCB2, NULL);
+  cc_dict_apply(khash, cc_flww32_kerninghash_deleteCB2, nullptr);
   cc_dict_destruct(khash);
 }
 void
@@ -281,7 +281,7 @@ cc_flww32_kerninghash_deleteCB2(uintptr_t key, void * val, void * closure)
 {
   cc_dict * khash;
   khash = (cc_dict *) val;
-  cc_dict_apply(khash, cc_flww32_kerninghash_deleteCB3, NULL);
+  cc_dict_apply(khash, cc_flww32_kerninghash_deleteCB3, nullptr);
   cc_dict_destruct(khash);
 }
 void
@@ -316,7 +316,7 @@ namespace {
     this->identifier = identifier;
     SetLastError(0);
     this->previous = static_cast<HFONT>(SelectObject(this->dc, font));
-    if (this->previous == NULL){
+    if (this->previous == nullptr){
       DWORD lastError = GetLastError();
       SoDebugError::post(this->identifier, 
         "Could not select font. HDC: %p, HFONT: %p", this->dc, this->font);
@@ -372,7 +372,7 @@ static HFONT cc_flww32_create_font(const char* fontname, int sizey,
                                    float angle, BOOL bold, BOOL italic)
 {
   HFONT font;
-  static const int disable_utf8 = (coin_getenv("COIN_DISABLE_UTF8") != NULL);
+  static const int disable_utf8 = (coin_getenv("COIN_DISABLE_UTF8") != nullptr);
 
   if (disable_utf8) {
     font = CreateFont(-sizey,
@@ -440,7 +440,7 @@ static HFONT cc_flww32_create_font(const char* fontname, int sizey,
     cc_string_sprintf(str, "CreateFontW(%d, ..., '%s')", sizey, fontname);
     cc_win32_print_error("cc_flww32_get_font", cc_string_get_text(str), lasterr);
     cc_string_destruct(str);
-    return NULL;
+    return nullptr;
   }
   return font;
 }
@@ -448,7 +448,7 @@ static HFONT cc_flww32_create_font(const char* fontname, int sizey,
 /* ************************************************************************* */
 
 /* Allocates and returns a new font id matching the exact fontname.
-   Returns NULL on error.
+   Returns nullptr on error.
 */
 void *
 cc_flww32_get_font(const char * fontname, int sizey, float angle, float complexity)
@@ -480,7 +480,7 @@ cc_flww32_get_font(const char * fontname, int sizey, float angle, float complexi
 
   wfont = cc_flww32_create_font(fontname, sizey, angle, false, false);
   if (!wfont) {
-    return NULL;
+    return nullptr;
   }
 
   /*
@@ -561,9 +561,9 @@ cc_flww32_get_font(const char * fontname, int sizey, float angle, float complexi
   */
 
   FontContext fontContext(cc_flww32_globals.devctx, (HFONT)wfont, "cc_flww32_get_font");
-  if (!fontContext.isValid()) return NULL;
+  if (!fontContext.isValid()) return nullptr;
 
-  nrkpairs = GetKerningPairs(cc_flww32_globals.devctx, 0, NULL);
+  nrkpairs = GetKerningPairs(cc_flww32_globals.devctx, 0, nullptr);
   if (nrkpairs) {
 
     kpairs = (KERNINGPAIR *) malloc(nrkpairs * sizeof(KERNINGPAIR));
@@ -571,7 +571,7 @@ cc_flww32_get_font(const char * fontname, int sizey, float angle, float complexi
     ret = GetKerningPairs(cc_flww32_globals.devctx, nrkpairs, kpairs);
     if (ret == 0) {
       cc_win32_print_error("cc_flww32_get_font", "GetKerningPairs()", GetLastError());
-      return NULL;
+      return nullptr;
     }
 
     if (!cc_dict_get(cc_flww32_globals.font2kerninghash, (uintptr_t) wfont, (void **) &fontkerninghash)) {
@@ -632,7 +632,7 @@ cc_flww32_get_font_name(void * font, cc_string * str)
     return;
   }
 
-  size = cc_win32()->GetTextFace(cc_flww32_globals.devctx, 0, NULL);
+  size = cc_win32()->GetTextFace(cc_flww32_globals.devctx, 0, nullptr);
 
   /* 'size' will never be 0. Then GetTextFaceW would have asserted. */
   s = (char *)malloc(size);
@@ -673,7 +673,7 @@ cc_flww32_done_font(void * font)
 
   if (cc_dict_get(cc_flww32_globals.font2kerninghash, (uintptr_t)font, (void **) &khash)) {
     cc_dict_remove(cc_flww32_globals.font2kerninghash, (uintptr_t)font);
-    cc_dict_apply(khash, cc_flww32_kerninghash_deleteCB2, NULL);
+    cc_dict_apply(khash, cc_flww32_kerninghash_deleteCB2, nullptr);
     cc_dict_destruct(khash);
   }
 
@@ -703,7 +703,7 @@ cc_flww32_get_vector_advance(void * font, int glyph, float * x, float * y)
 {
   LOGFONT lfont;
   GLYPHMETRICS gm;
-  static const int disable_utf8 = (coin_getenv("COIN_DISABLE_UTF8") != NULL);
+  static const int disable_utf8 = (coin_getenv("COIN_DISABLE_UTF8") != nullptr);
 
   /* NOTE: Do not make this matrix 'static'. It seems like Win95/98/ME
      fails if the idmatrix is static. Newer versions seems to not mind
@@ -730,7 +730,7 @@ cc_flww32_get_vector_advance(void * font, int glyph, float * x, float * y)
 			  GGO_METRICS, /* format of data to return */
 			  &gm, /* metrics */
 			  0, /* size of buffer for data */
-			  NULL, /* buffer for data */
+			  nullptr, /* buffer for data */
 			  &identitymatrix); /* transformation matrix */
   } else {
     ret = GetGlyphOutlineW(cc_flww32_globals.devctx,
@@ -738,7 +738,7 @@ cc_flww32_get_vector_advance(void * font, int glyph, float * x, float * y)
 			   GGO_METRICS, /* format of data to return */
 			   &gm, /* metrics */
 			   0, /* size of buffer for data */
-			   NULL, /* buffer for data */
+			   nullptr, /* buffer for data */
 			   &identitymatrix); /* transformation matrix */
   }
 
@@ -747,7 +747,7 @@ cc_flww32_get_vector_advance(void * font, int glyph, float * x, float * y)
     cc_string_construct(&str);
     cc_string_sprintf(&str,
                       "GetGlyphOutlineW(HDC=%p, 0x%x '%c', GGO_METRICS, "
-                      "<metricsstruct>, 0, NULL, <idmatrix>)",
+                      "<metricsstruct>, 0, nullptr, <idmatrix>)",
                       cc_flww32_globals.devctx, glyph, (unsigned char)glyph);
     cc_win32_print_error("cc_flww32_get_vector_advance", cc_string_get_text(&str), GetLastError());
     cc_string_clean(&str);
@@ -771,7 +771,7 @@ void
 cc_flww32_get_bitmap_kerning(void * font, int glyph1, int glyph2, int * x, int * y)
 {
 
-  float * kerning = NULL;
+  float * kerning = nullptr;
   cc_dict * khash;
 
   if (cc_dict_get(cc_flww32_globals.font2kerninghash, (uintptr_t)font, (void **) &khash)) {
@@ -794,7 +794,7 @@ void
 cc_flww32_get_vector_kerning(void * font, int glyph1, int glyph2, float * x, float * y)
 {
 
-  float * kerning = NULL;
+  float * kerning = nullptr;
   cc_dict * khash;
   DWORD ret;
   DWORD size;
@@ -833,9 +833,9 @@ cc_flww32_done_glyph(void * font, int glyph)
 struct cc_font_bitmap *
 cc_flww32_get_bitmap(void * font, int glyph)
 {
-  struct cc_font_bitmap * bm = NULL;
+  struct cc_font_bitmap * bm = nullptr;
   GLYPHMETRICS gm;
-  static const int disable_utf8 = (coin_getenv("COIN_DISABLE_UTF8") != NULL);
+  static const int disable_utf8 = (coin_getenv("COIN_DISABLE_UTF8") != nullptr);
 
   /* NOTE: Do not make this matrix 'static'. It seems like Win95/98/ME
      fails if the idmatrix is static. Newer versions seems to not mind
@@ -846,12 +846,12 @@ cc_flww32_get_bitmap(void * font, int glyph)
                                 { 0, 0 }, { 0, 1 } };
   DWORD ret;
   DWORD size = 0;
-  uint8_t * w32bitmap = NULL;
+  uint8_t * w32bitmap = nullptr;
 
   /* Connect device context to font. */
   FontContext fontContext(cc_flww32_globals.devctx, (HFONT)font, "cc_flww32_get_bitmap");
   if (!fontContext.isValid()) {
-    return NULL;
+    return nullptr;
   }
 
   /* The GetGlyphOutlineW function retrieves the outline or bitmap for
@@ -864,7 +864,7 @@ cc_flww32_get_bitmap(void * font, int glyph)
 			  GGO_GRAY8_BITMAP, /* format of data to return */
 			  &gm, /* metrics */
 			  0, /* size of buffer for data */
-			  NULL, /* buffer for data */
+			  nullptr, /* buffer for data */
 			  &identitymatrix); /* transformation matrix */
   } else {
     ret = GetGlyphOutlineW(cc_flww32_globals.devctx,
@@ -872,7 +872,7 @@ cc_flww32_get_bitmap(void * font, int glyph)
 			   GGO_GRAY8_BITMAP, /* format of data to return */
 			   &gm, /* metrics */
 			   0, /* size of buffer for data */
-			   NULL, /* buffer for data */
+			   nullptr, /* buffer for data */
 			   &identitymatrix); /* transformation matrix */
   }
 
@@ -891,11 +891,11 @@ cc_flww32_get_bitmap(void * font, int glyph)
     cc_string_construct(&str);
     cc_string_sprintf(&str,
                       "GetGlyphOutlineW(HDC=%p, 0x%x '%c', GGO_GRAY8_BITMAP, "
-                      "<metricsstruct>, 0, NULL, <idmatrix>)",
+                      "<metricsstruct>, 0, nullptr, <idmatrix>)",
                       cc_flww32_globals.devctx, glyph, (unsigned char)glyph);
     cc_win32_print_error("cc_flww32_get_bitmap", cc_string_get_text(&str), GetLastError());
     cc_string_clean(&str);
-    return NULL;
+    return nullptr;
   }
 
   assert((ret < 1024*1024) && "bogus buffer size");
@@ -905,7 +905,7 @@ cc_flww32_get_bitmap(void * font, int glyph)
      for at least the space char glyph for some charsets. */
   if (size > 0) {
     w32bitmap = (uint8_t *)malloc(ret);
-    assert(w32bitmap != NULL); /* FIXME: be robust. 20030530 mortene. */
+    assert(w32bitmap != nullptr); /* FIXME: be robust. 20030530 mortene. */
 
     if (disable_utf8) {
       ret = GetGlyphOutline(cc_flww32_globals.devctx,
@@ -935,7 +935,7 @@ cc_flww32_get_bitmap(void * font, int glyph)
       cc_win32_print_error("cc_flww32_get_bitmap", cc_string_get_text(&str), GetLastError());
       cc_string_clean(&str);
       free(w32bitmap);
-      return NULL;
+      return nullptr;
     }
   }
 
@@ -948,12 +948,12 @@ cc_flww32_get_bitmap(void * font, int glyph)
   bm->rows = gm.gmBlackBoxY;
   bm->width = gm.gmBlackBoxX;
   bm->pitch = bm->width;
-  bm->buffer = NULL;
+  bm->buffer = nullptr;
   /* FIXME: mono hardcoded to false. what about bitmapped fonts? any
      chance we could get one? if yes, we need to query and handle this
      case appropriately. 20040929 tamer. */
   bm->mono = 0;
-  if (w32bitmap != NULL) { /* Could be NULL for at least space char glyph. */
+  if (w32bitmap != nullptr) { /* Could be nullptr for at least space char glyph. */
     unsigned int i, j;
     unsigned char *dst, * src, * next_row;
 
@@ -985,8 +985,8 @@ static void
 flww32_getVerticesFromPath(HDC hdc)
 {
 
-  LPPOINT p_points = NULL;
-  LPBYTE p_types = NULL;
+  LPPOINT p_points = nullptr;
+  LPBYTE p_types = nullptr;
   int numpoints, i, lastmoveto;
   uintptr_t tmp;
 
@@ -998,7 +998,7 @@ flww32_getVerticesFromPath(HDC hdc)
   }
 
   /* determine the number of endpoints in the path*/
-  numpoints = GetPath(hdc, NULL, NULL, 0);
+  numpoints = GetPath(hdc, nullptr, nullptr, 0);
   if (numpoints < 0) {
     cc_win32_print_error("flww32_getVerticesFromPath", "Failed when handeling TrueType font; "
                          "GetPath()", GetLastError());
@@ -1053,8 +1053,8 @@ flww32_getVerticesFromPath(HDC hdc)
         flww32_addTessVertex(p_points[i].x, p_points[i].y);
       }
     }
-    if (p_points != NULL) free(p_points);
-    if (p_types != NULL) free(p_types);
+    if (p_points != nullptr) free(p_points);
+    if (p_types != nullptr) free(p_types);
   }
 
 }
@@ -1072,27 +1072,27 @@ cc_flww32_get_vector_glyph(void * font, unsigned int glyph, float complexity)
   unsigned int size;
   uintptr_t cast_aid;
   UINT previous;
-  static const int disable_utf8 = (coin_getenv("COIN_DISABLE_UTF8") != NULL);
+  static const int disable_utf8 = (coin_getenv("COIN_DISABLE_UTF8") != nullptr);
 
 
   if (!GLUWrapper()->available) {
     SoDebugError::post("cc_flww32_get_vector_glyph",
                        "GLU library could not be loaded.");
-    return NULL;
+    return nullptr;
   }
 
-  if ((GLUWrapper()->gluNewTess == NULL) ||
-      (GLUWrapper()->gluTessCallback == NULL) ||
-      (GLUWrapper()->gluTessBeginPolygon == NULL) ||
-      (GLUWrapper()->gluTessEndContour == NULL) ||
-      (GLUWrapper()->gluTessEndPolygon == NULL) ||
-      (GLUWrapper()->gluDeleteTess == NULL) ||
-      (GLUWrapper()->gluTessVertex == NULL) ||
-      (GLUWrapper()->gluTessBeginContour == NULL)) {
+  if ((GLUWrapper()->gluNewTess == nullptr) ||
+      (GLUWrapper()->gluTessCallback == nullptr) ||
+      (GLUWrapper()->gluTessBeginPolygon == nullptr) ||
+      (GLUWrapper()->gluTessEndContour == nullptr) ||
+      (GLUWrapper()->gluTessEndPolygon == nullptr) ||
+      (GLUWrapper()->gluDeleteTess == nullptr) ||
+      (GLUWrapper()->gluTessVertex == nullptr) ||
+      (GLUWrapper()->gluTessBeginContour == nullptr)) {
     SoDebugError::post("cc_flww32_get_vector_glyph",
                        "Unable to bind required GLU tessellation "
                        "functions for 3D Win32 TrueType font support.");
-    return NULL;
+    return nullptr;
   }
 
 
@@ -1103,18 +1103,18 @@ cc_flww32_get_vector_glyph(void * font, unsigned int glyph, float complexity)
      there -- to simplify the client code below. 20031118 mortene. */
 
   /*
-     If NULL is returned due to an error, glyph3d.c will load the
+     If nullptr is returned due to an error, glyph3d.c will load the
      default font instead.
   */
 
   /* FIXME: don't do the DC- and bitmap-initialization for each and
      every glyph -- once should be enough. 20050706 mortene. */
 
-  memdc = CreateCompatibleDC(NULL);
-  if (memdc == NULL) {
+  memdc = CreateCompatibleDC(nullptr);
+  if (memdc == nullptr) {
     cc_win32_print_error("cc_flww32_get_vector_glyph","Error calling CreateCompatibleDC(). "
                          "Cannot vectorize font.", GetLastError());
-    return NULL;
+    return nullptr;
   }
 
   /* About this: see comment on SetTextAlign() call in
@@ -1122,30 +1122,30 @@ cc_flww32_get_vector_glyph(void * font, unsigned int glyph, float complexity)
   previous = SetTextAlign(memdc, TA_BASELINE);
   assert(previous != GDI_ERROR);
 
-  screendc = GetDC(NULL);
-  if (screendc == NULL) {
+  screendc = GetDC(nullptr);
+  if (screendc == nullptr) {
     cc_win32_print_error("cc_flww32_get_vector_glyph","Error calling GetDC(). "
                          "Cannot vectorize font.", GetLastError());
-    return NULL;
+    return nullptr;
   }
 
   membmp = CreateCompatibleBitmap(screendc, 300, 300);
-  if (membmp == NULL) {
+  if (membmp == nullptr) {
     cc_win32_print_error("cc_flww32_get_vector_glyph","Error calling CreateCompatibleBitmap(). "
                          "Cannot vectorize font.", GetLastError());
-    return NULL;
+    return nullptr;
   }
 
-  if (SelectObject(memdc, membmp) == NULL) {
+  if (SelectObject(memdc, membmp) == nullptr) {
     cc_win32_print_error("cc_flww32_get_vector_glyph","Error calling SelectObject(). "
                          "Cannot vectorize font.", GetLastError());
-    return NULL;
+    return nullptr;
   }
 
-  if (SelectObject(memdc, font) == NULL) {
+  if (SelectObject(memdc, font) == nullptr) {
     cc_win32_print_error("cc_flww32_get_vector_glyph","Error calling SelectObject(). "
                          "Cannot vectorize font.", GetLastError());
-    return NULL;
+    return nullptr;
   }
 
   if (SetBkMode(memdc, TRANSPARENT) == 0) {
@@ -1155,37 +1155,37 @@ cc_flww32_get_vector_glyph(void * font, unsigned int glyph, float complexity)
   }
   if (BeginPath(memdc) == 0) {
     cc_win32_print_error("cc_flww32_get_vector_glyph","Error calling BeginPath(). Cannot vectorize font.", GetLastError());
-    return NULL;
+    return nullptr;
   }
   if (disable_utf8) {
     glyph_str[0] = glyph;
     if (TextOut(memdc, 0, 0, glyph_str, 1) == 0) {
       cc_win32_print_error("cc_flww32_get_vector_glyph","Error calling TextOut(). Cannot vectorize font.", GetLastError());
-      return NULL;
+      return nullptr;
     }
   } else {
     glyph_strw[0] = glyph;
     if (TextOutW(memdc, 0, 0, glyph_strw, 1) == 0) {
       cc_win32_print_error("cc_flww32_get_vector_glyph","Error calling TextOutW(). Cannot vectorize font.", GetLastError());
-      return NULL;
+      return nullptr;
     }
   }
   if (EndPath(memdc) == 0) {
     cc_win32_print_error("cc_flww32_get_vector_glyph","Error calling EndPath(). Cannot vectorize font.", GetLastError());
-    return NULL;
+    return nullptr;
   }
 
   /* FIXME: very inefficient to do initialization of the GLU
      tessellator object, and the cc_list instances, for each and every
      glyph to vectorize -- do this only once. 20050706 mortene. */
 
-  if (flww32_tessellator.vertexlist == NULL)
+  if (flww32_tessellator.vertexlist == nullptr)
     flww32_tessellator.vertexlist = cc_list_construct();
-  if (flww32_tessellator.faceindexlist == NULL)
+  if (flww32_tessellator.faceindexlist == nullptr)
     flww32_tessellator.faceindexlist = cc_list_construct();
-  if (flww32_tessellator.edgeindexlist == NULL)
+  if (flww32_tessellator.edgeindexlist == nullptr)
     flww32_tessellator.edgeindexlist = cc_list_construct();
-  if (flww32_tessellator.malloclist == NULL)
+  if (flww32_tessellator.malloclist == nullptr)
     flww32_tessellator.malloclist = cc_list_construct();
 
   flww32_tessellator.tessellator_object = GLUWrapper()->gluNewTess();
@@ -1203,7 +1203,7 @@ cc_flww32_get_vector_glyph(void * font, unsigned int glyph, float complexity)
   GLUWrapper()->gluTessCallback(flww32_tessellator.tessellator_object, GLU_TESS_COMBINE, (gluTessCallback_cb_t)flww32_combineCallback);
   GLUWrapper()->gluTessCallback(flww32_tessellator.tessellator_object, GLU_TESS_ERROR, (gluTessCallback_cb_t)flww32_errorCallback);
 
-  GLUWrapper()->gluTessBeginPolygon(flww32_tessellator.tessellator_object, NULL);
+  GLUWrapper()->gluTessBeginPolygon(flww32_tessellator.tessellator_object, nullptr);
 
   flww32_getVerticesFromPath(memdc);
 
@@ -1413,7 +1413,7 @@ flww32_buildVertexList(struct cc_font_vector_glyph * newglyph, int size)
   }
 
   cc_list_destruct(flww32_tessellator.vertexlist);
-  flww32_tessellator.vertexlist = NULL;
+  flww32_tessellator.vertexlist = nullptr;
 }
 
 static void
@@ -1426,7 +1426,7 @@ flww32_cleanupMallocList(void)
       free(cc_list_get(flww32_tessellator.malloclist, i));
     }
     cc_list_destruct(flww32_tessellator.malloclist);
-    flww32_tessellator.malloclist = NULL;
+    flww32_tessellator.malloclist = nullptr;
   }
 }
 
@@ -1448,7 +1448,7 @@ flww32_buildEdgeIndexList(struct cc_font_vector_glyph * newglyph)
   }
 
   cc_list_destruct(flww32_tessellator.edgeindexlist);
-  flww32_tessellator.edgeindexlist = NULL;
+  flww32_tessellator.edgeindexlist = nullptr;
 }
 
 static void
@@ -1469,7 +1469,7 @@ flww32_buildFaceIndexList(struct cc_font_vector_glyph * newglyph)
   }
 
   cc_list_destruct(flww32_tessellator.faceindexlist);
-  flww32_tessellator.faceindexlist = NULL;
+  flww32_tessellator.faceindexlist = nullptr;
 
 }
 
diff --git a/coin4/src/foreignfiles/SoForeignFileKit.cpp b/coin4/src/foreignfiles/SoForeignFileKit.cpp
index 3f967f9..2635440 100644
--- a/coin4/src/foreignfiles/SoForeignFileKit.cpp
+++ b/coin4/src/foreignfiles/SoForeignFileKit.cpp
@@ -99,7 +99,7 @@ public:
 
 };
 
-SbHash<const char *, SoType> * SoForeignFileKitP::fileexts = NULL;
+SbHash<const char *, SoType> * SoForeignFileKitP::fileexts = nullptr;
 
 SO_KIT_ABSTRACT_SOURCE(SoForeignFileKit);
 
@@ -107,7 +107,7 @@ static void
 foreignfilekit_cleanup(void)
 {
   delete SoForeignFileKitP::fileexts;
-  SoForeignFileKitP::fileexts = NULL;
+  SoForeignFileKitP::fileexts = nullptr;
 }
 
 void
@@ -137,7 +137,7 @@ SoForeignFileKit::initClasses(void)
 
 SoForeignFileKit::SoForeignFileKit(void)
 {
-  PRIVATE(this) = NULL;
+  PRIVATE(this) = nullptr;
   // PRIVATE(this) = new SoForeignFileKitP(this);
 
   SO_KIT_INTERNAL_CONSTRUCTOR(SoForeignFileKit);
@@ -161,7 +161,7 @@ SoForeignFileKit::~SoForeignFileKit(void)
 bool
 SoForeignFileKit::registerFileExtension(SoType handler, SbName extension, SoForeignFileIdentifyFunc * COIN_UNUSED_ARG(identify))
 {
-  assert(SoForeignFileKitP::fileexts != NULL);
+  assert(SoForeignFileKitP::fileexts != nullptr);
   assert(handler.canCreateInstance());
 
   if (extension.getString()[0] == '.') {
@@ -180,11 +180,11 @@ SoForeignFileKit::registerFileExtension(SoType handler, SbName extension, SoFore
 
 /*!
   Creates an instance of a suitable SoForeignFileKit subtype.
-  Returns NULL on failure or a kit with refcount of 1 on success.
+  Returns nullptr on failure or a kit with refcount of 1 on success.
 */
 static SoForeignFileKit *create_foreignfilekit(const char *filename, bool exhaust)
 {
-  assert(SoForeignFileKitP::fileexts != NULL);
+  assert(SoForeignFileKitP::fileexts != nullptr);
 
   const char * extptr = strrchr(filename, '.');
   if (extptr) {
@@ -222,7 +222,7 @@ static SoForeignFileKit *create_foreignfilekit(const char *filename, bool exhaus
     // FIXME: Implement
     // SoForeignFileKitP::fileexts->apply()
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -234,7 +234,7 @@ bool
 SoForeignFileKit::isFileSupported(const char * filename, bool exhaust)
 {
   SoForeignFileKit * foreignfile = create_foreignfilekit(filename, exhaust);
-  bool success = (foreignfile != NULL);
+  bool success = (foreignfile != nullptr);
   if (foreignfile) foreignfile->unref();
   return success;
 }
@@ -249,7 +249,7 @@ bool
 SoForeignFileKit::isFileSupported(SoInput * in, bool exhaust)
 {
   assert(in);
-  if (in->getCurFileName() == NULL || in->getNumBytesRead() > 0) {
+  if (in->getCurFileName() == nullptr || in->getNumBytesRead() > 0) {
     // can only read proper files, from the beginning
     return false;
   }
@@ -259,7 +259,7 @@ SoForeignFileKit::isFileSupported(SoInput * in, bool exhaust)
 /*!
   Creates an instance of a suitable SoForeignFileKit subtype from the given file 
   and reads its content.
-  Returns NULL on failure or a kit with refcount of 0 on success.
+  Returns nullptr on failure or a kit with refcount of 0 on success.
 
   FIXME: \e exhaust is not implemented.
  */
@@ -272,7 +272,7 @@ SoForeignFileKit::createForeignFileKit(const char * filename, bool exhaust)
       foreignfile->unrefNoDelete();
     } else {
       foreignfile->unref();
-      foreignfile = NULL;
+      foreignfile = nullptr;
     }
   }
   return foreignfile;
@@ -286,7 +286,7 @@ SoForeignFileKit *
 SoForeignFileKit::createForeignFileKit(SoInput * in, bool exhaust)
 {
   assert(in);
-  if (in->getCurFileName() == NULL || in->getNumBytesRead() > 0) {
+  if (in->getCurFileName() == nullptr || in->getNumBytesRead() > 0) {
     // can only read proper files, from the beginning
     return nullptr;
   }
diff --git a/coin4/src/foreignfiles/SoSTLFileKit.cpp b/coin4/src/foreignfiles/SoSTLFileKit.cpp
index 4b238ef..fd29dfc 100644
--- a/coin4/src/foreignfiles/SoSTLFileKit.cpp
+++ b/coin4/src/foreignfiles/SoSTLFileKit.cpp
@@ -223,7 +223,7 @@ SoSTLFileKit::SoSTLFileKit(void)
 SoSTLFileKit::~SoSTLFileKit(void)
 {
   delete PRIVATE(this);
-  PRIVATE(this) = NULL;
+  PRIVATE(this) = nullptr;
 }
 
 // doc in inherited class
diff --git a/coin4/src/foreignfiles/steel.cpp b/coin4/src/foreignfiles/steel.cpp
index 566a2e4..fb81ffb 100644
--- a/coin4/src/foreignfiles/steel.cpp
+++ b/coin4/src/foreignfiles/steel.cpp
@@ -286,14 +286,14 @@ static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
  * future we want to put the buffer states in a more general
  * "scanner state".
  *
- * Returns the top of the stack, or NULL.
+ * Returns the top of the stack, or nullptr.
  */
 #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
-                          : NULL)
+                          : nullptr)
 
 /* Same as previous macro, but useful when we know that the buffer stack is not
- * NULL or when we need an lvalue. For internal use only.
+ * nullptr or when we need an lvalue. For internal use only.
  */
 #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
 
@@ -1031,10 +1031,10 @@ YY_RULE_SETUP
 #line 155 "steel.l"
 {
 	  reader->hickups = 0; /* reset flex hickup counter */
-	  assert(reader->facet != NULL);
-	  if ( reader->info != NULL ) {
+	  assert(reader->facet != nullptr);
+	  if ( reader->info != nullptr ) {
 	    free(reader->info);
-	    reader->info = NULL;
+	    reader->info = nullptr;
 	  }
 	  stl_parse_real_triple(stl_yytext, &(reader->facet->nx), &(reader->facet->ny), &(reader->facet->nz));
 	}
@@ -1057,7 +1057,7 @@ YY_RULE_SETUP
 #line 169 "steel.l"
 {
 	  stl_real x = 0.0f, y = 0.0f, z = 0.0f;
-	  assert(reader->facet != NULL);
+	  assert(reader->facet != nullptr);
 	  stl_parse_real_triple(stl_yytext, &x, &y, &z);
 	  switch ( reader->vertex ) {
 	  case 0:
@@ -1110,9 +1110,9 @@ YY_RULE_SETUP
 #line 204 "steel.l"
 {
 	  char * ptr = stl_yytext;
-	  if ( reader->info != NULL ) {
+	  if ( reader->info != nullptr ) {
 	    free(reader->info);
-	    reader->info = NULL;
+	    reader->info = nullptr;
 	  }
 	  /* FIXME: this scanning is now incorrect if not "endsolid" */
 	  while ( *ptr && (*ptr == ' ' || *ptr == '\t') ) ptr++;
@@ -1765,7 +1765,7 @@ static void stl_yy_load_buffer_state  (void)
  */
 void stl_yypush_buffer_state (YY_BUFFER_STATE new_buffer )
 {
-    	if (new_buffer == NULL)
+    	if (new_buffer == nullptr)
 		return;
 
 	stl_yyensure_buffer_stack();
@@ -1799,7 +1799,7 @@ void stl_yypop_buffer_state (void)
 		return;
 
 	stl_yy_delete_buffer(YY_CURRENT_BUFFER );
-	YY_CURRENT_BUFFER_LVALUE = NULL;
+	YY_CURRENT_BUFFER_LVALUE = nullptr;
 	if ((yy_buffer_stack_top) > 0)
 		--(yy_buffer_stack_top);
 
@@ -1997,13 +1997,13 @@ int stl_yylex_destroy  (void)
     /* Pop the buffer stack, destroying each element. */
 	while(YY_CURRENT_BUFFER){
 		stl_yy_delete_buffer(YY_CURRENT_BUFFER  );
-		YY_CURRENT_BUFFER_LVALUE = NULL;
+		YY_CURRENT_BUFFER_LVALUE = nullptr;
 		stl_yypop_buffer_state();
 	}
 
 	/* Destroy the stack itself. */
 	stl_yyfree((yy_buffer_stack) );
-	(yy_buffer_stack) = NULL;
+	(yy_buffer_stack) = nullptr;
 
     /* Reset the globals. This is important in a non-reentrant scanner so the next time
      * stl_yylex() is called, initialization will occur. */
@@ -2120,9 +2120,9 @@ stl_parse_real_triple(char * text, stl_real * a, stl_real * b, stl_real * c)
   STL_SCAN_TO_WHITESPACE(text);
   STL_SCAN_TO_REAL(text);
   real3 = text;
-  if ( a ) *a = (stl_real) strtod(real1, NULL);
-  if ( b ) *b = (stl_real) strtod(real2, NULL);
-  if ( c ) *c = (stl_real) strtod(real3, NULL);
+  if ( a ) *a = (stl_real) strtod(real1, nullptr);
+  if ( b ) *b = (stl_real) strtod(real2, nullptr);
+  if ( c ) *c = (stl_real) strtod(real3, nullptr);
   return true;
 }
 
@@ -2171,9 +2171,9 @@ stl_reader_binary_facet(stl_reader * reader)
   } data;
 
 
-  assert(reader != NULL);
-  assert(reader->file != NULL);
-  assert(reader->facet != NULL);
+  assert(reader != nullptr);
+  assert(reader->file != nullptr);
+  assert(reader->facet != nullptr);
   readok &= fread(&data.bytes, 4, 1, reader->file);
   data.data = stl_ntohl(data.data);
   reader->facet->nx = data.real;
@@ -2227,9 +2227,9 @@ stl_writer_put_binary_facet(stl_writer * writer, stl_facet * COIN_UNUSED_ARG(fac
     uint32_t data;
     float real;
   } data;
-  assert(writer != NULL);
-  assert(writer->file != NULL);
-  assert(writer->facet != NULL);
+  assert(writer != nullptr);
+  assert(writer->file != nullptr);
+  assert(writer->facet != nullptr);
   data.real = writer->facet->nx;
   data.data = stl_ntohl(data.data);
   writeok &= fwrite(&data.bytes, 4, 1, writer->file);
@@ -2436,7 +2436,7 @@ stl_facet *
 stl_facet_clone(stl_facet * facet)
 {
   stl_facet * clone;
-  assert(facet != NULL);
+  assert(facet != nullptr);
   clone = stl_facet_create_uninitialized();
   stl_facet_copy(facet, clone);
   return clone;
@@ -2448,7 +2448,7 @@ stl_facet_clone(stl_facet * facet)
 void
 stl_facet_destroy(stl_facet * facet)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   free(facet);
 } /* stl_facet_destroy() */
 
@@ -2458,7 +2458,7 @@ stl_facet_destroy(stl_facet * facet)
 void
 stl_facet_copy(stl_facet * source, stl_facet * target)
 {
-  assert(source != NULL && target != NULL);
+  assert(source != nullptr && target != nullptr);
   target->nx = source->nx;
   target->ny = source->ny;
   target->nz = source->nz;
@@ -2480,7 +2480,7 @@ stl_facet_copy(stl_facet * source, stl_facet * target)
 void
 stl_facet_set_normal(stl_facet * facet, stl_real x, stl_real y, stl_real z)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   facet->nx = x;
   facet->ny = y;
   facet->nz = z;
@@ -2492,7 +2492,7 @@ stl_facet_set_normal(stl_facet * facet, stl_real x, stl_real y, stl_real z)
 void
 stl_facet_get_normal(stl_facet * facet, stl_real * x, stl_real * y, stl_real * z)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   if ( x ) *x = facet->nx;
   if ( y ) *y = facet->ny;
   if ( z ) *z = facet->nz;
@@ -2504,7 +2504,7 @@ stl_facet_get_normal(stl_facet * facet, stl_real * x, stl_real * y, stl_real * z
 void
 stl_facet_set_vertex1(stl_facet * facet, stl_real x, stl_real y, stl_real z)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   facet->v1x = x;
   facet->v1y = y;
   facet->v1z = z;
@@ -2516,7 +2516,7 @@ stl_facet_set_vertex1(stl_facet * facet, stl_real x, stl_real y, stl_real z)
 void
 stl_facet_get_vertex1(stl_facet * facet, stl_real * x, stl_real * y, stl_real * z)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   if ( x ) *x = facet->v1x;
   if ( y ) *y = facet->v1y;
   if ( z ) *z = facet->v1z;
@@ -2528,7 +2528,7 @@ stl_facet_get_vertex1(stl_facet * facet, stl_real * x, stl_real * y, stl_real *
 void
 stl_facet_set_vertex2(stl_facet * facet, stl_real x, stl_real y, stl_real z)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   facet->v2x = x;
   facet->v2y = y;
   facet->v2z = z;
@@ -2540,7 +2540,7 @@ stl_facet_set_vertex2(stl_facet * facet, stl_real x, stl_real y, stl_real z)
 void
 stl_facet_get_vertex2(stl_facet * facet, stl_real * x, stl_real * y, stl_real * z)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   if ( x ) *x = facet->v2x;
   if ( y ) *y = facet->v2y;
   if ( z ) *z = facet->v2z;
@@ -2552,7 +2552,7 @@ stl_facet_get_vertex2(stl_facet * facet, stl_real * x, stl_real * y, stl_real *
 void
 stl_facet_set_vertex3(stl_facet * facet, stl_real x, stl_real y, stl_real z)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   facet->v3x = x;
   facet->v3y = y;
   facet->v3z = z;
@@ -2564,7 +2564,7 @@ stl_facet_set_vertex3(stl_facet * facet, stl_real x, stl_real y, stl_real z)
 void
 stl_facet_get_vertex3(stl_facet * facet, stl_real * x, stl_real * y, stl_real * z)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   if ( x ) *x = facet->v3x;
   if ( y ) *y = facet->v3y;
   if ( z ) *z = facet->v3z;
@@ -2576,7 +2576,7 @@ stl_facet_get_vertex3(stl_facet * facet, stl_real * x, stl_real * y, stl_real *
 void
 stl_facet_set_padding(stl_facet * facet, unsigned int COIN_UNUSED_ARG(padding))
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
 } /* stl_facet_set_padding() */
 
 /* @stl_facet_get_padding@
@@ -2585,7 +2585,7 @@ stl_facet_set_padding(stl_facet * facet, unsigned int COIN_UNUSED_ARG(padding))
 unsigned int
 stl_facet_get_padding(stl_facet * facet)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   return 0;
 } /* stl_facet_get_padding() */
 
@@ -2595,7 +2595,7 @@ stl_facet_get_padding(stl_facet * facet)
 void
 stl_facet_set_color(stl_facet * facet, unsigned int rgb)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   facet->color = rgb;
 } /* stl_facet_set_color() */
 
@@ -2606,7 +2606,7 @@ This function returns the color of the facet, if one has been set.
 unsigned int
 stl_facet_get_color(stl_facet * facet)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   return facet->color;
 } /* stl_facet_get_color() */
 
@@ -2622,14 +2622,14 @@ stl_reader_create(const char * filename)
   int id;
   long length;
   unsigned char bytes[4];
-  assert(filename != NULL);
+  assert(filename != nullptr);
   reader = (stl_reader *) malloc(sizeof(stl_reader));
   assert(reader);
-  reader->filename = NULL;
-  reader->file = NULL;
-  reader->info = NULL;
-  reader->facet = NULL;
-  reader->error = NULL;
+  reader->filename = nullptr;
+  reader->file = nullptr;
+  reader->info = nullptr;
+  reader->facet = nullptr;
+  reader->error = nullptr;
   reader->flags = 0;
   reader->linenum = 0;
   reader->pending = STL_NO_PENDING;
@@ -2638,9 +2638,9 @@ stl_reader_create(const char * filename)
   reader->facets_total = 0;
   reader->hickups = 0;
   reader->file = fopen(filename, "rb");
-  if ( reader->file == NULL ) {
+  if ( reader->file == nullptr ) {
     free(reader);
-    return NULL;
+    return nullptr;
   }
   reader->filename = (char *) malloc(strlen(filename)+1);
   assert(reader->filename);
@@ -2691,12 +2691,12 @@ stl_reader_create(const char * filename)
   /* the file is not an stl file */
   (void)fclose(reader->file);
   free(reader->filename);
-  reader->filename = NULL;
+  reader->filename = nullptr;
   stl_facet_destroy(reader->facet);
-  reader->facet = NULL;
+  reader->facet = nullptr;
   free(reader);
   /* could return a reader with pending STL_ERROR and error message instead? */
-  return NULL;
+  return nullptr;
 } /* stl_reader_create() */
 
 /* @stl_reader_destroy@
@@ -2705,22 +2705,22 @@ stl_reader_create(const char * filename)
 void
 stl_reader_destroy(stl_reader * reader)
 {
-  assert(reader != NULL);
+  assert(reader != nullptr);
   if ( reader->filename ) {
     free(reader->filename);
-    reader->filename = NULL;
+    reader->filename = nullptr;
   }
   if ( reader->info ) {
     free(reader->info);
-    reader->info = NULL;
+    reader->info = nullptr;
   }
   if ( reader->file ) {
     fclose(reader->file);
-    reader->file = NULL;
+    reader->file = nullptr;
   }
   if ( reader->facet ) {
     stl_facet_destroy(reader->facet);
-    reader->facet = NULL;
+    reader->facet = nullptr;
   }
   free(reader);
 } /* stl_reader_destroy() */
@@ -2731,7 +2731,7 @@ stl_reader_destroy(stl_reader * reader)
 unsigned int
 stl_reader_flags(stl_reader * reader)
 {
-  assert(reader != NULL);
+  assert(reader != nullptr);
   return reader->flags;
 } /* stl_reader_flags() */
 
@@ -2742,14 +2742,14 @@ int
 stl_reader_peek(stl_reader * reader)
 {
   int peekval;
-  assert(reader != NULL);
+  assert(reader != nullptr);
   if ( reader->pending != STL_NO_PENDING ) {
     peekval = reader->pending;
     if ( reader->pending == STL_END ) {
       reader->pending = STL_ERROR;
     }
     if ( reader->pending == STL_BEGIN ) {
-      if ( reader->info != NULL ) {
+      if ( reader->info != nullptr ) {
         reader->pending = STL_INIT_INFO;
       } else {
         reader->pending = STL_NO_PENDING;
@@ -2781,7 +2781,7 @@ stl_reader_peek(stl_reader * reader)
 const char *
 stl_reader_get_info(stl_reader * reader)
 {
-  assert(reader != NULL);
+  assert(reader != nullptr);
   return reader->info;
 } /* stl_reader_get_info() */
 
@@ -2791,8 +2791,8 @@ stl_reader_get_info(stl_reader * reader)
 stl_facet *
 stl_reader_get_facet(stl_reader * reader)
 {
-  assert(reader != NULL);
-  assert(reader->facet != NULL);
+  assert(reader != nullptr);
+  assert(reader->facet != nullptr);
   return stl_facet_clone(reader->facet);
 } /* stl_reader_get_facet() */
 
@@ -2802,8 +2802,8 @@ stl_reader_get_facet(stl_reader * reader)
 void
 stl_reader_fill_facet(stl_reader * reader, stl_facet * facet)
 {
-  assert(reader != NULL);
-  assert(reader->facet != NULL);
+  assert(reader != nullptr);
+  assert(reader->facet != nullptr);
   facet->nx = reader->facet->nx;
   facet->ny = reader->facet->ny;
   facet->nz = reader->facet->nz;
@@ -2825,7 +2825,7 @@ stl_reader_fill_facet(stl_reader * reader, stl_facet * facet)
 const char *
 stl_reader_get_error(stl_reader * reader)
 {
-  assert(reader != NULL);
+  assert(reader != nullptr);
   return reader->error;
 } /* stl_reader_get_error() */
 
@@ -2835,7 +2835,7 @@ stl_reader_get_error(stl_reader * reader)
 int
 stl_reader_get_line_number(stl_reader * reader)
 {
-  assert(reader != NULL);
+  assert(reader != nullptr);
   return reader->linenum;
 }
 
@@ -2848,7 +2848,7 @@ stl_writer *
 stl_writer_create(const char * filename, unsigned int flags)
 {
   stl_writer * writer;
-  assert(filename != NULL);
+  assert(filename != nullptr);
   writer = (stl_writer *) malloc(sizeof(stl_writer));
   assert(writer);
   writer->filename = (char *) malloc(strlen(filename)+1);
@@ -2866,9 +2866,9 @@ stl_writer_create(const char * filename, unsigned int flags)
   }
   assert(writer->file);
   writer->facets = 0;
-  writer->error = NULL;
-  writer->facet = NULL;
-  writer->info = NULL;
+  writer->error = nullptr;
+  writer->facet = nullptr;
+  writer->info = nullptr;
   return writer;
 } /* stl_writer_create() */
 
@@ -2878,8 +2878,8 @@ stl_writer_create(const char * filename, unsigned int flags)
 int
 stl_writer_destroy(stl_writer * writer)
 {
-  assert(writer != NULL);
-  assert(writer->file != NULL);
+  assert(writer != nullptr);
+  assert(writer->file != nullptr);
   if ( writer->flags & STL_BINARY ) {
     int writeok = 1;
     unsigned char bytes[4];
@@ -2895,14 +2895,14 @@ stl_writer_destroy(stl_writer * writer)
     writer->linenum++;
   }
   fclose(writer->file);
-  writer->file = NULL;
-  if ( writer->info != NULL ) {
+  writer->file = nullptr;
+  if ( writer->info != nullptr ) {
     free(writer->info);
-    writer->info = NULL;
+    writer->info = nullptr;
   }
-  if ( writer->facet != NULL ) {
+  if ( writer->facet != nullptr ) {
     stl_facet_destroy(writer->facet);
-    writer->facet = NULL;
+    writer->facet = nullptr;
   }
   free(writer);
   return STL_OK;
@@ -2914,7 +2914,7 @@ stl_writer_destroy(stl_writer * writer)
 unsigned int
 stl_writer_get_flags(stl_writer * writer)
 {
-  assert(writer != NULL);
+  assert(writer != nullptr);
   return writer->flags & STL_PUBLIC_FLAGS;
 } /* stl_writer_flags() */
 
@@ -2924,13 +2924,13 @@ stl_writer_get_flags(stl_writer * writer)
 int
 stl_writer_set_info(stl_writer * writer, const char * info)
 {
-  assert(writer != NULL);
-  assert(writer->file != NULL);
-  if ( writer->info != NULL ) {
+  assert(writer != nullptr);
+  assert(writer->file != nullptr);
+  if ( writer->info != nullptr ) {
     free(writer->info);
-    writer->info = NULL;
+    writer->info = nullptr;
   }
-  if ( info == NULL ) {
+  if ( info == nullptr ) {
     return STL_OK;
   }
   if ( writer->facets != 0 ) {
@@ -2974,8 +2974,8 @@ stl_writer_get_facet(stl_writer * writer)
 int
 stl_writer_put_facet(stl_writer * writer, stl_facet * facet)
 {
-  assert(writer != NULL);
-  assert(writer->file != NULL);
+  assert(writer != nullptr);
+  assert(writer->file != nullptr);
   assert(facet);
 
   if ( writer->facets == 0 ) {
@@ -2997,7 +2997,7 @@ stl_writer_put_facet(stl_writer * writer, stl_facet * facet)
       if ( writer->info ) {
         fprintf(writer->file, "solid %s\n", writer->info);
         free(writer->info);
-        writer->info = NULL;
+        writer->info = nullptr;
       } else {
         fprintf(writer->file, "solid\n");
       }
@@ -3039,7 +3039,7 @@ This function returns the last error message for the writer object.
 const char *
 stl_writer_get_error(stl_writer * writer)
 {
-  assert(writer != NULL);
+  assert(writer != nullptr);
   return writer->error;
 } /* stl_writer_get_error() */
 
diff --git a/coin4/src/foreignfiles/steel.l b/coin4/src/foreignfiles/steel.l
index 9f3f79e..059d460 100644
--- a/coin4/src/foreignfiles/steel.l
+++ b/coin4/src/foreignfiles/steel.l
@@ -154,10 +154,10 @@ LINE    [^\n]*
 
 {WHITE}facet{WS}normal{WS}{FLOAT}{WS}{FLOAT}{WS}{FLOAT}{WHITE}$	{
 	  reader->hickups = 0; /* reset flex hickup counter */
-	  assert(reader->facet != NULL);
-	  if ( reader->info != NULL ) {
+	  assert(reader->facet != nullptr);
+	  if ( reader->info != nullptr ) {
 	    free(reader->info);
-	    reader->info = NULL;
+	    reader->info = nullptr;
 	  }
 	  stl_parse_real_triple(stl_yytext, &(reader->facet->nx), &(reader->facet->ny), &(reader->facet->nz));
 	}
@@ -168,7 +168,7 @@ LINE    [^\n]*
 
 {WHITE}vertex{WS}{FLOAT}{WS}{FLOAT}{WS}{FLOAT}{WHITE}$	{
 	  stl_real x = 0.0f, y = 0.0f, z = 0.0f;
-	  assert(reader->facet != NULL);
+	  assert(reader->facet != nullptr);
 	  stl_parse_real_triple(stl_yytext, &x, &y, &z);
 	  switch ( reader->vertex ) {
 	  case 0:
@@ -203,9 +203,9 @@ LINE    [^\n]*
 
 {WHITE}end{WHITE}solid{WHITE}{LINE}$	{
 	  char * ptr = stl_yytext;
-	  if ( reader->info != NULL ) {
+	  if ( reader->info != nullptr ) {
 	    free(reader->info);
-	    reader->info = NULL;
+	    reader->info = nullptr;
 	  }
 	  /* FIXME: this scanning is now incorrect if not "endsolid" */
 	  while ( *ptr && (*ptr == ' ' || *ptr == '\t') ) ptr++;
@@ -312,9 +312,9 @@ stl_parse_real_triple(char * text, stl_real * a, stl_real * b, stl_real * c)
   STL_SCAN_TO_WHITESPACE(text);
   STL_SCAN_TO_REAL(text);
   real3 = text;
-  if ( a ) *a = (stl_real) strtod(real1, NULL);
-  if ( b ) *b = (stl_real) strtod(real2, NULL);
-  if ( c ) *c = (stl_real) strtod(real3, NULL);
+  if ( a ) *a = (stl_real) strtod(real1, nullptr);
+  if ( b ) *b = (stl_real) strtod(real2, nullptr);
+  if ( c ) *c = (stl_real) strtod(real3, nullptr);
   return true;
 }
 
@@ -363,9 +363,9 @@ stl_reader_binary_facet(stl_reader * reader)
   } data;
 
 
-  assert(reader != NULL);
-  assert(reader->file != NULL);
-  assert(reader->facet != NULL);
+  assert(reader != nullptr);
+  assert(reader->file != nullptr);
+  assert(reader->facet != nullptr);
   readok &= fread(&data.bytes, 4, 1, reader->file);
   data.data = stl_ntohl(data.data);
   reader->facet->nx = data.real;
@@ -419,9 +419,9 @@ stl_writer_put_binary_facet(stl_writer * writer, stl_facet * facet)
     uint32_t data;
     float real;
   } data;
-  assert(writer != NULL);
-  assert(writer->file != NULL);
-  assert(writer->facet != NULL);
+  assert(writer != nullptr);
+  assert(writer->file != nullptr);
+  assert(writer->facet != nullptr);
   data.real = writer->facet->nx;
   data.data = stl_ntohl(data.data);
   writeok &= fwrite(&data.bytes, 4, 1, writer->file);
@@ -628,7 +628,7 @@ stl_facet *
 stl_facet_clone(stl_facet * facet)
 {
   stl_facet * clone;
-  assert(facet != NULL);
+  assert(facet != nullptr);
   clone = stl_facet_create_uninitialized();
   stl_facet_copy(facet, clone);
   return clone;
@@ -640,7 +640,7 @@ stl_facet_clone(stl_facet * facet)
 void
 stl_facet_destroy(stl_facet * facet)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   free(facet);
 } /* stl_facet_destroy() */
 
@@ -650,7 +650,7 @@ stl_facet_destroy(stl_facet * facet)
 void
 stl_facet_copy(stl_facet * source, stl_facet * target)
 {
-  assert(source != NULL && target != NULL);
+  assert(source != nullptr && target != nullptr);
   target->nx = source->nx;
   target->ny = source->ny;
   target->nz = source->nz;
@@ -672,7 +672,7 @@ stl_facet_copy(stl_facet * source, stl_facet * target)
 void
 stl_facet_set_normal(stl_facet * facet, stl_real x, stl_real y, stl_real z)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   facet->nx = x;
   facet->ny = y;
   facet->nz = z;
@@ -684,7 +684,7 @@ stl_facet_set_normal(stl_facet * facet, stl_real x, stl_real y, stl_real z)
 void
 stl_facet_get_normal(stl_facet * facet, stl_real * x, stl_real * y, stl_real * z)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   if ( x ) *x = facet->nx;
   if ( y ) *y = facet->ny;
   if ( z ) *z = facet->nz;
@@ -696,7 +696,7 @@ stl_facet_get_normal(stl_facet * facet, stl_real * x, stl_real * y, stl_real * z
 void
 stl_facet_set_vertex1(stl_facet * facet, stl_real x, stl_real y, stl_real z)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   facet->v1x = x;
   facet->v1y = y;
   facet->v1z = z;
@@ -708,7 +708,7 @@ stl_facet_set_vertex1(stl_facet * facet, stl_real x, stl_real y, stl_real z)
 void
 stl_facet_get_vertex1(stl_facet * facet, stl_real * x, stl_real * y, stl_real * z)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   if ( x ) *x = facet->v1x;
   if ( y ) *y = facet->v1y;
   if ( z ) *z = facet->v1z;
@@ -720,7 +720,7 @@ stl_facet_get_vertex1(stl_facet * facet, stl_real * x, stl_real * y, stl_real *
 void
 stl_facet_set_vertex2(stl_facet * facet, stl_real x, stl_real y, stl_real z)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   facet->v2x = x;
   facet->v2y = y;
   facet->v2z = z;
@@ -732,7 +732,7 @@ stl_facet_set_vertex2(stl_facet * facet, stl_real x, stl_real y, stl_real z)
 void
 stl_facet_get_vertex2(stl_facet * facet, stl_real * x, stl_real * y, stl_real * z)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   if ( x ) *x = facet->v2x;
   if ( y ) *y = facet->v2y;
   if ( z ) *z = facet->v2z;
@@ -744,7 +744,7 @@ stl_facet_get_vertex2(stl_facet * facet, stl_real * x, stl_real * y, stl_real *
 void
 stl_facet_set_vertex3(stl_facet * facet, stl_real x, stl_real y, stl_real z)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   facet->v3x = x;
   facet->v3y = y;
   facet->v3z = z;
@@ -756,7 +756,7 @@ stl_facet_set_vertex3(stl_facet * facet, stl_real x, stl_real y, stl_real z)
 void
 stl_facet_get_vertex3(stl_facet * facet, stl_real * x, stl_real * y, stl_real * z)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   if ( x ) *x = facet->v3x;
   if ( y ) *y = facet->v3y;
   if ( z ) *z = facet->v3z;
@@ -768,7 +768,7 @@ stl_facet_get_vertex3(stl_facet * facet, stl_real * x, stl_real * y, stl_real *
 void
 stl_facet_set_padding(stl_facet * facet, unsigned int padding)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
 } /* stl_facet_set_padding() */
 
 /* @stl_facet_get_padding@
@@ -777,7 +777,7 @@ stl_facet_set_padding(stl_facet * facet, unsigned int padding)
 unsigned int
 stl_facet_get_padding(stl_facet * facet)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   return 0;
 } /* stl_facet_get_padding() */
 
@@ -787,7 +787,7 @@ stl_facet_get_padding(stl_facet * facet)
 void
 stl_facet_set_color(stl_facet * facet, unsigned int rgb)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   facet->color = rgb;
 } /* stl_facet_set_color() */
 
@@ -798,7 +798,7 @@ This function returns the color of the facet, if one has been set.
 unsigned int
 stl_facet_get_color(stl_facet * facet)
 {
-  assert(facet != NULL);
+  assert(facet != nullptr);
   return facet->color;
 } /* stl_facet_get_color() */
 
@@ -814,14 +814,14 @@ stl_reader_create(const char * filename)
   int id;
   long length;
   unsigned char bytes[4];
-  assert(filename != NULL);
+  assert(filename != nullptr);
   reader = (stl_reader *) malloc(sizeof(stl_reader));
   assert(reader);
-  reader->filename = NULL;
-  reader->file = NULL;
-  reader->info = NULL;
-  reader->facet = NULL;
-  reader->error = NULL;
+  reader->filename = nullptr;
+  reader->file = nullptr;
+  reader->info = nullptr;
+  reader->facet = nullptr;
+  reader->error = nullptr;
   reader->flags = 0;
   reader->linenum = 0;
   reader->pending = STL_NO_PENDING;
@@ -830,9 +830,9 @@ stl_reader_create(const char * filename)
   reader->facets_total = 0;
   reader->hickups = 0;
   reader->file = fopen(filename, "rb");
-  if ( reader->file == NULL ) {
+  if ( reader->file == nullptr ) {
     free(reader);
-    return NULL;
+    return nullptr;
   }
   reader->filename = (char *) malloc(strlen(filename)+1);
   assert(reader->filename);
@@ -883,12 +883,12 @@ stl_reader_create(const char * filename)
   /* the file is not an stl file */
   (void)fclose(reader->file);
   free(reader->filename);
-  reader->filename = NULL;
+  reader->filename = nullptr;
   stl_facet_destroy(reader->facet);
-  reader->facet = NULL;
+  reader->facet = nullptr;
   free(reader);
   /* could return a reader with pending STL_ERROR and error message instead? */
-  return NULL;
+  return nullptr;
 } /* stl_reader_create() */
 
 /* @stl_reader_destroy@
@@ -897,22 +897,22 @@ stl_reader_create(const char * filename)
 void
 stl_reader_destroy(stl_reader * reader)
 {
-  assert(reader != NULL);
+  assert(reader != nullptr);
   if ( reader->filename ) {
     free(reader->filename);
-    reader->filename = NULL;
+    reader->filename = nullptr;
   }
   if ( reader->info ) {
     free(reader->info);
-    reader->info = NULL;
+    reader->info = nullptr;
   }
   if ( reader->file ) {
     fclose(reader->file);
-    reader->file = NULL;
+    reader->file = nullptr;
   }
   if ( reader->facet ) {
     stl_facet_destroy(reader->facet);
-    reader->facet = NULL;
+    reader->facet = nullptr;
   }
   free(reader);
 } /* stl_reader_destroy() */
@@ -923,7 +923,7 @@ stl_reader_destroy(stl_reader * reader)
 unsigned int
 stl_reader_flags(stl_reader * reader)
 {
-  assert(reader != NULL);
+  assert(reader != nullptr);
   return reader->flags;
 } /* stl_reader_flags() */
 
@@ -934,14 +934,14 @@ int
 stl_reader_peek(stl_reader * reader)
 {
   int peekval;
-  assert(reader != NULL);
+  assert(reader != nullptr);
   if ( reader->pending != STL_NO_PENDING ) {
     peekval = reader->pending;
     if ( reader->pending == STL_END ) {
       reader->pending = STL_ERROR;
     }
     if ( reader->pending == STL_BEGIN ) {
-      if ( reader->info != NULL ) {
+      if ( reader->info != nullptr ) {
         reader->pending = STL_INIT_INFO;
       } else {
         reader->pending = STL_NO_PENDING;
@@ -973,7 +973,7 @@ stl_reader_peek(stl_reader * reader)
 const char *
 stl_reader_get_info(stl_reader * reader)
 {
-  assert(reader != NULL);
+  assert(reader != nullptr);
   return reader->info;
 } /* stl_reader_get_info() */
 
@@ -983,8 +983,8 @@ stl_reader_get_info(stl_reader * reader)
 stl_facet *
 stl_reader_get_facet(stl_reader * reader)
 {
-  assert(reader != NULL);
-  assert(reader->facet != NULL);
+  assert(reader != nullptr);
+  assert(reader->facet != nullptr);
   return stl_facet_clone(reader->facet);
 } /* stl_reader_get_facet() */
 
@@ -994,8 +994,8 @@ stl_reader_get_facet(stl_reader * reader)
 void
 stl_reader_fill_facet(stl_reader * reader, stl_facet * facet)
 {
-  assert(reader != NULL);
-  assert(reader->facet != NULL);
+  assert(reader != nullptr);
+  assert(reader->facet != nullptr);
   facet->nx = reader->facet->nx;
   facet->ny = reader->facet->ny;
   facet->nz = reader->facet->nz;
@@ -1017,7 +1017,7 @@ stl_reader_fill_facet(stl_reader * reader, stl_facet * facet)
 const char *
 stl_reader_get_error(stl_reader * reader)
 {
-  assert(reader != NULL);
+  assert(reader != nullptr);
   return reader->error;
 } /* stl_reader_get_error() */
 
@@ -1027,7 +1027,7 @@ stl_reader_get_error(stl_reader * reader)
 int
 stl_reader_get_line_number(stl_reader * reader)
 {
-  assert(reader != NULL);
+  assert(reader != nullptr);
   return reader->linenum;
 }
 
@@ -1040,7 +1040,7 @@ stl_writer *
 stl_writer_create(const char * filename, unsigned int flags)
 {
   stl_writer * writer;
-  assert(filename != NULL);
+  assert(filename != nullptr);
   writer = (stl_writer *) malloc(sizeof(stl_writer));
   assert(writer);
   writer->filename = (char *) malloc(strlen(filename)+1);
@@ -1058,9 +1058,9 @@ stl_writer_create(const char * filename, unsigned int flags)
   }
   assert(writer->file);
   writer->facets = 0;
-  writer->error = NULL;
-  writer->facet = NULL;
-  writer->info = NULL;
+  writer->error = nullptr;
+  writer->facet = nullptr;
+  writer->info = nullptr;
   return writer;
 } /* stl_writer_create() */
 
@@ -1070,8 +1070,8 @@ stl_writer_create(const char * filename, unsigned int flags)
 int
 stl_writer_destroy(stl_writer * writer)
 {
-  assert(writer != NULL);
-  assert(writer->file != NULL);
+  assert(writer != nullptr);
+  assert(writer->file != nullptr);
   if ( writer->flags & STL_BINARY ) {
     int writeok = 1;
     unsigned char bytes[4];
@@ -1087,14 +1087,14 @@ stl_writer_destroy(stl_writer * writer)
     writer->linenum++;
   }
   fclose(writer->file);
-  writer->file = NULL;
-  if ( writer->info != NULL ) {
+  writer->file = nullptr;
+  if ( writer->info != nullptr ) {
     free(writer->info);
-    writer->info = NULL;
+    writer->info = nullptr;
   }
-  if ( writer->facet != NULL ) {
+  if ( writer->facet != nullptr ) {
     stl_facet_destroy(writer->facet);
-    writer->facet = NULL;
+    writer->facet = nullptr;
   }
   free(writer);
   return STL_OK;
@@ -1106,7 +1106,7 @@ stl_writer_destroy(stl_writer * writer)
 unsigned int
 stl_writer_get_flags(stl_writer * writer)
 {
-  assert(writer != NULL);
+  assert(writer != nullptr);
   return writer->flags & STL_PUBLIC_FLAGS;
 } /* stl_writer_flags() */
 
@@ -1116,13 +1116,13 @@ stl_writer_get_flags(stl_writer * writer)
 int
 stl_writer_set_info(stl_writer * writer, const char * info)
 {
-  assert(writer != NULL);
-  assert(writer->file != NULL);
-  if ( writer->info != NULL ) {
+  assert(writer != nullptr);
+  assert(writer->file != nullptr);
+  if ( writer->info != nullptr ) {
     free(writer->info);
-    writer->info = NULL;
+    writer->info = nullptr;
   }
-  if ( info == NULL ) {
+  if ( info == nullptr ) {
     return STL_OK;
   }
   if ( writer->facets != 0 ) {
@@ -1166,8 +1166,8 @@ stl_writer_get_facet(stl_writer * writer)
 int
 stl_writer_put_facet(stl_writer * writer, stl_facet * facet)
 {
-  assert(writer != NULL);
-  assert(writer->file != NULL);
+  assert(writer != nullptr);
+  assert(writer->file != nullptr);
   assert(facet);
 
   if ( writer->facets == 0 ) {
@@ -1189,7 +1189,7 @@ stl_writer_put_facet(stl_writer * writer, stl_facet * facet)
       if ( writer->info ) {
         fprintf(writer->file, "solid %s\n", writer->info);
         free(writer->info);
-        writer->info = NULL;
+        writer->info = nullptr;
       } else {
         fprintf(writer->file, "solid\n");
       }
@@ -1231,7 +1231,7 @@ This function returns the last error message for the writer object.
 const char *
 stl_writer_get_error(stl_writer * writer)
 {
-  assert(writer != NULL);
+  assert(writer != nullptr);
   return writer->error;
 } /* stl_writer_get_error() */
 
diff --git a/coin4/src/geo/SoGeoElement.cpp b/coin4/src/geo/SoGeoElement.cpp
index 0a66e7d..8ae3031 100644
--- a/coin4/src/geo/SoGeoElement.cpp
+++ b/coin4/src/geo/SoGeoElement.cpp
@@ -60,7 +60,7 @@ SoGeoElement::initClass(void)
 SoGeoElement::SoGeoElement(void)
 {
   PRIVATE(this) = new SoGeoElementP;
-  PRIVATE(this)->origin = NULL;
+  PRIVATE(this)->origin = nullptr;
 
   this->setTypeId(SoGeoElement::classTypeId);
   this->setStackIndex(SoGeoElement::classStackIndex);
@@ -106,7 +106,7 @@ void
 SoGeoElement::init(SoState * state)
 {
   inherited::init(state);
-  PRIVATE(this)->origin = NULL;
+  PRIVATE(this)->origin = nullptr;
 }
 
 //! FIXME: doc
diff --git a/coin4/src/glue/GLUWrapper.cpp b/coin4/src/glue/GLUWrapper.cpp
index 60200e6..fcb9328 100644
--- a/coin4/src/glue/GLUWrapper.cpp
+++ b/coin4/src/glue/GLUWrapper.cpp
@@ -66,8 +66,8 @@ extern "C" {
 
 /* ******************************************************************** */
 
-static GLUWrapper_t * GLU_instance = NULL;
-static cc_libhandle GLU_libhandle = NULL;
+static GLUWrapper_t * GLU_instance = nullptr;
+static cc_libhandle GLU_libhandle = nullptr;
 static int GLU_failed_to_load = 0;
 static int GLU_is_initializing = 0;
 
@@ -93,13 +93,13 @@ GLUWrapper_cleanup(void)
 #ifdef GLU_RUNTIME_LINKING
   if (GLU_libhandle) {
     cc_dl_close(GLU_libhandle);
-    GLU_libhandle = NULL;
+    GLU_libhandle = nullptr;
   }
 #endif /* GLU_RUNTIME_LINKING */
 
   assert(GLU_instance);
   free(GLU_instance);
-  GLU_instance = NULL;
+  GLU_instance = nullptr;
   GLU_failed_to_load = 0;
   GLU_is_initializing = 0;
 }
@@ -212,7 +212,7 @@ GLUWrapper_gluGetString(GLenum name)
 {
   static const GLubyte versionstring[] = "1.0.0";
   if (name == GLU_VERSION) return versionstring;
-  return NULL;
+  return nullptr;
 }
 
 /* Replacement function for gluScaleImage(). */
@@ -363,7 +363,7 @@ GLUWrapper(void)
     /* FIXME: should we get the system shared library name from an
        Autoconf check? 20000930 mortene. */
     const char * possiblelibnames[] = {
-      NULL, /* is set below */
+      nullptr, /* is set below */
       /* MSWindows DLL name for the GLU library */
       "glu32",
 
@@ -372,7 +372,7 @@ GLUWrapper(void)
       "libGLU", "libMesaGLU",
       "libGLU.so", "libMesaGLU.so",
       "libGLU.so.1", /* Some Debian distributions do not supply a symlink for libGLU.so, only libGLU.so.1 */
-      NULL
+      nullptr
     };
     possiblelibnames[0] = coin_getenv("COIN_GLU_LIBNAME");
     int idx = possiblelibnames[0] ? 0 : 1;
@@ -388,7 +388,7 @@ GLUWrapper(void)
     /* On Mac OS X, GLU is part of the OpenGL framework, which at this
        point is alrady loaded -> We can resolve symbols from the current
        process image. */
-    GLU_libhandle = cc_dl_open(NULL);
+    GLU_libhandle = cc_dl_open(nullptr);
     libname = "OpenGL.framework/Libraries/libGLU.dylib";
 
 #endif /* !GLU_IS_PART_OF_GL */
@@ -435,7 +435,7 @@ GLUWrapper(void)
   gi->available = 0;
     /* Define GLUWRAPPER_REGISTER_FUNC macro. */
 #define GLUWRAPPER_REGISTER_FUNC(_funcname_, _funcsig_) \
-      gi->_funcname_ = NULL
+      gi->_funcname_ = nullptr
 
 #endif /* !GLUWRAPPER_ASSUME_GLU */
 
@@ -466,7 +466,7 @@ GLUWrapper(void)
   // mortene & kyrah.
   GLUWRAPPER_REGISTER_FUNC(gluNurbsCallbackData, gluNurbsCallbackData_t);
 #else /* !gluNurbsCallbackData */
-  gi->gluNurbsCallbackData = NULL;
+  gi->gluNurbsCallbackData = nullptr;
 #endif /* !gluNurbsCallbackData */
   GLUWRAPPER_REGISTER_FUNC(gluNewTess, gluNewTess_t);
   GLUWRAPPER_REGISTER_FUNC(gluTessCallback, gluTessCallback_t);
@@ -481,9 +481,9 @@ GLUWrapper(void)
 
   /* "Backup" functions, makes it easier to be robust even when no GLU
      library can be loaded. */
-  if (gi->gluScaleImage == NULL)
+  if (gi->gluScaleImage == nullptr)
     gi->gluScaleImage = GLUWrapper_gluScaleImage;
-  if (gi->gluGetString == NULL) /* Was missing in GLU v1.0. */
+  if (gi->gluGetString == nullptr) /* Was missing in GLU v1.0. */
     gi->gluGetString = GLUWrapper_gluGetString;
 
   /* Makes it possible to place a debugging "filter" in front of the
@@ -493,7 +493,7 @@ GLUWrapper(void)
     const char * env = coin_getenv("COIN_DEBUG_GLUNURBSSURFACE");
     if (env && (atoi(env) > 0)) {
       gi->gluNurbsSurface_in_GLU = gi->gluNurbsSurface;
-      if (gi->gluNurbsSurface != NULL) { gi->gluNurbsSurface = (gluNurbsSurface_t)GLUWrapper_gluNurbsSurface; }
+      if (gi->gluNurbsSurface != nullptr) { gi->gluNurbsSurface = (gluNurbsSurface_t)GLUWrapper_gluNurbsSurface; }
     }
   }
 
diff --git a/coin4/src/glue/GLUWrapper.h b/coin4/src/glue/GLUWrapper.h
index f5d6c36..4c867cb 100644
--- a/coin4/src/glue/GLUWrapper.h
+++ b/coin4/src/glue/GLUWrapper.h
@@ -107,7 +107,7 @@ typedef struct {
                                unsigned int release);
 
   /* 
-     GLU calls which might be used. Note that any of these can be NULL
+     GLU calls which might be used. Note that any of these can be nullptr
      pointers if the function is not available, unless marked as being
      always available. (That is, as long as GLU itself is available.)
   */
diff --git a/coin4/src/glue/bzip2.cpp b/coin4/src/glue/bzip2.cpp
index 7d9e379..a8e5787 100644
--- a/coin4/src/glue/bzip2.cpp
+++ b/coin4/src/glue/bzip2.cpp
@@ -88,8 +88,8 @@ typedef struct {
 } cc_bzglue_t;
 
 
-static cc_bzglue_t * bzlib_instance = NULL;
-static cc_libhandle bzlib_libhandle = NULL;
+static cc_bzglue_t * bzlib_instance = nullptr;
+static cc_libhandle bzlib_libhandle = nullptr;
 static int bzlib_failed_to_load = 0;
 
 /* Cleans up at exit. */
@@ -99,12 +99,12 @@ bzglue_cleanup(void)
 #ifdef LIBBZIP2_RUNTIME_LINKING
   if (bzlib_libhandle) { 
     cc_dl_close(bzlib_libhandle); 
-    bzlib_libhandle = NULL;
+    bzlib_libhandle = nullptr;
   }
 #endif /* LIBBZIP2_RUNTIME_LINKING */
   assert(bzlib_instance);
   free(bzlib_instance);
-  bzlib_instance = NULL;
+  bzlib_instance = nullptr;
   bzlib_failed_to_load = 0;
 }
 
@@ -128,10 +128,10 @@ bzglue_init(void)
       /* FIXME: should we get the system shared library name from an
          Autoconf check? 20000930 mortene. */
       const char * possiblelibnames[] = {
-        NULL, /* is set below */ 
+        nullptr, /* is set below */ 
         "bz2", "libbz2", "libbz2.so",
         "libbz2.dylib", 
-        NULL
+        nullptr
       };
 
       possiblelibnames[0] = coin_getenv("COIN_BZIP2_LIBNAME");
@@ -151,7 +151,7 @@ bzglue_init(void)
 #define BZGLUE_REGISTER_FUNC(_funcsig_, _funcname_) \
     do { \
       bi->_funcname_ = (_funcsig_)cc_dl_sym(bzlib_libhandle, SO__QUOTE(_funcname_)); \
-      if (bi->_funcname_ == NULL) bi->available = 0; \
+      if (bi->_funcname_ == nullptr) bi->available = 0; \
     } while (0)
 
 #elif defined(BZGLUE_ASSUME_BZIP2) /* !LIBBZIP2_RUNTIME_LINKING */
@@ -164,7 +164,7 @@ bzglue_init(void)
     bi->available = 0;
     /* Define BZGLUE_REGISTER_FUNC macro. */
 #define BZGLUE_REGISTER_FUNC(_funcsig_, _funcname_) \
-    bi->_funcname_ = NULL
+    bi->_funcname_ = nullptr
 
 #endif /* !BZGLUE_ASSUME_BZIP2 */
 
diff --git a/coin4/src/glue/cg.cpp b/coin4/src/glue/cg.cpp
index 60e2fc8..e1b004d 100644
--- a/coin4/src/glue/cg.cpp
+++ b/coin4/src/glue/cg.cpp
@@ -157,10 +157,10 @@ typedef struct {
 
 /* ********************************************************************** */
 
-static cc_cgglue_t * cg_instance = NULL;
+static cc_cgglue_t * cg_instance = nullptr;
 /* Cg is split into two dll's under Windows. Need two libhandles */
-static cc_libhandle cg_libhandle = NULL;
-static cc_libhandle cg_libhandle2 = NULL;
+static cc_libhandle cg_libhandle = nullptr;
+static cc_libhandle cg_libhandle2 = nullptr;
 static int cg_failed_to_load = 0;
 
 /* ********************************************************************** */
@@ -177,9 +177,9 @@ cgglue_cleanup(void)
   free(cg_instance);
 
   /* restore variables to initial value */
-  cg_instance = NULL;
-  cg_libhandle = NULL;
-  cg_libhandle2 = NULL;
+  cg_instance = nullptr;
+  cg_libhandle = nullptr;
+  cg_libhandle2 = nullptr;
   cg_failed_to_load = 0;
 }
 
@@ -207,12 +207,12 @@ cgglue_init(void)
       /* FIXME: should we get the system shared library name from an
          Autoconf check? 20000930 mortene. */
       const char * possiblelibnames[] = {
-        NULL, /* is set below */
+        nullptr, /* is set below */
         "CgGL", "libCgGL", "libCgGL.so",
 
         /* FIXME: not yet tested on Mac OS X. 20050125 mortene. */
         "libCgGL.dylib", 
-        NULL
+        nullptr
       };
 
       possiblelibnames[0] = coin_getenv("COIN_CG_LIBNAME");
@@ -242,7 +242,7 @@ cgglue_init(void)
       if (!zi->_funcname_ && cg_libhandle2) { \
         zi->_funcname_ = (_funcsig_)cc_dl_sym(cg_libhandle2, SO__QUOTE(_funcname_)); \
       } \
-      if (zi->_funcname_ == NULL) { \
+      if (zi->_funcname_ == nullptr) { \
         zi->available = 0; \
         zi->cgfx_available = 0; \
       } \
@@ -253,7 +253,7 @@ cgglue_init(void)
       if (!zi->_funcname_ && cg_libhandle2) { \
         zi->_funcname_ = (_funcsig_)cc_dl_sym(cg_libhandle2, SO__QUOTE(_funcname_)); \
       } \
-      if (zi->_funcname_ == NULL) { \
+      if (zi->_funcname_ == nullptr) { \
         zi->cgfx_available = 0; \
       } \
     } while (0)
@@ -272,9 +272,9 @@ cgglue_init(void)
     zi->cgfx_available = 0;
     /* Define CGGLUE_REGISTER_FUNC macro. */
 #define CGGLUE_REGISTER_FUNC(_funcsig_, _funcname_) \
-    zi->_funcname_ = NULL
+    zi->_funcname_ = nullptr
 #define CGGLUE_REGISTER_FXFUNC(_funcsig_, _funcname_) \
-    zi->_funcname_ = NULL
+    zi->_funcname_ = nullptr
 
 #endif /* no linking */
 
diff --git a/coin4/src/glue/dl.cpp b/coin4/src/glue/dl.cpp
index 07e5cf1..e09dabd 100644
--- a/coin4/src/glue/dl.cpp
+++ b/coin4/src/glue/dl.cpp
@@ -52,7 +52,7 @@
       
             // Now the function can be used like any other, e.g. like this:
             //
-            // nurbsProperty(NULL, 0, 0.0f);
+            // nurbsProperty(nullptr, 0, 0.0f);
       
         * Now, notice the "__stdcall" part of the function signature
           typedef. As you all probably know, this specifies the _assumed_
@@ -99,7 +99,7 @@
 #endif /* HAVE_CONFIG_H */
 
 #include <assert.h>
-#include <stddef.h> /* NULL definition. */
+#include <stddef.h> /* nullptr definition. */
 #include <stdlib.h> /* atoi() */
 #include <errno.h>
 #include <string.h> /* strlen(), strcpy(), strerror() */
@@ -374,7 +374,7 @@ cc_dirname(const char *path) {
   static char dirpath [MAXPATHLEN];
   const char * ptr;
 
-  if (path == NULL || *path == '\0') return NULL;
+  if (path == nullptr || *path == '\0') return nullptr;
 
   /* Get rid of trailing '/'s */ 
   ptr = path + strlen(path) - 1;
@@ -396,7 +396,7 @@ cc_dirname(const char *path) {
   }
 
   if ((unsigned int)(ptr - path + 1) > sizeof(dirpath)) {
-    return NULL;
+    return nullptr;
   }
 
   strncpy(dirpath, path, ptr - path + 1);
@@ -508,10 +508,10 @@ cc_build_search_list(const char * libname)
 
 #ifdef COIN_MACOS_10
   /* (4) Check if library exists as framework (as in OS Xs 'OpenAL') */
-  if ((libname != NULL) &&
-      (strstr(libname, ".dylib") == NULL) &&
-      (strstr(libname, ".so") == NULL) &&
-      (strstr(libname, ".dll") == NULL)) {
+  if ((libname != nullptr) &&
+      (strstr(libname, ".dylib") == nullptr) &&
+      (strstr(libname, ".so") == nullptr) &&
+      (strstr(libname, ".dll") == nullptr)) {
     cc_string_construct(&framework_path);
     const char * framework_prefix = "/Library/Frameworks/";
     const char * framework_ext = ".framework";
@@ -526,7 +526,7 @@ cc_build_search_list(const char * libname)
 }
 
 /* Returns the absolute path to file if file can be found in the
-   library and framework search path, NULL otherwise. It is the
+   library and framework search path, nullptr otherwise. It is the
    caller's responsibility to free the returned string. */
 
 static cc_string *
@@ -539,7 +539,7 @@ cc_find_file(const char * file)
 
   while (!end_reached) {
     char * currententry = strsep((char **) &listptr, ":");
-    end_reached = (listptr == NULL);
+    end_reached = (listptr == nullptr);
     if (currententry) {
       struct stat sbuf;
       cc_string_sprintf(path, "%s/%s", currententry, file);
@@ -578,7 +578,7 @@ cc_libhandle
 cc_dl_open(const char * filename)
 {
   cc_libhandle h = new struct cc_libhandle_struct;
-  h->nativehnd = NULL;
+  h->nativehnd = nullptr;
   h->libname = NULL_STR;
 
 #ifdef HAVE_DL_LIB
@@ -587,7 +587,7 @@ cc_dl_open(const char * filename)
   /* Mac OS X: Search for library shipped with bundled Inventor framework
      or directly in application bundle. */
 
-  if (h->nativehnd == NULL) {
+  if (h->nativehnd == nullptr) {
     cc_string * path = cc_find_file(filename);
     if (cc_string_length(path) > 0) {
       if (cc_dl_debugging()) {
@@ -601,7 +601,7 @@ cc_dl_open(const char * filename)
   }
 #endif /* HAVE_DYLD_RUNTIME_BINDING */
 
-  if (h->nativehnd == NULL) {
+  if (h->nativehnd == nullptr) {
     /* try loading path-less */
     h->nativehnd = dlopen(filename, RTLD_LAZY);
   }
@@ -613,7 +613,7 @@ cc_dl_open(const char * filename)
     or release mode.
 
     The libdl interface doesn't provide any means to do that, though,
-    so we'll just /assume/ that a NULL return means the library
+    so we'll just /assume/ that a nullptr return means the library
     couldn't be found.
 
     But if a special debugging environment variable is found, we'll
@@ -621,7 +621,7 @@ cc_dl_open(const char * filename)
     debugging:
   */
 
-  if (cc_dl_debugging() && (h->nativehnd == NULL)) {
+  if (cc_dl_debugging() && (h->nativehnd == nullptr)) {
     const char * e = dlerror();
     if (e) {
       cc_debugerror_post("cc_dl_open", "dlopen(\"%s\") failed with: '%s'", 
@@ -631,16 +631,16 @@ cc_dl_open(const char * filename)
 
 #elif defined (HAVE_DYLD_RUNTIME_BINDING) 
 
-  if (filename == NULL) {
+  if (filename == nullptr) {
 
     /* 
-       Simulate the behaviour of dlopen(NULL) by returning a handle to
+       Simulate the behaviour of dlopen(nullptr) by returning a handle to
        the first image loaded by the dynamic linker, which is the
        current process. See dyld(3).
 
        Note that this handle is not necessary for the dyld cc_dl_sym()
        implementation, but it makes it possible to use cc_dl_open() in
-       the "classic" dlopen() style (where a NULL return value would
+       the "classic" dlopen() style (where a nullptr return value would
        indicate failure).
     */ 
     h->nativehnd = _dyld_get_image_header(0);
@@ -678,11 +678,11 @@ cc_dl_open(const char * filename)
 
 #elif defined (HAVE_WINDLL_RUNTIME_BINDING)
 
-  /* We don't want to call LoadLibrary(NULL) because this causes a
+  /* We don't want to call LoadLibrary(nullptr) because this causes a
      crash on some Windows platforms (Crashes on Windows2000 has been
      reported). 20021101 thammer.
   */
-  if (filename != NULL) {
+  if (filename != nullptr) {
 
     /* Don't use GetModuleHandle(): LoadLibrary() will *not* load a
        new image if the module is already loaded, it will only inc the
@@ -695,7 +695,7 @@ cc_dl_open(const char * filename)
     */
     h->nativehnd = LoadLibrary(filename);
 
-    if (cc_dl_debugging() && (h->nativehnd == NULL)) {
+    if (cc_dl_debugging() && (h->nativehnd == nullptr)) {
       cc_string funcstr;
       cc_string_construct(&funcstr);
       cc_string_sprintf(&funcstr, "LoadLibrary(\"%s\")", filename ? filename : "(null)");
@@ -704,9 +704,9 @@ cc_dl_open(const char * filename)
     }
   }
   else {
-    h->nativehnd = GetModuleHandle(NULL);
-    if (cc_dl_debugging() && (h->nativehnd == NULL)) {
-      cc_win32_print_error("cc_dl_open", "GetModuleHandle(NULL)", GetLastError());
+    h->nativehnd = GetModuleHandle(nullptr);
+    if (cc_dl_debugging() && (h->nativehnd == nullptr)) {
+      cc_win32_print_error("cc_dl_open", "GetModuleHandle(nullptr)", GetLastError());
     }
   }
 
@@ -729,7 +729,7 @@ cc_dl_open(const char * filename)
   /* Handle attempt to look at running executable image and already
      loaded dynamic libraries. */
 
-  if (filename == NULL) {
+  if (filename == nullptr) {
     shl_t exehnd = (shl_t)0;
     void * dummy;
     int ret = shl_findsym(&exehnd, "main", TYPE_UNDEFINED, &dummy);
@@ -759,7 +759,7 @@ cc_dl_open(const char * filename)
       what.
     */
 
-    if ((h->nativehnd == NULL) && (cc_dl_debugging() || (errno != ENOENT))) {
+    if ((h->nativehnd == nullptr) && (cc_dl_debugging() || (errno != ENOENT))) {
       const char * e = strerror(errno);
       cc_debugerror_post("cc_dl_open", "shl_load(\"%s\") failed with: '%s'",
                          filename ? filename : "(null)", e);
@@ -768,9 +768,9 @@ cc_dl_open(const char * filename)
 
 #endif
 
-  if (h->nativehnd == NULL) {
+  if (h->nativehnd == nullptr) {
     delete h;
-    h = NULL;
+    h = nullptr;
   }
   else {
     h->libname = filename ? filename : NULL_STR;
@@ -800,11 +800,11 @@ cc_dl_open(const char * filename)
 void *
 cc_dl_sym(cc_libhandle handle, const char * symbolname)
 {
-  void * ptr = NULL;  
+  void * ptr = nullptr;  
 
 #ifdef HAVE_DL_LIB
 
-  if ((handle == NULL) || (handle->nativehnd == NULL)) return NULL;
+  if ((handle == nullptr) || (handle->nativehnd == nullptr)) return nullptr;
   ptr = dlsym((void *)handle->nativehnd, symbolname);
 
   if (cc_dl_debugging()) {
@@ -817,13 +817,13 @@ cc_dl_sym(cc_libhandle handle, const char * symbolname)
 
 #elif defined (HAVE_DYLD_RUNTIME_BINDING) 
 
-  /* Note: The dlopen() version returns NULL here if handle or
-     handle->nativehnd are NULL, but we do not need a handle for
+  /* Note: The dlopen() version returns nullptr here if handle or
+     handle->nativehnd are nullptr, but we do not need a handle for
      symbol lookup on Mac OS X - if we have one, it makes the lookup
      faster, but that's all, so we can get away with having no valid
      handle. */
 
-  NSSymbol symbol = NULL;
+  NSSymbol symbol = nullptr;
   char * mangledname;
   NSLinkEditErrors c;
   int e;
@@ -847,7 +847,7 @@ cc_dl_sym(cc_libhandle handle, const char * symbolname)
   } 
 
   /* If we did not specifically load the library ourselves
-     (handle->nativehnd being NULL), or if the symbol could not be
+     (handle->nativehnd being nullptr), or if the symbol could not be
      found in the library, let's try if we can find it in any of the
      loaded libs. */
 
@@ -856,7 +856,7 @@ cc_dl_sym(cc_libhandle handle, const char * symbolname)
   } 
 
   if (cc_dl_debugging()) {
-    if (symbol == NULL) {
+    if (symbol == nullptr) {
       NSLinkEditError(&c, &e, &file, &errstr);
       cc_debugerror_post("cc_dl_sym", "symbol %s not found: %s", 
                          symbolname, errstr);
@@ -864,15 +864,15 @@ cc_dl_sym(cc_libhandle handle, const char * symbolname)
   }
 
   free (mangledname);
-  ptr = symbol ? NSAddressOfSymbol(symbol) : NULL;  
+  ptr = symbol ? NSAddressOfSymbol(symbol) : nullptr;  
   
 #elif defined (HAVE_WINDLL_RUNTIME_BINDING)
 
-  if ((handle == NULL) || (handle->nativehnd == NULL)) return NULL;
+  if ((handle == nullptr) || (handle->nativehnd == nullptr)) return nullptr;
  
   ptr = dl_internal::cstyle_cast<void *>(GetProcAddress((HINSTANCE) handle->nativehnd, symbolname));
 
-  if (cc_dl_debugging() && (ptr == NULL)) {
+  if (cc_dl_debugging() && (ptr == nullptr)) {
     cc_string funcstr;
     cc_string_construct(&funcstr);
     cc_string_sprintf(&funcstr, "GetProcAddress(\"%s\", \"%s\")", handle->libname.getString(), symbolname);
@@ -979,7 +979,7 @@ cc_dl_close(cc_libhandle handle)
 cc_libhandle
 cc_dl_process_handle(void)
 {
-  return cc_dl_open(NULL);
+  return cc_dl_open(nullptr);
 }
 
 /*
@@ -1005,7 +1005,7 @@ cc_dl_coin_handle(void)
     /* (instead of "cc_dl_open", we could use any other function in
        the public API) */
 
-    if (func == NULL) {
+    if (func == nullptr) {
       /* in case we're using the --enable-linkhack dev hack */
       cc_libhandle gluehnd = cc_dl_open("libglueLINKHACK" DYNAMIC_LIBRARY_EXTENSION);
       if (gluehnd) {
@@ -1038,7 +1038,7 @@ cc_dl_coin_handle(void)
   /* In case of errors when checking if we got a valid image, make
      sure to clean up to avoid resource leak. */
   if (hnd) { cc_dl_close(hnd); }
-  return NULL;
+  return nullptr;
 }
 
 /*
@@ -1082,7 +1082,7 @@ cc_dl_opengl_handle(void)
   /* In case of errors when checking if we got a valid image, make
      sure to clean up to avoid resource leak. */
   if (hnd) { cc_dl_close(hnd); }
-  return NULL;
+  return nullptr;
 }
 
 /* 
@@ -1137,7 +1137,7 @@ cc_dl_handle_with_gl_symbols(void)
       cc_dl_close(hnd); /* OpenGL symbol not found, close again */
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 /* ********************************************************************** */
diff --git a/coin4/src/glue/freetype.cpp b/coin4/src/glue/freetype.cpp
index 1bcb2df..1f15df2 100644
--- a/coin4/src/glue/freetype.cpp
+++ b/coin4/src/glue/freetype.cpp
@@ -125,12 +125,12 @@ typedef struct {
   cc_ftglue_FT_Outline_Decompose_t FT_Outline_Decompose;
 } cc_ftglue_t;
 
-static cc_fcglue_t * fontconfig_instance = NULL;
-static cc_libhandle fontconfig_libhandle = NULL;
+static cc_fcglue_t * fontconfig_instance = nullptr;
+static cc_libhandle fontconfig_libhandle = nullptr;
 static int fontconfig_failed_to_load = 0;
 
-static cc_ftglue_t * freetype_instance = NULL;
-static cc_libhandle freetype_libhandle = NULL;
+static cc_ftglue_t * freetype_instance = nullptr;
+static cc_libhandle freetype_libhandle = nullptr;
 static int freetype_failed_to_load = 0;
 
 /* Cleans up fontconfig at exit. */
@@ -140,12 +140,12 @@ fcglue_cleanup(void)
 #ifdef FONTCONFIG_RUNTIME_LINKING
   if (fontconfig_libhandle) {
     cc_dl_close(fontconfig_libhandle);
-    fontconfig_libhandle = NULL;
+    fontconfig_libhandle = nullptr;
   }
 #endif /* FONTCONFIG_RUNTIME_LINKING */
   assert(fontconfig_instance);
   free(fontconfig_instance);
-  fontconfig_instance = NULL;
+  fontconfig_instance = nullptr;
   fontconfig_failed_to_load = 0;
 }
 
@@ -169,10 +169,10 @@ fcglue_init(void)
       /* FIXME: should we get the system shared library name from an
          Autoconf check? 20000930 mortene. */
       const char * possiblelibnames[] = {
-        NULL, /* is set below */
+        nullptr, /* is set below */
         "fontconfig", "libfontconfig", "libfontconfig.so",
         "libfontconfig.dylib",
-        NULL
+        nullptr
       };
       possiblelibnames[0] = coin_getenv("COIN_FONTCONFIG_LIBNAME");
       idx = possiblelibnames[0] ? 0 : 1;
@@ -191,7 +191,7 @@ fcglue_init(void)
 #define FCGLUE_REGISTER_FUNC(_funcsig_, _funcname_) \
     do { \
       fi->_funcname_ = (_funcsig_)cc_dl_sym(fontconfig_libhandle, SO__QUOTE(_funcname_)); \
-      if (fi->_funcname_ == NULL) fi->available = 0; \
+      if (fi->_funcname_ == nullptr) fi->available = 0; \
     } while (0)
 
 #elif defined(FONTCONFIGGLUE_ASSUME_FONTCONFIG) /* !FONTCONFIG_RUNTIME_LINKING */
@@ -204,7 +204,7 @@ fcglue_init(void)
     fi->available = 0;
     /* Define FCGLUE_REGISTER_FUNC macro. */
 #define FCGLUE_REGISTER_FUNC(_funcsig_, _funcname_) \
-    fi->_funcname_ = NULL
+    fi->_funcname_ = nullptr
 
 #endif /* !FONTCONFIGGLUE_ASSUME_FONTCONFIG */
 
@@ -319,12 +319,12 @@ ftglue_cleanup(void)
 #ifdef FREETYPE_RUNTIME_LINKING
   if (freetype_libhandle) {
     cc_dl_close(freetype_libhandle);
-    freetype_libhandle = NULL;
+    freetype_libhandle = nullptr;
   }
 #endif /* FREETYPE_RUNTIME_LINKING */
   assert(freetype_instance);
   free(freetype_instance);
-  freetype_instance = NULL;
+  freetype_instance = nullptr;
   freetype_failed_to_load = 0;
 }
 
@@ -348,10 +348,10 @@ ftglue_init(void)
       /* FIXME: should we get the system shared library name from an
          Autoconf check? 20000930 mortene. */
       const char * possiblelibnames[] = {
-        NULL, /* is set below */
+        nullptr, /* is set below */
         "freetype", "libfreetype", "libfreetype.so",
         "libfreetype.dylib",
-        NULL
+        nullptr
       };
       possiblelibnames[0] = coin_getenv("COIN_FREETYPE2_LIBNAME");
       idx = possiblelibnames[0] ? 0 : 1;
@@ -371,7 +371,7 @@ ftglue_init(void)
 #define FTGLUE_REGISTER_FUNC(_funcsig_, _funcname_) \
     do { \
       fi->_funcname_ = (_funcsig_)cc_dl_sym(freetype_libhandle, SO__QUOTE(_funcname_)); \
-      if (fi->_funcname_ == NULL) fi->available = 0; \
+      if (fi->_funcname_ == nullptr) fi->available = 0; \
     } while (0)
 
 #elif defined(FREETYPEGLUE_ASSUME_FREETYPE) /* !FREETYPE_RUNTIME_LINKING */
@@ -384,7 +384,7 @@ ftglue_init(void)
     fi->available = 0;
     /* Define FTGLUE_REGISTER_FUNC macro. */
 #define FTGLUE_REGISTER_FUNC(_funcsig_, _funcname_) \
-    fi->_funcname_ = NULL
+    fi->_funcname_ = nullptr
 
 #endif /* !FREETYPEGLUE_ASSUME_FREETYPE */
 
diff --git a/coin4/src/glue/gl.cpp b/coin4/src/glue/gl.cpp
index 1300f76..8b6fb58 100644
--- a/coin4/src/glue/gl.cpp
+++ b/coin4/src/glue/gl.cpp
@@ -94,7 +94,7 @@
     cc_glglue_glTexImage3D(glw, GL_PROXY_TEXTURE_3D, 0, GL_RGBA,
                            64, 64, 64, 0,
                            GL_RGBA, GL_UNSIGNED_BYTE,
-                           NULL);
+                           nullptr);
   }
   else {
     // Implement a proper fallback or error handling.
@@ -252,10 +252,10 @@ extern "C" {
 }
 #endif
 
-static cc_list * gl_instance_created_cblist = NULL;
+static cc_list * gl_instance_created_cblist = nullptr;
 static int COIN_MAXIMUM_TEXTURE2_SIZE = -1;
 static int COIN_MAXIMUM_TEXTURE3_SIZE = -1;
-static cc_glglue_offscreen_cb_functions* offscreen_cb = NULL;
+static cc_glglue_offscreen_cb_functions* offscreen_cb = nullptr;
 static int COIN_USE_AGL = -1;
 
 /* ********************************************************************** */
@@ -569,7 +569,7 @@ coin_glglue_dl_handle(const cc_glglue * glue)
 void *
 cc_glglue_getprocaddress(const cc_glglue * glue, const char * symname)
 {
-  void * ptr = NULL;
+  void * ptr = nullptr;
 
   // FIXME: also supply 'glue' to coin_[x]gl_getprocaddress()
   ptr = coin_wgl_getprocaddress(glue, symname);
@@ -590,7 +590,7 @@ returnpoint:
 
 /* Global dictionary which stores the mappings from the context IDs to
    actual cc_glglue instances. */
-static cc_dict * gldict = NULL;
+static cc_dict * gldict = nullptr;
 
 static void
 free_glglue_instance(uintptr_t COIN_UNUSED_ARG(key), void * value, void * COIN_UNUSED_ARG(closure))
@@ -605,11 +605,11 @@ static void
 glglue_cleanup(void)
 {
   if (gldict) {
-    cc_dict_apply(gldict, free_glglue_instance, NULL);
+    cc_dict_apply(gldict, free_glglue_instance, nullptr);
     cc_dict_destruct(gldict);
-    gldict = NULL;
+    gldict = nullptr;
   }
-  offscreen_cb = NULL;
+  offscreen_cb = nullptr;
 
 #ifdef HAVE_GLX
   glxglue_cleanup();
@@ -753,7 +753,7 @@ coin_glglue_extension_available(const char * extensions, const char * ext)
 
   assert(ext && "NULL string");
   assert((ext[0] != '\0') && "empty string");
-  assert((strchr(ext, ' ') == NULL) && "extension name can't have spaces");
+  assert((strchr(ext, ' ') == nullptr) && "extension name can't have spaces");
 
   start = extensions;
   extlen = strlen(ext);
@@ -788,15 +788,15 @@ cc_glglue_glext_supported(const cc_glglue * wrapper, const char * extension)
 {
   const uintptr_t key = (uintptr_t)cc_namemap_get_address(extension);
 
-  void * result = NULL;
+  void * result = nullptr;
   if (cc_dict_get(wrapper->glextdict, key, &result)) {
-    return result != NULL;
+    return result != nullptr;
   }
   result = coin_glglue_extension_available(wrapper->extensionsstr, extension) ?
-    (void*) 1 : NULL;
+    (void*) 1 : nullptr;
   cc_dict_put(wrapper->glextdict, key, result);
 
-  return result != NULL;
+  return result != nullptr;
 }
 
 #ifdef HAVE_DYNAMIC_LINKING
@@ -860,8 +860,8 @@ glglue_resolve_symbols(cc_glglue * w)
   /* Appeared in OpenGL v1.1. We store both the "real" function
      pointer and the extension pointer, in case we need to work around
      an SGI bug (see comments in cc_glglue_glPolygonOffset(). */
-  w->glPolygonOffset = NULL;
-  w->glPolygonOffsetEXT = NULL;
+  w->glPolygonOffset = nullptr;
+  w->glPolygonOffsetEXT = nullptr;
 #ifdef GL_VERSION_1_1
   if (cc_glglue_glversion_matches_at_least(w, 1, 1, 0)) {
     w->glPolygonOffset = (COIN_PFNGLPOLYGONOFFSETPROC)PROC(w, glPolygonOffset);
@@ -876,9 +876,9 @@ glglue_resolve_symbols(cc_glglue * w)
 
 
   /* Appeared in OpenGL v1.1. */
-  w->glGenTextures = NULL;
-  w->glBindTexture = NULL;
-  w->glDeleteTextures = NULL;
+  w->glGenTextures = nullptr;
+  w->glBindTexture = nullptr;
+  w->glDeleteTextures = nullptr;
 #ifdef GL_VERSION_1_1
   if (cc_glglue_glversion_matches_at_least(w, 1, 1, 0)) {
     w->glGenTextures = (COIN_PFNGLGENTEXTURESPROC)PROC(w, glGenTextures);
@@ -895,7 +895,7 @@ glglue_resolve_symbols(cc_glglue * w)
 #endif /* GL_EXT_texture_object */
 
   /* Appeared in OpenGL v1.1. */
-  w->glTexSubImage2D = NULL;
+  w->glTexSubImage2D = nullptr;
 #ifdef GL_VERSION_1_1
   if (cc_glglue_glversion_matches_at_least(w, 1, 1, 0)) {
     w->glTexSubImage2D = (COIN_PFNGLTEXSUBIMAGE2DPROC)PROC(w, glTexSubImage2D);
@@ -908,8 +908,8 @@ glglue_resolve_symbols(cc_glglue * w)
 #endif /* GL_EXT_subtexture */
 
   /* Appeared in OpenGL 1.1 */
-  w->glPushClientAttrib = NULL;
-  w->glPopClientAttrib = NULL;
+  w->glPushClientAttrib = nullptr;
+  w->glPopClientAttrib = nullptr;
 #ifdef GL_VERSION_1_1
   if (cc_glglue_glversion_matches_at_least(w, 1, 1, 0)) {
     w->glPushClientAttrib = (COIN_PFNGLPUSHCLIENTATTRIBPROC) PROC(w, glPushClientAttrib);
@@ -918,9 +918,9 @@ glglue_resolve_symbols(cc_glglue * w)
 #endif /* GL_VERSION_1_1 */
 
   /* These were introduced with OpenGL v1.2. */
-  w->glTexImage3D = NULL;
-  w->glCopyTexSubImage3D = NULL;
-  w->glTexSubImage3D = NULL;
+  w->glTexImage3D = nullptr;
+  w->glCopyTexSubImage3D = nullptr;
+  w->glTexSubImage3D = nullptr;
 #ifdef GL_VERSION_1_2
   if (cc_glglue_glversion_matches_at_least(w, 1, 2, 0)) {
     w->glTexImage3D = (COIN_PFNGLTEXIMAGE3DPROC)PROC(w, glTexImage3D);
@@ -967,12 +967,12 @@ glglue_resolve_symbols(cc_glglue * w)
 
      20041108 mortene, based on information provided by handegar.
   */
-  w->glActiveTexture = NULL;
-  w->glClientActiveTexture = NULL;
-  w->glMultiTexCoord2f = NULL;
-  w->glMultiTexCoord2fv = NULL;
-  w->glMultiTexCoord3fv = NULL;
-  w->glMultiTexCoord4fv = NULL;
+  w->glActiveTexture = nullptr;
+  w->glClientActiveTexture = nullptr;
+  w->glMultiTexCoord2f = nullptr;
+  w->glMultiTexCoord2fv = nullptr;
+  w->glMultiTexCoord3fv = nullptr;
+  w->glMultiTexCoord4fv = nullptr;
 #ifdef GL_VERSION_1_3
   if (cc_glglue_glversion_matches_at_least(w, 1, 3, 0)) {
     w->glActiveTexture = (COIN_PFNGLACTIVETEXTUREPROC)PROC(w, glActiveTexture);
@@ -1000,7 +1000,7 @@ glglue_resolve_symbols(cc_glglue * w)
         !w->glMultiTexCoord2fv ||
         !w->glMultiTexCoord3fv ||
         !w->glMultiTexCoord4fv) {
-      w->glActiveTexture = NULL; /* cc_glglue_has_multitexture() will return false */
+      w->glActiveTexture = nullptr; /* cc_glglue_has_multitexture() will return false */
       if (COIN_DEBUG || coin_glglue_debug()) {
         cc_debugerror_postwarning("glglue_init",
                                   "glActiveTexture found, but one or more of the other "
@@ -1015,13 +1015,13 @@ glglue_resolve_symbols(cc_glglue * w)
     w->maxtextureunits = (int) tmp;
   }
 
-  w->glCompressedTexImage1D = NULL;
-  w->glCompressedTexImage2D = NULL;
-  w->glCompressedTexImage3D = NULL;
-  w->glCompressedTexSubImage1D = NULL;
-  w->glCompressedTexSubImage2D = NULL;
-  w->glCompressedTexSubImage3D = NULL;
-  w->glGetCompressedTexImage = NULL;
+  w->glCompressedTexImage1D = nullptr;
+  w->glCompressedTexImage2D = nullptr;
+  w->glCompressedTexImage3D = nullptr;
+  w->glCompressedTexSubImage1D = nullptr;
+  w->glCompressedTexSubImage2D = nullptr;
+  w->glCompressedTexSubImage3D = nullptr;
+  w->glGetCompressedTexImage = nullptr;
 
 #ifdef GL_VERSION_1_3
   if (cc_glglue_glversion_matches_at_least(w, 1, 3, 0)) {
@@ -1036,7 +1036,7 @@ glglue_resolve_symbols(cc_glglue * w)
 #endif /* GL_VERSION_1_3 */
 
 #ifdef GL_ARB_texture_compression
-  if ((w->glCompressedTexImage1D == NULL) &&
+  if ((w->glCompressedTexImage1D == nullptr) &&
       cc_glglue_glext_supported(w, "GL_ARB_texture_compression")) {
     w->glCompressedTexImage1D = (COIN_PFNGLCOMPRESSEDTEXIMAGE1DPROC)PROC(w, glCompressedTexImage1DARB);
     w->glCompressedTexImage2D = (COIN_PFNGLCOMPRESSEDTEXIMAGE2DPROC)PROC(w, glCompressedTexImage2DARB);
@@ -1048,11 +1048,11 @@ glglue_resolve_symbols(cc_glglue * w)
   }
 #endif /* GL_ARB_texture_compression */
 
-  w->glColorTable = NULL;
-  w->glColorSubTable = NULL;
-  w->glGetColorTable = NULL;
-  w->glGetColorTableParameteriv = NULL;
-  w->glGetColorTableParameterfv = NULL;
+  w->glColorTable = nullptr;
+  w->glColorSubTable = nullptr;
+  w->glGetColorTable = nullptr;
+  w->glGetColorTableParameteriv = nullptr;
+  w->glGetColorTableParameterfv = nullptr;
 
 #if defined(GL_VERSION_1_2) && defined(GL_ARB_imaging)
   if (cc_glglue_glversion_matches_at_least(w, 1, 2, 0) &&
@@ -1066,7 +1066,7 @@ glglue_resolve_symbols(cc_glglue * w)
 #endif /* GL_VERSION_1_2 && GL_ARB_imaging */
 
 #if defined(GL_EXT_color_table)
-  if ((w->glColorTable == NULL) &&
+  if ((w->glColorTable == nullptr) &&
       cc_glglue_glext_supported(w, "GL_EXT_color_table")) {
     w->glColorTable = (COIN_PFNGLCOLORTABLEPROC)PROC(w, glColorTableEXT);
     w->glGetColorTable = (COIN_PFNGLGETCOLORTABLEPROC)PROC(w, glGetColorTableEXT);
@@ -1076,7 +1076,7 @@ glglue_resolve_symbols(cc_glglue * w)
 #endif /* GL_EXT_color_table */
 
 #if defined(GL_SGI_color_table)
-  if ((w->glColorTable == NULL) &&
+  if ((w->glColorTable == nullptr) &&
       cc_glglue_glext_supported(w, "GL_SGI_color_table")) {
     w->glColorTable = (COIN_PFNGLCOLORTABLEPROC)PROC(w, glColorTableSGI);
     w->glGetColorTable = (COIN_PFNGLGETCOLORTABLEPROC)PROC(w, glGetColorTableSGI);
@@ -1086,7 +1086,7 @@ glglue_resolve_symbols(cc_glglue * w)
 #endif /* GL_SGI_color_table */
 
 #if defined(GL_EXT_color_subtable)
-  if ((w->glColorSubTable == NULL) &&
+  if ((w->glColorSubTable == nullptr) &&
       cc_glglue_glext_supported(w, "GL_EXT_color_subtable")) {
     w->glColorSubTable = (COIN_PFNGLCOLORSUBTABLEPROC)PROC(w, glColorSubTableEXT);
   }
@@ -1104,7 +1104,7 @@ glglue_resolve_symbols(cc_glglue * w)
      EXT_color_table / SGI_color_table / OGL1.2+ + ARB_imaging. It
      only defines a *subset* of what EXT_color_table etc defines,
      though. */
-  if ((w->glColorTable == NULL) &&
+  if ((w->glColorTable == nullptr) &&
       cc_glglue_glext_supported(w, "GL_EXT_paletted_texture")) {
     w->glColorTable = (COIN_PFNGLCOLORTABLEPROC)PROC(w, glColorTableEXT);
     w->glColorSubTable = (COIN_PFNGLCOLORSUBTABLEPROC)PROC(w, glColorSubTableEXT);
@@ -1153,7 +1153,7 @@ glglue_resolve_symbols(cc_glglue * w)
      EXT_color_table / SGI_color_table / OGL1.2+ + ARB_imaging. It
      only defines a *subset* of what EXT_color_table etc defines,
      though. */
-  if ((w->glColorTable == NULL) &&
+  if ((w->glColorTable == nullptr) &&
       cc_glglue_glext_supported(w, "GL_SGI_texture_color_table")) {
     w->glColorTable = (COIN_PFNGLCOLORTABLEPROC)PROC(w, glColorTableSGI);
     w->glGetColorTable = (COIN_PFNGLGETCOLORTABLEPROC)PROC(w, glGetColorTableSGI);
@@ -1164,8 +1164,8 @@ glglue_resolve_symbols(cc_glglue * w)
 #endif /* disabled */
 
 
-  w->glBlendEquation = NULL;
-  w->glBlendEquationEXT = NULL;
+  w->glBlendEquation = nullptr;
+  w->glBlendEquationEXT = nullptr;
 
 #if defined(GL_VERSION_1_4)
   if (cc_glglue_glversion_matches_at_least(w, 1, 4, 0)) {
@@ -1173,7 +1173,7 @@ glglue_resolve_symbols(cc_glglue * w)
   }
 #endif /* GL_VERSION_1_4 */
 
-  if (w->glBlendEquation == NULL) {
+  if (w->glBlendEquation == nullptr) {
 #if defined(GL_VERSION_1_2) && defined(GL_ARB_imaging)
     if (cc_glglue_glversion_matches_at_least(w, 1, 2, 0) &&
         cc_glglue_glext_supported(w, "GL_ARB_imaging")) {
@@ -1188,14 +1188,14 @@ glglue_resolve_symbols(cc_glglue * w)
   }
 #endif /* GL_EXT_blend_minmax */
 
-  w->glBlendFuncSeparate = NULL;
+  w->glBlendFuncSeparate = nullptr;
 #if defined(GL_VERSION_1_4)
   if (cc_glglue_glversion_matches_at_least(w, 1, 4, 0)) {
     w->glBlendFuncSeparate = (COIN_PFNGLBLENDFUNCSEPARATEPROC)PROC(w, glBlendFuncSeparate);
   }
 #endif /* GL_VERSION_1_4 */
 
-  w->glVertexPointer = NULL; /* for cc_glglue_has_vertex_array() */
+  w->glVertexPointer = nullptr; /* for cc_glglue_has_vertex_array() */
 #if defined(GL_VERSION_1_1)
   if (cc_glglue_glversion_matches_at_least(w, 1, 1, 0)) {
     w->glVertexPointer = (COIN_PFNGLVERTEXPOINTERPROC) PROC(w, glVertexPointer);
@@ -1221,7 +1221,7 @@ glglue_resolve_symbols(cc_glglue * w)
         !w->glDrawArrays ||
         !w->glDrawElements ||
         !w->glArrayElement) {
-      w->glVertexPointer = NULL; /* cc_glglue_has_vertex_array() will return false */
+      w->glVertexPointer = nullptr; /* cc_glglue_has_vertex_array() will return false */
       if (COIN_DEBUG || coin_glglue_debug()) {
         cc_debugerror_postwarning("glglue_init",
                                   "glVertexPointer found, but one or more of the other "
@@ -1233,15 +1233,15 @@ glglue_resolve_symbols(cc_glglue * w)
 
 
 #if defined(GL_VERSION_1_2)
-  w->glDrawRangeElements = NULL;
+  w->glDrawRangeElements = nullptr;
   if (cc_glglue_glversion_matches_at_least(w, 1, 2, 0))
     w->glDrawRangeElements = (COIN_PFNGLDRAWRANGEELEMENTSPROC) PROC(w, glDrawRangeElements);
 #endif /* GL_VERSION_1_2 */
 
 
   /* Appeared in OpenGL v1.4 (but also in GL_EXT_multi_draw_array extension */
-  w->glMultiDrawArrays = NULL;
-  w->glMultiDrawElements = NULL;
+  w->glMultiDrawArrays = nullptr;
+  w->glMultiDrawElements = nullptr;
 #if defined(GL_VERSION_1_4)
   if (cc_glglue_glversion_matches_at_least(w, 1, 4, 0)) {
     w->glMultiDrawArrays = (COIN_PFNGLMULTIDRAWARRAYSPROC) PROC(w, glMultiDrawArrays);
@@ -1249,13 +1249,13 @@ glglue_resolve_symbols(cc_glglue * w)
   }
 #endif /* GL_VERSION_1_4 */
 #if defined(GL_EXT_multi_draw_arrays)
-  if ((w->glMultiDrawArrays == NULL) && cc_glglue_glext_supported(w, "GL_EXT_multi_draw_arrays")) {
+  if ((w->glMultiDrawArrays == nullptr) && cc_glglue_glext_supported(w, "GL_EXT_multi_draw_arrays")) {
     w->glMultiDrawArrays = (COIN_PFNGLMULTIDRAWARRAYSPROC) PROC(w, glMultiDrawArraysEXT);
     w->glMultiDrawElements = (COIN_PFNGLMULTIDRAWELEMENTSPROC) PROC(w, glMultiDrawElementsEXT);
   }
 #endif /* GL_EXT_multi_draw_arrays */
 
-  w->glBindBuffer = NULL; /* so that cc_glglue_has_vertex_buffer_objects() works  */
+  w->glBindBuffer = nullptr; /* so that cc_glglue_has_vertex_buffer_objects() works  */
 #if defined(GL_VERSION_1_5)
   if (cc_glglue_glversion_matches_at_least(w, 1, 5, 0)) {
     w->glBindBuffer = (COIN_PFNGLBINDBUFFERPROC) PROC(w, glBindBuffer);
@@ -1273,7 +1273,7 @@ glglue_resolve_symbols(cc_glglue * w)
 #endif /* GL_VERSION_1_5 */
 
 #if defined(GL_ARB_vertex_buffer_object)
-  if ((w->glBindBuffer == NULL) && cc_glglue_glext_supported(w, "GL_ARB_vertex_buffer_object")) {
+  if ((w->glBindBuffer == nullptr) && cc_glglue_glext_supported(w, "GL_ARB_vertex_buffer_object")) {
     w->glBindBuffer = (COIN_PFNGLBINDBUFFERPROC) PROC(w, glBindBufferARB);
     w->glDeleteBuffers = (COIN_PFNGLDELETEBUFFERSPROC) PROC(w, glDeleteBuffersARB);
     w->glGenBuffers = (COIN_PFNGLGENBUFFERSPROC) PROC(w, glGenBuffersARB);
@@ -1294,13 +1294,13 @@ glglue_resolve_symbols(cc_glglue * w)
      the 53.28 driver (version 1.4.1). */
   if (!strcmp(w->vendorstr, "NVIDIA Corporation")) {
     if (!cc_glglue_glversion_matches_at_least(w, 1, 4, 1)) {
-      w->glBindBuffer = NULL;
+      w->glBindBuffer = nullptr;
     }
     /* VBOs seems really slow on the GeForce4 Go GPUs, but this test
        is disabled for now until we know for sure that VBOs will
        always be slow for this GPU */
     /*     else if (strstr(w->rendererstr, "GeForce4 420 Go")) { */
-    /*       w->glBindBuffer = NULL; */
+    /*       w->glBindBuffer = nullptr; */
     /*     } */
     /* FIXME: I guess the above has been made obsolete by the VBO
        performance testing we now do..? pederb should confirm.
@@ -1320,7 +1320,7 @@ glglue_resolve_symbols(cc_glglue * w)
   */
   if (w->glBindBuffer) {
     const char * env = coin_getenv("COIN_GL_DISABLE_VBO");
-    if (env && (atoi(env) > 0)) { w->glBindBuffer = NULL; }
+    if (env && (atoi(env) > 0)) { w->glBindBuffer = nullptr; }
   }
 
 
@@ -1336,7 +1336,7 @@ glglue_resolve_symbols(cc_glglue * w)
       const char * env = coin_getenv("COIN_VBO");
       if (!env || (atoi(env) > 0)) {
         if (w->vendor_is_intel) {
-          w->glBindBuffer = NULL;
+          w->glBindBuffer = nullptr;
         }
       }
     }
@@ -1352,7 +1352,7 @@ glglue_resolve_symbols(cc_glglue * w)
     /* Enable users to override this workaround by setting COIN_VBO=1 */
     const char * env = coin_getenv("COIN_VBO");
     if (!env || (atoi(env) > 0)) {
-      w->glBindBuffer = NULL;
+      w->glBindBuffer = nullptr;
     }
   }
 
@@ -1369,7 +1369,7 @@ glglue_resolve_symbols(cc_glglue * w)
         !w->glUnmapBuffer ||
         !w->glGetBufferParameteriv ||
         !w->glGetBufferPointerv) {
-      w->glBindBuffer = NULL; /* so that cc_glglue_has_vertex_buffer_object() will return false */
+      w->glBindBuffer = nullptr; /* so that cc_glglue_has_vertex_buffer_object() will return false */
       if (COIN_DEBUG || coin_glglue_debug()) {
         cc_debugerror_postwarning("glglue_init",
                                   "glBindBuffer found, but one or more of the other "
@@ -1379,19 +1379,19 @@ glglue_resolve_symbols(cc_glglue * w)
   }
 
   /* GL_NV_register_combiners */
-  w->glCombinerParameterfvNV = NULL;
-  w->glCombinerParameterivNV = NULL;
-  w->glCombinerParameterfNV = NULL;
-  w->glCombinerParameteriNV = NULL;
-  w->glCombinerInputNV = NULL;
-  w->glCombinerOutputNV = NULL;
-  w->glFinalCombinerInputNV = NULL;
-  w->glGetCombinerInputParameterfvNV = NULL;
-  w->glGetCombinerInputParameterivNV = NULL;
-  w->glGetCombinerOutputParameterfvNV = NULL;
-  w->glGetCombinerOutputParameterivNV = NULL;
-  w->glGetFinalCombinerInputParameterfvNV = NULL;
-  w->glGetFinalCombinerInputParameterivNV = NULL;
+  w->glCombinerParameterfvNV = nullptr;
+  w->glCombinerParameterivNV = nullptr;
+  w->glCombinerParameterfNV = nullptr;
+  w->glCombinerParameteriNV = nullptr;
+  w->glCombinerInputNV = nullptr;
+  w->glCombinerOutputNV = nullptr;
+  w->glFinalCombinerInputNV = nullptr;
+  w->glGetCombinerInputParameterfvNV = nullptr;
+  w->glGetCombinerInputParameterivNV = nullptr;
+  w->glGetCombinerOutputParameterfvNV = nullptr;
+  w->glGetCombinerOutputParameterivNV = nullptr;
+  w->glGetFinalCombinerInputParameterfvNV = nullptr;
+  w->glGetFinalCombinerInputParameterivNV = nullptr;
   w->has_nv_register_combiners = false;
 
 #ifdef GL_NV_register_combiners
@@ -1456,25 +1456,25 @@ glglue_resolve_symbols(cc_glglue * w)
                                 cc_glglue_glversion_matches_at_least(w, 1, 3, 0));
 
   /* GL_ARB_fragment_program */
-  w->glProgramStringARB = NULL;
-  w->glBindProgramARB = NULL;
-  w->glDeleteProgramsARB = NULL;
-  w->glGenProgramsARB = NULL;
-  w->glProgramEnvParameter4dARB = NULL;
-  w->glProgramEnvParameter4dvARB = NULL;
-  w->glProgramEnvParameter4fARB = NULL;
-  w->glProgramEnvParameter4fvARB = NULL;
-  w->glProgramLocalParameter4dARB = NULL;
-  w->glProgramLocalParameter4dvARB = NULL;
-  w->glProgramLocalParameter4fARB = NULL;
-  w->glProgramLocalParameter4fvARB = NULL;
-  w->glGetProgramEnvParameterdvARB = NULL;
-  w->glGetProgramEnvParameterfvARB = NULL;
-  w->glGetProgramLocalParameterdvARB = NULL;
-  w->glGetProgramLocalParameterfvARB = NULL;
-  w->glGetProgramivARB = NULL;
-  w->glGetProgramStringARB = NULL;
-  w->glIsProgramARB = NULL;
+  w->glProgramStringARB = nullptr;
+  w->glBindProgramARB = nullptr;
+  w->glDeleteProgramsARB = nullptr;
+  w->glGenProgramsARB = nullptr;
+  w->glProgramEnvParameter4dARB = nullptr;
+  w->glProgramEnvParameter4dvARB = nullptr;
+  w->glProgramEnvParameter4fARB = nullptr;
+  w->glProgramEnvParameter4fvARB = nullptr;
+  w->glProgramLocalParameter4dARB = nullptr;
+  w->glProgramLocalParameter4dvARB = nullptr;
+  w->glProgramLocalParameter4fARB = nullptr;
+  w->glProgramLocalParameter4fvARB = nullptr;
+  w->glGetProgramEnvParameterdvARB = nullptr;
+  w->glGetProgramEnvParameterfvARB = nullptr;
+  w->glGetProgramLocalParameterdvARB = nullptr;
+  w->glGetProgramLocalParameterfvARB = nullptr;
+  w->glGetProgramivARB = nullptr;
+  w->glGetProgramStringARB = nullptr;
+  w->glIsProgramARB = nullptr;
   w->has_arb_fragment_program = false;
 
 #ifdef GL_ARB_fragment_program
@@ -1523,68 +1523,68 @@ glglue_resolve_symbols(cc_glglue * w)
 #endif /* GL_ARB_fragment_program */
 
   w->has_arb_vertex_program = false;
-  w->glVertexAttrib1sARB = NULL;
-  w->glVertexAttrib1fARB = NULL;
-  w->glVertexAttrib1dARB = NULL;
-  w->glVertexAttrib2sARB = NULL;
-  w->glVertexAttrib2fARB = NULL;
-  w->glVertexAttrib2dARB = NULL;
-  w->glVertexAttrib3sARB = NULL;
-  w->glVertexAttrib3fARB = NULL;
-  w->glVertexAttrib3dARB = NULL;
-  w->glVertexAttrib4sARB = NULL;
-  w->glVertexAttrib4fARB = NULL;
-  w->glVertexAttrib4dARB = NULL;
-  w->glVertexAttrib4NubARB = NULL;
-  w->glVertexAttrib1svARB = NULL;
-  w->glVertexAttrib1fvARB = NULL;
-  w->glVertexAttrib1dvARB = NULL;
-  w->glVertexAttrib2svARB = NULL;
-  w->glVertexAttrib2fvARB = NULL;
-  w->glVertexAttrib2dvARB = NULL;
-  w->glVertexAttrib3svARB = NULL;
-  w->glVertexAttrib3fvARB = NULL;
-  w->glVertexAttrib3dvARB = NULL;
-  w->glVertexAttrib4bvARB = NULL;
-  w->glVertexAttrib4svARB = NULL;
-  w->glVertexAttrib4ivARB = NULL;
-  w->glVertexAttrib4ubvARB = NULL;
-  w->glVertexAttrib4usvARB = NULL;
-  w->glVertexAttrib4uivARB = NULL;
-  w->glVertexAttrib4fvARB = NULL;
-  w->glVertexAttrib4dvARB = NULL;
-  w->glVertexAttrib4NbvARB = NULL;
-  w->glVertexAttrib4NsvARB = NULL;
-  w->glVertexAttrib4NivARB = NULL;
-  w->glVertexAttrib4NubvARB = NULL;
-  w->glVertexAttrib4NusvARB = NULL;
-  w->glVertexAttrib4NuivARB = NULL;
-  w->glVertexAttribPointerARB = NULL;
-  w->glEnableVertexAttribArrayARB = NULL;
-  w->glDisableVertexAttribArrayARB = NULL;
-  w->glProgramStringARB = NULL;
-  w->glBindProgramARB = NULL;
-  w->glDeleteProgramsARB = NULL;
-  w->glGenProgramsARB = NULL;
-  w->glProgramEnvParameter4dARB = NULL;
-  w->glProgramEnvParameter4dvARB = NULL;
-  w->glProgramEnvParameter4fARB = NULL;
-  w->glProgramEnvParameter4fvARB = NULL;
-  w->glProgramLocalParameter4dARB = NULL;
-  w->glProgramLocalParameter4dvARB = NULL;
-  w->glProgramLocalParameter4fARB = NULL;
-  w->glProgramLocalParameter4fvARB = NULL;
-  w->glGetProgramEnvParameterdvARB = NULL;
-  w->glGetProgramEnvParameterfvARB = NULL;
-  w->glGetProgramLocalParameterdvARB = NULL;
-  w->glGetProgramLocalParameterfvARB = NULL;
-  w->glGetProgramivARB = NULL;
-  w->glGetProgramStringARB = NULL;
-  w->glGetVertexAttribdvARB = NULL;
-  w->glGetVertexAttribfvARB = NULL;
-  w->glGetVertexAttribivARB = NULL;
-  w->glGetVertexAttribPointervARB = NULL;
-  w->glIsProgramARB = NULL;
+  w->glVertexAttrib1sARB = nullptr;
+  w->glVertexAttrib1fARB = nullptr;
+  w->glVertexAttrib1dARB = nullptr;
+  w->glVertexAttrib2sARB = nullptr;
+  w->glVertexAttrib2fARB = nullptr;
+  w->glVertexAttrib2dARB = nullptr;
+  w->glVertexAttrib3sARB = nullptr;
+  w->glVertexAttrib3fARB = nullptr;
+  w->glVertexAttrib3dARB = nullptr;
+  w->glVertexAttrib4sARB = nullptr;
+  w->glVertexAttrib4fARB = nullptr;
+  w->glVertexAttrib4dARB = nullptr;
+  w->glVertexAttrib4NubARB = nullptr;
+  w->glVertexAttrib1svARB = nullptr;
+  w->glVertexAttrib1fvARB = nullptr;
+  w->glVertexAttrib1dvARB = nullptr;
+  w->glVertexAttrib2svARB = nullptr;
+  w->glVertexAttrib2fvARB = nullptr;
+  w->glVertexAttrib2dvARB = nullptr;
+  w->glVertexAttrib3svARB = nullptr;
+  w->glVertexAttrib3fvARB = nullptr;
+  w->glVertexAttrib3dvARB = nullptr;
+  w->glVertexAttrib4bvARB = nullptr;
+  w->glVertexAttrib4svARB = nullptr;
+  w->glVertexAttrib4ivARB = nullptr;
+  w->glVertexAttrib4ubvARB = nullptr;
+  w->glVertexAttrib4usvARB = nullptr;
+  w->glVertexAttrib4uivARB = nullptr;
+  w->glVertexAttrib4fvARB = nullptr;
+  w->glVertexAttrib4dvARB = nullptr;
+  w->glVertexAttrib4NbvARB = nullptr;
+  w->glVertexAttrib4NsvARB = nullptr;
+  w->glVertexAttrib4NivARB = nullptr;
+  w->glVertexAttrib4NubvARB = nullptr;
+  w->glVertexAttrib4NusvARB = nullptr;
+  w->glVertexAttrib4NuivARB = nullptr;
+  w->glVertexAttribPointerARB = nullptr;
+  w->glEnableVertexAttribArrayARB = nullptr;
+  w->glDisableVertexAttribArrayARB = nullptr;
+  w->glProgramStringARB = nullptr;
+  w->glBindProgramARB = nullptr;
+  w->glDeleteProgramsARB = nullptr;
+  w->glGenProgramsARB = nullptr;
+  w->glProgramEnvParameter4dARB = nullptr;
+  w->glProgramEnvParameter4dvARB = nullptr;
+  w->glProgramEnvParameter4fARB = nullptr;
+  w->glProgramEnvParameter4fvARB = nullptr;
+  w->glProgramLocalParameter4dARB = nullptr;
+  w->glProgramLocalParameter4dvARB = nullptr;
+  w->glProgramLocalParameter4fARB = nullptr;
+  w->glProgramLocalParameter4fvARB = nullptr;
+  w->glGetProgramEnvParameterdvARB = nullptr;
+  w->glGetProgramEnvParameterfvARB = nullptr;
+  w->glGetProgramLocalParameterdvARB = nullptr;
+  w->glGetProgramLocalParameterfvARB = nullptr;
+  w->glGetProgramivARB = nullptr;
+  w->glGetProgramStringARB = nullptr;
+  w->glGetVertexAttribdvARB = nullptr;
+  w->glGetVertexAttribfvARB = nullptr;
+  w->glGetVertexAttribivARB = nullptr;
+  w->glGetVertexAttribPointervARB = nullptr;
+  w->glIsProgramARB = nullptr;
 
 
 #ifdef GL_ARB_vertex_program
@@ -1679,9 +1679,9 @@ glglue_resolve_symbols(cc_glglue * w)
 
 #ifdef GL_ARB_vertex_shader
 
-  w->glBindAttribLocationARB = NULL;
-  w->glGetActiveAttribARB = NULL;
-  w->glGetAttribLocationARB = NULL;
+  w->glBindAttribLocationARB = nullptr;
+  w->glGetActiveAttribARB = nullptr;
+  w->glGetAttribLocationARB = nullptr;
 
   if (cc_glglue_glext_supported(w, "GL_ARB_vertex_shader")) {
 
@@ -1712,39 +1712,39 @@ glglue_resolve_symbols(cc_glglue * w)
 #endif /* GL_ARB_vertex_shader */
 
 
-  w->glGetUniformLocationARB = NULL;
-  w->glGetActiveUniformARB = NULL;
-  w->glUniform1fARB = NULL;
-  w->glUniform2fARB = NULL;
-  w->glUniform3fARB = NULL;
-  w->glUniform4fARB = NULL;
-  w->glCreateShaderObjectARB = NULL;
-  w->glShaderSourceARB = NULL;
-  w->glCompileShaderARB = NULL;
-  w->glGetObjectParameterivARB = NULL;
-  w->glDeleteObjectARB = NULL;
-  w->glAttachObjectARB = NULL;
-  w->glDetachObjectARB = NULL;
-  w->glGetInfoLogARB = NULL;
-  w->glLinkProgramARB = NULL;
-  w->glUseProgramObjectARB = NULL;
-  w->glCreateProgramObjectARB = NULL;
+  w->glGetUniformLocationARB = nullptr;
+  w->glGetActiveUniformARB = nullptr;
+  w->glUniform1fARB = nullptr;
+  w->glUniform2fARB = nullptr;
+  w->glUniform3fARB = nullptr;
+  w->glUniform4fARB = nullptr;
+  w->glCreateShaderObjectARB = nullptr;
+  w->glShaderSourceARB = nullptr;
+  w->glCompileShaderARB = nullptr;
+  w->glGetObjectParameterivARB = nullptr;
+  w->glDeleteObjectARB = nullptr;
+  w->glAttachObjectARB = nullptr;
+  w->glDetachObjectARB = nullptr;
+  w->glGetInfoLogARB = nullptr;
+  w->glLinkProgramARB = nullptr;
+  w->glUseProgramObjectARB = nullptr;
+  w->glCreateProgramObjectARB = nullptr;
   w->has_arb_shader_objects = false;
-  w->glUniform1fvARB = NULL;
-  w->glUniform2fvARB = NULL;
-  w->glUniform3fvARB = NULL;
-  w->glUniform4fvARB = NULL;
-  w->glUniform1iARB = NULL;
-  w->glUniform2iARB = NULL;
-  w->glUniform3iARB = NULL;
-  w->glUniform4iARB = NULL;
-  w->glUniform1ivARB = NULL;
-  w->glUniform2ivARB = NULL;
-  w->glUniform3ivARB = NULL;
-  w->glUniform4ivARB = NULL;
-  w->glUniformMatrix2fvARB = NULL;
-  w->glUniformMatrix3fvARB = NULL;
-  w->glUniformMatrix4fvARB = NULL;
+  w->glUniform1fvARB = nullptr;
+  w->glUniform2fvARB = nullptr;
+  w->glUniform3fvARB = nullptr;
+  w->glUniform4fvARB = nullptr;
+  w->glUniform1iARB = nullptr;
+  w->glUniform2iARB = nullptr;
+  w->glUniform3iARB = nullptr;
+  w->glUniform4iARB = nullptr;
+  w->glUniform1ivARB = nullptr;
+  w->glUniform2ivARB = nullptr;
+  w->glUniform3ivARB = nullptr;
+  w->glUniform4ivARB = nullptr;
+  w->glUniformMatrix2fvARB = nullptr;
+  w->glUniformMatrix3fvARB = nullptr;
+  w->glUniformMatrix4fvARB = nullptr;
 
 
 #ifdef GL_ARB_shader_objects
@@ -1803,7 +1803,7 @@ glglue_resolve_symbols(cc_glglue * w)
     BIND_FUNCTION_WITH_WARN(glUniformMatrix4fvARB, COIN_PFNGLUNIFORMMATRIX4FVARBPROC);
 
 
-    w->glProgramParameteriEXT = NULL;
+    w->glProgramParameteriEXT = nullptr;
     if (cc_glglue_glext_supported(w, "GL_EXT_geometry_shader4")) {
       BIND_FUNCTION_WITH_WARN(glProgramParameteriEXT, COIN_PFNGLPROGRAMPARAMETERIEXT);
     }
@@ -1811,7 +1811,7 @@ glglue_resolve_symbols(cc_glglue * w)
   }
 #endif /* GL_ARB_shader_objects */
 
-  w->glGenQueries = NULL; /* so that cc_glglue_has_occlusion_query() works  */
+  w->glGenQueries = nullptr; /* so that cc_glglue_has_occlusion_query() works  */
 #if defined(GL_VERSION_1_5)
   if (cc_glglue_glversion_matches_at_least(w, 1, 5, 0)) {
     w->glGenQueries = (COIN_PFNGLGENQUERIESPROC)PROC(w, glGenQueries);
@@ -1826,7 +1826,7 @@ glglue_resolve_symbols(cc_glglue * w)
 #endif /* GL_VERSION_1_5 */
 
 #if defined(GL_ARB_occlusion_query)
-  if ((w->glGenQueries == NULL) && cc_glglue_glext_supported(w, "GL_ARB_occlusion_query")) {
+  if ((w->glGenQueries == nullptr) && cc_glglue_glext_supported(w, "GL_ARB_occlusion_query")) {
     w->glGenQueries = (COIN_PFNGLGENQUERIESPROC)PROC(w, glGenQueriesARB);
     w->glDeleteQueries = (COIN_PFNGLDELETEQUERIESPROC)PROC(w, glDeleteQueriesARB);
     w->glIsQuery = (COIN_PFNGLISQUERYPROC)PROC(w, glIsQueryARB);
@@ -1846,7 +1846,7 @@ glglue_resolve_symbols(cc_glglue * w)
         !w->glGetQueryiv ||
         !w->glGetQueryObjectiv ||
         !w->glGetQueryObjectuiv) {
-      w->glGenQueries = NULL; /* so that cc_glglue_has_occlusion_query() will return false */
+      w->glGenQueries = nullptr; /* so that cc_glglue_has_occlusion_query() will return false */
       if (COIN_DEBUG || coin_glglue_debug()) {
         cc_debugerror_postwarning("glglue_init",
                                   "glGenQueries found, but one or more of the other "
@@ -1855,7 +1855,7 @@ glglue_resolve_symbols(cc_glglue * w)
     }
   }
 
-  w->glVertexArrayRangeNV = NULL;
+  w->glVertexArrayRangeNV = nullptr;
 #if defined(GL_NV_vertex_array_range) && (defined(HAVE_GLX) || defined(HAVE_WGL))
   if (cc_glglue_glext_supported(w, "GL_NV_vertex_array_range")) {
     w->glVertexArrayRangeNV = (COIN_PFNGLVERTEXARRAYRANGENVPROC) PROC(w, glVertexArrayRangeNV);
@@ -1872,7 +1872,7 @@ glglue_resolve_symbols(cc_glglue * w)
       if (!w->glFlushVertexArrayRangeNV ||
           !w->glAllocateMemoryNV ||
           !w->glFreeMemoryNV) {
-        w->glVertexArrayRangeNV = NULL;
+        w->glVertexArrayRangeNV = nullptr;
         if (COIN_DEBUG || coin_glglue_debug()) {
           cc_debugerror_postwarning("glglue_init",
                                     "glVertexArrayRangeNV found, but one or more of the other "
@@ -2299,7 +2299,7 @@ cc_glglue_instance(int contextid)
   void * ptr;
   GLint gltmp;
 
-  cc_glglue * gi = NULL;
+  cc_glglue * gi = nullptr;
 
   CC_SYNC_BEGIN(cc_glglue_instance);
 
@@ -2330,7 +2330,7 @@ cc_glglue_instance(int contextid)
 
        Make it possible to disabled this assert because GLX in Mesa
        version 3.4.2 (GL_VENDOR "VA Linux Systems, Inc", GL_RENDERER
-       "Mesa GLX Indirect", GL_VERSION "1.2 Mesa 3.4.2") returns NULL
+       "Mesa GLX Indirect", GL_VERSION "1.2 Mesa 3.4.2") returns nullptr
        even though there really is a current context set up. (Reported
        by kintel.)
     */
@@ -2352,7 +2352,7 @@ cc_glglue_instance(int contextid)
        hook into SoContextHandler and kill off an instance when a GL
        context is taken out. 20051104 mortene. */
     gi = (cc_glglue*)malloc(sizeof(cc_glglue));
-    /* clear to set all pointers and variables to NULL or 0 */
+    /* clear to set all pointers and variables to nullptr or 0 */
     memset(gi, 0, sizeof(cc_glglue));
     /* FIXME: handle out-of-memory on malloc(). 20000928 mortene. */
 
@@ -2411,20 +2411,20 @@ cc_glglue_instance(int contextid)
 
     gi->rendererstr = (const char *)glGetString(GL_RENDERER);
     gi->extensionsstr = (const char *)glGetString(GL_EXTENSIONS);
-    // gi->extensionsstr = NULL;  /* for testing */
+    // gi->extensionsstr = nullptr;  /* for testing */
 
-    /* the above is deprecated and may return NULL, in which case we need to do it
+    /* the above is deprecated and may return nullptr, in which case we need to do it
        the new way, producing same results as the old way.. */
     
 #ifndef GL_NUM_EXTENSIONS
 # define GL_NUM_EXTENSIONS 0x821D
 #endif
-    if(gi->extensionsstr == NULL) {
+    if(gi->extensionsstr == nullptr) {
       typedef GLubyte* (APIENTRY * COIN_PFNGLGETSTRINGIPROC)(GLenum enm, GLuint idx);
       COIN_PFNGLGETSTRINGIPROC glGetStringi = 0;
       glGetStringi = (COIN_PFNGLGETSTRINGIPROC)cc_glglue_getprocaddress(gi,
                                                                         "glGetStringi");
-      if(glGetStringi != NULL) {
+      if(glGetStringi != nullptr) {
         GLint n = 0;
         glGetIntegerv(GL_NUM_EXTENSIONS, &n);
         if(n > 0) {
@@ -2455,7 +2455,7 @@ cc_glglue_instance(int contextid)
       }
       else {
         cc_debugerror_postwarning("cc_glglue_instance",
-                                  "glGetString(GL_EXTENSIONS) returned null, but glGetStringi is NULL, so unable to get extensions for this gl driver, version:",
+                                  "glGetString(GL_EXTENSIONS) returned null, but glGetStringi is nullptr, so unable to get extensions for this gl driver, version:",
                                   gi->versionstr /* , " vendor: ",
                                                      gi->vendorstr */ );
       }
@@ -2633,7 +2633,7 @@ cc_glglue_has_polygon_offset(const cc_glglue * w)
 static COIN_PFNGLPOLYGONOFFSETPROC
 glglue_glPolygonOffset(const cc_glglue * w)
 {
-  COIN_PFNGLPOLYGONOFFSETPROC poff = NULL;
+  COIN_PFNGLPOLYGONOFFSETPROC poff = nullptr;
 
   assert(w->glPolygonOffset ||  w->glPolygonOffsetEXT);
 
@@ -2661,7 +2661,7 @@ glglue_glPolygonOffset(const cc_glglue * w)
   /* If glPolygonOffset() is not available (and the function pointer
      was not set by any of the bug workaround if-checks above), fall
      back on extension. */
-  if (poff == NULL) { poff = w->glPolygonOffsetEXT; }
+  if (poff == nullptr) { poff = w->glPolygonOffsetEXT; }
 
   return poff;
 }
@@ -2906,7 +2906,7 @@ bool
 cc_glglue_has_multitexture(const cc_glglue * w)
 {
   if (!glglue_allow_newer_opengl(w)) return false;
-  return w->glActiveTexture != NULL;
+  return w->glActiveTexture != nullptr;
 }
 
 int
@@ -3227,14 +3227,14 @@ bool
 cc_glglue_has_color_tables(const cc_glglue * glue)
 {
   if (!glglue_allow_newer_opengl(glue)) return false;
-  return glue->glColorTable != NULL;
+  return glue->glColorTable != nullptr;
 }
 
 bool
 cc_glglue_has_color_subtables(const cc_glglue * glue)
 {
   if (!glglue_allow_newer_opengl(glue)) return false;
-  return glue->glColorSubTable != NULL;
+  return glue->glColorSubTable != nullptr;
 }
 
 void
@@ -3333,7 +3333,7 @@ cc_glglue_has_blendfuncseparate(const cc_glglue * glue)
 {
   if (!glglue_allow_newer_opengl(glue)) return false;
 
-  return glue->glBlendFuncSeparate != NULL;
+  return glue->glBlendFuncSeparate != nullptr;
 }
 
 void
@@ -3349,7 +3349,7 @@ bool
 cc_glglue_has_vertex_array(const cc_glglue * glue)
 {
   if (!glglue_allow_newer_opengl(glue)) return false;
-  return glue->glVertexPointer != NULL;
+  return glue->glVertexPointer != nullptr;
 }
 
 void
@@ -3476,7 +3476,7 @@ bool
 cc_glglue_has_nv_vertex_array_range(const cc_glglue * glue)
 {
   if (!glglue_allow_newer_opengl(glue)) return false;
-  return glue->glVertexArrayRangeNV != NULL;
+  return glue->glVertexArrayRangeNV != nullptr;
 }
 
 void
@@ -3514,9 +3514,9 @@ cc_glglue_has_vertex_buffer_object(const cc_glglue * glue)
 {
   if (!glglue_allow_newer_opengl(glue)) return false;
 
-  /* check only one function for speed. It's set to NULL when
+  /* check only one function for speed. It's set to nullptr when
      initializing if one of the other functions wasn't found */
-  return glue->glBindBuffer != NULL;
+  return glue->glBindBuffer != nullptr;
 }
 
 void
@@ -4323,9 +4323,9 @@ cc_glglue_has_occlusion_query(const cc_glglue * glue)
 {
   if (!glglue_allow_newer_opengl(glue)) return false;
 
-  /* check only one function for speed. It's set to NULL when
+  /* check only one function for speed. It's set to nullptr when
      initializing if one of the other functions wasn't found */
-  return glue->glGenQueries != NULL;
+  return glue->glGenQueries != nullptr;
 }
 
 void
@@ -4438,12 +4438,12 @@ cc_glglue_has_texture_env_combine(const cc_glglue * glue)
 /*!
   Returns current X11 display the OpenGL context is in. If none, or if
   the glXGetCurrentDisplay() method is not available (it was
-  introduced with GLX 1.3), returns \c NULL.
+  introduced with GLX 1.3), returns \c nullptr.
 */
 void *
 cc_glglue_glXGetCurrentDisplay(const cc_glglue * w)
 {
-  return w->glx.glXGetCurrentDisplay ? w->glx.glXGetCurrentDisplay() : NULL;
+  return w->glx.glXGetCurrentDisplay ? w->glx.glXGetCurrentDisplay() : nullptr;
 }
 
 /*** Offscreen buffer handling. *********************************************/
@@ -4507,7 +4507,7 @@ cc_glglue_context_create_offscreen(unsigned int width, unsigned int height)
   } else {
 #ifdef HAVE_NOGL
   assert(false && "unimplemented");
-  return NULL;
+  return nullptr;
 #elif defined(HAVE_GLX)
   return glxglue_context_create_offscreen(width, height);
 #elif defined(HAVE_WGL)
@@ -4524,7 +4524,7 @@ cc_glglue_context_create_offscreen(unsigned int width, unsigned int height)
 #endif
   }
   assert(false && "unimplemented");
-  return NULL;
+  return nullptr;
 }
 
 bool
@@ -4898,7 +4898,7 @@ cc_glglue_win32_HDC(void * COIN_UNUSED_ARG(ctx))
 #if defined(HAVE_WGL)
   return wglglue_context_win32_HDC(ctx);
 #else /* not WGL */
-  return NULL;
+  return nullptr;
 #endif /* not WGL */
 }
 void cc_glglue_win32_updateHDCBitmap(void * COIN_UNUSED_ARG(ctx))
@@ -4933,7 +4933,7 @@ proxy_mipmap_2d(int width, int height,
   int levels = compute_log(cc_max(width, height));
 
   glTexImage2D(GL_PROXY_TEXTURE_2D, 0, internalFormat, width, height, 0,
-               format, type, NULL);
+               format, type, nullptr);
   glGetTexLevelParameteriv(GL_PROXY_TEXTURE_2D, 0,
                            GL_TEXTURE_WIDTH, &w);
 
@@ -4945,7 +4945,7 @@ proxy_mipmap_2d(int width, int height,
     if (height > 1) height >>= 1;
     glTexImage2D(GL_PROXY_TEXTURE_2D, level, internalFormat, width,
                  height, 0, format, type,
-                 NULL);
+                 nullptr);
     glGetTexLevelParameteriv(GL_PROXY_TEXTURE_2D, 0,
                              GL_TEXTURE_WIDTH, &w);
     if (w == 0) return false;
@@ -4967,7 +4967,7 @@ proxy_mipmap_3d(const cc_glglue * glw, int width, int height, int depth,
 
   cc_glglue_glTexImage3D(glw, GL_PROXY_TEXTURE_3D, 0, internalFormat,
                          width, height, depth, 0, format, type,
-                         NULL);
+                         nullptr);
   glGetTexLevelParameteriv(GL_PROXY_TEXTURE_3D, 0,
                            GL_TEXTURE_WIDTH, &w);
   if (w == 0) return false;
@@ -4979,7 +4979,7 @@ proxy_mipmap_3d(const cc_glglue * glw, int width, int height, int depth,
     if (depth > 1) depth >>= 1;
     cc_glglue_glTexImage3D(glw, GL_PROXY_TEXTURE_3D, level, internalFormat,
                            width, height, depth, 0, format, type,
-                           NULL);
+                           nullptr);
     glGetTexLevelParameteriv(GL_PROXY_TEXTURE_3D, 0,
                              GL_TEXTURE_WIDTH, &w);
     if (w == 0) return false;
@@ -5186,7 +5186,7 @@ coin_glerror_string(GLenum errorcode)
   default:
     return unknown;
   }
-  return NULL; /* avoid compiler warning */
+  return nullptr; /* avoid compiler warning */
 }
 
 /* Simple utility function for dumping the current set of error codes
@@ -5222,7 +5222,7 @@ coin_catch_gl_errors(cc_string * str)
 void *
 coin_gl_current_context(void)
 {
-  void * ctx = NULL;
+  void * ctx = nullptr;
 
 #ifdef HAVE_GLX
   ctx = glXGetCurrentContext();
@@ -5234,7 +5234,7 @@ coin_gl_current_context(void)
 
 #if defined(HAVE_AGL) || defined(HAVE_CGL)
   /* Note: We cannot use aglGetCurrentContext() here, since that only
-     returns a value != NULL if the context has been set using
+     returns a value != nullptr if the context has been set using
      aglSetCurrentContext(). */
   ctx = CGLGetCurrentContext();
 #endif
@@ -5277,14 +5277,14 @@ coin_glglue_get_contextid(const cc_glglue * glue)
 static void cleanup_instance_created_list(void)
 {
   cc_list_destruct(gl_instance_created_cblist);
-  gl_instance_created_cblist = NULL;
+  gl_instance_created_cblist = nullptr;
 }
 
 void
 coin_glglue_add_instance_created_callback(coin_glglue_instance_created_cb * cb,
                                           void * closure)
 {
-  if (gl_instance_created_cblist == NULL) {
+  if (gl_instance_created_cblist == nullptr) {
     gl_instance_created_cblist = cc_list_construct();
     coin_atexit((coin_atexit_f *)cleanup_instance_created_list, CC_ATEXIT_NORMAL);
   }
@@ -5417,7 +5417,7 @@ coin_glglue_has_generate_mipmap(const cc_glglue * glue)
   if ((coin_runtime_os() == COIN_MSWINDOWS) && glue->vendor_is_ati) {
     return false;
   }
-  return (glue->glGenerateMipmap != NULL);
+  return (glue->glGenerateMipmap != nullptr);
 }
 
 void
diff --git a/coin4/src/glue/gl_agl.cpp b/coin4/src/glue/gl_agl.cpp
index 9074ae9..e9a880e 100644
--- a/coin4/src/glue/gl_agl.cpp
+++ b/coin4/src/glue/gl_agl.cpp
@@ -65,12 +65,12 @@ bool aglglue_context_is_using_pbuffer(void * COIN_UNUSED_ARG(ctx))
 
 void * aglglue_getprocaddress(const char * COIN_UNUSED_ARG(fname))
 {
-  return NULL;
+  return nullptr;
 }
 
 void * aglglue_context_create_offscreen(unsigned int COIN_UNUSED_ARG(width), 
                                         unsigned int COIN_UNUSED_ARG(height)) { 
-  assert(false); return NULL; 
+  assert(false); return nullptr; 
 }
 
 bool aglglue_context_make_current(void * COIN_UNUSED_ARG(ctx))
@@ -126,13 +126,13 @@ typedef GLboolean (* COIN_AGLTEXIMAGEPBUFFER) (AGLContext ctx,
                                                AGLPbuffer pbuffer, 
                                                GLint source);
 
-static COIN_AGLCREATEPBUFFER aglglue_aglCreatePBuffer = NULL;
-static COIN_AGLDESTROYPBUFFER aglglue_aglDestroyPBuffer = NULL;
-static COIN_AGLSETPBUFFER aglglue_aglSetPBuffer = NULL;
-static COIN_AGLTEXIMAGEPBUFFER aglglue_aglTexImagePBuffer = NULL;
+static COIN_AGLCREATEPBUFFER aglglue_aglCreatePBuffer = nullptr;
+static COIN_AGLDESTROYPBUFFER aglglue_aglDestroyPBuffer = nullptr;
+static COIN_AGLSETPBUFFER aglglue_aglSetPBuffer = nullptr;
+static COIN_AGLTEXIMAGEPBUFFER aglglue_aglTexImagePBuffer = nullptr;
 
 struct aglglue_contextdata;
-static bool (* aglglue_context_create)(struct aglglue_contextdata * ctx) = NULL;
+static bool (* aglglue_context_create)(struct aglglue_contextdata * ctx) = nullptr;
 
 static void
 aglglue_resolve_symbols()
@@ -187,13 +187,13 @@ aglglue_contextdata_init(unsigned int width, unsigned int height)
   struct aglglue_contextdata * ctx;
   ctx = (struct aglglue_contextdata *)malloc(sizeof(struct aglglue_contextdata));
 
-  ctx->drawable = NULL;
-  ctx->aglcontext = NULL;
-  ctx->storedcontext = NULL;
-  ctx->pixformat = NULL;
-  ctx->savedport = NULL;
-  ctx->savedgdh = NULL;
-  ctx->aglpbuffer = NULL; 
+  ctx->drawable = nullptr;
+  ctx->aglcontext = nullptr;
+  ctx->storedcontext = nullptr;
+  ctx->pixformat = nullptr;
+  ctx->savedport = nullptr;
+  ctx->savedgdh = nullptr;
+  ctx->aglpbuffer = nullptr; 
   ctx->width = width;
   ctx->height = height;
   ctx->pbufferisbound = false;
@@ -270,14 +270,14 @@ aglglue_context_create_software(struct aglglue_contextdata * ctx)
                            "Creating software buffer.");
   }
     
-  ctx->pixformat = aglChoosePixelFormat( NULL, 0, attrib );
+  ctx->pixformat = aglChoosePixelFormat( nullptr, 0, attrib );
   if (!ctx->pixformat) {
     cc_debugerror_postwarning("aglglue_context_create_software",
                               "Couldn't get RGBA AGL pixelformat.");
     return false;
   }
   
-  ctx->aglcontext = aglCreateContext(ctx->pixformat, NULL );
+  ctx->aglcontext = aglCreateContext(ctx->pixformat, nullptr );
   if (!ctx->aglcontext) {
     cc_debugerror_postwarning("aglglue_context_create_software",
                               "Couldn't create AGL context.");
@@ -299,7 +299,7 @@ aglglue_context_create_software(struct aglglue_contextdata * ctx)
   GetGWorld(&ctx->savedport, &ctx->savedgdh); 
   
   {
-    QDErr e = NewGWorld(&ctx->drawable, 32, &ctx->bounds, NULL, NULL, 0);
+    QDErr e = NewGWorld(&ctx->drawable, 32, &ctx->bounds, nullptr, nullptr, 0);
     if (e != noErr) {
       cc_debugerror_postwarning("aglglue_context_create_software",
                                 "Error creating GWorld: %d", e);
@@ -371,7 +371,7 @@ aglglue_context_create_pbuffer(struct aglglue_contextdata * ctx)
                            "Creating pBuffer.");
   }
 
-  ctx->pixformat = aglChoosePixelFormat (NULL, 0, attribs);
+  ctx->pixformat = aglChoosePixelFormat (nullptr, 0, attribs);
   error = aglGetError();
   if (error != AGL_NO_ERROR) {
     cc_debugerror_post("aglglue_context_create_pbuffer",
@@ -381,7 +381,7 @@ aglglue_context_create_pbuffer(struct aglglue_contextdata * ctx)
   }
   
   if (ctx->pixformat) {
-    ctx->aglcontext = aglCreateContext (ctx->pixformat, NULL);
+    ctx->aglcontext = aglCreateContext (ctx->pixformat, nullptr);
     error = aglGetError();
     if (error != AGL_NO_ERROR) {
       cc_debugerror_post("aglglue_context_create_pbuffer",
@@ -432,10 +432,10 @@ aglglue_context_create_offscreen(unsigned int width, unsigned int height)
   bool ok, pbuffer = false, ispbuffer = false;
 
   ctx = aglglue_contextdata_init(width, height);
-  if (!ctx) return NULL;
+  if (!ctx) return nullptr;
 
   /* Use cached function pointer for pBuffer vs SW context creation... */
-  if (aglglue_context_create != NULL) {
+  if (aglglue_context_create != nullptr) {
 
     ispbuffer = (aglglue_context_create == aglglue_context_create_pbuffer);
 
@@ -453,7 +453,7 @@ aglglue_context_create_offscreen(unsigned int width, unsigned int height)
       if (aglglue_context_create_software(ctx)) { return ctx; } 
       aglglue_contextdata_cleanup(ctx);
     }
-    return NULL;
+    return nullptr;
   }
 
   /* ... but the first time around, we have to figure out. */
@@ -473,7 +473,7 @@ aglglue_context_create_offscreen(unsigned int width, unsigned int height)
     return ctx;
   } else {
     aglglue_contextdata_cleanup(ctx);
-    return NULL;
+    return nullptr;
   }
 }
 
@@ -573,7 +573,7 @@ aglglue_context_reinstate_previous(void * ctx)
   } else { /* pBuffer support available */
 
     if (context->storedcontext) CGLSetCurrentContext(context->storedcontext);
-    else CGLSetCurrentContext(NULL);
+    else CGLSetCurrentContext(nullptr);
 
   } 
 }
@@ -634,25 +634,25 @@ bool
 aglglue_context_can_render_to_texture(void * ctx)
 {
   struct aglglue_contextdata * context = (struct aglglue_contextdata *)ctx;
-  return context->aglpbuffer != NULL;
+  return context->aglpbuffer != nullptr;
 }
 
 void 
 aglglue_cleanup(void)
 {
-  aglglue_aglCreatePBuffer = NULL;
-  aglglue_aglDestroyPBuffer = NULL;
-  aglglue_aglSetPBuffer = NULL;
-  aglglue_aglTexImagePBuffer = NULL;
+  aglglue_aglCreatePBuffer = nullptr;
+  aglglue_aglDestroyPBuffer = nullptr;
+  aglglue_aglSetPBuffer = nullptr;
+  aglglue_aglTexImagePBuffer = nullptr;
 
-  aglglue_context_create = NULL;
+  aglglue_context_create = nullptr;
 }
 
 // used to look up AGL specific functions
 void * 
 aglglue_getprocaddress(const char * fname)
 {
-  void * ret = NULL;
+  void * ret = nullptr;
   cc_libhandle h = cc_dl_handle_with_gl_symbols();
   if (h) {
     ret = cc_dl_sym(h, fname);
diff --git a/coin4/src/glue/gl_cgl.cpp b/coin4/src/glue/gl_cgl.cpp
index 4a294be..12b55d3 100644
--- a/coin4/src/glue/gl_cgl.cpp
+++ b/coin4/src/glue/gl_cgl.cpp
@@ -58,13 +58,13 @@ bool cglglue_context_is_using_pbuffer(void * COIN_UNUSED_ARG(ctx))
 
 void * cglglue_getprocaddress(const char * COIN_UNUSED_ARG(fname))
 {
-  assert(false); return NULL;
+  assert(false); return nullptr;
 }
 
 void * cglglue_context_create_offscreen(unsigned int COIN_UNUSED_ARG(width), 
                                         unsigned int COIN_UNUSED_ARG(height))
 { 
-  assert(false); return NULL; 
+  assert(false); return nullptr; 
 }
 
 bool cglglue_context_make_current(void * COIN_UNUSED_ARG(ctx))
@@ -115,10 +115,10 @@ typedef CGLError (* COIN_CGLTEXIMAGEPBUFFER) (CGLContextObj ctx,
                                                CGLPBufferObj pbuffer, 
                                                GLenum source);
 
-static COIN_CGLCREATEPBUFFER cglglue_CGLCreatePBuffer = NULL;
-static COIN_CGLDESTROYPBUFFER cglglue_CGLDestroyPBuffer = NULL;
-static COIN_CGLSETPBUFFER cglglue_CGLSetPBuffer = NULL;
-static COIN_CGLTEXIMAGEPBUFFER cglglue_CGLTexImagePBuffer = NULL;
+static COIN_CGLCREATEPBUFFER cglglue_CGLCreatePBuffer = nullptr;
+static COIN_CGLDESTROYPBUFFER cglglue_CGLDestroyPBuffer = nullptr;
+static COIN_CGLSETPBUFFER cglglue_CGLSetPBuffer = nullptr;
+static COIN_CGLTEXIMAGEPBUFFER cglglue_CGLTexImagePBuffer = nullptr;
 
 struct cglglue_contextdata;
 
@@ -169,12 +169,12 @@ cglglue_contextdata_init(unsigned int width, unsigned int height)
   struct cglglue_contextdata * ctx;
   ctx = (struct cglglue_contextdata *)malloc(sizeof(struct cglglue_contextdata));
 
-  ctx->storedcontext = NULL;
+  ctx->storedcontext = nullptr;
   ctx->rowbytes = 0;
-  ctx->membuffer = NULL;
-  ctx->cglcontext = NULL;
-  ctx->pixformat = NULL;
-  ctx->cglpbuffer = NULL; 
+  ctx->membuffer = nullptr;
+  ctx->cglcontext = nullptr;
+  ctx->pixformat = nullptr;
+  ctx->cglpbuffer = nullptr; 
   ctx->width = width;
   ctx->height = height;
   ctx->pbufferisbound = false;
@@ -201,7 +201,7 @@ cglglue_context_create_software(struct cglglue_contextdata * ctx)
     kCGLPFAAlphaSize, 8,
     kCGLPFADepthSize, 24,
     kCGLPFAStencilSize, 1,
-    NULL
+    nullptr
   };
 
   /* FIXME: the following is a hack to get around a problem which
@@ -249,7 +249,7 @@ cglglue_context_create_software(struct cglglue_contextdata * ctx)
     return false;
   }
   
-  err = CGLCreateContext(ctx->pixformat, NULL, &ctx->cglcontext);
+  err = CGLCreateContext(ctx->pixformat, nullptr, &ctx->cglcontext);
   if (err != kCGLNoError || !ctx->cglcontext) {
     cc_debugerror_postwarning("cglglue_context_create_software",
                               "Couldn't create CGL context. %s",
@@ -305,7 +305,7 @@ cglglue_context_create_pbuffer(struct cglglue_contextdata * ctx)
     kCGLPFAClosestPolicy, 
     kCGLPFAAccelerated, 
     kCGLPFANoRecovery,
-    NULL
+    nullptr
   };
 
   /* FIXME: this is a hack. See comment elsewhere in the file where
@@ -343,7 +343,7 @@ cglglue_context_create_pbuffer(struct cglglue_contextdata * ctx)
   
   if (!ctx->pixformat) return false;
 
-  err = CGLCreateContext (ctx->pixformat, NULL, &ctx->cglcontext);
+  err = CGLCreateContext (ctx->pixformat, nullptr, &ctx->cglcontext);
   if (err != kCGLNoError || !ctx->cglcontext) {
     cc_debugerror_post("cglglue_context_create_pbuffer",
                        "Couldn't create CGL context: %s", 
@@ -388,10 +388,10 @@ cglglue_context_create_offscreen(unsigned int width, unsigned int height)
   bool ok, pbuffer = false, ispbuffer = false;
 
   ctx = cglglue_contextdata_init(width, height);
-  if (!ctx) return NULL;
+  if (!ctx) return nullptr;
 
   /* Use cached function pointer for pBuffer vs SW context creation... */
-  if (cglglue_context_create != NULL) {
+  if (cglglue_context_create != nullptr) {
 
     ispbuffer = (cglglue_context_create == cglglue_context_create_pbuffer);
 
@@ -409,7 +409,7 @@ cglglue_context_create_offscreen(unsigned int width, unsigned int height)
       if (cglglue_context_create_software(ctx)) { return ctx; } 
       cglglue_contextdata_cleanup(ctx);
     }
-    return NULL;
+    return nullptr;
   }
 
   /* ... but the first time around, we have to figure out. */
@@ -429,7 +429,7 @@ cglglue_context_create_offscreen(unsigned int width, unsigned int height)
     return ctx;
   } else {
     cglglue_contextdata_cleanup(ctx);
-    return NULL;
+    return nullptr;
   }
 }
 
@@ -514,7 +514,7 @@ cglglue_context_reinstate_previous(void * ctx)
   } else { /* pBuffer support available */
 
     if (context->storedcontext) CGLSetCurrentContext(context->storedcontext);
-    else CGLSetCurrentContext(NULL);
+    else CGLSetCurrentContext(nullptr);
 
   } 
 }
@@ -575,25 +575,25 @@ bool
 cglglue_context_can_render_to_texture(void * ctx)
 {
   struct cglglue_contextdata * context = (struct cglglue_contextdata *)ctx;
-  return context->cglpbuffer != NULL;
+  return context->cglpbuffer != nullptr;
 }
 
 void 
 cglglue_cleanup(void)
 {
-  cglglue_CGLCreatePBuffer = NULL;
-  cglglue_CGLDestroyPBuffer = NULL;
-  cglglue_CGLSetPBuffer = NULL;
-  cglglue_CGLTexImagePBuffer = NULL;
+  cglglue_CGLCreatePBuffer = nullptr;
+  cglglue_CGLDestroyPBuffer = nullptr;
+  cglglue_CGLSetPBuffer = nullptr;
+  cglglue_CGLTexImagePBuffer = nullptr;
 
-  cglglue_context_create = NULL;
+  cglglue_context_create = nullptr;
 }
 
 // used to look up CGL specific functions
 void * 
 cglglue_getprocaddress(const char * fname)
 {
-  void * ret = NULL;
+  void * ret = nullptr;
   cc_libhandle h = cc_dl_handle_with_gl_symbols();
   if (h) {
     ret = cc_dl_sym(h, fname);
diff --git a/coin4/src/glue/gl_glx.cpp b/coin4/src/glue/gl_glx.cpp
index 3cc13af..01948e3 100644
--- a/coin4/src/glue/gl_glx.cpp
+++ b/coin4/src/glue/gl_glx.cpp
@@ -62,19 +62,19 @@ void glxglue_init(cc_glglue * w)
   w->glx.version.minor = 0;
   w->glx.isdirect = 1;
 
-  w->glx.serverversion = NULL;
-  w->glx.servervendor = NULL;
-  w->glx.serverextensions = NULL;
-  w->glx.clientversion = NULL;
-  w->glx.clientvendor = NULL;
-  w->glx.clientextensions = NULL;
-  w->glx.glxextensions = NULL;
+  w->glx.serverversion = nullptr;
+  w->glx.servervendor = nullptr;
+  w->glx.serverextensions = nullptr;
+  w->glx.clientversion = nullptr;
+  w->glx.clientvendor = nullptr;
+  w->glx.clientextensions = nullptr;
+  w->glx.glxextensions = nullptr;
 }
 
-void * glxglue_getprocaddress(const cc_glglue * glue, const char * fname) { return NULL; }
+void * glxglue_getprocaddress(const cc_glglue * glue, const char * fname) { return nullptr; }
 int glxglue_ext_supported(const cc_glglue * w, const char * extension) { return 0; }
 
-void * glxglue_context_create_offscreen(unsigned int width, unsigned int height) { assert(false); return NULL; }
+void * glxglue_context_create_offscreen(unsigned int width, unsigned int height) { assert(false); return nullptr; }
 bool glxglue_context_make_current(void * ctx) { assert(false); return false; }
 void glxglue_context_reinstate_previous(void * ctx) { assert(false); }
 void glxglue_context_destruct(void * ctx) { assert(false); }
@@ -120,13 +120,13 @@ bool glxglue_context_pbuffer_max(void * ctx, unsigned int * lims) { assert(false
 
 /* ********************************************************************** */
 
-static Display * glxglue_display = NULL;
+static Display * glxglue_display = nullptr;
 static bool glxglue_opendisplay_failed = false;
 
 static int glxglue_screen = -1;
 
 struct glxglue_contextdata;
-static bool (* glxglue_context_create)(struct glxglue_contextdata * context) = NULL;
+static bool (* glxglue_context_create)(struct glxglue_contextdata * context) = nullptr;
 
 typedef void * COIN_GLXFBConfig;
 typedef COIN_GLXFBConfig * (APIENTRY * COIN_PFNGLXCHOOSEFBCONFIG)(Display * dpy, int screen, const int * attrib_list, int * nelements);
@@ -224,7 +224,7 @@ struct glxglue_contextdata {
 
  */
 static Display *
-glxglue_get_display(const cc_glglue * currentcontext = NULL)
+glxglue_get_display(const cc_glglue * currentcontext = nullptr)
 {
   if (currentcontext && currentcontext->glx.glXGetCurrentDisplay) {
     if (glxglue_screen == -1) {
@@ -242,18 +242,18 @@ glxglue_get_display(const cc_glglue * currentcontext = NULL)
     return (Display*)currentcontext->glx.glXGetCurrentDisplay();
   }
 
-  if ((glxglue_display == NULL) && !glxglue_opendisplay_failed) {
+  if ((glxglue_display == nullptr) && !glxglue_opendisplay_failed) {
     /* FIXME: should use the real display-setting. :-(  20020926 mortene. */
 
-    /* UPDATE 20090218 tamer: Passing NULL through XOpenDisplay()
+    /* UPDATE 20090218 tamer: Passing nullptr through XOpenDisplay()
      * makes a POSIX-conformant system default to the value of the
      * DISPLAY environment variable. Isn't that exactly what we want?
      * Do you mean that the display_name can potentially be provided
      * by other means than the DISPLAY envvar? */
     
-    if (!(glxglue_display = XOpenDisplay(NULL))) {
+    if (!(glxglue_display = XOpenDisplay(nullptr))) {
       cc_debugerror_post("glxglue_init",
-                         "Couldn't open NULL display.");
+                         "Couldn't open nullptr display.");
       glxglue_opendisplay_failed = true;
     }
     
@@ -276,7 +276,7 @@ glxglue_set_version(const cc_glglue * w, int * major, int * minor)
   *major = -1;
   *minor = 0;
 
-  if (glxglue_get_display(w) == NULL) { return; }
+  if (glxglue_get_display(w) == nullptr) { return; }
 
   ok = glXQueryVersion(glxglue_get_display(w), major, minor);
 
@@ -294,7 +294,7 @@ glxglue_set_version(const cc_glglue * w, int * major, int * minor)
 void *
 glxglue_getprocaddress(const cc_glglue * glue_in, const char * fname)
 {
-  void * ptr = NULL;
+  void * ptr = nullptr;
 
   if (!glue_in->glx.glXGetProcAddress && !glue_in->glx.tried_bind_glXGetProcAddress) {
     cc_glglue * glue = const_cast<cc_glglue*> (glue_in);
@@ -354,7 +354,7 @@ int
 glxglue_ext_supported(const cc_glglue * w, const char * extension)
 {
   return
-    (w->glx.glxextensions != NULL) &&
+    (w->glx.glxextensions != nullptr) &&
     coin_glglue_extension_available(w->glx.glxextensions, extension);
 }
 
@@ -390,12 +390,12 @@ glxglue_resolve_symbols(cc_glglue * w)
   const char * env;
   struct cc_glxglue * g = &(w->glx);
 
-  glxglue_glXChooseFBConfig = NULL;
-  glxglue_glXCreateNewContext = NULL;
-  glxglue_glXGetFBConfigAttrib = NULL;
+  glxglue_glXChooseFBConfig = nullptr;
+  glxglue_glXCreateNewContext = nullptr;
+  glxglue_glXGetFBConfigAttrib = nullptr;
 
   env = coin_getenv("COIN_GLXGLUE_NO_GLX13_PBUFFERS");
-  glx13pbuffer = (env == NULL) || (atoi(env) < 1);
+  glx13pbuffer = (env == nullptr) || (atoi(env) < 1);
 
 #ifdef GLX_EXT_import_context
   if (!g->glXGetCurrentDisplay && glxglue_ext_supported(w, "GLX_EXT_import_context")) {
@@ -418,9 +418,9 @@ glxglue_resolve_symbols(cc_glglue * w)
   }
 #endif /* GLX_SGIX_fbconfig */
 
-  glxglue_glXCreatePbuffer_GLX_1_3 = NULL;
-  glxglue_glXCreateGLXPbufferSGIX = NULL;
-  glxglue_glXDestroyPbuffer = NULL;
+  glxglue_glXCreatePbuffer_GLX_1_3 = nullptr;
+  glxglue_glXCreateGLXPbufferSGIX = nullptr;
+  glxglue_glXDestroyPbuffer = nullptr;
 
 #ifdef GLX_VERSION_1_3
   if (glx13pbuffer && cc_glglue_glxversion_matches_at_least(w, 1, 3)) {
@@ -472,7 +472,7 @@ glxglue_init(cc_glglue * w)
      for URL). So we will assume the man pages are correct.
   */
   struct cc_glxglue * g = &(w->glx);
-  g->glXGetCurrentDisplay = NULL;
+  g->glXGetCurrentDisplay = nullptr;
 #ifdef GLX_VERSION_1_2
   g->glXGetCurrentDisplay = (COIN_PFNGLXGETCURRENTDISPLAYPROC)PROC(w, glXGetCurrentDisplay);
 #endif /* GLX_VERSION_1_2 */
@@ -481,13 +481,13 @@ glxglue_init(cc_glglue * w)
   w->glx.isdirect = glxglue_isdirect(w);
 
 
-  w->glx.serverversion = NULL;
-  w->glx.servervendor = NULL;
-  w->glx.serverextensions = NULL;
-  w->glx.clientversion = NULL;
-  w->glx.clientvendor = NULL;
-  w->glx.clientextensions = NULL;
-  w->glx.glxextensions = NULL;
+  w->glx.serverversion = nullptr;
+  w->glx.servervendor = nullptr;
+  w->glx.serverextensions = nullptr;
+  w->glx.clientversion = nullptr;
+  w->glx.clientvendor = nullptr;
+  w->glx.clientextensions = nullptr;
+  w->glx.glxextensions = nullptr;
 
   if (glxglue_get_display(w)) {
 
@@ -619,11 +619,11 @@ glxglue_find_gl_visual(void)
      of this failing for some compiler under HP-UX 10.20.) */
 #define ARRAYSIZE 32
   int attrs[ARRAYSIZE];
-  XVisualInfo * visinfo = NULL;
+  XVisualInfo * visinfo = nullptr;
 
-  if (glxglue_get_display() == NULL) { return NULL; }
+  if (glxglue_get_display() == nullptr) { return nullptr; }
 
-  while (visinfo == NULL && trynum < 8) {
+  while (visinfo == nullptr && trynum < 8) {
     int arraysize = glxglue_build_GL_attrs(attrs, trynum);
     assert(arraysize < ARRAYSIZE);
     visinfo = glXChooseVisual(glxglue_get_display(), DefaultScreen(glxglue_get_display()),
@@ -634,7 +634,7 @@ glxglue_find_gl_visual(void)
   if (!visinfo) {
     cc_debugerror_postwarning("glxglue_find_gl_visual",
                               "Couldn't get any OpenGL-capable RGBA X11 visual.");
-    return NULL;
+    return nullptr;
   }
 
   return visinfo;
@@ -650,21 +650,21 @@ glxglue_contextdata_init(unsigned int width, unsigned int height)
   struct glxglue_contextdata * ctx;
 
   XVisualInfo * vi = glxglue_find_gl_visual();
-  if (vi == NULL) { return NULL; }
+  if (vi == nullptr) { return nullptr; }
 
   ctx = (struct glxglue_contextdata *)malloc(sizeof(struct glxglue_contextdata));
 
   ctx->visinfo = vi;
-  ctx->glxcontext = NULL;
+  ctx->glxcontext = nullptr;
   ctx->width = width;
   ctx->height = height;
 
   ctx->pixmap = 0;
   ctx->glxpixmap = 0;
 
-  ctx->storeddisplay = NULL;
+  ctx->storeddisplay = nullptr;
   ctx->storeddrawable = 0;
-  ctx->storedcontext = NULL;
+  ctx->storedcontext = nullptr;
   ctx->pbuffer = false;
 
   return ctx;
@@ -673,9 +673,9 @@ glxglue_contextdata_init(unsigned int width, unsigned int height)
 static void
 glxglue_contextdata_cleanup(struct glxglue_contextdata * ctx)
 {
-  if (ctx == NULL) { return; }
+  if (ctx == nullptr) { return; }
 
-  Display * display = glxglue_get_display(NULL);
+  Display * display = glxglue_get_display(nullptr);
   if (ctx->glxcontext) glXDestroyContext(display, ctx->glxcontext);
   if (ctx->glxpixmap) {
     if (ctx->pbuffer) { glxglue_glXDestroyPbuffer(display, ctx->glxpixmap); }
@@ -700,11 +700,11 @@ glxglue_context_create_software(struct glxglue_contextdata * context)
      Rendering to a GLX pixmap is of course exactly what we want to be
      able to do. */
 
-  Display * display = glxglue_get_display(NULL);
+  Display * display = glxglue_get_display(nullptr);
   context->glxcontext = glXCreateContext(display, context->visinfo, 0,
                                          False);
 
-  if (context->glxcontext == NULL) {
+  if (context->glxcontext == nullptr) {
     cc_debugerror_postwarning("glxglue_context_create_software",
                               "Couldn't create GLX context.");
     return false;
@@ -761,11 +761,11 @@ glxglue_glXCreatePbuffer(Display * dpy, COIN_GLXFBConfig config, int width, int
   /* The official SGIX pbuffer extensions documentation says the
      following about the glXCreateGLXPbufferSGIX() function:
 
-         <attrib_list> can be either NULL, in which case all the
+         <attrib_list> can be either nullptr, in which case all the
          attributes assume their default values as described
          below. [...]
 
-     ..but leaving attrib_list (i.e. the last argument) as NULL causes
+     ..but leaving attrib_list (i.e. the last argument) as nullptr causes
      a crash with NVidia's Linux driver, at least in version 41.91.
   */
   return glxglue_glXCreateGLXPbufferSGIX(dpy, config, width, height, sgix_attrs);
@@ -810,7 +810,7 @@ glxglue_context_create_pbuffer(struct glxglue_contextdata * context)
   assert(attrs[0] == GLX_STENCIL_SIZE);
   if (v != -1) { attrs[1] = v; };
 
-  dpy = glxglue_get_display(NULL);
+  dpy = glxglue_get_display(nullptr);
   if (!dpy) { return false; }
 
   /* get a list of matching GLX frame buffer configurations. the list is
@@ -819,7 +819,7 @@ glxglue_context_create_pbuffer(struct glxglue_contextdata * context)
 
   fbc = glxglue_glXChooseFBConfig(dpy, DefaultScreen(dpy), attrs, &fbc_cnt);
   assert(fbc_cnt >= 0);
-  if ((fbc_cnt == 0) || (fbc == NULL)) {
+  if ((fbc_cnt == 0) || (fbc == nullptr)) {
     /* FIXME: we have had reports of this hitting. Is it possible to
        improve the selection technique so we can be absolutely sure no
        usable fb-config is available, e.g. by iterating over all
@@ -841,7 +841,7 @@ glxglue_context_create_pbuffer(struct glxglue_contextdata * context)
   /* direct rendering graphic context creation == Hardware use */
 
   context->glxcontext = glxglue_glXCreateNewContext(dpy, fbc[0],
-                                                    GLX_RGBA_TYPE, NULL, true);
+                                                    GLX_RGBA_TYPE, nullptr, true);
 
   /* must store this before freeing the array */
   context->fbconfig = fbc[0];
@@ -849,7 +849,7 @@ glxglue_context_create_pbuffer(struct glxglue_contextdata * context)
   /* free the config list */
   XFree(fbc);
 
-  if (context->glxcontext == NULL) {
+  if (context->glxcontext == nullptr) {
     cc_debugerror_postwarning("glxglue_context_create_pbuffer",
                               "Couldn't create GLX context.");
     return false;
@@ -889,14 +889,14 @@ glxglue_context_create_offscreen(unsigned int width, unsigned int height)
   struct glxglue_contextdata * swctx, * pbctx;
 
   swctx = glxglue_contextdata_init(width, height);
-  if (swctx == NULL) { return NULL; }
+  if (swctx == nullptr) { return nullptr; }
 
-  if (glxglue_context_create != NULL) {
+  if (glxglue_context_create != nullptr) {
     ok = glxglue_context_create(swctx);
     if (ok) { return swctx; }
 
     glxglue_contextdata_cleanup(swctx);
-    return NULL;
+    return nullptr;
   }
 
   /* As there could possibly be no valid glx context at this moment,
@@ -906,7 +906,7 @@ glxglue_context_create_offscreen(unsigned int width, unsigned int height)
   ok = glxglue_context_create_software(swctx);
   if (!ok || !glxglue_context_make_current(swctx)) {
     glxglue_contextdata_cleanup(swctx);
-    return NULL;
+    return nullptr;
   }
 
   /* ok, so we can at least use a non-pbuffer offscreen context */
@@ -932,7 +932,7 @@ glxglue_context_create_offscreen(unsigned int width, unsigned int height)
      available doesn't really prove it) */
 
   pbctx = glxglue_contextdata_init(width, height);
-  if (pbctx == NULL) { return swctx; }
+  if (pbctx == nullptr) { return swctx; }
 
   ok = glxglue_context_create_pbuffer(pbctx);
 
@@ -976,7 +976,7 @@ glxglue_context_make_current(void * ctx)
                            context->storeddisplay);
   }
 
-  Display * display = glxglue_get_display(NULL);
+  Display * display = glxglue_get_display(nullptr);
   r = glXMakeCurrent(display, context->glxpixmap, context->glxcontext);
 
   if (coin_glglue_debug()) {
@@ -996,15 +996,15 @@ glxglue_context_reinstate_previous(void * ctx)
 
   if (coin_glglue_debug()) {
     cc_debugerror_postinfo("glxglue_context_reinstate_previous",
-                           "releasing context (glxMakeCurrent(%p, None, NULL))",
-                           glxglue_get_display(NULL));
+                           "releasing context (glxMakeCurrent(%p, None, nullptr))",
+                           glxglue_get_display(nullptr));
   }
 
-  Display * display = glxglue_get_display(NULL);
+  Display * display = glxglue_get_display(nullptr);
   /* FIXME: this causes a crash with ATI on Linux for me. ATI and Mesa
      is somehow mixed together, which is probably the reason why the
      crash happens..? 20041105 mortene. */
-  (void)glXMakeCurrent(display, None, NULL); /* release */
+  (void)glXMakeCurrent(display, None, nullptr); /* release */
 
   /* The previous context is stored and reset to make it possible to
      use an SoOffscreenRenderer from for instance an SoCallback node
@@ -1090,14 +1090,14 @@ glxglue_context_pbuffer_max(void * ctx, unsigned int * lims)
 void glxglue_cleanup(void)
 {
   glxglue_screen = -1;
-  glxglue_context_create = NULL;
+  glxglue_context_create = nullptr;
 
-  glxglue_glXChooseFBConfig = NULL;
-  glxglue_glXCreateNewContext = NULL;
-  glxglue_glXGetFBConfigAttrib = NULL;
-  glxglue_glXCreatePbuffer_GLX_1_3 = NULL;
-  glxglue_glXCreateGLXPbufferSGIX = NULL;
-  glxglue_glXDestroyPbuffer = NULL;
+  glxglue_glXChooseFBConfig = nullptr;
+  glxglue_glXCreateNewContext = nullptr;
+  glxglue_glXGetFBConfigAttrib = nullptr;
+  glxglue_glXCreatePbuffer_GLX_1_3 = nullptr;
+  glxglue_glXCreateGLXPbufferSGIX = nullptr;
+  glxglue_glXDestroyPbuffer = nullptr;
 
   /* FIXME: We used to not close the display due to potential problems
      on some NVidia drivers (see original comment, reproduced
@@ -1115,7 +1115,7 @@ void glxglue_cleanup(void)
        like doublebuffered visuals coming up just blank.
    */
   if (glxglue_display) XCloseDisplay(glxglue_display);
-  glxglue_display = NULL;
+  glxglue_display = nullptr;
   glxglue_opendisplay_failed = false;
 }
 
diff --git a/coin4/src/glue/gl_wgl.cpp b/coin4/src/glue/gl_wgl.cpp
index 782ae15..4806ea1 100644
--- a/coin4/src/glue/gl_wgl.cpp
+++ b/coin4/src/glue/gl_wgl.cpp
@@ -52,9 +52,9 @@
 
 /* Dummy implementations, for when WGL is not available: */
 
-void * coin_wgl_getprocaddress(const cc_glglue * COIN_UNUSED_ARG(glue), const char * COIN_UNUSED_ARG(fname)) { return NULL; }
+void * coin_wgl_getprocaddress(const cc_glglue * COIN_UNUSED_ARG(glue), const char * COIN_UNUSED_ARG(fname)) { return nullptr; }
 
-void * wglglue_context_create_offscreen(unsigned int COIN_UNUSED_ARG(width), unsigned int COIN_UNUSED_ARG(height)) { assert(false); return NULL; }
+void * wglglue_context_create_offscreen(unsigned int COIN_UNUSED_ARG(width), unsigned int COIN_UNUSED_ARG(height)) { assert(false); return nullptr; }
 bool wglglue_context_make_current(void * COIN_UNUSED_ARG(ctx)) { assert(false); return false; }
 void wglglue_context_reinstate_previous(void * COIN_UNUSED_ARG(ctx)) { assert(false); }
 void wglglue_context_destruct(void * COIN_UNUSED_ARG(ctx)) { assert(false); }
@@ -85,7 +85,7 @@ Type cstyle_cast(PROC procaddr)
 } }
 
 struct wglglue_contextdata;
-static bool (* wglglue_context_create)(struct wglglue_contextdata * context, bool warnonerrors) = NULL;
+static bool (* wglglue_context_create)(struct wglglue_contextdata * context, bool warnonerrors) = nullptr;
 
 /* ********************************************************************** */
 
@@ -120,13 +120,13 @@ typedef BOOL (WINAPI * COIN_PFNWGLQUERYPBUFFERPROC)(WGLGLUE_HPBUFFER hPbuffer,
 typedef BOOL (WINAPI * COIN_PFNWGLBINDTEXIMAGEARBPROC)(WGLGLUE_HPBUFFER hPbuffer, int iBuffer);
 typedef BOOL (WINAPI * COIN_PFNWGLRELEASETEXIMAGEARBPROC)(WGLGLUE_HPBUFFER hPbuffer, int iBuffer);
 
-static COIN_PFNWGLCREATEPBUFFERPROC wglglue_wglCreatePbuffer = NULL;
-static COIN_PFNWGLGETPBUFFERDCPROC wglglue_wglGetPbufferDC = NULL;
-static COIN_PFNWGLRELEASEPBUFFERDCPROC wglglue_wglReleasePbufferDC = NULL;
-static COIN_PFNWGLDESTROYPBUFFERPROC wglglue_wglDestroyPbuffer = NULL;
-static COIN_PFNWGLQUERYPBUFFERPROC wglglue_wglQueryPbuffer = NULL;
-static COIN_PFNWGLBINDTEXIMAGEARBPROC wglglue_wglBindTexImageARB = NULL;
-static COIN_PFNWGLBINDTEXIMAGEARBPROC wglglue_wglReleaseTexImageARB = NULL;
+static COIN_PFNWGLCREATEPBUFFERPROC wglglue_wglCreatePbuffer = nullptr;
+static COIN_PFNWGLGETPBUFFERDCPROC wglglue_wglGetPbufferDC = nullptr;
+static COIN_PFNWGLRELEASEPBUFFERDCPROC wglglue_wglReleasePbufferDC = nullptr;
+static COIN_PFNWGLDESTROYPBUFFERPROC wglglue_wglDestroyPbuffer = nullptr;
+static COIN_PFNWGLQUERYPBUFFERPROC wglglue_wglQueryPbuffer = nullptr;
+static COIN_PFNWGLBINDTEXIMAGEARBPROC wglglue_wglBindTexImageARB = nullptr;
+static COIN_PFNWGLBINDTEXIMAGEARBPROC wglglue_wglReleaseTexImageARB = nullptr;
 
 
 /* The following is from either the WGL_ARB_pixel_format or the
@@ -146,15 +146,15 @@ typedef BOOL (WINAPI * COIN_PFNWGLGETPIXELFORMATATTRIBIVPROC)(HDC hdc,
                                                               const int * piAttributes,
                                                               int * piValues);
 
-static COIN_PFNWGLCHOOSEPIXELFORMATPROC wglglue_wglChoosePixelFormat = NULL;
-static COIN_PFNWGLGETPIXELFORMATATTRIBIVPROC wglglue_wglGetPixelFormatAttribiv = NULL;
+static COIN_PFNWGLCHOOSEPIXELFORMATPROC wglglue_wglChoosePixelFormat = nullptr;
+static COIN_PFNWGLGETPIXELFORMATATTRIBIVPROC wglglue_wglGetPixelFormatAttribiv = nullptr;
 
 /* The function for finding extension strings is itself an extension
    string. */
 
 typedef const char * (WINAPI * COIN_PFNWGLGETEXTENSIONSSTRING)(HDC hDC);
 
-static COIN_PFNWGLGETEXTENSIONSSTRING wglglue_wglGetExtensionsString = NULL;
+static COIN_PFNWGLGETEXTENSIONSSTRING wglglue_wglGetExtensionsString = nullptr;
 
 /* ********************************************************************** */
 
@@ -199,7 +199,7 @@ coin_wgl_getprocaddress(const cc_glglue * glue, const char * fname)
      function-addresses for *extension* functions, not "proper" OpenGL
      (1.1+) functions. */
   
-  if (ptr == NULL) {
+  if (ptr == nullptr) {
     cc_libhandle glhnd = coin_glglue_dl_handle(glue);
     
     
@@ -386,16 +386,16 @@ wglglue_contextdata_init(unsigned int width, unsigned int height)
 
   context->width = width;
   context->height = height;
-  context->memorydc = NULL;
-  context->pbufferwnd = NULL;
+  context->memorydc = nullptr;
+  context->pbufferwnd = nullptr;
   context->didcreatememorydc = false;
   context->shouldreleasememorydc = false;
-  context->bitmap = NULL;
-  context->hpbuffer = NULL;
-  context->oldbitmap = NULL;
-  context->wglcontext = NULL;
-  context->storedcontext = NULL;
-  context->storeddc = NULL;
+  context->bitmap = nullptr;
+  context->hpbuffer = nullptr;
+  context->oldbitmap = nullptr;
+  context->wglcontext = nullptr;
+  context->storedcontext = nullptr;
+  context->storeddc = nullptr;
   context->noappglcontextavail = false;
   context->supports_render_to_texture = false;
   context->wanted_render_to_texture = true;
@@ -408,7 +408,7 @@ wglglue_contextdata_init(unsigned int width, unsigned int height)
 static void
 wglglue_contextdata_cleanup(struct wglglue_contextdata * ctx)
 {
-  if (ctx == NULL) { return; }
+  if (ctx == nullptr) { return; }
 
   /* FIXME: the error handling below can and should be simplified, by
      implementing and using excpetion catching wrappers from
@@ -601,7 +601,7 @@ wglglue_context_create_context(struct wglglue_contextdata * ctx, DWORD bitWin)
   context->pixelformat = pixelformat;
 
   context->wglcontext = wglCreateContext(context->memorydc);
-  if (context->wglcontext == NULL) {
+  if (context->wglcontext == nullptr) {
     DWORD dwError = GetLastError();
     cc_win32_print_error("wglglue_context_create_context",
                          "wglCreateContext()", dwError);
@@ -621,14 +621,14 @@ wglglue_context_create_software(struct wglglue_contextdata * ctx, bool warnonerr
                            "creating software buffer");
   }
 
-  context->memorydc = CreateCompatibleDC(NULL);
+  context->memorydc = CreateCompatibleDC(nullptr);
   context->didcreatememorydc = true;
   context->shouldreleasememorydc = false;
-  if (context->memorydc == NULL) {
+  if (context->memorydc == nullptr) {
     if (warnonerrors || coin_glglue_debug()) {
       DWORD dwError = GetLastError();
       cc_debugerror_postwarning("wglglue_context_create_software",
-                                "CreateCompatibleDC(NULL) failed with "
+                                "CreateCompatibleDC(nullptr) failed with "
                                 "error code %d.", dwError);
     }
     return false;
@@ -655,8 +655,8 @@ wglglue_context_create_software(struct wglglue_contextdata * ctx, bool warnonerr
     bmi.bmiColors[0].rgbReserved = 0;
 
     context->bitmap = CreateDIBSection(context->memorydc, &bmi, DIB_RGB_COLORS,
-                                      &(context->pvBits), NULL, 0);
-    if (context->bitmap == NULL) {
+                                      &(context->pvBits), nullptr, 0);
+    if (context->bitmap == nullptr) {
       if (warnonerrors || coin_glglue_debug()) {
         DWORD dwError = GetLastError();
         cc_debugerror_postwarning("wglglue_context_create_software",
@@ -669,7 +669,7 @@ wglglue_context_create_software(struct wglglue_contextdata * ctx, bool warnonerr
 
   context->oldbitmap = (HBITMAP)
     SelectObject(context->memorydc, context->bitmap);
-  if (context->oldbitmap == NULL) {
+  if (context->oldbitmap == nullptr) {
     if (warnonerrors || coin_glglue_debug()) {
       DWORD dwError = GetLastError();
       cc_debugerror_postwarning("wglglue_context_create_software",
@@ -720,11 +720,11 @@ wglglue_context_create_pbuffer(struct wglglue_contextdata * ctx, bool warnonerro
       wc.lpfnWndProc    = DefWindowProc;
       wc.cbClsExtra     = 0;
       wc.cbWndExtra     = 0;
-      wc.hInstance      = GetModuleHandle(NULL);
-      wc.hIcon          = NULL;
-      wc.hCursor        = NULL;
-      wc.hbrBackground  = NULL;
-      wc.lpszMenuName   = NULL;
+      wc.hInstance      = GetModuleHandle(nullptr);
+      wc.hIcon          = nullptr;
+      wc.hCursor        = nullptr;
+      wc.hbrBackground  = nullptr;
+      wc.lpszMenuName   = nullptr;
       wc.lpszClassName  = "coin_gl_wgl";
 
       if (!RegisterClass(&wc)) {
@@ -739,7 +739,7 @@ wglglue_context_create_pbuffer(struct wglglue_contextdata * ctx, bool warnonerro
 
     {
       HWND hWnd;
-      HINSTANCE hInstance = GetModuleHandle(NULL);
+      HINSTANCE hInstance = GetModuleHandle(nullptr);
 
       if (!(hWnd = CreateWindow(
                      "coin_gl_wgl",   /* class name */
@@ -748,10 +748,10 @@ wglglue_context_create_pbuffer(struct wglglue_contextdata * ctx, bool warnonerro
                      0, 0,            /* window position */
                      context->width,  /* calculate adjusted window width */
                      context->height, /* calculate adjusted window height */
-                     NULL,            /* no parent window */
-                     NULL,            /* no menu */
+                     nullptr,            /* no parent window */
+                     nullptr,            /* no menu */
                      hInstance,       /* Instance */
-                     NULL)))          /* don't pass anything to WM_CREATE */
+                     nullptr)))          /* don't pass anything to WM_CREATE */
       {
         DWORD dwError = GetLastError();
         cc_debugerror_postwarning("wglglue_context_create_pbuffer",
@@ -764,7 +764,7 @@ wglglue_context_create_pbuffer(struct wglglue_contextdata * ctx, bool warnonerro
       context->memorydc = GetDC(hWnd);
       context->shouldreleasememorydc = true;
       context->didcreatememorydc = false;
-      if (context->memorydc == NULL) {
+      if (context->memorydc == nullptr) {
         DWORD dwError = GetLastError();
         cc_debugerror_postwarning("wglglue_context_create_pbuffer",
                                   "GetDC(hWnd) failed with "
@@ -852,7 +852,7 @@ wglglue_context_create_pbuffer(struct wglglue_contextdata * ctx, bool warnonerro
     /* if render-to-texture extension not supported, don't attempt to
        set up a pbuffer with those capabilities (could in theory cause
        nasty WGL errors): */
-    if (!context->wanted_render_to_texture || wglglue_wglBindTexImageARB == NULL) {
+    if (!context->wanted_render_to_texture || wglglue_wglBindTexImageARB == nullptr) {
       thetry--;
     }
 
@@ -929,7 +929,7 @@ wglglue_context_create_pbuffer(struct wglglue_contextdata * ctx, bool warnonerro
         cc_win32_print_error("wglglue_context_create_pbuffer",
                              "DestroyWindow", GetLastError());
       }
-      context->pbufferwnd = NULL;
+      context->pbufferwnd = nullptr;
     }
 
 
@@ -954,7 +954,7 @@ wglglue_context_create_pbuffer(struct wglglue_contextdata * ctx, bool warnonerro
     bmi.bmiColors[0].rgbReserved = 0;
 
     context->bitmap = CreateDIBSection(context->memorydc, &bmi, DIB_RGB_COLORS,
-                                      &(context->pvBits), NULL, 0);
+                                      &(context->pvBits), nullptr, 0);
 	SelectObject(context->memorydc, context->bitmap);
 
     context->didcreatememorydc = true;
@@ -1046,7 +1046,7 @@ wglglue_context_create_offscreen(unsigned int width, unsigned int height, bool t
 
   swctx->wanted_render_to_texture = texture;
 
-  if (wglglue_context_create != NULL) {
+  if (wglglue_context_create != nullptr) {
 
     ispbuffer = wglglue_context_create == wglglue_context_create_pbuffer;
 
@@ -1065,7 +1065,7 @@ wglglue_context_create_offscreen(unsigned int width, unsigned int height, bool t
       if (wglglue_context_create_software(swctx, true)) { return swctx; }
       wglglue_contextdata_cleanup(swctx);
     }
-    return NULL;
+    return nullptr;
   }
 
   /* As there could possibly be no valid wgl context at this moment,
@@ -1074,7 +1074,7 @@ wglglue_context_create_offscreen(unsigned int width, unsigned int height, bool t
 
   if (!wglglue_context_create_software(swctx, true)) {
     wglglue_contextdata_cleanup(swctx);
-    return NULL;
+    return nullptr;
   }
 
   /* ok, so we can at least use a non-pbuffer offscreen context */
@@ -1136,9 +1136,9 @@ wglglue_context_reinstate_previous(void * ctx)
 
   if (context->storedcontext && context->storeddc) {
     (void)wglMakeCurrent(context->storeddc, context->storedcontext);
-    context->storedcontext = NULL;
+    context->storedcontext = nullptr;
   }
-  else { (void)wglMakeCurrent(NULL, NULL); }
+  else { (void)wglMakeCurrent(nullptr, nullptr); }
 }
 
 void
@@ -1165,7 +1165,7 @@ wglglue_context_bind_pbuffer(void * ctx)
   BOOL ok;
 
   struct wglglue_contextdata * context = (struct wglglue_contextdata *)ctx;
-  assert(wglglue_wglBindTexImageARB != NULL);
+  assert(wglglue_wglBindTexImageARB != nullptr);
   assert(context->supports_render_to_texture);
 
   ok = wglglue_wglBindTexImageARB(context->hpbuffer, WGL_FRONT_LEFT_ARB);
@@ -1179,7 +1179,7 @@ wglglue_context_release_pbuffer(void * ctx)
   BOOL ok;
 
   struct wglglue_contextdata * context = (struct wglglue_contextdata *)ctx;
-  assert(wglglue_wglReleaseTexImageARB != NULL);
+  assert(wglglue_wglReleaseTexImageARB != nullptr);
 
   ok = wglglue_wglReleaseTexImageARB(context->hpbuffer, WGL_FRONT_LEFT_ARB);
   assert(ok);
@@ -1245,20 +1245,20 @@ wglglue_context_pbuffer_max(void * c, unsigned int * lims)
 
 void wglglue_cleanup(void)
 {
-  wglglue_context_create = NULL;
+  wglglue_context_create = nullptr;
 
-  wglglue_wglCreatePbuffer = NULL;
-  wglglue_wglGetPbufferDC = NULL;
-  wglglue_wglReleasePbufferDC = NULL;
-  wglglue_wglDestroyPbuffer = NULL;
-  wglglue_wglQueryPbuffer = NULL;
-  wglglue_wglBindTexImageARB = NULL;
-  wglglue_wglReleaseTexImageARB = NULL;
+  wglglue_wglCreatePbuffer = nullptr;
+  wglglue_wglGetPbufferDC = nullptr;
+  wglglue_wglReleasePbufferDC = nullptr;
+  wglglue_wglDestroyPbuffer = nullptr;
+  wglglue_wglQueryPbuffer = nullptr;
+  wglglue_wglBindTexImageARB = nullptr;
+  wglglue_wglReleaseTexImageARB = nullptr;
 
-  wglglue_wglChoosePixelFormat = NULL;
-  wglglue_wglGetPixelFormatAttribiv = NULL;
+  wglglue_wglChoosePixelFormat = nullptr;
+  wglglue_wglGetPixelFormatAttribiv = nullptr;
 
-  wglglue_wglGetExtensionsString = NULL;
+  wglglue_wglGetExtensionsString = nullptr;
 
   attemptedextresolved = false;
 
diff --git a/coin4/src/glue/glp.h b/coin4/src/glue/glp.h
index cd39f9a..89c22ce 100644
--- a/coin4/src/glue/glp.h
+++ b/coin4/src/glue/glp.h
@@ -592,7 +592,7 @@ struct cc_glglue {
     unsigned int major, minor, release;
   } version;
 
-  /* OpenGL calls. Will be NULL if not available, otherwise they
+  /* OpenGL calls. Will be nullptr if not available, otherwise they
      contain a valid function pointer into the OpenGL library. */
   COIN_PFNGLPOLYGONOFFSETPROC glPolygonOffset;
   COIN_PFNGLPOLYGONOFFSETPROC glPolygonOffsetEXT;
diff --git a/coin4/src/glue/openal_wrapper.cpp b/coin4/src/glue/openal_wrapper.cpp
index 1d47ecc..882d249 100644
--- a/coin4/src/glue/openal_wrapper.cpp
+++ b/coin4/src/glue/openal_wrapper.cpp
@@ -56,8 +56,8 @@
 #endif
 #endif /* OPENALWRAPPER_ASSUME_OPENAL */
 
-static openal_wrapper_t * openal_instance = NULL;
-static cc_libhandle openal_libhandle = NULL;
+static openal_wrapper_t * openal_instance = nullptr;
+static cc_libhandle openal_libhandle = nullptr;
 static int openal_failed_to_load = 0;
 static int openal_is_initializing = 0;
 
@@ -68,13 +68,13 @@ openal_wrapper_cleanup(void)
 #ifdef OPENAL_RUNTIME_LINKING
   if (openal_libhandle) {
     cc_dl_close(openal_libhandle);
-    openal_libhandle = NULL;
+    openal_libhandle = nullptr;
   }
 #endif /* OPENAL_RUNTIME_LINKING */
 
   assert(openal_instance);
   free(openal_instance);
-  openal_instance = NULL;
+  openal_instance = nullptr;
   openal_failed_to_load = 0;
   openal_is_initializing = 0;
 }
@@ -107,9 +107,9 @@ openal_wrapper(void)
     {
       int idx;
       const char * possiblelibnames[] = {
-        NULL, /* is set below */
+        nullptr, /* is set below */
         "openal", "openal32", "libopenal.so", "libopenal.dylib",
-        NULL
+        nullptr
       };
 
       possiblelibnames[0] = coin_getenv("COIN_OPENAL_LIBNAME");
@@ -141,7 +141,7 @@ openal_wrapper(void)
     oal->available = 0;
     oal->runtime = 0;
 #define OPENALWRAPPER_REGISTER_FUNC(_funcname_, _funcsig_) \
-    oal->_funcname_ = NULL
+    oal->_funcname_ = nullptr
 
 #endif /* !OPENALWRAPPER_ASSUME_OPENAL */
 
diff --git a/coin4/src/glue/simage_wrapper.cpp b/coin4/src/glue/simage_wrapper.cpp
index 7f89a26..dcc577e 100644
--- a/coin4/src/glue/simage_wrapper.cpp
+++ b/coin4/src/glue/simage_wrapper.cpp
@@ -60,8 +60,8 @@
 extern "C" {
 #endif /* __cplusplus */
 
-static simage_wrapper_t * simage_instance = NULL;
-static cc_libhandle simage_libhandle = NULL;
+static simage_wrapper_t * simage_instance = nullptr;
+static cc_libhandle simage_libhandle = nullptr;
 static int simage_failed_to_load = 0;
 static int simage_is_initializing = 0;
 
@@ -85,13 +85,13 @@ simage_wrapper_cleanup(void)
 #ifdef SIMAGE_RUNTIME_LINKING
   if (simage_libhandle) {
     cc_dl_close(simage_libhandle);
-    simage_libhandle = NULL;
+    simage_libhandle = nullptr;
   }
 #endif /* SIMAGE_RUNTIME_LINKING */
 
   assert(simage_instance);
   free(simage_instance);
-  simage_instance = NULL;
+  simage_instance = nullptr;
   simage_failed_to_load = 0;
   simage_is_initializing = 0;
 }
@@ -121,7 +121,7 @@ simage_wrapper_get_num_savers(void)
 static void *
 simage_wrapper_get_saver_handle(int COIN_UNUSED_ARG(jada))
 {
-  return NULL;
+  return nullptr;
 }
 
 static int
@@ -148,13 +148,13 @@ simage_wrapper_get_saver_extensions(void * COIN_UNUSED_ARG(handle))
 static const char *
 simage_wrapper_get_saver_fullname(void * COIN_UNUSED_ARG(handle))
 {
-  return NULL;
+  return nullptr;
 }
 
 static const char *
 simage_wrapper_get_saver_description(void * COIN_UNUSED_ARG(handle))
 {
-  return NULL;
+  return nullptr;
 }
 
 static unsigned char *
@@ -166,13 +166,13 @@ simage_wrapper_resize3d(unsigned char * COIN_UNUSED_ARG(imagedata),
                         int COIN_UNUSED_ARG(newheight),
                         int COIN_UNUSED_ARG(newlayers))
 {
-  return NULL;
+  return nullptr;
 }
 
 static s_params *
 simage_wrapper_s_params_create(void)
 {
-  return NULL;
+  return nullptr;
 }
 
 static void
@@ -195,30 +195,30 @@ simage_wrapper_s_params_get(s_params * COIN_UNUSED_ARG(params), ...)
 
 static s_stream *
 simage_wrapper_s_stream_open(const char * COIN_UNUSED_ARG(filename),
-              s_params * COIN_UNUSED_ARG(params) /* | NULL */)
+              s_params * COIN_UNUSED_ARG(params) /* | nullptr */)
 {
-  return NULL;
+  return nullptr;
 }
 
 static s_stream *
 simage_wrapper_s_stream_create(const char * COIN_UNUSED_ARG(filename),
-                s_params * COIN_UNUSED_ARG(params) /* | NULL */)
+                s_params * COIN_UNUSED_ARG(params) /* | nullptr */)
 {
-  return NULL;
+  return nullptr;
 }
 
 static void *
 simage_wrapper_s_stream_get_buffer(s_stream * COIN_UNUSED_ARG(stream),
-                    void * COIN_UNUSED_ARG(prealloc) /* | NULL */,
-                    int * COIN_UNUSED_ARG(size) /* | NULL */,
-                    s_params * COIN_UNUSED_ARG(params) /* | NULL */)
+                    void * COIN_UNUSED_ARG(prealloc) /* | nullptr */,
+                    int * COIN_UNUSED_ARG(size) /* | nullptr */,
+                    s_params * COIN_UNUSED_ARG(params) /* | nullptr */)
 {
-  return NULL;
+  return nullptr;
 }
 
 static int
 simage_wrapper_s_stream_put_buffer(s_stream * COIN_UNUSED_ARG(stream), void * COIN_UNUSED_ARG(buffer),
-                    int COIN_UNUSED_ARG(size), s_params * COIN_UNUSED_ARG(params) /* | NULL */)
+                    int COIN_UNUSED_ARG(size), s_params * COIN_UNUSED_ARG(params) /* | nullptr */)
 {
   return 0;
 }
@@ -238,7 +238,7 @@ simage_wrapper_s_stream_destroy(s_stream * COIN_UNUSED_ARG(stream))
 static s_params *
 simage_wrapper_s_stream_params(s_stream * COIN_UNUSED_ARG(stream))
 {
-  return NULL;
+  return nullptr;
 }
 
 
@@ -285,13 +285,13 @@ simage_wrapper(void)
       /* FIXME: should we get the system shared library name from an
          Autoconf check? 20000930 mortene. */
       const char * possiblelibnames[] = {
-        NULL, /* is set below */
+        nullptr, /* is set below */
         "simage", "libsimage", "libsimage.so",
         /* Mach dynamic library name */
         "libsimage.dylib",
         /* MSWindows DLL names for the simage library */
         simage_dll_name,
-        NULL
+        nullptr
       };
 
       possiblelibnames[0] = coin_getenv("COIN_SIMAGE_LIBNAME");
@@ -333,7 +333,7 @@ simage_wrapper(void)
     si->available = 0;
     /* Define SIMAGEWRAPPER_REGISTER_FUNC macro. */
 #define SIMAGEWRAPPER_REGISTER_FUNC(_funcname_, _funcsig_) \
-    si->_funcname_ = NULL
+    si->_funcname_ = nullptr
 
 #endif /* !SIMAGEWRAPPER_ASSUME_SIMAGE */
 
@@ -400,7 +400,7 @@ simage_wrapper(void)
         SIMAGEWRAPPER_REGISTER_FUNC(simage_resize3d, simage_resize3d_t);
 #endif
       }
-      else si->simage_resize3d = NULL;
+      else si->simage_resize3d = nullptr;
 
       if (simage_wrapper_versionMatchesAtLeast(1,4,0)) {
 #if !defined(HAVE_LIBSIMAGE) || defined(SIMAGE_VERSION_1_4)
@@ -420,7 +420,7 @@ simage_wrapper(void)
       else {
 #if 0
         /* 20021018 thammer. I might want to use these later instead
-           of setting all of them to NULL */
+           of setting all of them to nullptr */
         si->s_params_set = simage_wrapper_s_params_set;
         si->s_params_get = simage_wrapper_s_params_get;
         si->s_stream_open = simage_wrapper_s_stream_open;
@@ -429,15 +429,15 @@ simage_wrapper(void)
         si->s_stream_destroy = simage_wrapper_s_stream_destroy;
         si->s_stream_params = simage_wrapper_s_stream_params;
 #endif
-        si->s_params_create = NULL;
-        si->s_params_destroy = NULL;
-        si->s_params_set = NULL;
-        si->s_params_get = NULL;
-        si->s_stream_open = NULL;
-        si->s_stream_get_buffer = NULL;
-        si->s_stream_close = NULL;
-        si->s_stream_destroy = NULL;
-        si->s_stream_params = NULL;
+        si->s_params_create = nullptr;
+        si->s_params_destroy = nullptr;
+        si->s_params_set = nullptr;
+        si->s_params_get = nullptr;
+        si->s_stream_open = nullptr;
+        si->s_stream_get_buffer = nullptr;
+        si->s_stream_close = nullptr;
+        si->s_stream_destroy = nullptr;
+        si->s_stream_params = nullptr;
       }
     }
     simage_is_initializing = 0;
diff --git a/coin4/src/glue/simage_wrapper.h b/coin4/src/glue/simage_wrapper.h
index f65735c..ee273b0 100644
--- a/coin4/src/glue/simage_wrapper.h
+++ b/coin4/src/glue/simage_wrapper.h
@@ -111,11 +111,11 @@ extern "C" {
   typedef int (*s_params_get_t)(s_params * params, ...);
 
   typedef s_stream * (*s_stream_open_t)(const char * filename, 
-                                          s_params * params /* | NULL */);
+                                          s_params * params /* | nullptr */);
   typedef void * (*s_stream_get_buffer_t)(s_stream * stream, 
-                                           void * prealloc /* | NULL */,
-                                           int *size /* | NULL */,
-                                           s_params * params /* | NULL */);
+                                           void * prealloc /* | nullptr */,
+                                           int *size /* | nullptr */,
+                                           s_params * params /* | nullptr */);
   typedef void (*s_stream_close_t)(s_stream * stream);
   typedef void (*s_stream_destroy_t)(s_stream * stream);
   typedef s_params * (*s_stream_params_t)(s_stream * stream);
diff --git a/coin4/src/glue/spidermonkey.cpp b/coin4/src/glue/spidermonkey.cpp
index 36a82fb..84f5f8d 100644
--- a/coin4/src/glue/spidermonkey.cpp
+++ b/coin4/src/glue/spidermonkey.cpp
@@ -63,8 +63,8 @@ extern "C" {
 
 /* ******************************************************************** */
 
-static SpiderMonkey_t * spidermonkey_instance = NULL;
-static cc_libhandle spidermonkey_libhandle = NULL;
+static SpiderMonkey_t * spidermonkey_instance = nullptr;
+static cc_libhandle spidermonkey_libhandle = nullptr;
 static bool spidermonkey_failed_to_load = false;
 static int spidermonkey_is_initializing = 0;
 
@@ -90,13 +90,13 @@ spidermonkey_cleanup(void)
 #ifdef SPIDERMONKEY_RUNTIME_LINKING
   if (spidermonkey_libhandle) {
     cc_dl_close(spidermonkey_libhandle);
-    spidermonkey_libhandle = NULL;
+    spidermonkey_libhandle = nullptr;
   }
 #endif /* SPIDERMONKEY_RUNTIME_LINKING */
 
   assert(spidermonkey_instance);
   free(spidermonkey_instance);
-  spidermonkey_instance = NULL;
+  spidermonkey_instance = nullptr;
   spidermonkey_failed_to_load = false;
   spidermonkey_is_initializing = 0;
 }
@@ -135,7 +135,7 @@ spidermonkey(void)
 
     /* FIXME: there's a configure mortene. */
     const char * possiblelibnames[] = {
-      NULL, /* is set below */
+      nullptr, /* is set below */
       /* MSWindows DLL name */
       "js32",
 
@@ -146,7 +146,7 @@ spidermonkey(void)
       "libsmjs.so.1",
 
       /* terminator */
-      NULL
+      nullptr
     };
     possiblelibnames[0] = coin_getenv("COIN_SPIDERMONKEY_LIBNAME");
     idx = possiblelibnames[0] ? 0 : 1;
@@ -193,7 +193,7 @@ spidermonkey(void)
      from the API name. */
   #define REGISTER_FUNC_ALTERNATE(_funcname_, _altname_, _funcsig_) \
           sm->_funcname_ = (_funcsig_)cc_dl_sym(spidermonkey_libhandle, SO__QUOTE(_funcname_)); \
-          if (sm->_funcname_ == NULL) { sm->_funcname_ = (_funcsig_)cc_dl_sym(spidermonkey_libhandle, SO__QUOTE(_altname_)); } \
+          if (sm->_funcname_ == nullptr) { sm->_funcname_ = (_funcsig_)cc_dl_sym(spidermonkey_libhandle, SO__QUOTE(_altname_)); } \
           assert(sm->_funcname_)
 
 #elif defined(HAVE_SPIDERMONKEY_VIA_LINKTIME_LINKING) /* static linking */
@@ -210,7 +210,7 @@ spidermonkey(void)
   sm->available = 0;
 
   #define REGISTER_FUNC(_funcname_, _funcsig_) \
-          sm->_funcname_ = NULL
+          sm->_funcname_ = nullptr
 
   #define REGISTER_FUNC_ALTERNATE(_funcname_, _altname_, _funcsig_) \
           REGISTER_FUNC(_funcname_, _funcsig_)
diff --git a/coin4/src/glue/win32api.cpp b/coin4/src/glue/win32api.cpp
index 68eff5f..dda4c9a 100644
--- a/coin4/src/glue/win32api.cpp
+++ b/coin4/src/glue/win32api.cpp
@@ -49,17 +49,17 @@ void
 cc_win32_print_error(const char * callerfuncname, const char * apifuncname,
                      DWORD lasterror)
 {
-  char * outputstr = NULL;
-  LPTSTR buffer = NULL;
+  char * outputstr = nullptr;
+  LPTSTR buffer = nullptr;
   BOOL result = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                               FORMAT_MESSAGE_FROM_SYSTEM |
                               FORMAT_MESSAGE_IGNORE_INSERTS,
-                              NULL,
+                              nullptr,
                               lasterror,
                               0,
                               (LPTSTR)&buffer,
                               0,
-                              NULL);
+                              nullptr);
   if (!result) {
     cc_debugerror_post("cc_win32_print_error",
                        "FormatMessage() failed! "
@@ -71,7 +71,7 @@ cc_win32_print_error(const char * callerfuncname, const char * apifuncname,
 #ifdef UNICODE
   { /* Narrow from wide characters to 8-bit characters. */
     size_t len;
-    len = wcstombs(NULL, buffer, 0);
+    len = wcstombs(nullptr, buffer, 0);
     outputstr = (char *)LocalAlloc(0, len + 1);
     if (!outputstr) {
       cc_debugerror_post("cc_win32_print_error",
@@ -99,13 +99,13 @@ exitfunc:
 
   /* Don't call coin_LocalFree() here, to make sure we don't get a
      recursive call back here again. */
-  if (buffer && LocalFree(buffer) != NULL) {
+  if (buffer && LocalFree(buffer) != nullptr) {
     cc_debugerror_post("cc_win32_print_error",
                        "LocalFree() failed! (errorcode %d)",
                        GetLastError());
   }
   if (outputstr && (outputstr != (char *)buffer)) {
-    if (LocalFree(outputstr) != NULL) {
+    if (LocalFree(outputstr) != nullptr) {
       cc_debugerror_post("cc_win32_print_error",
                          "LocalFree() failed! (errorcode %d)",
                          GetLastError());
@@ -143,8 +143,8 @@ coin_GetTextFace(HDC hdc, /* handle to device context */
 {
   int copied = GetTextFace(hdc, nCount, lpFaceName);
 
-  if (copied == 0 && lpFaceName == NULL) {    
-    /* Due to a well known bug in Win95/98/ME, GetTextFace(-,-,NULL)
+  if (copied == 0 && lpFaceName == nullptr) {    
+    /* Due to a well known bug in Win95/98/ME, GetTextFace(-,-,nullptr)
        will return size=0. Our workaround is to just return a number
        assumed large enough for the length of the font name string. */
 
@@ -197,7 +197,7 @@ static void WINAPI
 coin_LocalFree(HLOCAL hMem) /* handle to local memory object */
 {
   const HLOCAL ptr = LocalFree(hMem);
-  if (ptr != NULL) {
+  if (ptr != nullptr) {
     cc_win32_print_error("coin_LocalFree", "LocalFree()", GetLastError());
     assert(false && "unexpected error");
   }
@@ -217,7 +217,7 @@ coin_SelectObject(HDC hdc, HGDIOBJ hgdiobj)
 
   previous = SelectObject(hdc, hgdiobj);
   if (((d == OBJ_REGION) && (previous == HGDI_ERROR)) ||
-      ((d == OBJ_REGION) && (previous == NULL))) {
+      ((d == OBJ_REGION) && (previous == nullptr))) {
     cc_win32_print_error("coin_SelectObject", "SelectObject()", GetLastError());
     
     /* not sure about this one, suddenly start assert'ing on
diff --git a/coin4/src/glue/zlib.cpp b/coin4/src/glue/zlib.cpp
index b04a872..60220d3 100644
--- a/coin4/src/glue/zlib.cpp
+++ b/coin4/src/glue/zlib.cpp
@@ -126,8 +126,8 @@ typedef struct {
   cc_zlibglue_crc32_t crc32;
 } cc_zlibglue_t;
 
-static cc_zlibglue_t * zlib_instance = NULL;
-static cc_libhandle zlib_libhandle = NULL;
+static cc_zlibglue_t * zlib_instance = nullptr;
+static cc_libhandle zlib_libhandle = nullptr;
 static int zlib_failed_to_load = 0;
 
 /* Cleans up at exit. */
@@ -137,12 +137,12 @@ zlibglue_cleanup(void)
 #ifdef ZLIB_RUNTIME_LINKING
   if (zlib_libhandle) {
     cc_dl_close(zlib_libhandle);
-    zlib_libhandle = NULL;
+    zlib_libhandle = nullptr;
   }
 #endif /* ZLIB_RUNTIME_LINKING */
   assert(zlib_instance);
   free(zlib_instance);
-  zlib_instance = NULL;
+  zlib_instance = nullptr;
   zlib_failed_to_load = 0;
 }
 
@@ -166,10 +166,10 @@ zlibglue_init(void)
       /* FIXME: should we get the system shared library name from an
          Autoconf check? 20000930 mortene. */
       const char * possiblelibnames[] = {
-        NULL, /* is set below */
+        nullptr, /* is set below */
         "zlib1", "zlib", "libz", "libz.so",
         "libz.dylib", 
-        NULL
+        nullptr
       };
 
       possiblelibnames[0] = coin_getenv("COIN_ZLIB_LIBNAME");
@@ -190,7 +190,7 @@ zlibglue_init(void)
 #define ZLIBGLUE_REGISTER_FUNC(_funcsig_, _funcname_) \
     do { \
       zi->_funcname_ = (_funcsig_)cc_dl_sym(zlib_libhandle, SO__QUOTE(_funcname_)); \
-      if (zi->_funcname_ == NULL) zi->available = 0; \
+      if (zi->_funcname_ == nullptr) zi->available = 0; \
     } while (0)
 
 #elif defined(ZLIBGLUE_ASSUME_ZLIB) /* !ZLIB_RUNTIME_LINKING */
@@ -203,7 +203,7 @@ zlibglue_init(void)
     zi->available = 0;
     /* Define ZLIBGLUE_REGISTER_FUNC macro. */
 #define ZLIBGLUE_REGISTER_FUNC(_funcsig_, _funcname_) \
-    zi->_funcname_ = NULL
+    zi->_funcname_ = nullptr
 
 #endif /* !ZLIBGLUE_ASSUME_ZLIB */
 
diff --git a/coin4/src/hardcopy/VectorOutput.cpp b/coin4/src/hardcopy/VectorOutput.cpp
index 258180c..ff73153 100644
--- a/coin4/src/hardcopy/VectorOutput.cpp
+++ b/coin4/src/hardcopy/VectorOutput.cpp
@@ -90,7 +90,7 @@ SoVectorOutput::openFile(const char * filename)
     PRIVATE(this)->fp = fp;
     PRIVATE(this)->didopen = true;
   }
-  return fp != NULL;
+  return fp != nullptr;
 }
 
 /*!
diff --git a/coin4/src/hardcopy/VectorizeAction.cpp b/coin4/src/hardcopy/VectorizeAction.cpp
index 1e7a41c..125d2d1 100644
--- a/coin4/src/hardcopy/VectorizeAction.cpp
+++ b/coin4/src/hardcopy/VectorizeAction.cpp
@@ -219,7 +219,7 @@ SoVectorizeAction::~SoVectorizeAction()
 SoVectorOutput *
 SoVectorizeAction::getOutput(void) const
 {
-  if (PRIVATE(this)->output == NULL) {
+  if (PRIVATE(this)->output == nullptr) {
     PRIVATE(this)->output = new SoVectorOutput;
   }
   return PRIVATE(this)->output;
diff --git a/coin4/src/hardcopy/VectorizeActionP.cpp b/coin4/src/hardcopy/VectorizeActionP.cpp
index 5963645..e780e3e 100644
--- a/coin4/src/hardcopy/VectorizeActionP.cpp
+++ b/coin4/src/hardcopy/VectorizeActionP.cpp
@@ -69,7 +69,7 @@ SoVectorizeActionP::SoVectorizeActionP(SoVectorizeAction * p)
 
   this->clipper = new SbClip(clip_cb, this);
   this->shapeprojmatrix = SbMatrix::identity();
-  this->output = NULL;
+  this->output = nullptr;
 
   PUBLIC(this)->addTriangleCallback(SoShape::getClassTypeId(),
                                     SoVectorizeActionP::triangle_cb,
@@ -102,7 +102,7 @@ SoVectorizeActionP::SoVectorizeActionP(SoVectorizeAction * p)
                                 SoVectorizeActionP::post_anno_cb, this);
   // for view-frustum culling
   PUBLIC(this)->addPostCallback(SoCamera::getClassTypeId(),
-                                camera_cb, NULL);
+                                camera_cb, nullptr);
 
   this->page.startpos = SbVec2f(10.0f, 10.0f);
   this->page.size = SbVec2f(190.0f, 277.0f);
diff --git a/coin4/src/hardcopy/VectorizePSAction.cpp b/coin4/src/hardcopy/VectorizePSAction.cpp
index d341738..f8dd726 100644
--- a/coin4/src/hardcopy/VectorizePSAction.cpp
+++ b/coin4/src/hardcopy/VectorizePSAction.cpp
@@ -220,7 +220,7 @@ static const char * gouraudtriangle[] = {
   "roll aload pop 9 3 roll 4 index 6 index 4 index add add 3 div 10 1 roll 7",
   "index 5 index 3 index add add 3 div 10 1 roll 6 index 4 index 2 index add",
   "add 3 div 10 1 roll 9 {pop} repeat 3 array astore triangle } ifelse } bd",
-  NULL
+  nullptr
 };
 
 static const char * flatshadetriangle[] = {
@@ -232,7 +232,7 @@ static const char * flatshadetriangle[] = {
   "closepath",
   "setrgbcolor",
   "fill } def",
-  NULL
+  nullptr
 };
 
 static const char * rightshow[] = {
@@ -242,7 +242,7 @@ static const char * rightshow[] = {
   "neg",
   "0 rmoveto",
   "show } def",
-  NULL
+  nullptr
 };
 
 static const char * centershow[] = {
@@ -253,7 +253,7 @@ static const char * centershow[] = {
   "neg",
   "0 rmoveto",
   "show } def",
-  NULL
+  nullptr
 };
 
 static void print_array(FILE * fp, const char ** array)
diff --git a/coin4/src/io/SoByteStream.cpp b/coin4/src/io/SoByteStream.cpp
index 38746e2..dcb78a5 100644
--- a/coin4/src/io/SoByteStream.cpp
+++ b/coin4/src/io/SoByteStream.cpp
@@ -60,7 +60,7 @@ void *
 SoByteStream::getData(void)
 {
   COIN_STUB();
-  return NULL;
+  return nullptr;
 }
 
 uint32_t
@@ -74,14 +74,14 @@ SoPathList *
 SoByteStream::unconvert(SoByteStream * COIN_UNUSED_ARG(stream))
 {
   COIN_STUB();
-  return NULL;
+  return nullptr;
 }
 
 SoPathList *
 SoByteStream::unconvert(void * COIN_UNUSED_ARG(data), uint32_t COIN_UNUSED_ARG(bytesinstream))
 {
   COIN_STUB();
-  return NULL;
+  return nullptr;
 }
 
 void
diff --git a/coin4/src/io/SoInput.cpp b/coin4/src/io/SoInput.cpp
index c14ff02..433873d 100644
--- a/coin4/src/io/SoInput.cpp
+++ b/coin4/src/io/SoInput.cpp
@@ -134,9 +134,9 @@
 
 // *************************************************************************
 
-SbStringList * SoInput::dirsearchlist = NULL;
+SbStringList * SoInput::dirsearchlist = nullptr;
 
-static SbStorage * soinput_tls = NULL;
+static SbStorage * soinput_tls = nullptr;
 
 struct soinput_tls_data {
   SbStringList * searchlist;
@@ -582,7 +582,7 @@ SoInput::findProto(const SbName & name)
   if (info) {
     return info->findProto(name);
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -742,7 +742,7 @@ SoInput::setFilePointer(FILE * newFP)
   this->closeFile();
 
   const char * name = (newFP == coin_get_stdin()) ? "<stdin>" : "";
-  SoInput_Reader * reader = NULL;
+  SoInput_Reader * reader = nullptr;
 
   // delay creating the reader if we're reading from
   // stdin. SoInput_FileInfo will create it when we know that we're
@@ -879,7 +879,7 @@ SoInput::closeFile(void)
 bool
 SoInput::isValidFile(void)
 {
-  if (this->getTopOfStack() == NULL) return false;
+  if (this->getTopOfStack() == nullptr) return false;
 
   // Abstract away the stupidity of providing both isValidFile() and
   // isValidBuffer().
@@ -901,7 +901,7 @@ SoInput::isValidFile(void)
 bool
 SoInput::isValidBuffer(void)
 {
-  if (this->getTopOfStack() == NULL) return false;
+  if (this->getTopOfStack() == nullptr) return false;
 
   // Abstract away the stupidity of providing both isValidFile() and
   // isValidBuffer().
@@ -914,7 +914,7 @@ SoInput::isValidBuffer(void)
 
 /*!
   Returns file pointer of the file on top of the input stack. If the
-  "file" is actually a memory buffer, returns \c NULL.
+  "file" is actually a memory buffer, returns \c nullptr.
 
   Important note: do \e not use this method when the Coin library has
   been compiled as an MSWindows DLL, as passing FILE* instances back
@@ -928,11 +928,11 @@ SoInput::getCurFile(void) const
 {
   SoInput_FileInfo * fi = this->getTopOfStack();
   assert(fi);
-  return fi->isMemBuffer() ? NULL : fi->ivFilePointer();
+  return fi->isMemBuffer() ? nullptr : fi->ivFilePointer();
 }
 
 /*!
-  Returns the name of the file on top of the input stack. \c NULL will
+  Returns the name of the file on top of the input stack. \c nullptr will
   be returned if the toplevel "file" is a memory buffer.
 
   \sa getCurFile()
@@ -942,12 +942,12 @@ SoInput::getCurFileName(void) const
 {
   SoInput_FileInfo * fi = this->getTopOfStack();
   assert(fi);
-  return fi->isMemBuffer() ? NULL : fi->ivFilename().getString();
+  return fi->isMemBuffer() ? nullptr : fi->ivFilename().getString();
 }
 
 /*!
   Sets up the input stream for reading from the strings pointed to by a
-  NULL-terminated array of string pointers.  It is intended for reading
+  nullptr-terminated array of string pointers.  It is intended for reading
   memory-inlined scene graphs.
 
   The rationale for this function is that there is a compiler portability
@@ -967,10 +967,10 @@ SoInput::getCurFileName(void) const
       "  Cube {\n",
       "  }\n",
       "}\n",
-      NULL
+      nullptr
     };
     SoInput in;
-    if ( !in.setStringArray(inlinescenegraph) ) return NULL;
+    if ( !in.setStringArray(inlinescenegraph) ) return nullptr;
     return SoDB::readAll(&in);
   }
   \endcode
@@ -986,10 +986,10 @@ SoInput::setStringArray(const char * strings[])
 {
   size_t bufsize = 0;
   size_t i;
-  for (i = bufsize = 0; strings[i] != NULL; i++ )
+  for (i = bufsize = 0; strings[i] != nullptr; i++ )
     bufsize += strlen(strings[i]);
   char * buf = new char [bufsize + 1];
-  for (i = bufsize = 0; strings[i] != NULL; i++ ) {
+  for (i = bufsize = 0; strings[i] != nullptr; i++ ) {
     const size_t len = strlen(strings[i]);
     memcpy(buf+bufsize, strings[i], len);
     bufsize += len;
@@ -1011,7 +1011,7 @@ void
 SoInput::setBuffer(const void * bufpointer, size_t bufsize)
 {
   this->closeFile();
-  SoInput_Reader * reader = NULL;
+  SoInput_Reader * reader = nullptr;
 
   unsigned char * header = (unsigned char*) bufpointer;
   if ((bufsize >= 2) && (header[0] == 0x1f) && (header[1] == 0x8b)) {
@@ -1024,7 +1024,7 @@ SoInput::setBuffer(const void * bufpointer, size_t bufsize)
                                 "not available.");
     }
   }
-  if (reader == NULL) {
+  if (reader == nullptr) {
     reader = new SoInput_MemBufferReader(bufpointer, bufsize);
   }
   SoInput_FileInfo * newfile =
@@ -1906,7 +1906,7 @@ SoInput::findReference(const SbName & name) const
       return SoBase::getNamedBase(name, SoNode::getClassTypeId());
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -2025,8 +2025,8 @@ SoInput::addEnvDirectoriesIdx(int startidx,
   // FIXME: the following "tokenizer" code could perhaps be factored
   // out and moved to e.g. SbStringList? 20030820 mortene.
 
-  if (separator == NULL) {
-    // use default separators if NULL
+  if (separator == nullptr) {
+    // use default separators if nullptr
     separator = ":\t ";
   }
   const char * end = p + strlen(p);
@@ -2135,7 +2135,7 @@ SoInput::init(void)
   // This will catch multiple initClass() calls (unless there's a
   // removeDirectories() in between them, which is unlikely to happen
   // inadvertently).
-  assert(SoInput::dirsearchlist == NULL);
+  assert(SoInput::dirsearchlist == nullptr);
 
   SoInput::dirsearchlist = new SbStringList;
   SoInput::addDirectoryFirst(".");
@@ -2152,9 +2152,9 @@ SoInput::clean(void)
 {
   SoInput::clearDirectories();
   delete SoInput::dirsearchlist;
-  SoInput::dirsearchlist = NULL;
+  SoInput::dirsearchlist = nullptr;
 
-  delete soinput_tls; soinput_tls = NULL;
+  delete soinput_tls; soinput_tls = nullptr;
 }
 
 /*!
@@ -2173,7 +2173,7 @@ SoInput::getPathname(const char * const filename)
   char drive[_MAX_DRIVE];
   char dir[_MAX_DIR];
 
-  _splitpath(filename, drive, dir, NULL, NULL);
+  _splitpath(filename, drive, dir, nullptr, nullptr);
 
   SbString s(drive);
   s += dir;
@@ -2182,7 +2182,7 @@ SoInput::getPathname(const char * const filename)
 #else // HAVE__SPLITPATH
 
   const char * ptr = strrchr(filename, '/');
-  if (ptr == NULL) return SbString("");
+  if (ptr == nullptr) return SbString("");
 
   SbString s = filename;
   return s.getSubString(0, ptr-filename);
@@ -2216,7 +2216,7 @@ SoInput::getBasename(const char * const filename)
   char fname[_MAX_FNAME];
   char ext[_MAX_EXT];
 
-  _splitpath(filename, NULL, NULL, fname, ext);
+  _splitpath(filename, nullptr, nullptr, fname, ext);
 
   SbString s(fname);
   s += ext;
@@ -2225,7 +2225,7 @@ SoInput::getBasename(const char * const filename)
 #else // UNIX systems
 
   const char * ptr = strrchr(filename, '/');
-  if (ptr == NULL) return SbString(filename);
+  if (ptr == nullptr) return SbString(filename);
 
   SbString s = filename;
   return s.getSubString(ptr - filename + 1, -1);
@@ -2253,7 +2253,7 @@ test_filename(const SbString & filename)
                          filename.getString(), fp ? "hit" : "miss");
 #endif // !COIN_DEBUG
 
-  if (fp != NULL) {
+  if (fp != nullptr) {
     fclose(fp);
     return true;
   }
@@ -2730,7 +2730,7 @@ char *
 SoInput::URLToFile(char * /* out_buf */, const char * /* in_buf */)
 {
   COIN_STUB();
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -2770,7 +2770,7 @@ SoInput::getTopOfStack(void) const
 {
   if (this->filestack.getLength() == 0) {
     SoDebugError::post("SoInput::getTopOfStack", "no files in stack");
-    return NULL;
+    return nullptr;
   }
   return this->filestack[0];
 }
@@ -2783,7 +2783,7 @@ SoInput::getTopOfStack(void) const
   \a fullname, open the file and return the file pointer.
 
   If the file could either not be found or not opened for reading,
-  return \c NULL.
+  return \c nullptr.
 
   Important note: do \e not use this method when the Coin library has
   been compiled as an MSWindows DLL, as passing FILE* instances back
@@ -2803,7 +2803,7 @@ SoInput::findFile(const char * basename, SbString & fullname)
 
   if (strlen(basename) < 1) {
     SoDebugError::post("SoInput::findFile", "Was asked to find a file with no name!");
-    return NULL;
+    return nullptr;
   }
 
   const char * env = coin_getenv("COIN_DEBUG_SOINPUT_FINDFILE");
@@ -2831,7 +2831,7 @@ SoInput::findFile(const char * basename, SbString & fullname)
   SbString relativepath("");
   sl.insert(&relativepath, 0);
 
-  FILE * fp = NULL;
+  FILE * fp = nullptr;
   for (int diridx = 0; diridx < sl.getLength(); diridx++) {
     SbString n = * sl[diridx];
     const int namelen = n.getLength();
@@ -2844,7 +2844,7 @@ SoInput::findFile(const char * basename, SbString & fullname)
     struct stat buf;
     if ((stat(n.getString(), &buf) == 0) && !S_ISDIR(buf.st_mode)) {
       fp = fopen(n.getString(), "rb");
-      if (fp != NULL) {
+      if (fp != nullptr) {
         if (DEBUG_FILE_SEARCHING) {
           SoDebugError::postInfo("SoInput::findFile", "successfully fopened '%s'", n.getString());
         }
@@ -2881,7 +2881,7 @@ SoInput::findFile(const char * basename, SbString & fullname)
     }
   }
 
-  return NULL;
+  return nullptr;
 }
 
 #undef READ_NUM
diff --git a/coin4/src/io/SoInput_FileInfo.cpp b/coin4/src/io/SoInput_FileInfo.cpp
index bf30d4a..3ffd4f7 100644
--- a/coin4/src/io/SoInput_FileInfo.cpp
+++ b/coin4/src/io/SoInput_FileInfo.cpp
@@ -61,14 +61,14 @@ SoInput_FileInfo::SoInput_FileInfo(SoInput_Reader * readerptr,
   this->threadreadidx = 0;
   this->threadbufidx = 0;
   this->threadeof = false;
-  this->readbuf = NULL;
+  this->readbuf = nullptr;
 #else // HAVE_THREADS && SOINPUT_ASYNC_IO
   this->readbuf = new char[READBUFSIZE];
 #endif // !(HAVE_THREADS && SOINPUT_ASYNC_IO)
   this->readbuflen = 0;
   this->readbufidx = 0;
 
-  this->header = NULL;
+  this->header = nullptr;
   this->headerisread = false;
   this->ivversion = 0.0f;
   this->linenr = 1;
@@ -79,10 +79,10 @@ SoInput_FileInfo::SoInput_FileInfo(SoInput_Reader * readerptr,
   this->isbinary = false;
   this->vrml1file = false;
   this->vrml2file = false;
-  this->prefunc = NULL;
-  this->postfunc = NULL;
+  this->prefunc = nullptr;
+  this->postfunc = nullptr;
   this->stdinname = "<stdin>";
-  this->deletebuffer = NULL;
+  this->deletebuffer = nullptr;
 
 #if defined(HAVE_THREADS) && defined(SOINPUT_ASYNC_IO)
   if (this->reader) {
@@ -238,7 +238,7 @@ SoInput_FileInfo::findReference(const SbName & name) const
 {
   SoBase * base;
   if (this->references.get(name.getString(), base)) { return base; }
-  return NULL;
+  return nullptr;
 }
 
 bool
@@ -461,15 +461,15 @@ SoInput_FileInfo::findProto(const SbName & name)
   for (int i = 0; i < n; i++) {
     if (ptr[i]->getProtoName() == name) return ptr[i];
   }
-  return NULL;
+  return nullptr;
 }
 
 // wrapper around this->reader. We delay creating the reader if we're
-// reading from stdin (reader == NULL).
+// reading from stdin (reader == nullptr).
 SoInput_Reader *
 SoInput_FileInfo::getReader(void)
 {
-  if (this->reader == NULL) {
+  if (this->reader == nullptr) {
     this->reader = SoInput_Reader::createReader(coin_get_stdin(), SbString("<stdin>"));
 #if defined(HAVE_THREADS) && defined(SOINPUT_ASYNC_IO)
     // schedule a buffer read
@@ -517,7 +517,7 @@ SoInput_FileInfo::readUnsignedInteger(uint32_t & l)
   // FIXME: check man page of strtoul and exploit the functionality
   // provided better -- it looks like we are duplicating some of the
   // effort. 19990530 mortene.
-  l = strtoul(str, NULL, 0);
+  l = strtoul(str, nullptr, 0);
 
   return true;
 }
@@ -543,7 +543,7 @@ SoInput_FileInfo::readInteger(int32_t & l)
   // provided better -- it looks like we are duplicating some of the
   // effort. 19990530 mortene.
 #if 1 // old code
-  l = strtol(str, NULL, 0);
+  l = strtol(str, nullptr, 0);
 #else // first version of replacement of strtol. Not activated yet
   int i, n = strlen(s);
   if (n >= 3 && s[0] == '0' && s[1] == 'x') {
diff --git a/coin4/src/io/SoInput_FileInfo.h b/coin4/src/io/SoInput_FileInfo.h
index 44e501b..fac22aa 100644
--- a/coin4/src/io/SoInput_FileInfo.h
+++ b/coin4/src/io/SoInput_FileInfo.h
@@ -92,8 +92,8 @@ public:
   }
 
   bool isMemBuffer(void) {
-    // if reader == NULL, it means that we're reading from stdin
-    if (this->reader == NULL) return false;
+    // if reader == nullptr, it means that we're reading from stdin
+    if (this->reader == nullptr) return false;
     return
       (this->getReader()->getType() == SoInput_Reader::MEMBUFFER) ||
       (this->getReader()->getType() == SoInput_Reader::GZMEMBUFFER);
@@ -124,13 +124,13 @@ public:
     return this->linenr;
   }
   FILE * ivFilePointer(void) {
-    // if reader == NULL, it means that we're reading from stdin
-    if (this->reader == NULL) return coin_get_stdin();
+    // if reader == nullptr, it means that we're reading from stdin
+    if (this->reader == nullptr) return coin_get_stdin();
     return this->getReader()->getFilePointer();
   }
   const SbString & ivFilename(void) {
-    // if reader == NULL, it means that we're reading from stdin
-    if (this->reader == NULL) return this->stdinname;
+    // if reader == nullptr, it means that we're reading from stdin
+    if (this->reader == nullptr) return this->stdinname;
     return this->getReader()->getFilename();
   }
   bool isEndOfFile(void) const {
@@ -163,7 +163,7 @@ public:
   SoProto * getCurrentProto(void) {
     const int n = this->protostack.getLength();
     if (n) return this->protostack[n-1];
-    return NULL;
+    return nullptr;
   }
 
   bool isSpace(const char c) {
diff --git a/coin4/src/io/SoInput_Reader.cpp b/coin4/src/io/SoInput_Reader.cpp
index 5bd54ea..67d8ae2 100644
--- a/coin4/src/io/SoInput_Reader.cpp
+++ b/coin4/src/io/SoInput_Reader.cpp
@@ -79,7 +79,7 @@ SoInput_Reader::getFilename(void)
 FILE *
 SoInput_Reader::getFilePointer(void)
 {
-  return NULL;
+  return nullptr;
 }
 
 // creates the correct reader based on the file type in fp (will
@@ -89,7 +89,7 @@ SoInput_Reader::getFilePointer(void)
 SoInput_Reader *
 SoInput_Reader::createReader(FILE * fp, const SbString & fullname)
 {
-  SoInput_Reader * reader = NULL;
+  SoInput_Reader * reader = nullptr;
   bool trycompression = false;
 
 #ifdef HAVE_FSTAT
diff --git a/coin4/src/io/SoInput_Reader.h b/coin4/src/io/SoInput_Reader.h
index ca97c9d..db84046 100644
--- a/coin4/src/io/SoInput_Reader.h
+++ b/coin4/src/io/SoInput_Reader.h
@@ -60,7 +60,7 @@ public:
   // an empty string.
   virtual const SbString & getFilename(void);
 
-  // default method returns NULL. Should only be overloaded if the
+  // default method returns nullptr. Should only be overloaded if the
   // reader uses FILE * to read data.
   virtual FILE * getFilePointer(void);
 
diff --git a/coin4/src/io/SoOutput.cpp b/coin4/src/io/SoOutput.cpp
index e78edd4..0554406 100644
--- a/coin4/src/io/SoOutput.cpp
+++ b/coin4/src/io/SoOutput.cpp
@@ -165,7 +165,7 @@ typedef SbHash<const char *, void *> BogusSet;
 class SoOutputP {
 public:
   SoOutputP(void) {
-    this->writer = NULL;
+    this->writer = nullptr;
   }
   ~SoOutputP() {
     delete this->writer;
@@ -204,7 +204,7 @@ public:
     const int n = this->routestack.getLength();
     assert(n);
     SoOutputROUTEList * list = this->routestack[n-1];
-    if (list == NULL && createifnull) {
+    if (list == nullptr && createifnull) {
       list = new SoOutputROUTEList;
       this->routestack[n-1] = list;
     }
@@ -225,7 +225,7 @@ public:
     if (copyprev && prev) {
       this->defstack.append(new BogusSet(*prev));
     }
-    else this->defstack.append(NULL);
+    else this->defstack.append(nullptr);
   }
   void popDefNames(void) {
     assert(this->defstack.getLength());
@@ -236,7 +236,7 @@ public:
     const int idx = this->defstack.getLength() - 1;
     assert(idx >= 0);
     BogusSet * dict = this->defstack[idx];
-    if (createifnull && dict == NULL) {
+    if (createifnull && dict == nullptr) {
       dict = new BogusSet;
       this->defstack[idx] = dict;
     }
@@ -244,7 +244,7 @@ public:
   }
 
   SoOutput_Writer * getWriter(void) {
-    if (this->writer == NULL) {
+    if (this->writer == nullptr) {
       this->writer = SoOutput_Writer::createWriter(coin_get_stdout(), false,
                                                    this->compmethod, this->complevel);
     }
@@ -259,7 +259,7 @@ private:
 
 };
 
-static SbList <SbName> * SoOutput_compmethods = NULL;
+static SbList <SbName> * SoOutput_compmethods = nullptr;
 
 // *************************************************************************
 
@@ -267,7 +267,7 @@ static void
 SoOutput_compression_list_cleanup(void)
 {
   delete SoOutput_compmethods;
-  SoOutput_compmethods = NULL;
+  SoOutput_compmethods = nullptr;
 }
 
 static void
@@ -296,9 +296,9 @@ SoOutput_compression_list_init(void)
 SoOutput::SoOutput(void)
 {
   this->constructorCommon();
-  PRIVATE(this)->defstack.append(NULL);
+  PRIVATE(this)->defstack.append(nullptr);
 
-  SoWriterefCounter::create(this, NULL);
+  SoWriterefCounter::create(this, nullptr);
   PRIVATE(this)->counter = SoWriterefCounter::instance(this);
 }
 
@@ -308,11 +308,11 @@ SoOutput::SoOutput(void)
 */
 SoOutput::SoOutput(SoOutput * dictOut)
 {
-  assert(dictOut != NULL);
+  assert(dictOut != nullptr);
   this->constructorCommon();
 
   BogusSet * olddef = PRIVATE(dictOut)->getCurrentDefNames(false);
-  PRIVATE(this)->defstack.append(olddef ? new BogusSet(*olddef) : NULL);
+  PRIVATE(this)->defstack.append(olddef ? new BogusSet(*olddef) : nullptr);
 
   SoWriterefCounter::create(this, dictOut);
   PRIVATE(this)->counter = SoWriterefCounter::instance(this);
@@ -334,10 +334,10 @@ SoOutput::constructorCommon(void)
   PRIVATE(this)->disabledwriting = false;
   this->wroteHeader = false;
   PRIVATE(this)->writecompact = false;
-  PRIVATE(this)->headerstring = NULL;
+  PRIVATE(this)->headerstring = nullptr;
   PRIVATE(this)->indentlevel = 0;
   PRIVATE(this)->annotationbits = 0x00;
-  PRIVATE(this)->routestack.append(NULL);
+  PRIVATE(this)->routestack.append(nullptr);
 
   PRIVATE(this)->compmethod = SbName("NONE");
   PRIVATE(this)->complevel = 0.0f;;
@@ -375,7 +375,7 @@ SoOutput::setFilePointer(FILE * newFP)
 
 /*!
   Returns the current filepointer. If we're writing to a memory
-  buffer, \c NULL is returned.
+  buffer, \c nullptr is returned.
 
   Important note: do \e not use this method when the Coin library has
   been compiled as an MSWindows DLL, as passing FILE* instances back
@@ -417,7 +417,7 @@ SoOutput::openFile(const char * const fileName)
                               "Couldn't open file '%s' for writing.",
                               fileName);
   }
-  return newfile != NULL;
+  return newfile != nullptr;
 }
 
 /*!
@@ -430,7 +430,7 @@ void
 SoOutput::closeFile(void)
 {
   if (PRIVATE(this)->usercalledopenfile) {
-    PRIVATE(this)->setWriter(NULL);
+    PRIVATE(this)->setWriter(nullptr);
     PRIVATE(this)->usercalledopenfile = false;
   }
 }
@@ -507,7 +507,7 @@ SoOutput::getAvailableCompressionMethods(unsigned int & num)
   Writing will start at \a bufPointer + \a offset.
 
   If the buffer is filled up, \a reallocFunc is called to get more
-  memory. If \a reallocFunc returns \a NULL, further writing is
+  memory. If \a reallocFunc returns \a nullptr, further writing is
   disabled.
 
   Important note: remember that the resultant memory buffer after
@@ -677,7 +677,7 @@ void
 SoOutput::resetHeaderString(void)
 {
   delete PRIVATE(this)->headerstring;
-  PRIVATE(this)->headerstring = NULL;
+  PRIVATE(this)->headerstring = nullptr;
 }
 
 /*!
@@ -1163,14 +1163,14 @@ SoOutput::reset(void)
     delete PRIVATE(this)->routestack[0];
     PRIVATE(this)->routestack.removeFast(0);
   }
-  PRIVATE(this)->routestack.append(NULL);
+  PRIVATE(this)->routestack.append(nullptr);
 
   PRIVATE(this)->protostack.truncate(0);
   while (PRIVATE(this)->defstack.getLength()) {
     delete PRIVATE(this)->defstack[0];
     PRIVATE(this)->defstack.removeFast(0);
   }
-  PRIVATE(this)->defstack.append(NULL);
+  PRIVATE(this)->defstack.append(nullptr);
 
   PRIVATE(this)->disabledwriting = false;
   this->wroteHeader = false;
@@ -1245,7 +1245,7 @@ SoOutput::getAnnotation(void)
 
   Note that there will automatically be made an attempt at allocating
   more memory if the realloction callback function argument of
-  setBuffer() was not \a NULL.
+  setBuffer() was not \a nullptr.
 */
 bool
 SoOutput::makeRoomInBuf(size_t bytes)
@@ -1375,7 +1375,7 @@ SoOutput::setReference(const SoBase * base, int refid)
 void
 SoOutput::addDEFNode(SbName name)
 {
-  void * value = NULL;
+  void * value = nullptr;
   BogusSet * defnames = PRIVATE(this)->getCurrentDefNames(true);
   defnames->put(name.getString(), value);
 }
@@ -1446,7 +1446,7 @@ SoOutput::getCurrentProto(void) const
   if (PRIVATE(this)->protostack.getLength()) {
     return PRIVATE(this)->protostack[PRIVATE(this)->protostack.getLength()-1];
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
diff --git a/coin4/src/io/SoOutput_Writer.cpp b/coin4/src/io/SoOutput_Writer.cpp
index f353ca8..31a7853 100644
--- a/coin4/src/io/SoOutput_Writer.cpp
+++ b/coin4/src/io/SoOutput_Writer.cpp
@@ -71,7 +71,7 @@ SoOutput_Writer::~SoOutput_Writer()
 FILE * 
 SoOutput_Writer::getFilePointer(void)
 {
-  return NULL;
+  return nullptr;
 }
 
 
@@ -217,7 +217,7 @@ SoOutput_MemBufferWriter::makeRoomInBuf(size_t bytes)
 
 SoOutput_GZFileWriter::SoOutput_GZFileWriter(FILE * fp, const bool shouldclose, const float level)
 {
-  this->gzfp = NULL;
+  this->gzfp = nullptr;
 
   int fd = fileno(fp);
   if (fd >= 0 && !shouldclose) fd = dup(fd);
@@ -281,7 +281,7 @@ SoOutput_GZFileWriter::bytesInBuf(void)
 
 SoOutput_BZ2FileWriter::SoOutput_BZ2FileWriter(FILE * fparg, const bool shouldclose, const float level)
 {
-  this->fp = shouldclose ? fparg : NULL;
+  this->fp = shouldclose ? fparg : nullptr;
   this->writecounter = 0;
 
   int bzerror = BZ_OK;
@@ -291,8 +291,8 @@ SoOutput_BZ2FileWriter::SoOutput_BZ2FileWriter(FILE * fparg, const bool shouldcl
   if (this->bzfp && (bzerror != BZ_OK)) {
     SoDebugError::postWarning("SoOutput_BZ2FileWriter::SoOutput_BZF2ileWriter", 
                               "Unable to open file for writing.");    
-    cc_bzglue_BZ2_bzWriteClose(&bzerror, this->bzfp, 0, NULL, NULL);
-    this->bzfp = NULL;
+    cc_bzglue_BZ2_bzWriteClose(&bzerror, this->bzfp, 0, nullptr, nullptr);
+    this->bzfp = nullptr;
   }
 }
 
@@ -300,7 +300,7 @@ SoOutput_BZ2FileWriter::~SoOutput_BZ2FileWriter()
 {
   if (this->bzfp) {
     int bzerror = BZ_OK;
-    cc_bzglue_BZ2_bzWriteClose(&bzerror, this->bzfp, 0, NULL, NULL);
+    cc_bzglue_BZ2_bzWriteClose(&bzerror, this->bzfp, 0, nullptr, nullptr);
     if (bzerror != BZ_OK) {
       SoDebugError::postWarning("SoOutput_BZ2FileWriter::~SoOutput_BZ2FileWriter", 
                                 "Error when closing bzip2 file.");    
@@ -330,8 +330,8 @@ SoOutput_BZ2FileWriter::write(const char * buf, size_t numbytes, const bool COIN
       assert(bzerror == BZ_IO_ERROR);
       SoDebugError::postWarning("SoOutput_BZ2FileWriter::write", 
                                 "I/O error while writing.");    
-      cc_bzglue_BZ2_bzWriteClose(&bzerror, this->bzfp, 0, NULL, NULL);
-      this->bzfp = NULL;
+      cc_bzglue_BZ2_bzWriteClose(&bzerror, this->bzfp, 0, nullptr, nullptr);
+      this->bzfp = nullptr;
       return 0;
     }
     this->writecounter += numbytes;
diff --git a/coin4/src/io/SoOutput_Writer.h b/coin4/src/io/SoOutput_Writer.h
index 9681cf4..86cfe67 100644
--- a/coin4/src/io/SoOutput_Writer.h
+++ b/coin4/src/io/SoOutput_Writer.h
@@ -48,7 +48,7 @@ public:
     BZ2FILE
   };
 
-  // default method returns NULL. Should return the FILE pointer if
+  // default method returns nullptr. Should return the FILE pointer if
   // the Writer uses stdio to write.
   virtual FILE * getFilePointer(void);
 
diff --git a/coin4/src/io/SoTranSender.cpp b/coin4/src/io/SoTranSender.cpp
index 5131203..3f09e08 100644
--- a/coin4/src/io/SoTranSender.cpp
+++ b/coin4/src/io/SoTranSender.cpp
@@ -41,7 +41,7 @@ SoOutput *
 SoTranSender::getOutput(void) const
 {
   COIN_STUB();
-  return NULL;
+  return nullptr;
 }
 
 void
diff --git a/coin4/src/io/SoWriterefCounter.cpp b/coin4/src/io/SoWriterefCounter.cpp
index a1b364c..78ec53f 100644
--- a/coin4/src/io/SoWriterefCounter.cpp
+++ b/coin4/src/io/SoWriterefCounter.cpp
@@ -165,11 +165,11 @@ public:
   static SbString * refwriteprefix;
 
   static void atexit_cleanup(void) {
-    current = NULL;
+    current = nullptr;
     delete refwriteprefix;
-    refwriteprefix = NULL;
+    refwriteprefix = nullptr;
     delete outputdict;
-    outputdict = NULL;
+    outputdict = nullptr;
     CC_MUTEX_DESTRUCT(mutex);
   }
 
@@ -177,7 +177,7 @@ public:
 
 void * SoWriterefCounterP::mutex;
 SoOutput2SoWriterefCounterMap *  SoWriterefCounterP::outputdict;
-SoWriterefCounter *  SoWriterefCounterP::current = NULL; // used to be backwards compatible
+SoWriterefCounter *  SoWriterefCounterP::current = nullptr; // used to be backwards compatible
 SbString *  SoWriterefCounterP::refwriteprefix;
 
 #define PRIVATE(obj) obj->pimpl
@@ -186,7 +186,7 @@ SbString *  SoWriterefCounterP::refwriteprefix;
 
 SoWriterefCounter::SoWriterefCounter(SoOutput * out, SoOutput * copyfrom)
 {
-  SoWriterefCounterP * datafrom = NULL;
+  SoWriterefCounterP * datafrom = nullptr;
   if (copyfrom) {
     SoWriterefCounter * frominst = SoWriterefCounter::instance(copyfrom);
     datafrom = frominst->pimpl;
@@ -246,14 +246,14 @@ SoWriterefCounter::setInstancePrefix(const SbString & s)
 SoWriterefCounter *
 SoWriterefCounter::instance(SoOutput * out)
 {
-  if (out == NULL) {
+  if (out == nullptr) {
     // to be backwards compatible with old code
     return SoWriterefCounterP::current;
   }
 
   CC_MUTEX_LOCK(SoWriterefCounterP::mutex);
 
-  SoWriterefCounter * inst = NULL;
+  SoWriterefCounter * inst = nullptr;
 
   const bool ok = SoWriterefCounterP::outputdict->get(out, inst);
   assert(ok && "no instance");
diff --git a/coin4/src/io/gzmemio.cpp b/coin4/src/io/gzmemio.cpp
index 811b1b3..613441a 100644
--- a/coin4/src/io/gzmemio.cpp
+++ b/coin4/src/io/gzmemio.cpp
@@ -67,7 +67,7 @@ typedef struct {
   unsigned int avail_out; /* remaining free space at next_out */
   unsigned long total_out; /* total nb of bytes output so far */
   
-  char * msg;      /* last error message, NULL if no error */
+  char * msg;      /* last error message, nullptr if no error */
   struct internal_state * state; /* not visible by applications */
   
   alloc_func zalloc;  /* used to allocate the internal state */
@@ -150,21 +150,21 @@ void * cc_gzm_open(const uint8_t * buffer, uint32_t len)
 
 
   s = (cc_gzm_stream *) Z_ALLOC(sizeof(cc_gzm_stream));
-  if (!s) return NULL;
+  if (!s) return nullptr;
 
   s->stream.zalloc = (alloc_func)0;
   s->stream.zfree = (free_func)0;
   s->stream.opaque = (void *)0;
-  s->stream.next_in = s->inbuf = NULL;
-  s->stream.next_out = s->outbuf = NULL;
+  s->stream.next_in = s->inbuf = nullptr;
+  s->stream.next_out = s->outbuf = nullptr;
   s->stream.avail_in = s->stream.avail_out = 0;
   s->z_err = Z_OK;
   s->z_eof = 0;
-  s->crc = cc_zlibglue_crc32(0L, NULL, 0);
-  s->msg = NULL;
+  s->crc = cc_zlibglue_crc32(0L, nullptr, 0);
+  s->msg = nullptr;
   s->transparent = 0;
-  s->path = NULL;
-  s->memfile = NULL;
+  s->path = nullptr;
+  s->memfile = nullptr;
 
   s->mode = 'r'; /* read */
   if (s->mode == 'w') { /* not supported yet */
@@ -177,9 +177,9 @@ void * cc_gzm_open(const uint8_t * buffer, uint32_t len)
 
     s->stream.next_out = s->outbuf = (uint8_t*)Z_ALLOC(Z_BUFSIZE);
 #endif
-    if (err != Z_OK || s->outbuf == NULL) {
+    if (err != Z_OK || s->outbuf == nullptr) {
       destroy(s);
-      return NULL;
+      return nullptr;
     }
   }
   else {
@@ -197,9 +197,9 @@ void * cc_gzm_open(const uint8_t * buffer, uint32_t len)
      * return Z_STREAM_END. Here the gzip CRC32 ensures that 4 bytes are
      * present after the compressed stream.
      */
-    if (err != Z_OK || s->inbuf == NULL) {
+    if (err != Z_OK || s->inbuf == nullptr) {
       destroy(s);
-      return NULL;
+      return nullptr;
     }
   }
   s->stream.avail_out = Z_BUFSIZE;
@@ -318,7 +318,7 @@ static int destroy (cc_gzm_stream * s)
 
   Z_TRYFREE(s->msg);
 
-  if (s->stream.state != NULL) {
+  if (s->stream.state != nullptr) {
     if (s->mode == 'w') {
 #ifdef Z_NO_DEFLATE
       err = Z_STREAM_ERROR;
@@ -352,7 +352,7 @@ cc_gzm_read (void * file, void * buf, uint32_t len)
   uint8_t *start = (uint8_t*)buf; /* starting point for crc computation */
   uint8_t * next_out; /* == stream.next_out but not forced far (for MSDOS) */
 
-  if (s == NULL || s->mode != 'r') return Z_STREAM_ERROR;
+  if (s == nullptr || s->mode != 'r') return Z_STREAM_ERROR;
 
   if (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO) return -1;
   if (s->z_err == Z_STREAM_END) return 0;  /* EOF */
@@ -420,7 +420,7 @@ cc_gzm_read (void * file, void * buf, uint32_t len)
           cc_zlibglue_inflateReset(&(s->stream));
           s->stream.total_in = total_in;
           s->stream.total_out = total_out;
-          s->crc = cc_zlibglue_crc32(0L, NULL, 0);
+          s->crc = cc_zlibglue_crc32(0L, nullptr, 0);
         }
       }
     }
@@ -448,7 +448,7 @@ cc_gzm_getc(void * file)
    read, or a newline character is read and transferred to buf, or an
    end-of-file condition is encountered.  The string is then terminated
    with a null character.
-   gzgets returns buf, or NULL in case of error.
+   gzgets returns buf, or nullptr in case of error.
 
    The current implementation is not optimized at all.
 */
@@ -456,11 +456,11 @@ char *
 cc_gzm_gets(void * file, char * buf, int len)
 {
   char * b = buf;
-  if (buf == NULL || len <= 0) return NULL;
+  if (buf == nullptr || len <= 0) return nullptr;
 
   while (--len > 0 && cc_gzm_read(file, buf, 1) == 1 && *buf++ != '\n') ;
   *buf = '\0';
-  return b == buf && len > 0 ? NULL : b;
+  return b == buf && len > 0 ? nullptr : b;
 }
 
 #ifndef Z_NO_DEFLATE
@@ -474,7 +474,7 @@ cc_gzm_setparams(void * file, int level, int strategy)
 {
   cc_gzm_stream *s = (cc_gzm_stream*)file;
 
-  if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;
+  if (s == nullptr || s->mode != 'w') return Z_STREAM_ERROR;
 
   /* Make room to allow flushing */
   if (s->stream.avail_out == 0) {
@@ -496,7 +496,7 @@ cc_gzm_write(void * file, void * buf, unsigned int len)
 {
   cc_gzm_stream *s = (cc_gzm_stream*)file;
 
-  if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;
+  if (s == nullptr || s->mode != 'w') return Z_STREAM_ERROR;
 
   s->stream.next_in = (uint8_t*)buf;
   s->stream.avail_in = len;
@@ -553,7 +553,7 @@ static int do_flush (void * file, int flush)
   int done = 0;
   cc_gzm_stream *s = (cc_gzm_stream*)file;
 
-  if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;
+  if (s == nullptr || s->mode != 'w') return Z_STREAM_ERROR;
 
   s->stream.avail_in = 0; /* should be zero already anyway */
 
@@ -608,7 +608,7 @@ cc_gzm_seek(void * file, off_t offset, int whence)
 {
   cc_gzm_stream *s = (cc_gzm_stream*)file;
 
-  if (s == NULL || whence == SEEK_END ||
+  if (s == nullptr || whence == SEEK_END ||
       s->z_err == Z_ERRNO || s->z_err == Z_DATA_ERROR) {
     return -1L;
   }
@@ -623,7 +623,7 @@ cc_gzm_seek(void * file, off_t offset, int whence)
     if (offset < 0) return -1L;
 
     /* At this point, offset is the number of zero bytes to write. */
-    if (s->inbuf == NULL) {
+    if (s->inbuf == nullptr) {
       s->inbuf = (uint8_t*)Z_ALLOC(Z_BUFSIZE); /* for seeking */
       zmemzero(s->inbuf, Z_BUFSIZE);
     }
@@ -665,7 +665,7 @@ cc_gzm_seek(void * file, off_t offset, int whence)
   }
   /* offset is now the number of bytes to skip. */
 
-  if (offset != 0 && s->outbuf == NULL) {
+  if (offset != 0 && s->outbuf == nullptr) {
     s->outbuf = (uint8_t*)Z_ALLOC(Z_BUFSIZE);
   }
   while (offset > 0)  {
@@ -686,13 +686,13 @@ int cc_gzm_rewind(void * file)
 {
   cc_gzm_stream *s = (cc_gzm_stream*)file;
 
-  if (s == NULL || s->mode != 'r') return -1;
+  if (s == nullptr || s->mode != 'r') return -1;
 
   s->z_err = Z_OK;
   s->z_eof = 0;
   s->stream.avail_in = 0;
   s->stream.next_in = s->inbuf;
-  s->crc = cc_zlibglue_crc32(0L, NULL, 0);
+  s->crc = cc_zlibglue_crc32(0L, nullptr, 0);
 
   if (s->startpos == 0) { /* not a compressed file */
     s->memfile->currpos = 0;
@@ -721,7 +721,7 @@ int cc_gzm_eof(void * file)
 {
   cc_gzm_stream *s = (cc_gzm_stream*)file;
 
-  return (s == NULL || s->mode != 'r') ? 0 : s->z_eof;
+  return (s == nullptr || s->mode != 'r') ? 0 : s->z_eof;
 }
 
 #ifndef Z_NO_DEFLATE
@@ -766,7 +766,7 @@ int cc_gzm_close(void * file)
   int err;
   cc_gzm_stream *s = (cc_gzm_stream*)file;
 
-  if (s == NULL) return Z_STREAM_ERROR;
+  if (s == nullptr) return Z_STREAM_ERROR;
 
   if (s->mode == 'w') {
 #ifdef Z_NO_DEFLATE
diff --git a/coin4/src/lists/SbPList.cpp b/coin4/src/lists/SbPList.cpp
index 9d66a47..d42c13f 100644
--- a/coin4/src/lists/SbPList.cpp
+++ b/coin4/src/lists/SbPList.cpp
@@ -103,7 +103,7 @@
 
   Will automatically expand the size of the internal array if \a index
   is outside the current bounds of the list. The values of any
-  additional pointers are then set to \c NULL.
+  additional pointers are then set to \c nullptr.
 */
 
 /*!
@@ -280,14 +280,14 @@ SbPList::operator==(const SbPList & l) const
   return true;
 }
 
-// Expand list to the given size, filling in with NULL pointers.
+// Expand list to the given size, filling in with nullptr pointers.
 void
 SbPList::expandlist(const int size) const
 {
   const int oldsize = this->getLength();
   SbPList * thisp = (SbPList *)this;
   thisp->expand(size);
-  for (int i = oldsize; i < size; i++) (*thisp)[i] = NULL;
+  for (int i = oldsize; i < size; i++) (*thisp)[i] = nullptr;
 }
 
 // grow allocated array, not number of items
diff --git a/coin4/src/lists/SoActionMethodList.cpp b/coin4/src/lists/SoActionMethodList.cpp
index a6a5f76..57b45fb 100644
--- a/coin4/src/lists/SoActionMethodList.cpp
+++ b/coin4/src/lists/SoActionMethodList.cpp
@@ -77,7 +77,7 @@ public:
 
 /*!
   The constructor.  The \a parentlist argument is the parent action's
-  action method list.  It can be \c NULL for action method lists that
+  action method list.  It can be \c nullptr for action method lists that
   are not based on inheriting from a parent action.
 */
 SoActionMethodList::SoActionMethodList(SoActionMethodList * const parentlist)
@@ -124,7 +124,7 @@ static void unsetActionMethod(SoAction *, SoNode *)
 
 /*!
   This method must be called as the last initialization step before
-  using the list. It fills in \c NULL entries with the parent's
+  using the list. It fills in \c nullptr entries with the parent's
   method.
 */
 void
@@ -142,10 +142,10 @@ SoActionMethodList::setUp(void)
       (*this)[SoNode::getActionMethodIndex(PRIVATE(this)->addedtypes[i])] = PRIVATE(this)->addedmethods[i];
     }
     
-    // make sure SoNode's action method is set to avoid a NULL action method
+    // make sure SoNode's action method is set to avoid a nullptr action method
     i = SoNode::getActionMethodIndex(SoNode::getClassTypeId());
-    if ((*this)[i] == NULL) {
-      if (PRIVATE(this)->parent == NULL) {
+    if ((*this)[i] == nullptr) {
+      if (PRIVATE(this)->parent == nullptr) {
         (*this)[i] = SoAction::nullAction;
       }
       else {
@@ -163,17 +163,17 @@ SoActionMethodList::setUp(void)
       SoType type = allnodes[i];
       int idx = SoNode::getActionMethodIndex(type);
       SoActionMethod m = (*this)[idx];
-      if (m == NULL) {
+      if (m == nullptr) {
         do {
           type = type.getParent();
           m = (*this)[SoNode::getActionMethodIndex(type)];
-        } while (m == NULL);
+        } while (m == nullptr);
         (*this)[idx] = m;
       }
     }
 
     // inherit unset methods from parent action
-    if (PRIVATE(this)->parent != NULL) {
+    if (PRIVATE(this)->parent != nullptr) {
       PRIVATE(this)->parent->setUp();
       n = this->getLength();
       for (i = 0; i < n; i++) {
diff --git a/coin4/src/lists/SoBaseList.cpp b/coin4/src/lists/SoBaseList.cpp
index 79835ff..a0ffe88 100644
--- a/coin4/src/lists/SoBaseList.cpp
+++ b/coin4/src/lists/SoBaseList.cpp
@@ -121,7 +121,7 @@ void
 SoBaseList::remove(const int index)
 {
   assert(index >= 0 && index < this->getLength());
-  if (this->referencing && GET_BASEPTR(index) != NULL)
+  if (this->referencing && GET_BASEPTR(index) != nullptr)
     GET_BASEPTR(index)->unref();
   SbPList::remove(index);
 }
@@ -158,7 +158,7 @@ SoBaseList::truncate(const int length)
   if (this->referencing) {
     const int n = this->getLength();
     for (int i = length; i < n; i++)
-      if (GET_BASEPTR(i) != NULL) GET_BASEPTR(i)->unref();
+      if (GET_BASEPTR(i) != nullptr) GET_BASEPTR(i)->unref();
   }
   SbPList::truncate(length);
 }
@@ -197,7 +197,7 @@ SoBaseList::operator=(const SoBaseList & l)
 
   Will automatically expand the size of the internal array if \a idx
   is outside the current bounds of the list. The values of any
-  additional pointers are then set to \c NULL.
+  additional pointers are then set to \c nullptr.
 */
 SoBase *
 SoBaseList::operator[](const int idx) const
diff --git a/coin4/src/lists/SoDetailList.cpp b/coin4/src/lists/SoDetailList.cpp
index 22561f0..d2bb62c 100644
--- a/coin4/src/lists/SoDetailList.cpp
+++ b/coin4/src/lists/SoDetailList.cpp
@@ -61,7 +61,7 @@
 
   Will automatically expand the size of the internal array if \a idx
   is outside the current bounds of the list. The values of any
-  additional pointers are then set to \c NULL.
+  additional pointers are then set to \c nullptr.
 */
 
 
diff --git a/coin4/src/lists/SoEngineOutputList.cpp b/coin4/src/lists/SoEngineOutputList.cpp
index 77b4cc4..c2a6fc1 100644
--- a/coin4/src/lists/SoEngineOutputList.cpp
+++ b/coin4/src/lists/SoEngineOutputList.cpp
@@ -61,7 +61,7 @@
 
   Will automatically expand the size of the internal array if \a idx
   is outside the current bounds of the list. The values of any
-  additional pointers are then set to \c NULL.
+  additional pointers are then set to \c nullptr.
 */
 
 
diff --git a/coin4/src/lists/SoPathList.cpp b/coin4/src/lists/SoPathList.cpp
index 63e6da3..9e382c7 100644
--- a/coin4/src/lists/SoPathList.cpp
+++ b/coin4/src/lists/SoPathList.cpp
@@ -35,8 +35,9 @@
 #include <Inventor/SoPath.h>
 #include <Inventor/SoFullPath.h>
 #include <Inventor/C/tidbits.h>
-#include <assert.h>
 
+#include <assert.h>
+#include <cstdlib> // qsort
 
 /*!
   Default constructor.
diff --git a/coin4/src/lists/SoPickedPointList.cpp b/coin4/src/lists/SoPickedPointList.cpp
index 6463716..f0e2092 100644
--- a/coin4/src/lists/SoPickedPointList.cpp
+++ b/coin4/src/lists/SoPickedPointList.cpp
@@ -61,7 +61,7 @@
 
   Will automatically expand the size of the internal array if \a idx
   is outside the current bounds of the list. The values of any
-  additional pointers are then set to \c NULL.
+  additional pointers are then set to \c nullptr.
 */
 
 
diff --git a/coin4/src/manips/SoClipPlaneManip.cpp b/coin4/src/manips/SoClipPlaneManip.cpp
index 1ec44fe..e7875b0 100644
--- a/coin4/src/manips/SoClipPlaneManip.cpp
+++ b/coin4/src/manips/SoClipPlaneManip.cpp
@@ -220,7 +220,7 @@ SoClipPlaneManip::SoClipPlaneManip(void)
  */
 SoClipPlaneManip::~SoClipPlaneManip()
 {
-  this->setDragger(NULL);
+  this->setDragger(nullptr);
 
   delete this->draggerPosFieldSensor;
   delete this->onFieldSensor;
@@ -246,9 +246,9 @@ SoClipPlaneManip::setDragger(SoDragger * newdragger)
     olddragger->removeValueChangedCallback(SoClipPlaneManip::valueChangedCB, this);
     this->children->remove(0);
   }
-  if (newdragger != NULL) {
+  if (newdragger != nullptr) {
     this->children->append(newdragger);
-    SoClipPlaneManip::fieldSensorCB(this, NULL);
+    SoClipPlaneManip::fieldSensorCB(this, nullptr);
     newdragger->addValueChangedCallback(SoClipPlaneManip::valueChangedCB, this);
   }
 }
@@ -270,7 +270,7 @@ SoClipPlaneManip::getDragger(void)
 #endif // debug
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 // *************************************************************************
@@ -339,7 +339,7 @@ SoClipPlaneManip::replaceNode(SoPath * path)
     SbString partname = kit->getPartString(path);
     if (partname != "") {
       SoClipPlane *oldpart = (SoClipPlane*) kit->getPart(partname, true);
-      if (oldpart != NULL) {
+      if (oldpart != nullptr) {
         this->attachSensors(false);
         this->transferFieldValues(oldpart, this);
         this->attachSensors(true);
@@ -571,7 +571,7 @@ SoClipPlaneManip::fieldSensorCB(void * m, SoSensor * s)
   if (s == thisp->onFieldSensor) return; // FIXME: should we care? pederb, 2003-02-28
 
   SoDragger * dragger = thisp->getDragger();
-  if (dragger != NULL) {
+  if (dragger != nullptr) {
     SbMatrix matrix = dragger->getMotionMatrix();
 
     SbVec3f planept;
diff --git a/coin4/src/manips/SoDirectionalLightManip.cpp b/coin4/src/manips/SoDirectionalLightManip.cpp
index 40138e9..b4cd624 100644
--- a/coin4/src/manips/SoDirectionalLightManip.cpp
+++ b/coin4/src/manips/SoDirectionalLightManip.cpp
@@ -117,7 +117,7 @@ SoDirectionalLightManip::SoDirectionalLightManip(void)
 */
 SoDirectionalLightManip::~SoDirectionalLightManip()
 {
-  this->setDragger(NULL);
+  this->setDragger(nullptr);
 
   delete this->colorFieldSensor;
   delete this->directionFieldSensor;
@@ -136,14 +136,14 @@ SoDirectionalLightManip::setDragger(SoDragger * newdragger)
     olddragger->removeValueChangedCallback(SoDirectionalLightManip::valueChangedCB, this);
     this->children->remove(0);
   }
-  if (newdragger != NULL) {
+  if (newdragger != nullptr) {
     if (this->children->getLength() > 0) {
       this->children->set(0, newdragger);
     }
     else {
       this->children->append(newdragger);
     }
-    SoDirectionalLightManip::fieldSensorCB(this, NULL);
+    SoDirectionalLightManip::fieldSensorCB(this, nullptr);
     newdragger->addValueChangedCallback(SoDirectionalLightManip::valueChangedCB, this);
   }
 }
@@ -165,7 +165,7 @@ SoDirectionalLightManip::getDragger(void)
 #endif // debug
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -191,11 +191,11 @@ SoDirectionalLightManip::replaceNode(SoPath * path)
     SbString partname = kit->getPartString(path);
     if (partname != "") {
       SoDirectionalLight * oldpart = (SoDirectionalLight *) kit->getPart(partname, true);
-      if (oldpart != NULL) {
+      if (oldpart != nullptr) {
         this->attachSensors(false);
         this->transferFieldValues(oldpart, this);
         this->attachSensors(true);
-        SoDirectionalLightManip::fieldSensorCB(this, NULL);
+        SoDirectionalLightManip::fieldSensorCB(this, nullptr);
         kit->setPart(partname, this);
         return true;
       }
@@ -223,7 +223,7 @@ SoDirectionalLightManip::replaceNode(SoPath * path)
   this->attachSensors(false);
   this->transferFieldValues((SoDirectionalLight *)fulltail, this);
   this->attachSensors(true);
-  SoDirectionalLightManip::fieldSensorCB(this, NULL);
+  SoDirectionalLightManip::fieldSensorCB(this, nullptr);
 
   ((SoGroup *)parent)->replaceChild(fulltail, this);
   this->unrefNoDelete();
@@ -385,7 +385,7 @@ SoDirectionalLightManip::fieldSensorCB(void * m, SoSensor *)
 {
   SoDirectionalLightManip * thisp = (SoDirectionalLightManip *)m;
   SoDragger * dragger = thisp->getDragger();
-  if (dragger != NULL) {
+  if (dragger != nullptr) {
     SbVec3f direction = thisp->direction.getValue();
     SbMatrix matrix = dragger->getMotionMatrix();
     SbVec3f t, s;
diff --git a/coin4/src/manips/SoPointLightManip.cpp b/coin4/src/manips/SoPointLightManip.cpp
index 691a08f..069d82f 100644
--- a/coin4/src/manips/SoPointLightManip.cpp
+++ b/coin4/src/manips/SoPointLightManip.cpp
@@ -117,7 +117,7 @@ SoPointLightManip::SoPointLightManip(void)
 */
 SoPointLightManip::~SoPointLightManip()
 {
-  this->setDragger(NULL);
+  this->setDragger(nullptr);
 
   delete this->colorFieldSensor;
   delete this->locationFieldSensor;
@@ -136,14 +136,14 @@ SoPointLightManip::setDragger(SoDragger * newdragger)
     olddragger->removeValueChangedCallback(SoPointLightManip::valueChangedCB, this);
     this->children->remove(0);
   }
-  if (newdragger != NULL) {
+  if (newdragger != nullptr) {
     if (this->children->getLength() > 0) {
       this->children->set(0, newdragger);
     }
     else {
       this->children->append(newdragger);
     }
-    SoPointLightManip::fieldSensorCB(this, NULL);
+    SoPointLightManip::fieldSensorCB(this, nullptr);
     newdragger->addValueChangedCallback(SoPointLightManip::valueChangedCB, this);
   }
 }
@@ -166,7 +166,7 @@ SoPointLightManip::getDragger(void)
 #endif // debug
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -192,11 +192,11 @@ SoPointLightManip::replaceNode(SoPath * path)
     SbString partname = kit->getPartString(path);
     if (partname != "") {
       SoPointLight * oldpart = (SoPointLight *) kit->getPart(partname, true);
-      if (oldpart != NULL) {
+      if (oldpart != nullptr) {
         this->attachSensors(false);
         this->transferFieldValues(oldpart, this);
         this->attachSensors(true);
-        SoPointLightManip::fieldSensorCB(this, NULL);
+        SoPointLightManip::fieldSensorCB(this, nullptr);
         kit->setPart(partname, this);
         return true;
       }
@@ -224,7 +224,7 @@ SoPointLightManip::replaceNode(SoPath * path)
   this->attachSensors(false);
   this->transferFieldValues((SoPointLight *)fulltail, this);
   this->attachSensors(true);
-  SoPointLightManip::fieldSensorCB(this, NULL);
+  SoPointLightManip::fieldSensorCB(this, nullptr);
 
   ((SoGroup *)parent)->replaceChild(fulltail, this);
   this->unrefNoDelete();
@@ -379,7 +379,7 @@ SoPointLightManip::fieldSensorCB(void * m, SoSensor *)
 {
   SoPointLightManip * thisp = (SoPointLightManip *)m;
   SoDragger * dragger = thisp->getDragger();
-  if (dragger != NULL) {
+  if (dragger != nullptr) {
     SbVec3f location = thisp->location.getValue();
     SbMatrix matrix = dragger->getMotionMatrix();
     matrix[3][0] = location[0];
diff --git a/coin4/src/manips/SoSpotLightManip.cpp b/coin4/src/manips/SoSpotLightManip.cpp
index 9f31294..903f49b 100644
--- a/coin4/src/manips/SoSpotLightManip.cpp
+++ b/coin4/src/manips/SoSpotLightManip.cpp
@@ -134,7 +134,7 @@ SoSpotLightManip::SoSpotLightManip(void)
  */
 SoSpotLightManip::~SoSpotLightManip()
 {
-  this->setDragger(NULL);
+  this->setDragger(nullptr);
 
   delete this->colorFieldSensor;
   delete this->locationFieldSensor;
@@ -155,14 +155,14 @@ SoSpotLightManip::setDragger(SoDragger * newdragger)
     olddragger->removeValueChangedCallback(SoSpotLightManip::valueChangedCB, this);
     this->children->remove(0);
   }
-  if (newdragger != NULL) {
+  if (newdragger != nullptr) {
     if (this->children->getLength() > 0) {
       this->children->set(0, newdragger);
     }
     else {
       this->children->append(newdragger);
     }
-    SoSpotLightManip::fieldSensorCB(this, NULL);
+    SoSpotLightManip::fieldSensorCB(this, nullptr);
     newdragger->addValueChangedCallback(SoSpotLightManip::valueChangedCB, this);
   }
 }
@@ -184,7 +184,7 @@ SoSpotLightManip::getDragger(void)
 #endif // debug
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -210,11 +210,11 @@ SoSpotLightManip::replaceNode(SoPath * path)
     SbString partname = kit->getPartString(path);
     if (partname != "") {
       SoSpotLight *oldpart = (SoSpotLight*) kit->getPart(partname, true);
-      if (oldpart != NULL) {
+      if (oldpart != nullptr) {
         this->attachSensors(false);
         this->transferFieldValues(oldpart, this);
         this->attachSensors(true);
-        SoSpotLightManip::fieldSensorCB(this, NULL);
+        SoSpotLightManip::fieldSensorCB(this, nullptr);
         kit->setPart(partname, this);
         return true;
       }
@@ -242,7 +242,7 @@ SoSpotLightManip::replaceNode(SoPath * path)
   this->attachSensors(false);
   this->transferFieldValues((SoSpotLight*)fulltail, this);
   this->attachSensors(true);
-  SoSpotLightManip::fieldSensorCB(this, NULL);
+  SoSpotLightManip::fieldSensorCB(this, nullptr);
 
   ((SoGroup*)parent)->replaceChild(fulltail, this);
   this->unrefNoDelete();
@@ -421,7 +421,7 @@ SoSpotLightManip::fieldSensorCB(void * m, SoSensor *)
 {
   SoSpotLightManip *thisp = (SoSpotLightManip*)m;
   SoDragger *dragger = thisp->getDragger();
-  if (dragger != NULL) {
+  if (dragger != nullptr) {
     float cutoffangle = thisp->cutOffAngle.getValue();
     SbVec3f direction = thisp->direction.getValue();
     SbMatrix matrix = dragger->getMotionMatrix();
@@ -462,7 +462,7 @@ SoSpotLightManip::copyContents(const SoFieldContainer * fromfc, bool copyconnect
 {
   assert(fromfc->isOfType(SoSpotLightManip::getClassTypeId()));
   SoDragger * dragger = ((SoSpotLightManip*)fromfc)->getDragger();
-  this->setDragger(dragger ? (SoDragger*)dragger->copy() : NULL);
+  this->setDragger(dragger ? (SoDragger*)dragger->copy() : nullptr);
   inherited::copyContents(fromfc, copyconnections);
 }
 
diff --git a/coin4/src/manips/SoTransformManip.cpp b/coin4/src/manips/SoTransformManip.cpp
index 341a10d..95021ac 100644
--- a/coin4/src/manips/SoTransformManip.cpp
+++ b/coin4/src/manips/SoTransformManip.cpp
@@ -140,7 +140,7 @@ SoTransformManip::SoTransformManip(void)
 */
 SoTransformManip::~SoTransformManip()
 {
-  this->setDragger(NULL);
+  this->setDragger(nullptr);
 
   delete this->rotateFieldSensor;
   delete this->translFieldSensor;
@@ -166,14 +166,14 @@ SoTransformManip::setDragger(SoDragger * newdragger)
     olddragger->removeValueChangedCallback(SoTransformManip::valueChangedCB, this);
     this->children->remove(0);
   }
-  if (newdragger != NULL) {
+  if (newdragger != nullptr) {
     if (this->children->getLength() > 0) {
       this->children->set(0, newdragger);
     }
     else {
       this->children->append(newdragger);
     }
-    SoTransformManip::fieldSensorCB(this, NULL);
+    SoTransformManip::fieldSensorCB(this, nullptr);
     newdragger->addValueChangedCallback(SoTransformManip::valueChangedCB, this);
   }
 }
@@ -195,7 +195,7 @@ SoTransformManip::getDragger(void)
 #endif // COIN_DEBUG
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 // *************************************************************************
@@ -234,11 +234,11 @@ SoTransformManip::replaceNode(SoPath * path)
     SbString partname = kit->getPartString(path);
     if (partname != "") {  // FIXME: isn't this an assert condition? 20010909 mortene.
       SoTransform *oldpart = (SoTransform*) kit->getPart(partname, true);
-      if (oldpart != NULL) {  // FIXME: isn't this an assert condition? 20010909 mortene.
+      if (oldpart != nullptr) {  // FIXME: isn't this an assert condition? 20010909 mortene.
         this->attachSensors(false);
         this->transferFieldValues(oldpart, this);
         this->attachSensors(true);
-        SoTransformManip::fieldSensorCB(this, NULL);
+        SoTransformManip::fieldSensorCB(this, nullptr);
         kit->setPart(partname, this);
         return true;
       }
@@ -278,7 +278,7 @@ SoTransformManip::replaceNode(SoPath * path)
   this->attachSensors(false);
   this->transferFieldValues((SoTransform*)fulltail, this);
   this->attachSensors(true);
-  SoTransformManip::fieldSensorCB(this, NULL);
+  SoTransformManip::fieldSensorCB(this, nullptr);
 
   // FIXME: this looks too simple -- what if there's more than one
   // parent SoGroup for the SoTransform we're replacing.  Looks to me
@@ -437,7 +437,7 @@ SoTransformManip::getChildren(void) const
 void
 SoTransformManip::valueChangedCB(void * m, SoDragger * dragger)
 {
-  if (dragger == NULL) return;
+  if (dragger == nullptr) return;
 
   SoTransformManip * thisp = (SoTransformManip*)m;
 
@@ -482,7 +482,7 @@ SoTransformManip::fieldSensorCB(void * m, SoSensor *)
 {
   SoTransformManip *thisp = (SoTransformManip*)m;
   SoDragger *dragger = thisp->getDragger();
-  if (dragger != NULL) {
+  if (dragger != nullptr) {
     bool wasenabled = dragger->enableValueChangedCallbacks(false);
     SbMatrix matrix;
     SbVec3f center = thisp->center.getValue();
@@ -511,7 +511,7 @@ SoTransformManip::copyContents(const SoFieldContainer * fromfc, bool copyconnect
 {
   assert(fromfc->isOfType(SoTransformManip::getClassTypeId()));
   SoDragger *dragger = ((SoTransformManip*)fromfc)->getDragger();
-  this->setDragger(dragger ? (SoDragger*) dragger->copy() : NULL);
+  this->setDragger(dragger ? (SoDragger*) dragger->copy() : nullptr);
   inherited::copyContents(fromfc, copyconnections);
 }
 
@@ -524,7 +524,7 @@ SoTransformManip::transferFieldValues(const SoTransform * from, SoTransform * to
 {
   SoTransformManip * tomanip = 
     to->isOfType(SoTransformManip::getClassTypeId()) ?
-    (SoTransformManip*) to : NULL;
+    (SoTransformManip*) to : nullptr;
   
   if (tomanip) tomanip->attachSensors(false);    
   
@@ -535,7 +535,7 @@ SoTransformManip::transferFieldValues(const SoTransform * from, SoTransform * to
   to->center = from->center.getValue();
 
   if (tomanip) {
-    SoTransformManip::fieldSensorCB(tomanip, NULL);
+    SoTransformManip::fieldSensorCB(tomanip, nullptr);
     tomanip->attachSensors(true);
   }
 }
diff --git a/coin4/src/manips/commoncode.cpp b/coin4/src/manips/commoncode.cpp
index 03f4e69..b0169da 100644
--- a/coin4/src/manips/commoncode.cpp
+++ b/coin4/src/manips/commoncode.cpp
@@ -53,7 +53,7 @@
   \fn bool SoTransformManip::replaceManip(SoPath * path, SoTransform * newone) const
 
   Replaces this manipulator from the position specified by \a path
-  with \a newnode. If \a newnode is \c NULL, an SoTransform will be
+  with \a newnode. If \a newnode is \c nullptr, an SoTransform will be
   created for you.
 */
 
@@ -61,7 +61,7 @@
   \fn bool SoDirectionalLightManip::replaceManip(SoPath * path, SoDirectionalLight * newone) const
 
   Replaces this manipulator from the position specified by \a path
-  with \a newnode. If \a newnode is \c NULL, an SoDirectionalLight
+  with \a newnode. If \a newnode is \c nullptr, an SoDirectionalLight
   will be created for you.
 */
 
@@ -69,7 +69,7 @@
   \fn bool SoSpotLightManip::replaceManip(SoPath * path, SoSpotLight * newone) const
 
   Replaces this manipulator from the position specified by \a path
-  with \a newnode. If \a newnode is \c NULL, an SoSpotLight
+  with \a newnode. If \a newnode is \c nullptr, an SoSpotLight
   will be created for you.
 */
 
@@ -77,7 +77,7 @@
   \fn bool SoPointLightManip::replaceManip(SoPath * path, SoPointLight * newone) const
 
   Replaces this manipulator from the position specified by \a path
-  with \a newnode. If \a newnode is \c NULL, an SoPointLight
+  with \a newnode. If \a newnode is \c nullptr, an SoPointLight
   will be created for you.
 */
 
@@ -85,7 +85,7 @@
   \fn bool SoClipPlaneManip::replaceManip(SoPath * path, SoClipPlane * newone) const
 
   Replaces this manipulator from the position specified by \a path
-  with \a newnode. If \a newnode is \c NULL, an SoClipPlane
+  with \a newnode. If \a newnode is \c nullptr, an SoClipPlane
   will be created for you.
 */
 
@@ -109,7 +109,7 @@ _class_::replaceManip(SoPath * path, _parentclass_ * newone) const \
   } \
  \
   bool constructed = false; \
-  if (newone == NULL) { \
+  if (newone == nullptr) { \
     newone = new _parentclass_; \
     constructed = true; \
   } \
diff --git a/coin4/src/misc/CoinResources.cpp b/coin4/src/misc/CoinResources.cpp
index 3888306..3529721 100644
--- a/coin4/src/misc/CoinResources.cpp
+++ b/coin4/src/misc/CoinResources.cpp
@@ -93,7 +93,7 @@ namespace CoinResources { namespace {
     class ResourceHandle {
     public:
       ResourceHandle(void)
-        : resloc(NULL), canbefile(false), filenotfound(false)
+        : resloc(nullptr), canbefile(false), filenotfound(false)
       { }
 
       char * resloc;
@@ -121,7 +121,7 @@ namespace CoinResources { namespace {
         it++;
       }
       delete resourcemap;
-      resourcemap = NULL;
+      resourcemap = nullptr;
     }
 
     ResourceHandle *
@@ -131,7 +131,7 @@ namespace CoinResources { namespace {
       SbName reslochash(resloc);
       ResourceMap::iterator it =
         resourcemap->find(reslochash.getString());
-      if (it == resourcemap->end()) return NULL;
+      if (it == resourcemap->end()) return nullptr;
       return it->second;
     }
 
@@ -209,7 +209,7 @@ CoinResources::get(const char * resloc)
       CFRelease(url);
 #else // !COIN_MACOSX_FRAMEWORK
       static const char * coindirenv = coin_getenv("COINDIR");
-      if (coindirenv == NULL) {
+      if (coindirenv == nullptr) {
         handle->filenotfound = true;
         break;
       }
@@ -239,7 +239,7 @@ CoinResources::get(const char * resloc)
 
       size_t num = fread(buffer.data(), size, 1, fp);
       fclose(fp);
-      fp = NULL;
+      fp = nullptr;
 
       if (num == 1) {
         // FIXME: at this point we can check if this is the first
diff --git a/coin4/src/misc/CoinStaticObjectInDLL.cpp b/coin4/src/misc/CoinStaticObjectInDLL.cpp
index 63ae283..6843af7 100644
--- a/coin4/src/misc/CoinStaticObjectInDLL.cpp
+++ b/coin4/src/misc/CoinStaticObjectInDLL.cpp
@@ -53,8 +53,8 @@
 
 // *************************************************************************
 
-void * CoinStaticObjectInDLL::mutexhandle = NULL;
-CoinStaticObjectInDLL * CoinStaticObjectInDLL::singleton = NULL;
+void * CoinStaticObjectInDLL::mutexhandle = nullptr;
+CoinStaticObjectInDLL * CoinStaticObjectInDLL::singleton = nullptr;
 
 // *************************************************************************
 
@@ -134,11 +134,11 @@ CoinStaticObjectInDLL::CoinStaticObjectInDLL(void)
            this, SbTime::getTimeOfDay().getValue());
   }
 
-  assert(CoinStaticObjectInDLL::singleton == NULL);
+  assert(CoinStaticObjectInDLL::singleton == nullptr);
   CoinStaticObjectInDLL::singleton = this;
 
   if (!CoinStaticObjectInDLL::activateMutex()) {
-    MessageBox(NULL,
+    MessageBox(nullptr,
                "Detected two instances of the Coin library in the same\n"
                "process image!!\n\n"
 
@@ -191,7 +191,7 @@ CoinStaticObjectInDLL::~CoinStaticObjectInDLL()
   }
 
   assert(CoinStaticObjectInDLL::singleton);
-  CoinStaticObjectInDLL::singleton = NULL;
+  CoinStaticObjectInDLL::singleton = nullptr;
 }
 
 // Called from SoDB::init().
@@ -236,12 +236,12 @@ CoinStaticObjectInDLL::activateMutex(void)
            CoinStaticObjectInDLL::mutexName().getString());
   }
 
-  assert(CoinStaticObjectInDLL::mutexhandle == NULL);
+  assert(CoinStaticObjectInDLL::mutexhandle == nullptr);
 
   SetLastError(0); // so we don't react to an old error for the check below
 
   CoinStaticObjectInDLL::mutexhandle = (HANDLE)
-    CreateMutex(NULL, true, CoinStaticObjectInDLL::mutexName().getString());
+    CreateMutex(nullptr, true, CoinStaticObjectInDLL::mutexName().getString());
   // (The mutex is automatically destructed by the operating system
   // when the process exits.)
 
@@ -260,8 +260,8 @@ CoinStaticObjectInDLL::deactivateMutex(void)
 
   // it's only necessary to close the mutex handle the first time 
   // CoinStaticObjectInDLL::init() is called. In subsequent calls the handle
-  // will be NULL.
-  if (CoinStaticObjectInDLL::mutexhandle != NULL) {
+  // will be nullptr.
+  if (CoinStaticObjectInDLL::mutexhandle != nullptr) {
     const BOOL ok = CloseHandle((HANDLE)CoinStaticObjectInDLL::mutexhandle);
     if (!ok) { // just in case
       if (debug()) {
@@ -272,12 +272,12 @@ CoinStaticObjectInDLL::deactivateMutex(void)
                CoinStaticObjectInDLL::mutexhandle);
       }
 
-      MessageBox(NULL,
+      MessageBox(nullptr,
                  "CloseHandle() in CoinStaticObjectInDLL::deactivateMutex()\n"
                  "failed! Please report to <coin-support@coin3d.org>.\n",
                  "Warning!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
     }
-    CoinStaticObjectInDLL::mutexhandle = (HANDLE)NULL;
+    CoinStaticObjectInDLL::mutexhandle = (HANDLE)nullptr;
   }
 }
 
diff --git a/coin4/src/misc/SbHash.h b/coin4/src/misc/SbHash.h
index d4946e5..a7ad934 100644
--- a/coin4/src/misc/SbHash.h
+++ b/coin4/src/misc/SbHash.h
@@ -40,7 +40,6 @@
 // *************************************************************************
 
 #include <assert.h>
-#include <stddef.h> // NULL
 #include <string.h> // memset()
 
 #include <Inventor/lists/SbList.h>
@@ -172,7 +171,7 @@ class SbHash {
       setNextUsedBucket();
     }
     iterator() {
-      this->elem = NULL;
+      this->elem = nullptr;
     }
 
     inline void setNextUsedBucket() {
@@ -182,7 +181,7 @@ class SbHash {
           return;
         }
       }
-      this->elem = NULL;
+      this->elem = nullptr;
     }
 
     inline void setNext(){
@@ -236,7 +235,7 @@ class SbHash {
       setNextUsedBucket();
     }
     const_iterator() {
-      this->elem = NULL;
+      this->elem = nullptr;
     }
 
     inline void setNextUsedBucket() {
@@ -246,7 +245,7 @@ class SbHash {
           return;
         }
       }
-      this->elem = NULL;
+      this->elem = nullptr;
     }
 
     inline void setNext(){
@@ -354,12 +353,12 @@ class SbHash {
   size_t erase(const Key & key)
   {
     unsigned int i = this->getIndex(key);
-    SbHashEntry * entry = this->buckets[i], * next, * prev = NULL;
+    SbHashEntry * entry = this->buckets[i], * next, * prev = nullptr;
     while (entry) {
       next = entry->next;
       if (entry->key == key) {
         this->elements--;
-        if (prev == NULL) {
+        if (prev == nullptr) {
           this->buckets[i] = next;
         }
         else {
diff --git a/coin4/src/misc/SoAudioDevice.cpp b/coin4/src/misc/SoAudioDevice.cpp
index 290524f..439e959 100644
--- a/coin4/src/misc/SoAudioDevice.cpp
+++ b/coin4/src/misc/SoAudioDevice.cpp
@@ -49,6 +49,8 @@
 
 // *************************************************************************
 
+#include <cstdlib> // atoi
+
 #include <Inventor/misc/SoAudioDevice.h>
 
 #ifdef HAVE_CONFIG_H
@@ -87,7 +89,7 @@ private:
 #define PRIVATE(p) ((p)->pimpl)
 #define PUBLIC(p) ((p)->master)
 
-SoAudioDevice *SoAudioDeviceP::singleton = NULL;
+SoAudioDevice *SoAudioDeviceP::singleton = nullptr;
 
 // *************************************************************************
 
@@ -98,7 +100,7 @@ SoAudioDevice *SoAudioDeviceP::singleton = NULL;
 SoAudioDevice *
 SoAudioDevice::instance()
 {
-  if (SoAudioDeviceP::singleton == NULL) {
+  if (SoAudioDeviceP::singleton == nullptr) {
     SoAudioDeviceP::singleton = new SoAudioDevice();
 
     // Note: there is a known problem with the OpenAL driver on
@@ -118,7 +120,7 @@ void
 SoAudioDeviceP::clean()
 {
   if (SoAudioDeviceP::singleton) { delete SoAudioDeviceP::singleton; }
-  SoAudioDeviceP::singleton = NULL;
+  SoAudioDeviceP::singleton = nullptr;
 }
 
 // *************************************************************************
@@ -126,8 +128,8 @@ SoAudioDeviceP::clean()
 SoAudioDeviceP::SoAudioDeviceP(SoAudioDevice * master)
   : master(master)
 {
-  this->context = NULL;
-  this->device = NULL;
+  this->context = nullptr;
+  this->device = nullptr;
   this->enabled = false;
   this->initOK = false;
   this->lastGain = 1.0f;
@@ -147,7 +149,7 @@ SoAudioDeviceP::~SoAudioDeviceP()
 
 SoAudioDevice::SoAudioDevice()
 {
-  PRIVATE(this) = NULL;
+  PRIVATE(this) = nullptr;
 
   const char * env = coin_getenv("COIN_SOUND_DRIVER_NAME");
   (void)this->init("OpenAL", env ? env : "DirectSound3D");
@@ -271,7 +273,7 @@ SoAudioDevice::init(const SbString & devicetype, const SbString & devicename)
   PRIVATE(this)->device = 
     openal_wrapper()->alcOpenDevice((unsigned char*)devicename.getString());
 
-  if (PRIVATE(this)->device == NULL) {
+  if (PRIVATE(this)->device == nullptr) {
     SoDebugError::postWarning("SoAudioDevice::init",
                               "Failed to initialize OpenAL. "
                               "Sound will not be available.");
@@ -289,7 +291,7 @@ SoAudioDevice::init(const SbString & devicetype, const SbString & devicename)
   // 20021029 mortene.
 
   PRIVATE(this)->context = 
-    openal_wrapper()->alcCreateContext(PRIVATE(this)->device, NULL);
+    openal_wrapper()->alcCreateContext(PRIVATE(this)->device, nullptr);
   openal_wrapper()->alcMakeContextCurrent(PRIVATE(this)->context);
 
   // Clear Error Code
diff --git a/coin4/src/misc/SoBase.cpp b/coin4/src/misc/SoBase.cpp
index 8c33c70..611fd16 100644
--- a/coin4/src/misc/SoBase.cpp
+++ b/coin4/src/misc/SoBase.cpp
@@ -204,7 +204,7 @@ SoBase::SoBase(void)
     CC_MUTEX_LOCK(SoBase::PImpl::allbaseobj_mutex);
     //void * dummy;
     assert(SoBase::PImpl::allbaseobj->find(this)==SoBase::PImpl::allbaseobj->const_end());
-    (*SoBase::PImpl::allbaseobj)[this]=NULL;
+    (*SoBase::PImpl::allbaseobj)[this]=nullptr;
     CC_MUTEX_UNLOCK(SoBase::PImpl::allbaseobj_mutex);
   }
 #endif // COIN_DEBUG
@@ -392,12 +392,12 @@ SoBase::cleanClass(void)
     delete iter->obj;
   }
 
-  delete SoBase::PImpl::allbaseobj; SoBase::PImpl::allbaseobj = NULL;
+  delete SoBase::PImpl::allbaseobj; SoBase::PImpl::allbaseobj = nullptr;
 
-  delete SoBase::PImpl::name2obj; SoBase::PImpl::name2obj = NULL;
-  delete SoBase::PImpl::obj2name; SoBase::PImpl::obj2name = NULL;
+  delete SoBase::PImpl::name2obj; SoBase::PImpl::name2obj = nullptr;
+  delete SoBase::PImpl::obj2name; SoBase::PImpl::obj2name = nullptr;
 
-  delete SoBase::PImpl::refwriteprefix; SoBase::PImpl::refwriteprefix = NULL;
+  delete SoBase::PImpl::refwriteprefix; SoBase::PImpl::refwriteprefix = nullptr;
 
   SoBase::classTypeId STATIC_SOTYPE_INIT;
 
@@ -636,7 +636,7 @@ SoBase::getName(void) const
   // you have invoked SoDB::cleanup().
   assert(SoBase::PImpl::obj2name);
 
-  //const char * value = NULL;
+  //const char * value = nullptr;
   CC_MUTEX_LOCK(SoBase::PImpl::obj2name_mutex);
   SbHash<const SoBase *, const char *>::const_iterator tmp = SoBase::PImpl::obj2name->find(this);
   bool found = (tmp != SoBase::PImpl::obj2name->const_end());
@@ -672,7 +672,7 @@ SoBase::setName(const SbName & newname)
   // in a debugger and check the backtrace.)  -mortene.
 #if 0 // debug
   static bool checked = false;
-  static const char * tracename = NULL;
+  static const char * tracename = nullptr;
   if (!checked) {
     tracename = coin_getenv("COIN_DEBUG_ASSERT_SOBASE_SETNAME");
     checked = true;
@@ -851,12 +851,12 @@ SoBase::getAuditors(void) const
 {
   CC_MUTEX_LOCK(SoBase::PImpl::auditor_mutex);
 
-  if (SoBase::PImpl::auditordict == NULL) {
+  if (SoBase::PImpl::auditordict == nullptr) {
     SoBase::PImpl::auditordict = new SbHash<const SoBase *, SoAuditorList *>();
     coin_atexit((coin_atexit_f*)SoBase::PImpl::cleanup_auditordict, CC_ATEXIT_NORMAL);
   }
 
-  SoAuditorList * l = NULL;
+  SoAuditorList * l = nullptr;
   SbHash<const SoBase *, SoAuditorList *>::const_iterator iter
     = 
     SoBase::PImpl::auditordict->find(this);
@@ -922,7 +922,7 @@ SoBase::addWriteReference(SoOutput * out, bool isfromfield)
 bool
 SoBase::shouldWrite(void)
 {
-  return SoWriterefCounter::instance(NULL)->shouldWrite(this);
+  return SoWriterefCounter::instance(nullptr)->shouldWrite(this);
 }
 
 /*!
@@ -949,7 +949,7 @@ SoBase::decrementCurrentWriteCounter(void)
   with the same type, returns the \e last one which was registered.
 
   If no object of a valid type or subtype has been registered with the
-  given name, returns \c NULL.
+  given name, returns \c nullptr.
 */
 SoBase *
 SoBase::getNamedBase(const SbName & name, SoType type)
@@ -968,7 +968,7 @@ SoBase::getNamedBase(const SbName & name, SoType type)
     }
   }
   CC_MUTEX_UNLOCK(SoBase::PImpl::name2obj_mutex);
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -1011,7 +1011,7 @@ SoBase::getNamedBases(const SbName & name, SoBaseList & baselist, SoType type)
   expectedtype, or if there are attempts at referencing (through the
   \c USE keyword) unknown instances.
 
-  If we return \c true with \a base equal to \c NULL, three things
+  If we return \c true with \a base equal to \c nullptr, three things
   might have happened:
 
   1. End-of-file. Use SoInput::eof() after calling this method to
@@ -1022,11 +1022,11 @@ SoBase::getNamedBases(const SbName & name, SoBaseList & baselist, SoType type)
   nodes of a group has been read. Check if the next character in the
   stream is a '}' to detect the latter case.
 
-  3. A child was given as the \c NULL keyword. This can happen when
-  reading the contents of SoSFNode fields (note that NULL is not
+  3. A child was given as the \c nullptr keyword. This can happen when
+  reading the contents of SoSFNode fields (note that nullptr is not
   allowed for SoMFNode)
 
-  If \c true is returned and \a base is not \c NULL upon return, the
+  If \c true is returned and \a base is not \c nullptr upon return, the
   instance was allocated and initialized according to what was read
   from the \a in stream.
 */
@@ -1056,7 +1056,7 @@ SoBase::read(SoInput * in, SoBase *& base, SoType expectedtype)
   // 20060202 mortene.
 
   assert(expectedtype != SoType::badType());
-  base = NULL;
+  base = nullptr;
 
   SbName name;
   bool result = in->read(name, true);
@@ -1081,7 +1081,7 @@ SoBase::read(SoInput * in, SoBase *& base, SoType expectedtype)
   }
 
   // The SoInput stream does not start with a valid base name. Return
-  // true with base==NULL.
+  // true with base==nullptr.
   if (!result) return true;
 
   // If no valid name / identifier string is found, the return value
@@ -1173,7 +1173,7 @@ SoBase::getTraceRefs(void)
 bool
 SoBase::hasMultipleWriteRefs(void) const
 {
-  return SoWriterefCounter::instance(NULL)->getWriteref(this) > 1;
+  return SoWriterefCounter::instance(nullptr)->getWriteref(this) > 1;
 }
 
 // FIXME: temporary bug-workaround needed to test if we are exporting
@@ -1413,7 +1413,7 @@ SoBase::readRoute(SoInput * in)
 
     // parse from-string
     char * str1 = (char*) fromstring.getString();
-    char * str2 = str1 ? (char*) strchr(str1, '.') : NULL;
+    char * str2 = str1 ? (char*) strchr(str1, '.') : nullptr;
     if (str1 && str2) {
       *str2++ = 0;
 
@@ -1421,7 +1421,7 @@ SoBase::readRoute(SoInput * in)
       fromnodename = str1;
       fromfieldname = str2;
       str1 = (char*) tostring.getString();
-      str2 = str1 ? strchr(str1, '.') : NULL;
+      str2 = str1 ? strchr(str1, '.') : nullptr;
       if (str1 && str2) {
         *str2++ = 0;
         tonodename = str1;
diff --git a/coin4/src/misc/SoBaseP.cpp b/coin4/src/misc/SoBaseP.cpp
index b5ed51a..7f072c7 100644
--- a/coin4/src/misc/SoBaseP.cpp
+++ b/coin4/src/misc/SoBaseP.cpp
@@ -57,13 +57,13 @@ const char SoBase::PImpl::ROUTE_KEYWORD[] = "ROUTE";
 const char SoBase::PImpl::PROTO_KEYWORD[] = "PROTO";
 const char SoBase::PImpl::EXTERNPROTO_KEYWORD[] = "EXTERNPROTO";
 
-void * SoBase::PImpl::mutex = NULL;
-void * SoBase::PImpl::name2obj_mutex = NULL;
-void * SoBase::PImpl::obj2name_mutex = NULL;
-void * SoBase::PImpl::auditor_mutex = NULL;
-void * SoBase::PImpl::global_mutex = NULL;
+void * SoBase::PImpl::mutex = nullptr;
+void * SoBase::PImpl::name2obj_mutex = nullptr;
+void * SoBase::PImpl::obj2name_mutex = nullptr;
+void * SoBase::PImpl::auditor_mutex = nullptr;
+void * SoBase::PImpl::global_mutex = nullptr;
 
-SbHash<const SoBase *, SoAuditorList *> * SoBase::PImpl::auditordict = NULL;
+SbHash<const SoBase *, SoAuditorList *> * SoBase::PImpl::auditordict = nullptr;
 
 // Only a small number of SoBase derived objects will under usual
 // conditions have designated names, so we use a couple of static
@@ -71,17 +71,17 @@ SbHash<const SoBase *, SoAuditorList *> * SoBase::PImpl::auditordict = NULL;
 // pointer for each and every object, we'll cut down on a decent
 // amount of memory use this way (SoBase should be kept as slim as
 // possible, as any dead weight is brought along in a lot of objects).
-SbHash<const char *, SbPList *> * SoBase::PImpl::name2obj = NULL;
-SbHash<const SoBase *, const char *> * SoBase::PImpl::obj2name = NULL;
+SbHash<const char *, SbPList *> * SoBase::PImpl::name2obj = nullptr;
+SbHash<const SoBase *, const char *> * SoBase::PImpl::obj2name = nullptr;
 
 // This is used for debugging purposes: it stores a pointer to all
 // SoBase-derived objects that have been allocated and not
 // deallocated.
 bool SoBase::PImpl::trackbaseobjects = false;
-void * SoBase::PImpl::allbaseobj_mutex = NULL;
-SoBaseSet * SoBase::PImpl::allbaseobj = NULL; // maps from SoBase * to NULL
+void * SoBase::PImpl::allbaseobj_mutex = nullptr;
+SoBaseSet * SoBase::PImpl::allbaseobj = nullptr; // maps from SoBase * to nullptr
 
-SbString * SoBase::PImpl::refwriteprefix = NULL;
+SbString * SoBase::PImpl::refwriteprefix = nullptr;
 
 bool SoBase::PImpl::tracerefs = false;
 uint32_t SoBase::PImpl::writecounter = 0;
@@ -93,9 +93,9 @@ SoNode *
 SoBase::PImpl::readNode(SoInput * in)
 {
   SbName name;
-  if (!in->read(name, true)) return NULL;
-  SoBase * node = NULL;
-  if (!SoBase::PImpl::readBase(in, name, node)) return NULL;
+  if (!in->read(name, true)) return nullptr;
+  SoBase * node = nullptr;
+  if (!SoBase::PImpl::readBase(in, name, node)) return nullptr;
   assert(node->isOfType(SoNode::getClassTypeId()));
   return (SoNode *) node;
 }
@@ -141,7 +141,7 @@ SoBase::PImpl::cleanup_auditordict(void)
     }
 
     delete SoBase::PImpl::auditordict;
-    SoBase::PImpl::auditordict = NULL;
+    SoBase::PImpl::auditordict = nullptr;
   }
 }
 
@@ -234,7 +234,7 @@ SoBase::PImpl::readReference(SoInput * in, SoBase *& base)
     refname = startstr;
   }
 
-  if ((base = in->findReference(refname)) == NULL) {
+  if ((base = in->findReference(refname)) == nullptr) {
     SoReadError::post(in, "Unknown reference \"%s\"", refname.getString());
     return false;
   }
@@ -265,7 +265,7 @@ SoBase::PImpl::readBase(SoInput * in, SbName & classname, SoBase *& base)
 #endif // debug
 
   bool ret = true;
-  base = NULL;
+  base = nullptr;
 
   SbName refname;
 
@@ -476,7 +476,7 @@ failed:
 
     base->ref();
     base->unref();
-    base = NULL;
+    base = nullptr;
   }
 
   return false;
@@ -513,7 +513,7 @@ SoBase::PImpl::createInstance(SoInput * in, const SbName & classname)
   if (type == SoType::badType())
     type = SoType::fromName(classname);
 
-  SoBase * instance = NULL;
+  SoBase * instance = nullptr;
 
   if (type == SoType::badType() ||
       type == SoUnknownNode::getClassTypeId()) {
@@ -600,7 +600,7 @@ BOOST_AUTO_TEST_CASE(realTime_globalfield_import)
 
   SoInput * in = new SoInput;
   in->setBuffer(scene, strlen(scene));
-  SoNode * g = NULL;
+  SoNode * g = nullptr;
   const bool readok = SoDB::read(in, g);
   assert(readok); // that import is ok is tested by a case in SoDB.cpp
   delete in;
diff --git a/coin4/src/misc/SoBaseP.h b/coin4/src/misc/SoBaseP.h
index 1290893..d77831f 100644
--- a/coin4/src/misc/SoBaseP.h
+++ b/coin4/src/misc/SoBaseP.h
@@ -65,7 +65,7 @@ public:
 
   static bool trackbaseobjects;
   static void * allbaseobj_mutex;
-  static SoBaseSet * allbaseobj; // maps from SoBase * to NULL
+  static SoBaseSet * allbaseobj; // maps from SoBase * to nullptr
 
   static SbString * refwriteprefix;
   static bool tracerefs;
diff --git a/coin4/src/misc/SoChildList.cpp b/coin4/src/misc/SoChildList.cpp
index 77afc51..0237472 100644
--- a/coin4/src/misc/SoChildList.cpp
+++ b/coin4/src/misc/SoChildList.cpp
@@ -303,7 +303,7 @@ void
 SoChildList::traverse(SoAction * const action, const int first, const int last)
 {
   int i;
-  SoNode * node = NULL;
+  SoNode * node = nullptr;
 
   assert((first >= 0) && (first < this->getLength()) && "index out of bounds");
   assert((last >= 0) && (last < this->getLength()) && "index out of bounds");
diff --git a/coin4/src/misc/SoConfigSettings.cpp b/coin4/src/misc/SoConfigSettings.cpp
index 4753c64..930816c 100644
--- a/coin4/src/misc/SoConfigSettings.cpp
+++ b/coin4/src/misc/SoConfigSettings.cpp
@@ -8,7 +8,7 @@
 
 
 namespace {
-  SoConfigSettings * singleton = NULL;
+  SoConfigSettings * singleton = nullptr;
   const char * VALID_OPTIONS[] = {
     "COIN_VBO",
     "COIN_WARNING_LEVEL"
@@ -49,7 +49,7 @@ void
 SoConfigSettings::destroy()
 {
   delete singleton;
-  singleton = NULL;
+  singleton = nullptr;
 }
 
 SoConfigSettings::SoConfigSettings()
@@ -79,7 +79,7 @@ SoConfigSettings::reinitialize()
   //disabling this for now. Write a configure test for this in the
   //future. BFG 20091013
 #if COIN_DEBUG && 0
-  for (char ** test = environ; *test != NULL; ++test) {
+  for (char ** test = environ; *test != nullptr; ++test) {
     char * first = strchr(*test,'=');
     if (first) {
       size_t n;
diff --git a/coin4/src/misc/SoContextHandler.cpp b/coin4/src/misc/SoContextHandler.cpp
index 329a450..6abb16f 100644
--- a/coin4/src/misc/SoContextHandler.cpp
+++ b/coin4/src/misc/SoContextHandler.cpp
@@ -65,7 +65,7 @@
 
 class socontexthandler_cbitem {
 public:
-  socontexthandler_cbitem(void) : func(NULL), closure(NULL), idx(0) { }
+  socontexthandler_cbitem(void) : func(nullptr), closure(nullptr), idx(0) { }
 
   bool operator==(const socontexthandler_cbitem & theother) {
     return
@@ -132,7 +132,7 @@ socontexthandler_cleanup(void)
   }
 #endif // COIN_DEBUG
   delete socontexthandler_hashlist;
-  socontexthandler_hashlist = NULL;
+  socontexthandler_hashlist = nullptr;
   socontexthandler_idx = 0;
   CC_MUTEX_DESTRUCT(socontexthandler_mutex);
 }
@@ -158,7 +158,7 @@ SoContextHandler::destructingContext(uint32_t contextid)
 {
   CC_MUTEX_CONSTRUCT(socontexthandler_mutex);
   CC_MUTEX_LOCK(socontexthandler_mutex);
-  if (socontexthandler_hashlist == NULL) {
+  if (socontexthandler_hashlist == nullptr) {
     CC_MUTEX_UNLOCK(socontexthandler_mutex);
     return;
   }
@@ -220,7 +220,7 @@ SoContextHandler::addContextDestructionCallback(ContextDestructionCB * func,
 {
   CC_MUTEX_CONSTRUCT(socontexthandler_mutex);
   CC_MUTEX_LOCK(socontexthandler_mutex);
-  if (socontexthandler_hashlist == NULL) {
+  if (socontexthandler_hashlist == nullptr) {
     socontexthandler_hashlist = new SbHash<socontexthandler_cbitem, uint32_t> (64);
     // make this callback trigger after the SoGLCacheContext cleanup function
     // by setting priority to -1
diff --git a/coin4/src/misc/SoDB.cpp b/coin4/src/misc/SoDB.cpp
index 096f940..aac5de4 100644
--- a/coin4/src/misc/SoDB.cpp
+++ b/coin4/src/misc/SoDB.cpp
@@ -142,13 +142,13 @@ const char * SoDBP::EnvVars::COIN_PROFILER_OVERLAY = "COIN_PROFILER_OVERLAY";
 
 // *************************************************************************
 
-static SbString * coin_versionstring = NULL;
+static SbString * coin_versionstring = nullptr;
 
 // atexit callback
 static void cleanup_func(void)
 {
   delete coin_versionstring;
-  coin_versionstring = NULL;
+  coin_versionstring = nullptr;
 }
 
 
@@ -334,28 +334,28 @@ SoDB::init(void)
 
   // Register all valid file format headers.
   SoDB::registerHeader(SbString("#Inventor V2.1 ascii   "), false, 2.1f,
-                       NULL, NULL, NULL);
+                       nullptr, nullptr, nullptr);
   SoDB::registerHeader(SbString("#Inventor V2.1 binary  "), true, 2.1f,
-                       NULL, NULL, NULL);
+                       nullptr, nullptr, nullptr);
 
   // FIXME: this is really only valid if the HAVE_VRML97 define is in
   // place. If it's not, we should register the header in a way so
   // that we spit out a /specific/ warning about why VRML97 is not
   // supported in the configuration of the compiled libCoin. 20020808 mortene.
   SoDB::registerHeader(SbString("#VRML V2.0 utf8"), false, 2.1f,
-                       NULL, NULL, NULL);
+                       nullptr, nullptr, nullptr);
 
   // FIXME: there are nodes in TGS' later Inventor versions that we do
   // not support, so it's not really correct to register 2.4 and 2.5
   // headers.  20010925 mortene.
   SoDB::registerHeader(SbString("#Inventor V2.4 ascii   "), false, 2.4f,
-                       NULL, NULL, NULL);
+                       nullptr, nullptr, nullptr);
   SoDB::registerHeader(SbString("#Inventor V2.4 binary  "), true, 2.4f,
-                       NULL, NULL, NULL);
+                       nullptr, nullptr, nullptr);
   SoDB::registerHeader(SbString("#Inventor V2.5 ascii   "), false, 2.5f,
-                       NULL, NULL, NULL);
+                       nullptr, nullptr, nullptr);
   SoDB::registerHeader(SbString("#Inventor V2.5 binary  "), true, 2.5f,
-                       NULL, NULL, NULL);
+                       nullptr, nullptr, nullptr);
   // FIXME: TGS has released many more versions than this. There are
   // at least 2.6, 3.0, 3.1 and 4.0, as of now. What should we do with
   // those? Simply add them in the same manner? Should investigate
@@ -363,9 +363,9 @@ SoDB::init(void)
   // written with these versions. 20040909 mortene.
 
   SoDB::registerHeader(SbString("#Inventor V2.0 ascii   "), false, 2.0f,
-                       NULL, NULL, NULL);
+                       nullptr, nullptr, nullptr);
   SoDB::registerHeader(SbString("#Inventor V2.0 binary  "), true, 2.0f,
-                       NULL, NULL, NULL);
+                       nullptr, nullptr, nullptr);
 
   // FIXME: this is erroneous, we don't _really_ support v1.x Inventor
   // files.  Should spit out a warning, and a helpful message on how
@@ -376,15 +376,15 @@ SoDB::init(void)
   // mechanism, and at least a few upgrader nodes for V1.0
   // stuff. Should investigate the exact status of this.
   SoDB::registerHeader(SbString("#Inventor V1.0 ascii   "), false, 1.0f,
-                       NULL, NULL, NULL);
+                       nullptr, nullptr, nullptr);
   SoDB::registerHeader(SbString("#Inventor V1.0 binary  "), true, 1.0f,
-                       NULL, NULL, NULL);
+                       nullptr, nullptr, nullptr);
 
   // The VRML 1 standard was made from SGI's Inventor V2.1 (and should
   // be a pure sub-set), so that's what we pretend the format version
   // is, internally.
   SoDB::registerHeader(SbString("#VRML V1.0 ascii   "), false, 2.1f,
-                       NULL, NULL, NULL);
+                       nullptr, nullptr, nullptr);
 
 
   // FIXME: should be more robust and accept a set of headers that
@@ -422,7 +422,7 @@ SoDB::init(void)
   SoDBP::globaltimersensor->schedule();
 
   // Force correct time on first getValue() from "realTime" field.
-  SoDBP::updateRealTimeFieldCB(NULL, NULL);
+  SoDBP::updateRealTimeFieldCB(nullptr, nullptr);
 
   // This should prove helpful for debugging the pervasive problem
   // under Win32 with loading multiple instances of the same library.
@@ -494,7 +494,7 @@ SoDB::cleanup(void)
 const char *
 SoDB::getVersion(void)
 {
-  if (coin_versionstring == NULL) {
+  if (coin_versionstring == nullptr) {
     coin_versionstring = new SbString("SIM Coin " COIN_VERSION);
     coin_atexit((coin_atexit_f *)cleanup_func, CC_ATEXIT_NORMAL);
   }
@@ -508,13 +508,13 @@ SoDB::getVersion(void)
   The reference count of the SoPath object will initially be zero.
 
   Returns \c false on error. Returns \c true with \a path equal to \a
-  NULL if we hit end of file instead of a new path specification in
+  nullptr if we hit end of file instead of a new path specification in
   the file.
 */
 bool
 SoDB::read(SoInput * in, SoPath *& path)
 {
-  path = NULL;
+  path = nullptr;
   SoBase * baseptr;
   if (!SoDB::read(in, baseptr))  return false;
   if (!baseptr) return true; // eof
@@ -533,7 +533,7 @@ SoDB::read(SoInput * in, SoPath *& path)
 
 /*!
   Instantiates and reads an object of type SoBase from \a in and
-  returns a pointer to it in \a base. \a base will be \c NULL on
+  returns a pointer to it in \a base. \a base will be \c nullptr on
   return if we hit end of file.
 
   The reference count of the base object will initially be zero.
@@ -550,13 +550,13 @@ SoDB::read(SoInput * in, SoBase *& base)
        SoForeignFileKit::getClassTypeId() != SoType::badType() &&
        SoForeignFileKit::isFileSupported(in)) {
     base = SoForeignFileKit::createForeignFileKit(in);
-    return (base != NULL);
+    return (base != nullptr);
   }
 #endif // NODEKITS
 
   if (!valid && SoDBP::is3dsFile(in)) {
     base = SoDBP::read3DSFile(in);
-    return (base != NULL);
+    return (base != nullptr);
   }
 
   // Header is only required when reading from a stream, if reading from
@@ -574,18 +574,18 @@ SoDB::read(SoInput * in, SoBase *& base)
   The reference count of the node will initially be zero.
 
   Returns \c false on error. Returns \c true with \a rootnode equal to
-  \c NULL if we hit end of file instead of a new node specification in
+  \c nullptr if we hit end of file instead of a new node specification in
   the file.
  */
 bool
 SoDB::read(SoInput * in, SoNode *& rootnode)
 {
-  rootnode = NULL;
+  rootnode = nullptr;
   SoBase * baseptr;
 
   if (SoDBP::is3dsFile(in)) {
     rootnode = SoDBP::read3DSFile(in);
-    return (rootnode != NULL);
+    return (rootnode != nullptr);
   }
 
   // allow engines at the top level of a file
@@ -647,7 +647,7 @@ SoDB::read(SoInput * in, SoNode *& rootnode)
   // memory resources it was using.)
   \endcode
 
-  Returns \c NULL on any error.
+  Returns \c nullptr on any error.
 
   Tip: a common operation to do after importing a scene graph is to
   pick out the memory pointers to one or more of the imported nodes
@@ -677,7 +677,7 @@ SoDB::readAllVRML(SoInput * in)
   return (SoVRMLGroup*)
     SoDB::readAllWrapper(in, SoVRMLGroup::getClassTypeId());
 #else // HAVE_VRML97
-  return NULL;
+  return nullptr;
 #endif // ! HAVE_VRML97
 }
 
@@ -697,7 +697,7 @@ SoDB::isValidHeader(const char * teststring)
 #if COIN_DEBUG
   if (!teststring) {
     SoDebugError::postWarning("SoDB::isValidHeader",
-                              "Passed a NULL string pointer.");
+                              "Passed a nullptr string pointer.");
     return false;
   }
 #endif // COIN_DEBUG
@@ -853,7 +853,7 @@ SoDB::getHeaderString(const int i)
   subsequent accesses to getGlobalField() by \a name. If a global
   field by the name and type already exists, returns a pointer to it.
   If a global field with the same name but a different type exists,
-  returns \c NULL.
+  returns \c nullptr.
 
   A global field can be deallocated by calling
   SoDB::renameGlobalField(), with the second argument set to an empty
@@ -869,7 +869,7 @@ SoDB::createGlobalField(const SbName & name, SoType type)
   SoField * f = SoDB::getGlobalField(name);
   if (f) {
     if (f->getTypeId() == type) return f;
-    else return NULL;
+    else return nullptr;
   }
 
 #if COIN_DEBUG
@@ -877,7 +877,7 @@ SoDB::createGlobalField(const SbName & name, SoType type)
     SoDebugError::postWarning("SoDB::createGlobalField",
                               "Can't create instance of field type ``%s''.",
                               type.getName().getString());
-    return NULL;
+    return nullptr;
   }
 #endif // COIN_DEBUG
 
@@ -890,7 +890,7 @@ SoDB::createGlobalField(const SbName & name, SoType type)
 
 /*!
   If there exist a global field with the given \a name, return a
-  pointer to it. If there is no field with this name, return \c NULL.
+  pointer to it. If there is no field with this name, return \c nullptr.
 
   Of particular interest is the \c realTime global field set up by the
   library on initialization. This field is used as a source field to
@@ -909,7 +909,7 @@ SoField *
 SoDB::getGlobalField(const SbName & name)
 {
   SoGlobalField * gf = SoGlobalField::getGlobalFieldContainer(name);
-  return gf ? gf->getGlobalField() : NULL;
+  return gf ? gf->getGlobalField() : nullptr;
 }
 
 /*!
@@ -925,7 +925,7 @@ SoDB::renameGlobalField(const SbName & from, const SbName & to)
   SoGlobalField * gf = SoGlobalField::getGlobalFieldContainer(from);
 
 #if COIN_DEBUG
-  if (gf == NULL) {
+  if (gf == nullptr) {
     SoDebugError::postWarning("SoDB::renameGlobalField",
                               "Couldn't find global field '%s' to rename.",
                               from.getString());
@@ -1203,7 +1203,7 @@ SoDB::readAllWrapper(SoInput * in, const SoType & grouptype)
 
   if (!valid && SoDBP::is3dsFile(in)) {
     SoSeparator * root3ds = SoDBP::read3DSFile(in);
-    if (root3ds == NULL) { return NULL; }
+    if (root3ds == nullptr) { return nullptr; }
 
     if (!SoSeparator::getClassTypeId().isDerivedFrom(grouptype)) {
       SoGroup * root = (SoGroup *)grouptype.createInstance();
@@ -1217,7 +1217,7 @@ SoDB::readAllWrapper(SoInput * in, const SoType & grouptype)
 
   if (!valid) {
     SoReadError::post(in, "Not a valid Inventor file.");
-    return NULL;
+    return nullptr;
   }
 
   const int stackdepth = in->filestack.getLength();
@@ -1228,7 +1228,7 @@ SoDB::readAllWrapper(SoInput * in, const SoType & grouptype)
     if (!SoDB::read(in, topnode)) {
       root->ref();
       root->unref();
-      return NULL;
+      return nullptr;
     }
     if (topnode) { root->addChild(topnode); }
   } while (topnode && in->skipWhiteSpace());
@@ -1359,7 +1359,7 @@ SoDB::readAllWrapper(SoInput * in, const SoType & grouptype)
 void
 SoDB::addProgressCallback(ProgressCallbackType * func, void * userdata)
 {
-  if (SoDBP::progresscblist == NULL) {
+  if (SoDBP::progresscblist == nullptr) {
     SoDBP::progresscblist = new SbList<SoDBP::ProgressCallbackInfo>;
   }
 
@@ -1544,8 +1544,8 @@ SoDB::createRoute(SoNode * fromnode, const char * eventout,
   if (tonodename == "") {
     tonodename = "<noname>";
   }
-  SoEngineOutput * output = NULL;
-  if (from == NULL && fromnode->isOfType(SoNodeEngine::getClassTypeId())) {
+  SoEngineOutput * output = nullptr;
+  if (from == nullptr && fromnode->isOfType(SoNodeEngine::getClassTypeId())) {
     output = ((SoNodeEngine*) fromnode)->getOutput(fromfieldname);
   }
 
@@ -1635,8 +1635,8 @@ SoDB::removeRoute(SoNode * fromnode, const char * eventout,
   SoField * from = find_route_field(fromnode, fromfieldname);
   SoField * to = find_route_field(tonode, tofieldname);
 
-  SoEngineOutput * output = NULL;
-  if (from == NULL && fromnode->isOfType(SoNodeEngine::getClassTypeId())) {
+  SoEngineOutput * output = nullptr;
+  if (from == nullptr && fromnode->isOfType(SoNodeEngine::getClassTypeId())) {
     output = ((SoNodeEngine*) fromnode)->getOutput(fromfieldname);
   }
 
@@ -1685,8 +1685,8 @@ BOOST_AUTO_TEST_CASE(globalRealTimeField)
   SoDB::getSensorManager()->processTimerQueue();
   SoSFTime * realtime = (SoSFTime *)SoDB::getGlobalField("realTime");
 
-  BOOST_REQUIRE(realtime != NULL);
-  BOOST_REQUIRE(realtime->getContainer() != NULL);
+  BOOST_REQUIRE(realtime != nullptr);
+  BOOST_REQUIRE(realtime->getContainer() != nullptr);
 
   // check that realtime field actually is initialized with something
   // close to actual time
@@ -1724,7 +1724,7 @@ BOOST_AUTO_TEST_CASE(readEmptyChildList)
   // FIXME: We are forced to restore the global state before terminating,
   // or independent tests could fail. (sveinung 20071108)
   SoErrorCB * prevErrorCB = SoReadError::getHandlerCallback();
-  SoReadError::setHandlerCallback(readErrorHandler, NULL);
+  SoReadError::setHandlerCallback(readErrorHandler, nullptr);
 
   static const char scene[] = "#VRML V2.0 utf8\n"
                               "DEF TestGroup Group { children }";
@@ -1735,9 +1735,9 @@ BOOST_AUTO_TEST_CASE(readEmptyChildList)
     SoGroup * group = (SoGroup *) SoNode::getByName("TestGroup");
     BOOST_CHECK_MESSAGE(group->getNumChildren() == 0, "Should have no children");
   }
-  BOOST_CHECK_MESSAGE(root == NULL, "Expected the import to fail");
+  BOOST_CHECK_MESSAGE(root == nullptr, "Expected the import to fail");
 
-  SoReadError::setHandlerCallback(prevErrorCB, NULL);
+  SoReadError::setHandlerCallback(prevErrorCB, nullptr);
 }
 
 BOOST_AUTO_TEST_CASE(readNullChildList)
@@ -1745,10 +1745,10 @@ BOOST_AUTO_TEST_CASE(readNullChildList)
   // FIXME: We are forced to restore the global state before terminating,
   // or independent tests could fail. (sveinung 20071108)
   SoErrorCB * prevErrorCB = SoReadError::getHandlerCallback();
-  SoReadError::setHandlerCallback(readErrorHandler, NULL);
+  SoReadError::setHandlerCallback(readErrorHandler, nullptr);
 
   static const char scene[] = "#VRML V2.0 utf8\n"
-                              "PROTO Object [ field MFNode testChildren NULL ] { }\n"
+                              "PROTO Object [ field MFNode testChildren nullptr ] { }\n"
                               "DEF TestObject Object { }";
   SoInput in;
   in.setBuffer((void *) scene, strlen(scene));
@@ -1758,9 +1758,9 @@ BOOST_AUTO_TEST_CASE(readNullChildList)
     SoMFNode * field = (SoMFNode *) object->getField("testChildren");
     BOOST_CHECK_MESSAGE(field->getNumNodes() == 0, "Should have no children");
   }
-  BOOST_CHECK_MESSAGE(root == NULL, "Expected the import to fail");
+  BOOST_CHECK_MESSAGE(root == nullptr, "Expected the import to fail");
 
-  SoReadError::setHandlerCallback(prevErrorCB, NULL);
+  SoReadError::setHandlerCallback(prevErrorCB, nullptr);
 }
 
 BOOST_AUTO_TEST_CASE(readInvalidChildList)
@@ -1768,16 +1768,16 @@ BOOST_AUTO_TEST_CASE(readInvalidChildList)
   // FIXME: We are forced to restore the global state before terminating,
   // or independent tests could fail. (sveinung 20071108)
   SoErrorCB * prevErrorCB = SoReadError::getHandlerCallback();
-  SoReadError::setHandlerCallback(readErrorHandler, NULL);
+  SoReadError::setHandlerCallback(readErrorHandler, nullptr);
 
   static const char scene[] = "#VRML V2.0 utf8\n"
                               "Group { children[0] }";
   SoInput in;
   in.setBuffer((void *) scene, strlen(scene));
   SoSeparator * root = SoDB::readAll(&in);
-  BOOST_CHECK_MESSAGE(root == NULL, "Expected the import to fail");
+  BOOST_CHECK_MESSAGE(root == nullptr, "Expected the import to fail");
 
-  SoReadError::setHandlerCallback(prevErrorCB, NULL);
+  SoReadError::setHandlerCallback(prevErrorCB, nullptr);
 }
 
 BOOST_AUTO_TEST_CASE(testAlternateRepNull)
@@ -1785,7 +1785,7 @@ BOOST_AUTO_TEST_CASE(testAlternateRepNull)
   // FIXME: We are forced to restore the global state before terminating,
   // or independent tests could fail. (sveinung 20071108)
   SoErrorCB * prevErrorCB = SoReadError::getHandlerCallback();
-  SoReadError::setHandlerCallback(readErrorHandler, NULL);
+  SoReadError::setHandlerCallback(readErrorHandler, nullptr);
 
   static const char scene[] = "#Inventor V2.1 ascii\n"
                               "ExtensionNode { fields [ SFNode alternateRep ] }";
@@ -1796,7 +1796,7 @@ BOOST_AUTO_TEST_CASE(testAlternateRepNull)
   root->ref();
   root->unref();
 
-  SoReadError::setHandlerCallback(prevErrorCB, NULL);
+  SoReadError::setHandlerCallback(prevErrorCB, nullptr);
 }
 
 BOOST_AUTO_TEST_CASE(testInitCleanup)
@@ -1842,7 +1842,7 @@ BOOST_AUTO_TEST_CASE(globalfield_import)
 
   SoInput * in = new SoInput;
   in->setBuffer(scene, strlen(scene));
-  SoNode * g = NULL;
+  SoNode * g = nullptr;
   const bool readok = SoDB::read(in, g);
 
   delete in;
diff --git a/coin4/src/misc/SoDBP.cpp b/coin4/src/misc/SoDBP.cpp
index 76ab914..2588396 100644
--- a/coin4/src/misc/SoDBP.cpp
+++ b/coin4/src/misc/SoDBP.cpp
@@ -22,15 +22,15 @@
 // need to include SbRWMutex.h to make C++ call the actual destructor,
 // and not just default destructor
 #include <Inventor/threads/SbRWMutex.h>
-SbRWMutex * SoDBP::globalmutex = NULL;
+SbRWMutex * SoDBP::globalmutex = nullptr;
 #endif // COIN_THREADSAFE
-SbList<SoDB_HeaderInfo *> * SoDBP::headerlist = NULL;
-SoSensorManager * SoDBP::sensormanager = NULL;
-SoTimerSensor * SoDBP::globaltimersensor = NULL;
-UInt32ToInt16Map * SoDBP::converters = NULL;
+SbList<SoDB_HeaderInfo *> * SoDBP::headerlist = nullptr;
+SoSensorManager * SoDBP::sensormanager = nullptr;
+SoTimerSensor * SoDBP::globaltimersensor = nullptr;
+UInt32ToInt16Map * SoDBP::converters = nullptr;
 bool SoDBP::isinitialized = false;
 int SoDBP::notificationcounter = 0;
-SbList<SoDBP::ProgressCallbackInfo> * SoDBP::progresscblist = NULL;
+SbList<SoDBP::ProgressCallbackInfo> * SoDBP::progresscblist = nullptr;
 
 // *************************************************************************
 // FIXME: this should be moved into a function in tidsbits.c. 20050509 mortene.
@@ -108,7 +108,7 @@ void
 SoDBP::clean(void)
 {
   delete SoDBP::progresscblist;
-  SoDBP::progresscblist = NULL;
+  SoDBP::progresscblist = nullptr;
 
   // Avoid having the SoSensorManager instance trigging the callback
   // into the So@Gui@ class -- not only have it possible "died", but
@@ -118,24 +118,24 @@ SoDBP::clean(void)
   // the SoQt library, which wets its pants on the
   // SoDBP::globaltimersensor destruction under MSWindows if we don't
   // first nullify the callback function pointer.)
-  SoDBP::sensormanager->setChangedCallback(NULL, NULL);
+  SoDBP::sensormanager->setChangedCallback(nullptr, nullptr);
 
   delete SoDBP::globaltimersensor;
-  SoDBP::globaltimersensor = NULL;
+  SoDBP::globaltimersensor = nullptr;
   delete SoDBP::converters;
-  SoDBP::converters = NULL;
+  SoDBP::converters = nullptr;
 
   delete SoDBP::sensormanager;
-  SoDBP::sensormanager = NULL;
+  SoDBP::sensormanager = nullptr;
 
   for (int i = 0; i < SoDBP::headerlist->getLength(); i++)
     delete (*SoDBP::headerlist)[i];
   delete SoDBP::headerlist;
-  SoDBP::headerlist = NULL;
+  SoDBP::headerlist = nullptr;
 
 #ifdef COIN_THREADSAFE
   delete SoDBP::globalmutex;
-  SoDBP::globalmutex = NULL;
+  SoDBP::globalmutex = nullptr;
 #endif // COIN_THREADSAFE
 }
 
@@ -277,7 +277,7 @@ SoDBP::read3DSFile(SoInput * in)
 
 #endif // !HAVE_3DS_IMPORT_CAPABILITIES
 
-  return NULL;
+  return nullptr;
 }
 
 
@@ -286,7 +286,7 @@ SoDBP::progress(const SbName & itemid,
                 float fraction,
                 bool interruptible)
 {
-  if (SoDBP::progresscblist != NULL) {
+  if (SoDBP::progresscblist != nullptr) {
     for (int i = 0; i < SoDBP::progresscblist->getLength(); i++) {
       SoDBP::ProgressCallbackInfo info = (*SoDBP::progresscblist)[i];
       info.func(itemid, fraction, interruptible, info.userdata);
diff --git a/coin4/src/misc/SoDebug.cpp b/coin4/src/misc/SoDebug.cpp
index 7e60c5e..c8d1ea8 100644
--- a/coin4/src/misc/SoDebug.cpp
+++ b/coin4/src/misc/SoDebug.cpp
@@ -61,7 +61,7 @@ struct SoDebug_internal {
   static void delete_namedict(void);
 };
 
-SbHash<void *, char *> * SoDebug_internal::namedict = NULL;
+SbHash<void *, char *> * SoDebug_internal::namedict = nullptr;
 
 } // anonymous namespace
 
@@ -105,11 +105,11 @@ SoDebug::RTPrintf(const char * formatstr, ...)
 void
 SoDebug::NamePtr(const char * name, void * ptr)
 {
-  if ( SoDebug_internal::namedict == NULL ) {
+  if ( SoDebug_internal::namedict == nullptr ) {
     SoDebug_internal::namedict = new SbHash<void *, char *>;
     coin_atexit(SoDebug_internal::delete_namedict, CC_ATEXIT_NORMAL);
   }
-  char * data = NULL;
+  char * data = nullptr;
   if ( SoDebug_internal::namedict->get(ptr, data) ) {
     free(data);
     SoDebug_internal::namedict->erase(ptr);
@@ -130,8 +130,8 @@ const char *
 SoDebug::PtrName(void * ptr)
 {
   static const char fallback[] = "<noName>";
-  if ( SoDebug_internal::namedict == NULL ) return fallback;
-  char * data = NULL;
+  if ( SoDebug_internal::namedict == nullptr ) return fallback;
+  char * data = nullptr;
   if ( SoDebug_internal::namedict->get(ptr, data) ) {
     if ( data ) {
       return data;
@@ -158,7 +158,7 @@ SoDebug::write(SoNode * node)
 }
 
 /*!
-  Writes the node to the given filename, or /tmp/debug.iv if filename is NULL.
+  Writes the node to the given filename, or /tmp/debug.iv if filename is nullptr.
 */
 
 void
@@ -223,7 +223,7 @@ SoDebug_internal::delete_namedict(void)
   }
 
   delete namedict;
-  namedict = NULL;
+  namedict = nullptr;
 }
 
 // *************************************************************************
diff --git a/coin4/src/misc/SoEventManager.cpp b/coin4/src/misc/SoEventManager.cpp
index 2751b9e..373eda6 100644
--- a/coin4/src/misc/SoEventManager.cpp
+++ b/coin4/src/misc/SoEventManager.cpp
@@ -99,8 +99,8 @@ SoEventManager::SoEventManager(void)
   PRIVATE(this)->deletehandleeventaction = true;
   PRIVATE(this)->searchaction = new SoSearchAction;
 
-  PRIVATE(this)->camera = NULL;
-  PRIVATE(this)->scene = NULL;
+  PRIVATE(this)->camera = nullptr;
+  PRIVATE(this)->scene = nullptr;
 }
 
 /*!
@@ -111,14 +111,14 @@ SoEventManager::SoEventManager(void)
 */
 SoEventManager::~SoEventManager()
 {
-  this->setCamera(NULL);
-  this->setSceneGraph(NULL);
+  this->setCamera(nullptr);
+  this->setSceneGraph(nullptr);
 
   delete PRIVATE(this)->searchaction;
 
   if (PRIVATE(this)->deletehandleeventaction) {
     delete PRIVATE(this)->handleeventaction;
-    PRIVATE(this)->handleeventaction = NULL;
+    PRIVATE(this)->handleeventaction = nullptr;
   }
   for (int c = this->getNumSoScXMLStateMachines() - 1; c >= 0; --c) {
     SoScXMLStateMachine * sm = this->getSoScXMLStateMachine(c);
@@ -342,7 +342,7 @@ SoEventManager::actuallyProcessEvent(const SoEvent * const event)
   assert(PRIVATE(this)->handleeventaction);
 
   bool handled = false;
-  if ( PRIVATE(this)->handleeventaction->getState() != NULL &&
+  if ( PRIVATE(this)->handleeventaction->getState() != nullptr &&
        PRIVATE(this)->handleeventaction->getState()->getDepth() != 0 ) {
     // recursive invocation - action currently in use
 #if COIN_DEBUG
@@ -350,7 +350,7 @@ SoEventManager::actuallyProcessEvent(const SoEvent * const event)
                        "Recursive invocation detected. Delay processing event "
                        "until the current event is finished processing.");
 #endif // COIN_DEBUG
-  } else if ( PRIVATE(this)->scene == NULL ) {
+  } else if ( PRIVATE(this)->scene == nullptr ) {
     // nothing
   } else {
     PRIVATE(this)->handleeventaction->setEvent(event);
@@ -368,7 +368,7 @@ SoEventManager::actuallyProcessEvent(const SoEvent * const event)
 void
 SoEventManager::setHandleEventAction(SoHandleEventAction * handleeventaction)
 {
-  assert(handleeventaction && "SoEventManager::setHandleEventAction, action == NULL");
+  assert(handleeventaction && "SoEventManager::setHandleEventAction, action == nullptr");
 
   // remember old viewport region
   SbViewportRegion region = PRIVATE(this)->handleeventaction->getViewportRegion();
diff --git a/coin4/src/misc/SoGlyph.cpp b/coin4/src/misc/SoGlyph.cpp
index 46a295d..c2cd186 100644
--- a/coin4/src/misc/SoGlyph.cpp
+++ b/coin4/src/misc/SoGlyph.cpp
@@ -106,7 +106,7 @@ public:
   void setup3DFontData();
 
   static SoGlyph * createSystemGlyph(const char character, const SbName & font);
-  static SoGlyph * createSystemGlyph(const unsigned int COIN_UNUSED_ARG(character), SoState * COIN_UNUSED_ARG(state)) {return NULL;};  static SoGlyph * createSystemGlyph(const char character, int fontid);
+  static SoGlyph * createSystemGlyph(const unsigned int COIN_UNUSED_ARG(character), SoState * COIN_UNUSED_ARG(state)) {return nullptr;};  static SoGlyph * createSystemGlyph(const char character, int fontid);
 };
 
 #define PRIVATE(p) ((p)->pimpl)
@@ -121,9 +121,9 @@ SoGlyph::SoGlyph(void)
   PRIVATE(this) = new SoGlyphP(this);
   PRIVATE(this)->refcount = 0;
   PRIVATE(this)->flags.didcalcbbox = 0;
-  PRIVATE(this)->coords = NULL;
-  PRIVATE(this)->faceidx = NULL;
-  PRIVATE(this)->edgeidx = NULL;
+  PRIVATE(this)->coords = nullptr;
+  PRIVATE(this)->faceidx = nullptr;
+  PRIVATE(this)->edgeidx = nullptr;
   PRIVATE(this)->ymin = 0.0f;
   PRIVATE(this)->ymax = 0.0f;
 
@@ -136,7 +136,7 @@ SoGlyph::SoGlyph(void)
 
   PRIVATE(this)->bitmapwidth = 0;
   PRIVATE(this)->bitmapheight = 0;
-  PRIVATE(this)->bitmap = NULL;
+  PRIVATE(this)->bitmap = nullptr;
 }
 
 /*!
@@ -217,7 +217,7 @@ SoGlyph::getEdgeIndices(void) const
 }
 
 /*!
-  Returns a pointer to the next clockwise edge. Returns NULL if
+  Returns a pointer to the next clockwise edge. Returns nullptr if
   none could be found.
 */
 const int *
@@ -236,12 +236,12 @@ SoGlyph::getNextCWEdge(const int edgeidx) const
     if (ptr[1] == findidx) return ptr;
     ptr += 2;
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
   Returns a pointer to the next counter clockwise edge.
-  NULL if none could be found.
+  nullptr if none could be found.
 */
 const int *
 SoGlyph::getNextCCWEdge(const int edgeidx) const
@@ -257,7 +257,7 @@ SoGlyph::getNextCCWEdge(const int edgeidx) const
     if (*ptr == findidx) return ptr;
     ptr += 2;
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -386,7 +386,7 @@ public:
   coin_glyph_info() {
     this->character = 0;
     this->size = 0.0;
-    this->glyph = NULL;
+    this->glyph = nullptr;
     this->angle = 0.0;
   }
   coin_glyph_info(const unsigned int characterarg, const float sizearg, const SbName &fontarg, SoGlyph *glypharg, const float anglearg)
@@ -422,14 +422,14 @@ public:
   float angle;
 };
 
-static SbList <coin_glyph_info> * activeGlyphs = NULL;
-static void * SoGlyph_mutex = NULL;
+static SbList <coin_glyph_info> * activeGlyphs = nullptr;
+static void * SoGlyph_mutex = nullptr;
 
 static void
 SoGlyph_cleanup(void)
 {
   delete activeGlyphs;
-  activeGlyphs = NULL;
+  activeGlyphs = nullptr;
   CC_MUTEX_DESTRUCT(SoGlyph_mutex);
 }
 
@@ -449,7 +449,7 @@ SoGlyph::getGlyph(const char character, const SbName & font)
   // 20030611 mortene.
   
   // Similar code in start of getGlyph(..., state) - keep in sync.
-  if (SoGlyph_mutex == NULL) {
+  if (SoGlyph_mutex == nullptr) {
     CC_MUTEX_CONSTRUCT(SoGlyph_mutex);
   }
 
@@ -461,7 +461,7 @@ SoGlyph::getGlyph(const char character, const SbName & font)
 
   CC_MUTEX_LOCK(SoGlyph_mutex);
 
-  if (activeGlyphs == NULL) {
+  if (activeGlyphs == nullptr) {
     activeGlyphs = new SbList <coin_glyph_info>;
     coin_atexit((coin_atexit_f *)SoGlyph_cleanup, CC_ATEXIT_NORMAL);
   }
@@ -484,12 +484,12 @@ SoGlyph::getGlyph(const char character, const SbName & font)
   // glyph. If none exist in the font, we should eventually fall back
   // on making a square in the code we're calling into. Move the code
   // below to handle this deeper down into the call-stack. 20030527 mortene.
-  if (glyph == NULL) { // no system font could be loaded
+  if (glyph == nullptr) { // no system font could be loaded
     glyph = new SoGlyph;
     if (character <= 32 || character >= 127) {
       // treat all these characters as spaces
       static int spaceidx[] = { -1 };
-      glyph->setCoords(NULL);
+      glyph->setCoords(nullptr);
       glyph->setFaceIndices(spaceidx);
       glyph->setEdgeIndices(spaceidx);
       PRIVATE(glyph)->bbox.setBounds(SbVec2f(0.0f, 0.0f), SbVec2f(0.2f, 0.0f));
@@ -557,13 +557,13 @@ SoGlyph::getGlyph(SoState * state,
   if (size != SbVec2s(0,0)) { fontsize = size; }
   
   // Similar code in start of getGlyph(..., fontname) - keep in sync.
-  if (SoGlyph_mutex == NULL) {
+  if (SoGlyph_mutex == nullptr) {
     CC_MUTEX_CONSTRUCT(SoGlyph_mutex);
   }
 
   CC_MUTEX_LOCK(SoGlyph_mutex);
   
-  if (activeGlyphs == NULL) {
+  if (activeGlyphs == nullptr) {
     activeGlyphs = new SbList <coin_glyph_info>;
     coin_atexit((coin_atexit_f *)SoGlyph_cleanup, CC_ATEXIT_NORMAL);
   }
@@ -642,7 +642,7 @@ SoGlyph::getKerning(const SoGlyph & rightglyph) const
   Bitmap for glyph. \a size and \a pos are return parameters.
   Antialiased bitmap graphics not yet supported.
 
-  Note that this function may return \c NULL if the glyph has no
+  Note that this function may return \c nullptr if the glyph has no
   visible pixels (as for e.g. the space character).
 
   The returned buffer should \e not be deallocated by the caller.
@@ -650,7 +650,7 @@ SoGlyph::getKerning(const SoGlyph & rightglyph) const
 unsigned char *
 SoGlyph::getBitmap(SbVec2s & size, SbVec2s & pos, const bool COIN_UNUSED_ARG(antialiased)) const
 {
-  if (PRIVATE(this)->bitmap == NULL) {
+  if (PRIVATE(this)->bitmap == nullptr) {
     PRIVATE(this)->bitmap = cc_flw_get_bitmap(PRIVATE(this)->fontidx, PRIVATE(this)->glyphidx);
   }
   struct cc_font_bitmap * bm = PRIVATE(this)->bitmap;
@@ -676,7 +676,7 @@ SoGlyphP::setup3DFontData(void)
   if (character <= 32 || character >= 127) {
     // treat all these characters as spaces
     static int spaceidx[] = { -1 };
-    PUBLIC(this)->setCoords(NULL);
+    PUBLIC(this)->setCoords(nullptr);
     PUBLIC(this)->setFaceIndices(spaceidx);
     PUBLIC(this)->setEdgeIndices(spaceidx);
     this->bbox.setBounds(SbVec2f(0.0f, 0.0f), SbVec2f(0.2f, 0.0f));
@@ -685,7 +685,7 @@ SoGlyphP::setup3DFontData(void)
   else {
     cc_font_vector_glyph * vector_glyph = cc_flw_get_vector_glyph(this->fontidx, this->character);
     
-    if (vector_glyph == NULL) {
+    if (vector_glyph == nullptr) {
       // Default hardcoded 3d font. Size = 1.0
       const int idx = this->character-33;
       PUBLIC(this)->setCoords((const SbVec2f *)coin_default3dfont_get_coords()[idx]);
@@ -707,13 +707,13 @@ SoGlyphP::setup3DFontData(void)
 SoGlyph *
 SoGlyphP::createSystemGlyph(const char COIN_UNUSED_ARG(character), int COIN_UNUSED_ARG(fontid))
 { 
-  return NULL;
+  return nullptr;
 }
 
 SoGlyph *
 SoGlyphP::createSystemGlyph(const char COIN_UNUSED_ARG(character), const SbName & COIN_UNUSED_ARG(font))
 {
-  return NULL;
+  return nullptr;
 }
 
 #undef PRIVATE
diff --git a/coin4/src/misc/SoJavaScriptEngine.cpp b/coin4/src/misc/SoJavaScriptEngine.cpp
index 8e3bf5f..3267b50 100644
--- a/coin4/src/misc/SoJavaScriptEngine.cpp
+++ b/coin4/src/misc/SoJavaScriptEngine.cpp
@@ -65,7 +65,7 @@ public:
   bool autonodeunref;
 };
 
-JSRuntime * SoJavaScriptEngineP::runtime = NULL;
+JSRuntime * SoJavaScriptEngineP::runtime = nullptr;
 size_t SoJavaScriptEngineP::CONTEXT_STACK_CHUNK_SIZE = 8192; /* stack chunk size */
 JSClass SoJavaScriptEngineP::globalclass;
 
@@ -213,7 +213,7 @@ SoJavaScriptEngine::SoJavaScriptEngine()
   // the same global object? 20050719 erikgors.
   JSObject * global = PRIVATE(this)->global = 
     spidermonkey()->JS_NewObject(cx, &SoJavaScriptEngineP::globalclass, 
-                                 NULL, NULL);
+                                 nullptr, nullptr);
   if (!global) {
     SoDebugError::postWarning("SoJavaScriptEngine::SoJavaScriptEngine",
                               "SpiderMonkey Javascript engine available, "
@@ -321,7 +321,7 @@ SoJavaScriptEngine::setGlobal(JSObject * global)
 bool
 SoJavaScriptEngine::init(uint32_t maxBytes)
 {
-  assert(SoJavaScriptEngine::getRuntime() == NULL);
+  assert(SoJavaScriptEngine::getRuntime() == nullptr);
 
   if (!spidermonkey()->available) {
     SoDebugError::postWarning("SoJavaScriptEngine::init",
@@ -334,7 +334,7 @@ SoJavaScriptEngine::init(uint32_t maxBytes)
 
   JSRuntime * rt = spidermonkey()->JS_NewRuntime(maxBytes);
 
-  if (rt == NULL) {
+  if (rt == nullptr) {
     SoDebugError::post("SoJavaScriptEngine::init",
                        "SpiderMonkey Javascript engine available, "
                        "but failed to instantiate a JSRuntime!");
@@ -364,12 +364,12 @@ void
 SoJavaScriptEngine::shutdown(void)
 {
   JSRuntime * rt = SoJavaScriptEngine::getRuntime();
-  if (rt != NULL) {
+  if (rt != nullptr) {
     spidermonkey()->JS_DestroyRuntime(rt);
   }
 
   spidermonkey()->JS_ShutDown();
-  SoJavaScriptEngine::setRuntime(NULL);
+  SoJavaScriptEngine::setRuntime(nullptr);
 }
 
 bool
@@ -475,7 +475,7 @@ SoJavaScriptEngine::executeFunction(const SbName & name,
     }
 
     bool ok2 = true;
-    if (rval != NULL) {
+    if (rval != nullptr) {
       ok2 = jsval2field(rjsval, rval);
     }
     return ok2;
@@ -500,7 +500,7 @@ SoJavaScriptEngine::field2jsval(const SoField * f, jsval * v) const
   while (n --> 0) {
     const SoJavaScriptEngineP::JavascriptHandler & handler = PRIVATE(this)->handlerList[n];
 
-    if (handler.field2jsval != NULL && f->isOfType(handler.type)) {
+    if (handler.field2jsval != nullptr && f->isOfType(handler.type)) {
       handler.field2jsval(PRIVATE(this)->context, f, v);
       return true;
     }
@@ -513,7 +513,7 @@ SoJavaScriptEngine::field2jsval(const SoField * f, jsval * v) const
 /*!
   Returns the SoJavaScriptEngine associated with the given context.
   If the context isn't associated with an SoJavaScriptEngine it will 
-  return NULL.
+  return nullptr.
 
   NB! Setting the context private data (using JS_SetContextPrivate()) will
   overwrite this information and cause this method to return a garbage
@@ -541,7 +541,7 @@ SoJavaScriptEngine::jsval2field(const jsval v, SoField * f) const
   while (n --> 0) {
     const SoJavaScriptEngineP::JavascriptHandler & handler = PRIVATE(this)->handlerList[n];
 
-    if (handler.jsval2field != NULL && f->isOfType(handler.type)) {
+    if (handler.jsval2field != nullptr && f->isOfType(handler.type)) {
       if (handler.jsval2field(PRIVATE(this)->context, v, f)) {
         return true;
       }
@@ -565,7 +565,7 @@ SoJavaScriptEngine::jsval2field(const jsval v, SoField * f) const
   \a init is the class init function and will be called immediately 
   if specified.
   \a field2jsval and \a jsval2field will convert an SoField to a jsval 
-  or vice versa. Setting these to NULL is allowed but will result in the 
+  or vice versa. Setting these to nullptr is allowed but will result in the 
   fields not being accessible from JavaScript.
 
   New handlers will get precedence over old handlers.
@@ -584,7 +584,7 @@ SoJavaScriptEngine::addHandler(const SoType & type,
 
   PRIVATE(this)->handlerList.append(handler);
 
-  if (handler.init != NULL) {
+  if (handler.init != nullptr) {
     handler.init(PRIVATE(this)->context, PRIVATE(this)->global);
   }
 }
diff --git a/coin4/src/misc/SoLightPath.cpp b/coin4/src/misc/SoLightPath.cpp
index 37e9d75..3f17aa9 100644
--- a/coin4/src/misc/SoLightPath.cpp
+++ b/coin4/src/misc/SoLightPath.cpp
@@ -47,7 +47,7 @@
   the path.
 */
 SoLightPath::SoLightPath(SoNode *headnodeptr, const int approxlength)
-  : headnode(NULL),
+  : headnode(nullptr),
     indices(approxlength)
 {
   this->setHead(headnodeptr);
@@ -57,7 +57,7 @@ SoLightPath::SoLightPath(SoNode *headnodeptr, const int approxlength)
   A constructor. Supply the appriximate length of the path.
 */
 SoLightPath::SoLightPath(const int approxlength)
-  : headnode(NULL),
+  : headnode(nullptr),
     indices(approxlength)
 {
 }
@@ -162,8 +162,8 @@ SoLightPath::getNode(const int index) const
   for (int i = 1; i < index; i++) {
     int childidx = this->indices[i];
     SoChildList *children = node->getChildren();
-    node = NULL;
-    if (children == NULL || childidx < 0 || childidx >= children->getLength()) break;
+    node = nullptr;
+    if (children == nullptr || childidx < 0 || childidx >= children->getLength()) break;
     node = (*children)[childidx];
   }
   return node;
@@ -215,7 +215,7 @@ SoLightPath::makeTempPath(SoTempPath *path) const
     int childidx = this->indices[i];
     // check validity of path, return if invalid
     SoChildList *children = node->getChildren();
-    if (children == NULL || childidx < 0 || childidx >= children->getLength()) break;
+    if (children == nullptr || childidx < 0 || childidx >= children->getLength()) break;
     node = (*children)[childidx];
     path->append(childidx); // childidx should be ok
   }
diff --git a/coin4/src/misc/SoLockManager.cpp b/coin4/src/misc/SoLockManager.cpp
index 8c68860..a764a39 100644
--- a/coin4/src/misc/SoLockManager.cpp
+++ b/coin4/src/misc/SoLockManager.cpp
@@ -48,18 +48,18 @@
 
 class SoLockManager_pimpl {
 public:
-  SoLockManager_pimpl(void) { this->unlockstr = NULL; }
+  SoLockManager_pimpl(void) { this->unlockstr = nullptr; }
   ~SoLockManager_pimpl() { delete this->unlockstr; }
 
   char * unlockstr;
 };
 
-static SoLockManager_pimpl * solockmanager_pimpl = NULL;
+static SoLockManager_pimpl * solockmanager_pimpl = nullptr;
 
 static void solockmanager_cleanup(void)
 {
   delete solockmanager_pimpl;
-  solockmanager_pimpl = NULL;
+  solockmanager_pimpl = nullptr;
 }
 
 /*!
@@ -90,5 +90,5 @@ SoLockManager::SetUnlockString(char * unlockstr)
 char *
 SoLockManager::GetUnlockString(void)
 {
-  return solockmanager_pimpl ? solockmanager_pimpl->unlockstr : NULL;
+  return solockmanager_pimpl ? solockmanager_pimpl->unlockstr : nullptr;
 }
diff --git a/coin4/src/misc/SoNormalGenerator.cpp b/coin4/src/misc/SoNormalGenerator.cpp
index c4d9116..a03afed 100644
--- a/coin4/src/misc/SoNormalGenerator.cpp
+++ b/coin4/src/misc/SoNormalGenerator.cpp
@@ -355,11 +355,11 @@ SoNormalGenerator::getNormals(void) const
 {
   if (!this->perVertex) {
     if (this->faceNormals.getLength()) return this->faceNormals.getArrayPtr();
-    return NULL;
+    return nullptr;
   }
   if (this->vertexNormals.getLength())
     return this->vertexNormals.getArrayPtr();
-  return NULL;
+  return nullptr;
 }
 
 /*!
diff --git a/coin4/src/misc/SoNotRec.cpp b/coin4/src/misc/SoNotRec.cpp
index ea6e449..ebc22bb 100644
--- a/coin4/src/misc/SoNotRec.cpp
+++ b/coin4/src/misc/SoNotRec.cpp
@@ -58,8 +58,8 @@
   Constructor. Initializes the record with \a notifbase pointer.
 */
 SoNotRec::SoNotRec(SoBase * const notifbase) :
-  type((SoNotRec::Type)-1), base(notifbase), prev(NULL), index(-1),
-  fieldNumIndices(0), operationType(UNSPECIFIED), groupChild(NULL), groupPrevChild(NULL)
+  type((SoNotRec::Type)-1), base(notifbase), prev(nullptr), index(-1),
+  fieldNumIndices(0), operationType(UNSPECIFIED), groupChild(nullptr), groupPrevChild(nullptr)
 {
 }
 
@@ -139,7 +139,7 @@ SoNotRec::print(FILE * const file) const
                   this->base->getName().getString());
   }
   else {
-    (void)fprintf(file," base is NULL\n");
+    (void)fprintf(file," base is nullptr\n");
   }
 #endif // COIN_DEBUG
 }
diff --git a/coin4/src/misc/SoNotification.cpp b/coin4/src/misc/SoNotification.cpp
index e5504d2..7780801 100644
--- a/coin4/src/misc/SoNotification.cpp
+++ b/coin4/src/misc/SoNotification.cpp
@@ -40,7 +40,7 @@
   Initialize list.
 */
 SoNotList::SoNotList(void) :
-  head(NULL), tail(NULL), firstnoderec(NULL), lastfield(NULL), lastengine(NULL),
+  head(nullptr), tail(nullptr), firstnoderec(nullptr), lastfield(nullptr), lastengine(nullptr),
   // this is used in SoNode::notify() to stop a notification
   // when a node has already been notified.
   stamp(SoNode::getNextNodeId())
@@ -70,7 +70,7 @@ SoNotList::append(SoNotRec * const rec)
                            rec->getBase()->getName().getString());
   }
   else {
-    SoDebugError::postInfo("SoNotList::append", "%p - %p (base is NULL)",
+    SoDebugError::postInfo("SoNotList::append", "%p - %p (base is nullptr)",
                            this, rec);
   }
 #endif // debug
@@ -124,7 +124,7 @@ SoNotList::setLastType(const SoNotRec::Type type)
   switch (type) {
   case SoNotRec::FIELD:
   case SoNotRec::ENGINE:
-    this->firstnoderec = NULL;
+    this->firstnoderec = nullptr;
   default:
     break;
   }
diff --git a/coin4/src/misc/SoPath.cpp b/coin4/src/misc/SoPath.cpp
index a658bb4..3df42e0 100644
--- a/coin4/src/misc/SoPath.cpp
+++ b/coin4/src/misc/SoPath.cpp
@@ -183,13 +183,13 @@ SoPath::setHead(SoNode * const node)
 }
 
 /*!
-  This method returns the head of the path, or \c NULL if the path is
+  This method returns the head of the path, or \c nullptr if the path is
   empty.
 */
 SoNode *
 SoPath::getHead(void) const
 {
-  if (this->getFullLength() == 0) return NULL;
+  if (this->getFullLength() == 0) return nullptr;
   return (SoNode *) this->nodes[0];
 }
 
@@ -305,7 +305,7 @@ SoPath::append(const SoPath * const frompath)
   SoChildList * tailchildren = tail->getChildren();
 
 #if COIN_DEBUG
-  if (tailchildren == NULL) {
+  if (tailchildren == nullptr) {
     SoDebugError::post("SoPath::append",
                        "The tail of this SoPath has no children node ('%s').\n",
                        tail->getTypeId().getName().getString());
@@ -348,7 +348,7 @@ has_hidden_children(const SoNode * node)
   assert(node);
 
   return
-    (node->getChildren() != NULL) &&
+    (node->getChildren() != nullptr) &&
     !node->isOfType(SoGroup::getClassTypeId());
 }
 
@@ -398,7 +398,7 @@ SoPath::getTail(void) const
 #if COIN_DEBUG
     SoDebugError::postWarning("SoPath::getTail", "empty path!");
 #endif // COIN_DEBUG
-    return NULL;
+    return nullptr;
   }
 
 #if COIN_DEBUG && 0 // debug
@@ -427,7 +427,7 @@ SoPath::getNode(const int index) const
   if (index < 0 || index >= this->getFullLength()) {
     SoDebugError::post("SoPath::getNode", "index %d is out of bounds.",
                        index);
-    return NULL;
+    return nullptr;
   }
 #endif // COIN_DEBUG
   return this->nodes[index];
@@ -444,7 +444,7 @@ SoPath::getNodeFromTail(const int index) const
   if (index < 0 || index >= this->getLength()) {
     SoDebugError::post("SoPath::getNodeFromTail",
                        "index %d is out of bounds.", index);
-    return NULL;
+    return nullptr;
   }
 #endif // COIN_DEBUG
   return this->nodes[this->getLength() - index - 1];
@@ -547,7 +547,7 @@ SoPath::truncate(const int length, const bool donotify)
     for (int l = 0; l < fp->getLength(); l++) {
       SoNode * n = fp->getNode(l);
       // FIXME: are there actually conditions where we can "legally" get
-      // a NULL pointer here? Or would that be an indication of an
+      // a nullptr pointer here? Or would that be an indication of an
       // internal error? 20020928 mortene.
       if (n) { n->assertAlive(); }
     }
@@ -703,7 +703,7 @@ SoPath::copy(const int startfromnodeindex, int numnodes) const
     SoDebugError::post("SoPath::copy",
                        "startfromnodeindex was out of bounds with %d.",
                        startfromnodeindex);
-    return NULL;
+    return nullptr;
   }
 #endif // COIN_DEBUG
   if (numnodes == 0) numnodes = this->getFullLength() - startfromnodeindex;
@@ -713,7 +713,7 @@ SoPath::copy(const int startfromnodeindex, int numnodes) const
       (startfromnodeindex + numnodes) > this->getFullLength()) {
     SoDebugError::post("SoPath::copy", "numnodes has invalid value %d",
                        numnodes);
-    return NULL;
+    return nullptr;
   }
 #endif // COIN_DEBUG
 
@@ -737,13 +737,13 @@ SoPath::copy(const int startfromnodeindex, int numnodes) const
 /*!
   This static method is for retrieving an SoPath by it's \a name.  The
   last registered SoPath with the given \a name is returned, or \c
-  NULL if no SoPath by \a name exists.
+  nullptr if no SoPath by \a name exists.
 */
 SoPath *
 SoPath::getByName(const SbName name)
 {
   SoBase * b = SoBase::getNamedBase(name, SoPath::getClassTypeId());
-  if (!b) return NULL;
+  if (!b) return nullptr;
   return (SoPath *)b;
 }
 
@@ -1150,7 +1150,7 @@ SoPath::setFirstHidden(void)
   const int nr = this->nodes.getLength();
   for (int i = 0; i < nr; i++) {
     const SoNode * n = this->nodes[i];
-    if (n == NULL) { continue; } // this is a valid case, for instance
+    if (n == nullptr) { continue; } // this is a valid case, for instance
                                  // if getLength() is called right
                                  // after SoAction::pushCurPath(void)
                                  // has been invoked
diff --git a/coin4/src/misc/SoPickedPoint.cpp b/coin4/src/misc/SoPickedPoint.cpp
index 2ac6018..6b56f47 100644
--- a/coin4/src/misc/SoPickedPoint.cpp
+++ b/coin4/src/misc/SoPickedPoint.cpp
@@ -51,7 +51,7 @@
 // this is not thread-safe, but creating a new matrix action for
 // each picked point is not very efficient.
 //
-static SoGetMatrixAction *matrixAction = NULL;
+static SoGetMatrixAction *matrixAction = nullptr;
 
 //
 //  Will be called at the end of program to free static memory
@@ -61,7 +61,7 @@ static
 void clean_class()
 {
   delete matrixAction;
-  matrixAction = NULL;
+  matrixAction = nullptr;
 }
 
 /*!
@@ -87,7 +87,7 @@ SoPickedPoint::SoPickedPoint(const SoPickedPoint &pp)
     if (pp.detailList[i])
       this->detailList.append(pp.detailList[i]->copy());
     else
-      this->detailList.append(NULL);
+      this->detailList.append(nullptr);
   }
 }
 
@@ -111,7 +111,7 @@ SoPickedPoint::SoPickedPoint(const SoPath * const pathptr, SoState * const state
 
   int pathlen = ((SoFullPath*)this->path)->getLength();
   for (int i = 0; i < pathlen; i++) {
-    this->detailList.append(NULL);
+    this->detailList.append(nullptr);
   }
 }
 
@@ -195,7 +195,7 @@ SoPickedPoint::isOnGeometry() const
 }
 
 /*!
-  Returns detail for \a node. If \a node equals NULL, the detail
+  Returns detail for \a node. If \a node equals nullptr, the detail
   for the picked object is returned.
 */
 const SoDetail *
@@ -203,12 +203,12 @@ SoPickedPoint::getDetail(const SoNode * const node) const
 {
   int idx = node ? this->path->findNode(node) :
     ((SoFullPath*)this->path)->getLength() - 1;
-  return idx >= 0 ? this->detailList[idx] : NULL;
+  return idx >= 0 ? this->detailList[idx] : nullptr;
 }
 
 /*!
   Returns the matrix which converts from object (specified by \a node)
-  to world space. If \a node equals NULL, the object space of the
+  to world space. If \a node equals nullptr, the object space of the
   picked object will used.
 */
 const SbMatrix &
@@ -220,7 +220,7 @@ SoPickedPoint::getObjectToWorld(const SoNode * const node) const
 
 /*!
   Returns the matrix which converts from world to object (specified
-  by \a node) space. If \a node equals NULL, the object space of the
+  by \a node) space. If \a node equals nullptr, the object space of the
   picked object will used.
 */
 const SbMatrix &
@@ -232,7 +232,7 @@ SoPickedPoint::getWorldToObject(const SoNode * const node) const
 
 /*!
   Returns the matrix which converts from object (specified by \a node)
-  to image space. If \a node equals NULL, the object space of the
+  to image space. If \a node equals nullptr, the object space of the
   picked object will used.
 */
 const SbMatrix &
@@ -244,7 +244,7 @@ SoPickedPoint::getObjectToImage(const SoNode * const node) const
 
 /*!
   Returns the matrix which converts from image to object (specified
-  by \a node) space. If \a node equals NULL, the object space of the
+  by \a node) space. If \a node equals nullptr, the object space of the
   picked object will used.
 */
 const SbMatrix &
@@ -256,7 +256,7 @@ SoPickedPoint::getImageToObject(const SoNode * const node) const
 
 /*!
   Returns the object space point, in the object space specified by \a
-  node. If \a node equals \c NULL, the object space of the node where
+  node. If \a node equals \c nullptr, the object space of the node where
   the point was actually picked will be used (this is what one would
   usually be interested in).
 
@@ -275,7 +275,7 @@ SoPickedPoint::getObjectPoint(const SoNode * const node) const
 
 /*!
   Returns the object space (specified by \a node) normal. If
-  \a node equals NULL, the picked point object space will
+  \a node equals nullptr, the picked point object space will
   be used.
 */
 SbVec3f
@@ -291,7 +291,7 @@ SoPickedPoint::getObjectNormal(const SoNode * const node) const
 
 /*!
   Returns the object space (specified by \a node) texture coordinates.
-  If \a node equals NULL, the picked point object space will be used.
+  If \a node equals nullptr, the picked point object space will be used.
 */
 SbVec4f
 SoPickedPoint::getObjectTextureCoords(const SoNode * const node) const
@@ -335,7 +335,7 @@ SoPickedPoint::setMaterialIndex(const int index)
 
 /*!
   Sets the detail for \a node. \a node must be in the picked
-  path, of course. Set to NULL if you want to remove a detail
+  path, of course. Set to nullptr if you want to remove a detail
   for a node.
 */
 void
@@ -349,7 +349,7 @@ SoPickedPoint::setDetail(SoDetail *detail, SoNode *node)
 }
 
 //
-// applies a matrix action to the path. Stops at node if != NULL
+// applies a matrix action to the path. Stops at node if != nullptr
 //
 void
 SoPickedPoint::applyMatrixAction(const SoNode * const node) const
@@ -376,7 +376,7 @@ SoPickedPoint::applyMatrixAction(const SoNode * const node) const
 SoGetMatrixAction *
 SoPickedPoint::getMatrixAction() const
 {
-  if (matrixAction == NULL) {
+  if (matrixAction == nullptr) {
     matrixAction = new SoGetMatrixAction(this->viewport);
     coin_atexit((coin_atexit_f *)clean_class, CC_ATEXIT_NORMAL);
   }
diff --git a/coin4/src/misc/SoPrimitiveVertex.cpp b/coin4/src/misc/SoPrimitiveVertex.cpp
index aae1184..7214305 100644
--- a/coin4/src/misc/SoPrimitiveVertex.cpp
+++ b/coin4/src/misc/SoPrimitiveVertex.cpp
@@ -44,7 +44,7 @@ SoPrimitiveVertex::SoPrimitiveVertex(void)
     normal(0.0f, 0.0f, 1.0f),
     textureCoords(0.0f, 0.0f, 0.0f, 1.0f),
     materialIndex(0),
-    detail(NULL),
+    detail(nullptr),
     packedColor(0)
 {
 }
@@ -126,7 +126,7 @@ SoPrimitiveVertex::~SoPrimitiveVertex()
   \fn const SoDetail * SoPrimitiveVertex::getDetail(void) const
 
   Returns pointer to detail instance with more information about the
-  vertex. A detail instance may not be available, and if so \c NULL is
+  vertex. A detail instance may not be available, and if so \c nullptr is
   returned.
 */
 
diff --git a/coin4/src/misc/SoProto.cpp b/coin4/src/misc/SoProto.cpp
index 54f550a..d3f25a0 100644
--- a/coin4/src/misc/SoProto.cpp
+++ b/coin4/src/misc/SoProto.cpp
@@ -107,8 +107,8 @@
 static SoType soproto_type;
 
 static SbList <SoProto*> * protolist;
-static SoFetchExternProtoCB * soproto_fetchextern_cb = NULL;
-static void * soproto_fetchextern_closure = NULL;
+static SoFetchExternProtoCB * soproto_fetchextern_cb = nullptr;
+static void * soproto_fetchextern_closure = nullptr;
 static void * soproto_mutex;
 
 // atexit callback
@@ -116,7 +116,7 @@ static void
 soproto_cleanup(void)
 {
   delete protolist;
-  protolist = NULL;
+  protolist = nullptr;
   CC_MUTEX_DESTRUCT(soproto_mutex);
 }
 
@@ -126,7 +126,7 @@ soproto_fetchextern_default_cb(SoInput * in,
                                const int numurls,
                                void * COIN_UNUSED_ARG(closure))
 {
-  if (numurls == 0) return NULL;
+  if (numurls == 0) return nullptr;
   SbString filename(urls[0]);
   SbString name("");
 
@@ -140,7 +140,7 @@ soproto_fetchextern_default_cb(SoInput * in,
   if (!in->pushFile(filename.getString())) {
     SoReadError::post(in, "Unable to find EXTERNPROTO file: ``%s''",
                       filename.getString());
-    return NULL;
+    return nullptr;
   }
 
   SoSeparator * root = SoDB::readAll(in);
@@ -163,11 +163,11 @@ soproto_fetchextern_default_cb(SoInput * in,
 
     SoReadError::post(in, "Unable to read EXTERNPROTO file: ``%s''",
                       filename.getString());
-    return NULL;
+    return nullptr;
   }
   else {
     root->ref();
-    SoProto * foundproto = NULL;
+    SoProto * foundproto = nullptr;
 
     SoSearchAction sa;
     sa.setType(SoProto::getClassTypeId());
@@ -180,7 +180,7 @@ soproto_fetchextern_default_cb(SoInput * in,
     if (pl.getLength() == 1) {
       foundproto = (SoProto*) pl[0]->getTail();
       if (name.getLength() && name != foundproto->getProtoName().getString()) {
-        foundproto = NULL;
+        foundproto = nullptr;
       }
     }
     else if (name.getLength()) {
@@ -201,7 +201,7 @@ soproto_fetchextern_default_cb(SoInput * in,
   }
 
   // just in case to fool stupid compilers
-  return NULL;
+  return nullptr;
 }
 
 // *************************************************************************
@@ -210,7 +210,7 @@ typedef SbHash<const char *, SoBase *> Name2SoBaseMap;
 
 class SoProtoP {
 public:
-  SoProtoP() : fielddata(NULL), defroot(NULL) { }
+  SoProtoP() : fielddata(nullptr), defroot(nullptr) { }
 
   SoFieldData * fielddata;
   SoGroup * defroot;
@@ -246,13 +246,13 @@ SoProto::initClass(void)
 {
   CC_MUTEX_CONSTRUCT(soproto_mutex);
   soproto_type = SoType::createType(SoNode::getClassTypeId(),
-                                    SbName("SoProto"), NULL,
+                                    SbName("SoProto"), nullptr,
                                     SoNode::nextActionMethodIndex++);
   protolist = new SbList<SoProto*>;
 
   coin_atexit((coin_atexit_f*) soproto_cleanup, CC_ATEXIT_NORMAL);
   // this will set a default callback
-  SoProto::setFetchExternProtoCallback(NULL, NULL);
+  SoProto::setFetchExternProtoCallback(nullptr, nullptr);
 }
 
 #define PRIVATE(obj) ((obj)->pimpl)
@@ -263,14 +263,14 @@ SoProto::initClass(void)
 SoProto::SoProto(const bool externproto)
 {
   PRIVATE(this) = new SoProtoP;
-  PRIVATE(this)->externurl = NULL;
+  PRIVATE(this)->externurl = nullptr;
   if (externproto) {
     PRIVATE(this)->externurl = new SoMFString;
   }
   PRIVATE(this)->fielddata = new SoFieldData;
   PRIVATE(this)->defroot = new SoGroup;
   PRIVATE(this)->defroot->ref();
-  PRIVATE(this)->extprotonode = NULL;
+  PRIVATE(this)->extprotonode = nullptr;
 
   CC_MUTEX_LOCK(soproto_mutex);
   protolist->insert(this, 0);
@@ -300,9 +300,9 @@ void
 SoProto::setFetchExternProtoCallback(SoFetchExternProtoCB * cb,
                                      void * closure)
 {
-  if (cb == NULL) {
+  if (cb == nullptr) {
     soproto_fetchextern_cb = soproto_fetchextern_default_cb;
-    soproto_fetchextern_closure = NULL;
+    soproto_fetchextern_closure = nullptr;
   }
   else {
     soproto_fetchextern_cb = cb;
@@ -311,17 +311,17 @@ SoProto::setFetchExternProtoCallback(SoFetchExternProtoCB * cb,
 }
 
 /*!
-  Returns the PROTO definition named \a name or NULL if not found.
+  Returns the PROTO definition named \a name or nullptr if not found.
 */
 SoProto *
 SoProto::findProto(const SbName & name)
 {
-  SoProto * ret = NULL;
+  SoProto * ret = nullptr;
   CC_MUTEX_LOCK(soproto_mutex);
   if (protolist) {
     const int n = protolist->getLength();
     SoProto * const * ptr = protolist->getArrayPtr();
-    for (int i = 0; (ret == NULL) && (i < n); i++) {
+    for (int i = 0; (ret == nullptr) && (i < n); i++) {
       if (ptr[i]->getProtoName() == name) ret = ptr[i];
     }
   }
@@ -379,7 +379,7 @@ SoProto::readInstance(SoInput * in, unsigned short COIN_UNUSED_ARG(flags))
                                                PRIVATE(this)->externurl->getValues(0),
                                                PRIVATE(this)->externurl->getNum(),
                                                soproto_fetchextern_closure);
-      if (proto == NULL) {
+      if (proto == nullptr) {
         SoReadError::post(in, "Error reading EXTERNPROTO definition.");
         ok = false;
       }
@@ -671,7 +671,7 @@ SoProto::findReference(const SbName & name) const
   SoBase * base;
 
   if (PRIVATE(this)->refdict.get(name.getString(), base)) { return base; }
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -693,7 +693,7 @@ SoProto::addRoute(const SbName & fromnode, const SbName & fromfield,
 bool
 SoProto::readInterface(SoInput * in)
 {
-  bool ok = PRIVATE(this)->fielddata->readFieldDescriptions(in, this, 4, PRIVATE(this)->externurl == NULL);
+  bool ok = PRIVATE(this)->fielddata->readFieldDescriptions(in, this, 4, PRIVATE(this)->externurl == nullptr);
   if ( ok ) {
     const int numfields = PRIVATE(this)->fielddata->getNumFields();
     for (int i = 0; i < numfields; i++) {
@@ -721,7 +721,7 @@ SoProto::readDefinition(SoInput * in)
   while (ok) {
     ok = SoBase::read(in, child, SoNode::getClassTypeId());
     if (ok) {
-      if (child == NULL) {
+      if (child == nullptr) {
         if (in->eof()) {
           ok = false;
           SoReadError::post(in, "Premature end of file");
@@ -747,7 +747,7 @@ soproto_find_node(SoNode * root, SbName name, SoSearchAction & sa)
 
   sa.apply(root);
 
-  SoNode * ret = NULL;
+  SoNode * ret = nullptr;
 
   if (sa.getPath()) {
     ret = ((SoFullPath*)sa.getPath())->getTail();
@@ -867,8 +867,8 @@ SoProto::createInstanceRoot(SoProtoInstance * inst) const
     if (fromnode && tonode) {
       SoField * from = soproto_find_field(fromnode, fromfieldname);
       SoField * to = soproto_find_field(tonode, tofieldname);
-      SoEngineOutput * output = NULL;
-      if (from == NULL && fromnode->isOfType(SoNodeEngine::getClassTypeId())) {
+      SoEngineOutput * output = nullptr;
+      if (from == nullptr && fromnode->isOfType(SoNodeEngine::getClassTypeId())) {
         output = ((SoNodeEngine*) fromnode)->getOutput(fromfieldname);
       }
 
@@ -907,10 +907,10 @@ SoProto::createInstanceRoot(SoProtoInstance * inst) const
 static SoNode *
 locate_node_copy(SoNode * searchfor, SoNode * org, SoNode * cpy)
 {
-  if (org == NULL) return NULL;
-  if (cpy == NULL) return NULL;
+  if (org == nullptr) return nullptr;
+  if (cpy == nullptr) return nullptr;
 
-  if (org->getTypeId() != cpy->getTypeId()) return NULL;
+  if (org->getTypeId() != cpy->getTypeId()) return nullptr;
   if (org == searchfor) return cpy;
 
   const SoFieldData * fd = org->getFieldData();
@@ -923,7 +923,7 @@ locate_node_copy(SoNode * searchfor, SoNode * org, SoNode * cpy)
     // should never happen (in theory)
     SoDebugError::postWarning("SoProto::locate_node_copy",
                               "SoFieldData mismatch in PROTO scene.");
-    return NULL;
+    return nullptr;
   }
 
   int i;
@@ -933,7 +933,7 @@ locate_node_copy(SoNode * searchfor, SoNode * org, SoNode * cpy)
     SoField * orgf = fd->getField(org, i);
     if (orgf->getTypeId() == sosftype) {
       SoNode * orgnode = ((SoSFNode*) orgf)->getValue();
-      if (orgnode != NULL) {
+      if (orgnode != nullptr) {
         SoField * cpyf = fd2->getField(cpy, i);
         if (cpyf->getTypeId() == sosftype) {
           SoNode * found = locate_node_copy(searchfor, orgnode, ((SoSFNode*) cpyf)->getValue());
@@ -942,7 +942,7 @@ locate_node_copy(SoNode * searchfor, SoNode * org, SoNode * cpy)
         else {
           SoDebugError::postWarning("SoProto::locate_node_copy",
                                     "SoField mismatch in PROTO scene.");
-          return NULL;
+          return nullptr;
         }
       }
     }
@@ -957,7 +957,7 @@ locate_node_copy(SoNode * searchfor, SoNode * org, SoNode * cpy)
       if (found) return found;
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 
@@ -981,7 +981,7 @@ SoProto::connectISRefs(SoProtoInstance * inst, SoNode * src, SoNode * dst) const
     SbName fieldname = PRIVATE(this)->isfieldlist[i];
     fieldname = soproto_find_fieldname(node, fieldname);
     SoField * dstfield = node->getField(fieldname);
-    SoEngineOutput * eventout = NULL;
+    SoEngineOutput * eventout = nullptr;
 
     if (!dstfield) {
       if (node->isOfType(SoNodeEngine::getClassTypeId())) {
@@ -1071,7 +1071,7 @@ SoProto::connectISRefs(SoProtoInstance * inst, SoNode * src, SoNode * dst) const
     }
     else {
       assert(dstfield);
-      SoEngineOutput * output = NULL;
+      SoEngineOutput * output = nullptr;
       if (inst->isOfType(SoNodeEngine::getClassTypeId())) {
         output = ((SoNodeEngine*) inst)->getOutput(iname);
       }
diff --git a/coin4/src/misc/SoProtoInstance.cpp b/coin4/src/misc/SoProtoInstance.cpp
index 0db8536..0366af4 100644
--- a/coin4/src/misc/SoProtoInstance.cpp
+++ b/coin4/src/misc/SoProtoInstance.cpp
@@ -54,9 +54,9 @@
 class SoProtoInstanceP {
 public:
   SoProtoInstanceP() :
-    fielddata(NULL),
-    protodef(NULL),
-    root(NULL)
+    fielddata(nullptr),
+    protodef(nullptr),
+    root(nullptr)
   { }
 
   SoFieldData * fielddata;
@@ -93,7 +93,7 @@ SoProtoInstance::initClass(void)
   SoProtoInstance::classTypeId =
     SoType::createType(inherited::getClassTypeId(),
                        "ProtoInstance",
-                       NULL,
+                       nullptr,
                        SoNode::nextActionMethodIndex++);
 
   protoinstance_dict = new SoNode2SoProtoInstanceMap;
@@ -129,7 +129,7 @@ SoProtoInstance::SoProtoInstance(SoProto * proto,
 */
 SoProtoInstance::~SoProtoInstance()
 {
-  this->setRootNode(NULL);
+  this->setRootNode(nullptr);
   const int n = PRIVATE(this)->fielddata->getNumFields();
   for (int i = 0; i < n; i++) {
     delete PRIVATE(this)->fielddata->getField(this, i);
@@ -225,7 +225,7 @@ SoProtoInstance::getFileFormatName(void) const
 }
 
 /*!
-  Given root node \a rootnode, return the PROTO instance, or NULL if
+  Given root node \a rootnode, return the PROTO instance, or nullptr if
   \a rootnode is not a PROTO instance root node.
 */
 SoProtoInstance *
@@ -233,7 +233,7 @@ SoProtoInstance::findProtoInstance(const SoNode * rootnode)
 {
   SoProtoInstance * ret;
   CC_MUTEX_LOCK(protoinstance_mutex);
-  if (!protoinstance_dict->get(rootnode, ret)) { ret = NULL; }
+  if (!protoinstance_dict->get(rootnode, ret)) { ret = nullptr; }
   CC_MUTEX_UNLOCK(protoinstance_mutex);
   return ret;
 }
@@ -268,7 +268,7 @@ SoProtoInstance::sensorCB(void * data, SoSensor *)
 {
   // not used anymore. ProtoInstance is unref'ed from SoNode destructor
   SoProtoInstance * thisp = (SoProtoInstance*) data;
-  thisp->setRootNode(NULL);
+  thisp->setRootNode(nullptr);
   thisp->unref();
 }
 
diff --git a/coin4/src/misc/SoSceneManager.cpp b/coin4/src/misc/SoSceneManager.cpp
index 171850c..e87767f 100644
--- a/coin4/src/misc/SoSceneManager.cpp
+++ b/coin4/src/misc/SoSceneManager.cpp
@@ -93,11 +93,11 @@ SoSceneManager::SoSceneManager(void)
 
   PRIVATE(this) = new SoSceneManagerP(this);
 
-  PRIVATE(this)->rendercb = NULL;
-  PRIVATE(this)->rendercbdata = NULL;
+  PRIVATE(this)->rendercb = nullptr;
+  PRIVATE(this)->rendercbdata = nullptr;
 
-  PRIVATE(this)->scene = NULL;
-  PRIVATE(this)->camera = NULL;
+  PRIVATE(this)->scene = nullptr;
+  PRIVATE(this)->camera = nullptr;
 
   PRIVATE(this)->rendermanager = new SoRenderManager;
   PRIVATE(this)->eventmanager = new SoEventManager;
@@ -110,7 +110,7 @@ SoSceneManager::SoSceneManager(void)
  */
 SoSceneManager::~SoSceneManager()
 {
-  this->setSceneGraph(NULL);
+  this->setSceneGraph(nullptr);
   
   if (PRIVATE(this)->camera) PRIVATE(this)->camera->unref();
 
@@ -261,7 +261,7 @@ SoSceneManager::setSceneGraph(SoNode * const sceneroot)
     PRIVATE(this)->scene->ref();
     this->setCamera(PRIVATE(this)->searchForCamera(PRIVATE(this)->scene));
   } else {
-    this->setCamera(NULL);
+    this->setCamera(nullptr);
   }
   
   if (oldroot) oldroot->unref();
@@ -495,7 +495,7 @@ SoSceneManager::setRenderCallback(SoSceneManagerRenderCB * f,
   scene upon detecting changes in the scene graph.
 
   The automatic redraw is turned on and off by setting either a valid
-  callback function with setRenderCallback(), or by passing \c NULL.
+  callback function with setRenderCallback(), or by passing \c nullptr.
  */
 bool
 SoSceneManager::isAutoRedraw(void) const
diff --git a/coin4/src/misc/SoSceneManagerP.h b/coin4/src/misc/SoSceneManagerP.h
index ce7de72..5f73141 100644
--- a/coin4/src/misc/SoSceneManagerP.h
+++ b/coin4/src/misc/SoSceneManagerP.h
@@ -37,7 +37,7 @@ public:
   ~SoSceneManagerP();
 
   SoCamera * searchForCamera(SoNode * root,
-                             SoCamera * defcamera = NULL);
+                             SoCamera * defcamera = nullptr);
   static void renderCB(void * userdata, class SoRenderManager * mgr);
 
   SoCamera * camera;
diff --git a/coin4/src/misc/SoState.cpp b/coin4/src/misc/SoState.cpp
index b26eb0f..d6c2d29 100644
--- a/coin4/src/misc/SoState.cpp
+++ b/coin4/src/misc/SoState.cpp
@@ -94,7 +94,7 @@
 class sostate_pushstore {
 public:
   sostate_pushstore(void) {
-    this->next = this->prev = NULL;
+    this->next = this->prev = nullptr;
   }
   SbList <int> elements;
   sostate_pushstore * next;
@@ -144,8 +144,8 @@ SoState::SoState(SoAction * theAction, const SoTypeList & enabledelements)
   PRIVATE(this)->initial = new SoElement * [this->numstacks];
 
   for (i = 0; i < this->numstacks; i++) {
-    PRIVATE(this)->initial[i] = NULL;
-    this->stack[i] = NULL;
+    PRIVATE(this)->initial[i] = nullptr;
+    this->stack[i] = nullptr;
   }
 
   const int numelements = enabledelements.getLength();
@@ -222,7 +222,7 @@ SoState::getElement(const int stackindex)
   // time debugging it, pederb, 2007-08-01)
   assert(!PRIVATE(this)->ispopping);
 
-  if (!this->isElementEnabled(stackindex)) return NULL;
+  if (!this->isElementEnabled(stackindex)) return nullptr;
   SoElement * element = this->stack[stackindex];
 
 #if 0 // debug
@@ -264,7 +264,7 @@ SoState::getElement(const int stackindex)
 void
 SoState::push(void)
 {
-  if (PRIVATE(this)->pushstore->next == NULL) {
+  if (PRIVATE(this)->pushstore->next == nullptr) {
     sostate_pushstore * store = new sostate_pushstore;
     store->prev = PRIVATE(this)->pushstore;
     PRIVATE(this)->pushstore->next = store;
@@ -313,7 +313,7 @@ SoState::print(FILE * const file) const
   fprintf(file, "  enabled elements {\n");
   for (int i = 0; i < this->numstacks; i++) {
     SoElement * element;
-    if ((element = this->stack[i]) != NULL)
+    if ((element = this->stack[i]) != nullptr)
       fprintf(file, "    %s\n",
                element->getTypeId().getName().getString());
   }
diff --git a/coin4/src/misc/SoType.cpp b/coin4/src/misc/SoType.cpp
index 998c0cb..c0f48cf 100644
--- a/coin4/src/misc/SoType.cpp
+++ b/coin4/src/misc/SoType.cpp
@@ -123,7 +123,6 @@
 #include <Inventor/SoType.h>
 
 #include <assert.h>
-#include <stdlib.h> // NULL
 #include <string.h> // strcmp()
 #include <cctype>   // toupper()
 
@@ -156,7 +155,7 @@ struct SoTypeData {
              const bool ispublic = false,
              const uint16_t theData = 0,
              const SoType theParent = SoType::badType(),
-             const SoType::instantiationMethod createMethod = NULL)
+             const SoType::instantiationMethod createMethod = nullptr)
     : name(theName), type(type), isPublic(ispublic), data(theData),
       parent(theParent), method(createMethod) { };
 
@@ -181,19 +180,19 @@ template class SbList<SoTypeData *>;
 // *************************************************************************
 
 // list of SoType internal data structures, indexed over SoType 'data' id.
-SbList<SoTypeData *> * SoType::typedatalist = NULL;
+SbList<SoTypeData *> * SoType::typedatalist = nullptr;
 
 // hash map from type name to SoType 'data' id.
 typedef SbHash<const char *, int16_t> Name2IdMap;
-static Name2IdMap * type_dict = NULL;
+static Name2IdMap * type_dict = nullptr;
 
 // hash map from type name to handle for dynamically loaded library
 typedef SbHash<const char *, cc_libhandle> Name2HandleMap;
-static Name2HandleMap * module_dict = NULL;
+static Name2HandleMap * module_dict = nullptr;
 
 // hash map for flagging all the shared library names we have tried
 typedef SbHash<const char *, void *> NameMap;
-static NameMap * dynload_tries = NULL;
+static NameMap * dynload_tries = nullptr;
 
 // *************************************************************************
 
@@ -222,7 +221,7 @@ SoType::init(void)
 
   // If any of these assert fails, it is probably because
   // SoType::init() has been called for a second time. --mortene
-  assert(SoType::typedatalist == NULL);
+  assert(SoType::typedatalist == nullptr);
 
   SoType::typedatalist = new SbList<SoTypeData *>;
   type_dict = new Name2IdMap;
@@ -241,13 +240,13 @@ SoType::clean(void)
   const int num = SoType::typedatalist->getLength();
   for (int i = 0; i < num; i++) delete (*SoType::typedatalist)[i];
   delete SoType::typedatalist;
-  SoType::typedatalist = NULL;
+  SoType::typedatalist = nullptr;
   delete dynload_tries;
-  dynload_tries = NULL;
+  dynload_tries = nullptr;
   delete type_dict;
-  type_dict = NULL;
+  type_dict = nullptr;
   delete module_dict;
-  module_dict = NULL;
+  module_dict = nullptr;
 }
 
 /*!
@@ -255,7 +254,7 @@ SoType::clean(void)
 
   Classes that do not inherit any other class should use
   SoType::badType() for the first argument. Abstract classes should
-  use \c NULL for the \a method argument.
+  use \c nullptr for the \a method argument.
 
   The value passed in for the \a data parameter can be retrieved with
   SoType::getData().
@@ -317,7 +316,7 @@ SoType::removeType(const SbName & name)
 
   type_dict->erase(name.getString());
   SoTypeData *typedata = (*SoType::typedatalist)[index];
-  (*SoType::typedatalist)[index] = NULL;
+  (*SoType::typedatalist)[index] = nullptr;
   delete typedata;
 
 #if COIN_DEBUG && 0 // debug
@@ -334,7 +333,7 @@ SoType::removeType(const SbName & name)
   The new type should be a C++ subclass of the original class type, but
   this won't be checked though.
 
-  If \c NULL is passed as the second argument, the type will be
+  If \c nullptr is passed as the second argument, the type will be
   considered uninstantiable -- it does not revert the configuration to
   the default setting as one might think.
 
@@ -507,7 +506,7 @@ SoType::fromName(const SbName name)
     if (env && atoi(env) > 0) enable_dynload = false;
   }
 
-  assert((type_dict != NULL) && "SoType static class data not yet initialized");
+  assert((type_dict != nullptr) && "SoType static class data not yet initialized");
 
   // It should be possible to specify a type name with the "So" prefix
   // and get the correct type id, even though the types in some type
@@ -527,7 +526,7 @@ SoType::fromName(const SbName name)
 
       // find out which C++ name mangling scheme the compiler uses
       static mangleFunc * manglefunc = getManglingFunction();
-      if ( manglefunc == NULL ) {
+      if ( manglefunc == nullptr ) {
         // dynamic loading is not yet supported for this compiler suite
         static long first = 1;
         if ( first ) {
@@ -542,12 +541,12 @@ SoType::fromName(const SbName name)
       }
       SbString mangled = manglefunc(name.getString());
 
-      if ( module_dict == NULL ) {
+      if ( module_dict == nullptr ) {
         module_dict = new Name2HandleMap;
       }
 
       // FIXME: should we search the application code for the initClass()
-      // symbol first?  dlopen(NULL) might not be portable enough, but it
+      // symbol first?  dlopen(nullptr) might not be portable enough, but it
       // could be a cool feature.  20030223 larsa
 
       // FIXME: We probably should use loadable modules (type MH_BUNDLE)
@@ -559,13 +558,13 @@ SoType::fromName(const SbName name)
 
       static const char * modulenamepatterns[] = {
         "%s.so", "lib%s.so", "%s.dll", "lib%s.dll", "%s.dylib", "lib%s.dylib",
-        NULL
+        nullptr
       };
 
       SbString modulenamestring;
-      cc_libhandle handle = NULL;
+      cc_libhandle handle = nullptr;
       int i;
-      for ( i = 0; (modulenamepatterns[i] != NULL) && (handle == NULL); i++ ) {
+      for ( i = 0; (modulenamepatterns[i] != nullptr) && (handle == nullptr); i++ ) {
         modulenamestring.sprintf(modulenamepatterns[i], name.getString());
 
         // We need to move the name string to an SbName since we use
@@ -575,13 +574,13 @@ SoType::fromName(const SbName name)
 
         // Register all the module names we have tried so we don't try
         // them again.
-        if (dynload_tries == NULL) dynload_tries = new NameMap;
+        if (dynload_tries == nullptr) dynload_tries = new NameMap;
         void * dummy;
         if (dynload_tries->get(module.getString(), dummy))
           continue; // already tried
-        dynload_tries->put(module.getString(), NULL);
+        dynload_tries->put(module.getString(), nullptr);
 
-        cc_libhandle idx = NULL;
+        cc_libhandle idx = nullptr;
         if ( module_dict->get(module.getString(), idx) ) {
           // Module has been loaded, but type is not yet finished initializing.
           // SoType::badType() is here the expected return value.  See below.
@@ -592,7 +591,7 @@ SoType::fromName(const SbName name)
         // instead of the LD_LIBRARY_PATH one?  20020216 larsa
 
         handle = cc_dl_open(module.getString());
-        if ( handle != NULL ) {
+        if ( handle != nullptr ) {
           // We register the module so we don't recurse infinitely in the
           // initClass() function which calls SoType::fromName() on itself
           // which expects SoType::badType() in return.  See above.
@@ -608,12 +607,12 @@ SoType::fromName(const SbName name)
         }
       }
 
-      if ( handle == NULL ) return SoType::badType();
+      if ( handle == nullptr ) return SoType::badType();
 
       // find and invoke the initClass() function.
       // FIXME: declspec stuff
       initClassFunction * initClass = (initClassFunction *) cc_dl_sym(handle, mangled.getString());
-      if ( initClass == NULL ) {
+      if ( initClass == nullptr ) {
         // FIXME: if a module is found and opened and initialization
         // fails, the remaining module name patterns are not tried.
         // might trigger as a problem one day...  2030224 larsa
@@ -828,13 +827,13 @@ SoType::getAllDerivedFrom(const SoType type, SoTypeList & list)
 bool
 SoType::canCreateInstance(void) const
 {
-  return ((*SoType::typedatalist)[(int)this->getKey()]->method != NULL);
+  return ((*SoType::typedatalist)[(int)this->getKey()]->method != nullptr);
 }
 
 /*!
   This method instantiates an object of the current type.
 
-  For types that can not be instantiated, \c NULL is returned.
+  For types that can not be instantiated, \c nullptr is returned.
 
   \DANGEROUS_ALLOC_RETURN
 
@@ -855,7 +854,7 @@ SoType::createInstance(void) const
                               " use SoType::canCreateInstance()",
                               this->getName().getString());
 #endif // COIN_DEBUG
-    return NULL;
+    return nullptr;
   }
 }
 
diff --git a/coin4/src/misc/cppmangle.icc b/coin4/src/misc/cppmangle.icc
index b1f5c19..b61a530 100644
--- a/coin4/src/misc/cppmangle.icc
+++ b/coin4/src/misc/cppmangle.icc
@@ -32,7 +32,7 @@ static
 SbString
 gcc2_initClassMangling(const char * classname)
 {
-  assert(classname != NULL);
+  assert(classname != nullptr);
   const size_t len = strlen(classname);
   SbString mangling;
   mangling.sprintf("initClass__%d%s", len, classname);
@@ -48,7 +48,7 @@ static
 SbString
 gcc3_initClassMangling(const char * classname)
 {
-  assert(classname != NULL);
+  assert(classname != nullptr);
   const size_t len = strlen(classname);
   SbString mangling;
   mangling.sprintf("_ZN%d%s9initClassEv", len, classname);
@@ -65,7 +65,7 @@ static
 SbString
 msvc6_initClassMangling(const char * classname)
 {
-  assert(classname != NULL);
+  assert(classname != nullptr);
   SbString mangling;
   mangling.sprintf("?initClass@%s@@SAXXZ", classname);
   return mangling;
@@ -80,7 +80,7 @@ static
 SbString
 MIPSpro_CC_initClassMangling(const char * classname)
 {
-  assert(classname != NULL);
+  assert(classname != nullptr);
   const size_t len = strlen(classname);
   SbString mangling;
   mangling.sprintf("initClass__%d%sSGv", len, classname);
@@ -98,7 +98,7 @@ static
 SbString
 HPUX_aCC_initClassMangling(const char * classname)
 {
-  assert(classname != NULL);
+  assert(classname != nullptr);
   const size_t len = strlen(classname);
   SbString mangling;
   mangling.sprintf("initClass__%d%sSFv", len, classname);
@@ -116,7 +116,7 @@ static
 SbString
 sunCC_initClassMangling(const char * classname)
 {
-  assert(classname != NULL);
+  assert(classname != nullptr);
   size_t len = strlen(classname);
   SbString mangling;
   SbString mangled_len;
@@ -153,11 +153,11 @@ static mangleFunc * manglefunctions[] = {
   msvc6_initClassMangling,
   MIPSpro_CC_initClassMangling,
   sunCC_initClassMangling,
-  (mangleFunc *)NULL
+  (mangleFunc *)nullptr
 };
 
 /*
-  return the correct name mangling function, or NULL in case none seem
+  return the correct name mangling function, or nullptr in case none seem
   appropriate
 */
 
@@ -166,13 +166,13 @@ mangleFunc *
 getManglingFunction(void)
 {
   static bool initialized = false;
-  static mangleFunc * manglefunc = NULL;
+  static mangleFunc * manglefunc = nullptr;
   if (!initialized) {
     initialized = true;
     int i;
-    cc_libhandle handle = cc_dl_open(NULL);
-    if (handle == NULL) goto failure;
-    for (i = 0; (manglefunctions[i] != NULL) && (manglefunc == NULL); i++) {
+    cc_libhandle handle = cc_dl_open(nullptr);
+    if (handle == nullptr) goto failure;
+    for (i = 0; (manglefunctions[i] != nullptr) && (manglefunc == nullptr); i++) {
       mangleFunc * attempt = manglefunctions[i];
       SbString symbol(attempt("SoBase"));
       if (cc_dl_sym(handle, symbol.getString())) {
@@ -180,12 +180,12 @@ getManglingFunction(void)
       }
     }
     cc_dl_close(handle);
-    if (manglefunc == NULL) { goto failure; }
+    if (manglefunc == nullptr) { goto failure; }
   }
   return manglefunc;
 failure:
 #ifdef _MSC_VER
-  // LoadLibrary(NULL) doesn't work, so we fall-back on the MSVC++ mangling
+  // LoadLibrary(nullptr) doesn't work, so we fall-back on the MSVC++ mangling
   // scheme on MS Windows.
   manglefunc = msvc6_initClassMangling;
 #endif
diff --git a/coin4/src/navigation/SoCameraUtils.cpp b/coin4/src/navigation/SoCameraUtils.cpp
index 3f5ea3c..c42d93b 100644
--- a/coin4/src/navigation/SoCameraUtils.cpp
+++ b/coin4/src/navigation/SoCameraUtils.cpp
@@ -102,7 +102,7 @@ SoCameraManager::createFor(SoCamera * camera)
   assert(camera);
 
   // FIXME: need to be able to instantiate an appdomain orthographic camera as well
-  SoCameraManager * manager = NULL;
+  SoCameraManager * manager = nullptr;
   if (camera->isOfType(SoPerspectiveCamera::getClassTypeId())) {
     manager = new SoPerspectiveCameraManager(camera);
   }
@@ -135,7 +135,7 @@ SoCameraManager::SoCameraManager(SoCamera * thecamera)
 SoCameraManager::~SoCameraManager(void)
 {
   camera->unref();
-  camera = NULL;
+  camera = nullptr;
 }
 
 void
diff --git a/coin4/src/navigation/SoScXMLDollyTarget.cpp b/coin4/src/navigation/SoScXMLDollyTarget.cpp
index 231101b..90264ce 100644
--- a/coin4/src/navigation/SoScXMLDollyTarget.cpp
+++ b/coin4/src/navigation/SoScXMLDollyTarget.cpp
@@ -161,12 +161,12 @@ SoScXMLDollyTarget::cleanClass(void)
   SoScXMLDollyTarget::classTypeId = SoType::badType();
 }
 
-SoScXMLDollyTarget * SoScXMLDollyTarget::theSingleton = NULL;
+SoScXMLDollyTarget * SoScXMLDollyTarget::theSingleton = nullptr;
 
 SoScXMLDollyTarget *
 SoScXMLDollyTarget::constructSingleton(void)
 {
-  assert(SoScXMLDollyTarget::theSingleton == NULL);
+  assert(SoScXMLDollyTarget::theSingleton == nullptr);
   SoScXMLDollyTarget::theSingleton =
     static_cast<SoScXMLDollyTarget *>(SoScXMLDollyTarget::classTypeId.createInstance());
   return SoScXMLDollyTarget::theSingleton;
@@ -175,15 +175,15 @@ SoScXMLDollyTarget::constructSingleton(void)
 void
 SoScXMLDollyTarget::destructSingleton(void)
 {
-  assert(SoScXMLDollyTarget::theSingleton != NULL);
+  assert(SoScXMLDollyTarget::theSingleton != nullptr);
   delete SoScXMLDollyTarget::theSingleton;
-  SoScXMLDollyTarget::theSingleton = NULL;
+  SoScXMLDollyTarget::theSingleton = nullptr;
 }
 
 SoScXMLDollyTarget *
 SoScXMLDollyTarget::singleton(void)
 {
-  assert(SoScXMLDollyTarget::theSingleton != NULL);
+  assert(SoScXMLDollyTarget::theSingleton != nullptr);
   return SoScXMLDollyTarget::theSingleton;
 }
 
diff --git a/coin4/src/navigation/SoScXMLFlightControlTarget.cpp b/coin4/src/navigation/SoScXMLFlightControlTarget.cpp
index 82b8229..e823877 100644
--- a/coin4/src/navigation/SoScXMLFlightControlTarget.cpp
+++ b/coin4/src/navigation/SoScXMLFlightControlTarget.cpp
@@ -89,12 +89,12 @@ SoScXMLFlightControlTarget::cleanClass(void)
   SoScXMLFlightControlTarget::classTypeId = SoType::badType();
 }
 
-SoScXMLFlightControlTarget * SoScXMLFlightControlTarget::theSingleton = NULL;
+SoScXMLFlightControlTarget * SoScXMLFlightControlTarget::theSingleton = nullptr;
 
 SoScXMLFlightControlTarget *
 SoScXMLFlightControlTarget::constructSingleton(void)
 {
-  assert(SoScXMLFlightControlTarget::theSingleton == NULL);
+  assert(SoScXMLFlightControlTarget::theSingleton == nullptr);
   SoScXMLFlightControlTarget::theSingleton =
     static_cast<SoScXMLFlightControlTarget *>(SoScXMLFlightControlTarget::classTypeId.createInstance());
   return SoScXMLFlightControlTarget::theSingleton;
@@ -103,15 +103,15 @@ SoScXMLFlightControlTarget::constructSingleton(void)
 void
 SoScXMLFlightControlTarget::destructSingleton(void)
 {
-  assert(SoScXMLFlightControlTarget::theSingleton != NULL);
+  assert(SoScXMLFlightControlTarget::theSingleton != nullptr);
   delete SoScXMLFlightControlTarget::theSingleton;
-  SoScXMLFlightControlTarget::theSingleton = NULL;
+  SoScXMLFlightControlTarget::theSingleton = nullptr;
 }
 
 SoScXMLFlightControlTarget *
 SoScXMLFlightControlTarget::singleton(void)
 {
-  assert(SoScXMLFlightControlTarget::theSingleton != NULL);
+  assert(SoScXMLFlightControlTarget::theSingleton != nullptr);
   return SoScXMLFlightControlTarget::theSingleton;
 }
 
diff --git a/coin4/src/navigation/SoScXMLMiscTarget.cpp b/coin4/src/navigation/SoScXMLMiscTarget.cpp
index c05a3f3..21ad403 100644
--- a/coin4/src/navigation/SoScXMLMiscTarget.cpp
+++ b/coin4/src/navigation/SoScXMLMiscTarget.cpp
@@ -83,12 +83,12 @@ SoScXMLMiscTarget::cleanClass(void)
   SoScXMLMiscTarget::classTypeId = SoType::badType();
 }
 
-SoScXMLMiscTarget * SoScXMLMiscTarget::theSingleton = NULL;
+SoScXMLMiscTarget * SoScXMLMiscTarget::theSingleton = nullptr;
 
 SoScXMLMiscTarget *
 SoScXMLMiscTarget::constructSingleton(void)
 {
-  assert(SoScXMLMiscTarget::theSingleton == NULL);
+  assert(SoScXMLMiscTarget::theSingleton == nullptr);
   SoScXMLMiscTarget::theSingleton =
     static_cast<SoScXMLMiscTarget *>(SoScXMLMiscTarget::classTypeId.createInstance());
   return SoScXMLMiscTarget::theSingleton;
@@ -97,15 +97,15 @@ SoScXMLMiscTarget::constructSingleton(void)
 void
 SoScXMLMiscTarget::destructSingleton(void)
 {
-  assert(SoScXMLMiscTarget::theSingleton != NULL);
+  assert(SoScXMLMiscTarget::theSingleton != nullptr);
   delete SoScXMLMiscTarget::theSingleton;
-  SoScXMLMiscTarget::theSingleton = NULL;
+  SoScXMLMiscTarget::theSingleton = nullptr;
 }
 
 SoScXMLMiscTarget *
 SoScXMLMiscTarget::singleton(void)
 {
-  assert(SoScXMLMiscTarget::theSingleton != NULL);
+  assert(SoScXMLMiscTarget::theSingleton != nullptr);
   return SoScXMLMiscTarget::theSingleton;
 }
 
diff --git a/coin4/src/navigation/SoScXMLMotionTarget.cpp b/coin4/src/navigation/SoScXMLMotionTarget.cpp
index e260d3d..24a9689 100644
--- a/coin4/src/navigation/SoScXMLMotionTarget.cpp
+++ b/coin4/src/navigation/SoScXMLMotionTarget.cpp
@@ -50,12 +50,12 @@ SoScXMLMotionTarget::cleanClass(void)
   SoScXMLMotionTarget::classTypeId = SoType::badType();
 }
 
-SoScXMLMotionTarget * SoScXMLMotionTarget::theSingleton = NULL;
+SoScXMLMotionTarget * SoScXMLMotionTarget::theSingleton = nullptr;
 
 SoScXMLMotionTarget *
 SoScXMLMotionTarget::constructSingleton(void)
 {
-  assert(SoScXMLMotionTarget::theSingleton == NULL);
+  assert(SoScXMLMotionTarget::theSingleton == nullptr);
   SoScXMLMotionTarget::theSingleton =
     static_cast<SoScXMLMotionTarget *>(SoScXMLMotionTarget::classTypeId.createInstance());
   return SoScXMLMotionTarget::theSingleton;
@@ -64,15 +64,15 @@ SoScXMLMotionTarget::constructSingleton(void)
 void
 SoScXMLMotionTarget::destructSingleton(void)
 {
-  assert(SoScXMLMotionTarget::theSingleton != NULL);
+  assert(SoScXMLMotionTarget::theSingleton != nullptr);
   delete SoScXMLMotionTarget::theSingleton;
-  SoScXMLMotionTarget::theSingleton = NULL;
+  SoScXMLMotionTarget::theSingleton = nullptr;
 }
 
 SoScXMLMotionTarget *
 SoScXMLMotionTarget::singleton(void)
 {
-  assert(SoScXMLMotionTarget::theSingleton != NULL);
+  assert(SoScXMLMotionTarget::theSingleton != nullptr);
   return SoScXMLMotionTarget::theSingleton;
 }
 
diff --git a/coin4/src/navigation/SoScXMLNavigation.cpp b/coin4/src/navigation/SoScXMLNavigation.cpp
index 75fb876..ebc1d54 100644
--- a/coin4/src/navigation/SoScXMLNavigation.cpp
+++ b/coin4/src/navigation/SoScXMLNavigation.cpp
@@ -55,12 +55,12 @@ public:
   static void * syncmutex;
 };
 
-void * SoScXMLNavigation::PImpl::syncmutex = NULL;
+void * SoScXMLNavigation::PImpl::syncmutex = nullptr;
 
 void
 SoScXMLNavigation::initClasses(void)
 {
-  assert(PImpl::syncmutex == NULL);
+  assert(PImpl::syncmutex == nullptr);
   CC_MUTEX_CONSTRUCT(PImpl::syncmutex);
 
   SoScXMLNavigationTarget::initClass();
@@ -122,7 +122,7 @@ SoScXMLNavigation::cleanClasses(void)
   SoScXMLNavigationTarget::cleanClass();
 
   CC_MUTEX_DESTRUCT(PImpl::syncmutex);
-  PImpl::syncmutex = NULL;
+  PImpl::syncmutex = nullptr;
 }
 
 void
diff --git a/coin4/src/navigation/SoScXMLNavigationTarget.cpp b/coin4/src/navigation/SoScXMLNavigationTarget.cpp
index 5a73294..8cdacf1 100644
--- a/coin4/src/navigation/SoScXMLNavigationTarget.cpp
+++ b/coin4/src/navigation/SoScXMLNavigationTarget.cpp
@@ -57,7 +57,7 @@
 
 class SoScXMLNavigationTarget::PImpl {
 public:
-  PImpl(void) : sessiondatamap(NULL) { }
+  PImpl(void) : sessiondatamap(nullptr) { }
 
   typedef std::map<const char *, SoScXMLNavigationTarget::Data *> SessionDataMap;
   typedef std::pair<const char *, SoScXMLNavigationTarget::Data *> SessionDataEntry;
@@ -101,7 +101,7 @@ SoScXMLNavigationTarget::~SoScXMLNavigationTarget(void)
     ++it;
   }
   delete PRIVATE(this)->sessiondatamap;
-  PRIVATE(this)->sessiondatamap = NULL;
+  PRIVATE(this)->sessiondatamap = nullptr;
 }
 
 /*!
@@ -113,7 +113,7 @@ SoScXMLNavigationTarget::~SoScXMLNavigationTarget(void)
 SoScXMLNavigationTarget::Data *
 SoScXMLNavigationTarget::getSessionData(SbName sessionid, NewDataFunc * constructor)
 {
-  Data * data = NULL;
+  Data * data = nullptr;
   SoScXMLNavigation::syncLock();
   PImpl::SessionDataMap::iterator findit =
     PRIVATE(this)->sessiondatamap->find(sessionid.getString());
@@ -173,7 +173,7 @@ SoScXMLNavigationTarget::getSessionId(const ScXMLEvent * event)
 }
 
 /*!
-  Returns the state machine that is associated with the given sessionid, or NULL
+  Returns the state machine that is associated with the given sessionid, or nullptr
   if there are no state machines registered for the session id.
 */
 ScXMLStateMachine *
@@ -185,13 +185,13 @@ SoScXMLNavigationTarget::getStateMachine(const ScXMLEvent * event, SbName sessio
     SoDebugError::post("SoScXMLNavigationTarget::getSoStateMachine",
                        "while processing %s: no statemachine for session '%s'.",
                        event->getEventName().getString(), sessionid.getString());
-    return NULL;
+    return nullptr;
   }
   return sm;
 }
 
 /*!
-  Returns the So- state machine that is associated with the given sessionid, or NULL
+  Returns the So- state machine that is associated with the given sessionid, or nullptr
   if there are no state machines registered for the session id or if the state machine
   is not of SoScXMLStateMachine type.
 */
@@ -201,33 +201,33 @@ SoScXMLNavigationTarget::getSoStateMachine(const ScXMLEvent * event, SbName sess
   assert(event);
   ScXMLStateMachine * sm = SoScXMLNavigationTarget::getStateMachine(event, sessionid);
   if unlikely (!sm) {
-    return NULL;
+    return nullptr;
   }
   if unlikely (!sm->isOfType(SoScXMLStateMachine::getClassTypeId())) {
     SoDebugError::post("SoScXMLNavigationTarget::getSoStateMachine",
                        "while processing %s: statemachine not of So-type for session '%s'.",
                        event->getEventName().getString(), sessionid.getString());
-    return NULL;
+    return nullptr;
   }
   return static_cast<SoScXMLStateMachine *>(sm);
 }
 
 /*!
-  Returns the current active camera, or NULL if there is no active camera set.
-  If NULL is returned, error messages has been posted.
+  Returns the current active camera, or nullptr if there is no active camera set.
+  If nullptr is returned, error messages has been posted.
 */
 SoCamera *
 SoScXMLNavigationTarget::getActiveCamera(const ScXMLEvent * event, SbName sessionid)
 {
   SoScXMLStateMachine * statemachine = SoScXMLNavigationTarget::getSoStateMachine(event, sessionid);
-  if unlikely (!statemachine) { return NULL; }
+  if unlikely (!statemachine) { return nullptr; }
 
   SoCamera * camera = statemachine->getActiveCamera();
   if unlikely (!camera) {
     SoDebugError::post("SoScXMLZoomTarget::processOneEvent",
                        "while processing %s: no current camera",
                        event->getEventName().getString());
-    return NULL;
+    return nullptr;
   }
   return camera;
 }
diff --git a/coin4/src/navigation/SoScXMLPanTarget.cpp b/coin4/src/navigation/SoScXMLPanTarget.cpp
index c7bfbfb..578efad 100644
--- a/coin4/src/navigation/SoScXMLPanTarget.cpp
+++ b/coin4/src/navigation/SoScXMLPanTarget.cpp
@@ -101,12 +101,12 @@ SoScXMLPanTarget::cleanClass(void)
   SoScXMLPanTarget::classTypeId = SoType::badType();
 }
 
-SoScXMLPanTarget * SoScXMLPanTarget::theSingleton = NULL;
+SoScXMLPanTarget * SoScXMLPanTarget::theSingleton = nullptr;
 
 SoScXMLPanTarget *
 SoScXMLPanTarget::constructSingleton(void)
 {
-  assert(SoScXMLPanTarget::theSingleton == NULL);
+  assert(SoScXMLPanTarget::theSingleton == nullptr);
   SoScXMLPanTarget::theSingleton =
     static_cast<SoScXMLPanTarget *>(SoScXMLPanTarget::classTypeId.createInstance());
   return SoScXMLPanTarget::theSingleton;
@@ -115,15 +115,15 @@ SoScXMLPanTarget::constructSingleton(void)
 void
 SoScXMLPanTarget::destructSingleton(void)
 {
-  assert(SoScXMLPanTarget::theSingleton != NULL);
+  assert(SoScXMLPanTarget::theSingleton != nullptr);
   delete SoScXMLPanTarget::theSingleton;
-  SoScXMLPanTarget::theSingleton = NULL;
+  SoScXMLPanTarget::theSingleton = nullptr;
 }
 
 SoScXMLPanTarget *
 SoScXMLPanTarget::singleton(void)
 {
-  assert(SoScXMLPanTarget::theSingleton != NULL);
+  assert(SoScXMLPanTarget::theSingleton != nullptr);
   return SoScXMLPanTarget::theSingleton;
 }
 
@@ -346,7 +346,7 @@ SoScXMLPanTarget::panCamera(SoCamera * camera,
                             const SbVec2f & previous,
                             const SbVec2f & current)
 {
-  if (camera == NULL) return; // can happen for empty scenegraph
+  if (camera == nullptr) return; // can happen for empty scenegraph
   if (current == previous) return; // useless invocation
 
   // Find projection points for the last and current mouse coordinates.
diff --git a/coin4/src/navigation/SoScXMLRotateTarget.cpp b/coin4/src/navigation/SoScXMLRotateTarget.cpp
index 4863c39..cd50ba2 100644
--- a/coin4/src/navigation/SoScXMLRotateTarget.cpp
+++ b/coin4/src/navigation/SoScXMLRotateTarget.cpp
@@ -137,12 +137,12 @@ SoScXMLRotateTarget::cleanClass(void)
   SoScXMLRotateTarget::classTypeId = SoType::badType();
 }
 
-SoScXMLRotateTarget * SoScXMLRotateTarget::theSingleton = NULL;
+SoScXMLRotateTarget * SoScXMLRotateTarget::theSingleton = nullptr;
 
 SoScXMLRotateTarget *
 SoScXMLRotateTarget::constructSingleton(void)
 {
-  assert(SoScXMLRotateTarget::theSingleton == NULL);
+  assert(SoScXMLRotateTarget::theSingleton == nullptr);
   SoScXMLRotateTarget::theSingleton =
     static_cast<SoScXMLRotateTarget *>(SoScXMLRotateTarget::classTypeId.createInstance());
   return SoScXMLRotateTarget::theSingleton;
@@ -151,15 +151,15 @@ SoScXMLRotateTarget::constructSingleton(void)
 void
 SoScXMLRotateTarget::destructSingleton(void)
 {
-  assert(SoScXMLRotateTarget::theSingleton != NULL);
+  assert(SoScXMLRotateTarget::theSingleton != nullptr);
   delete SoScXMLRotateTarget::theSingleton;
-  SoScXMLRotateTarget::theSingleton = NULL;
+  SoScXMLRotateTarget::theSingleton = nullptr;
 }
 
 SoScXMLRotateTarget *
 SoScXMLRotateTarget::singleton(void)
 {
-  assert(SoScXMLRotateTarget::theSingleton != NULL);
+  assert(SoScXMLRotateTarget::theSingleton != nullptr);
   return SoScXMLRotateTarget::theSingleton;
 }
 
@@ -408,7 +408,7 @@ SoScXMLRotateTarget::processOneEvent(const ScXMLEvent * event)
 void
 SoScXMLRotateTarget::reorientCamera(SoCamera * camera, const SbRotation & rot)
 {
-  if (camera == NULL) return;
+  if (camera == nullptr) return;
 
   // Find global coordinates of focal point.
   SbVec3f direction;
diff --git a/coin4/src/navigation/SoScXMLSeekTarget.cpp b/coin4/src/navigation/SoScXMLSeekTarget.cpp
index f698df8..132328b 100644
--- a/coin4/src/navigation/SoScXMLSeekTarget.cpp
+++ b/coin4/src/navigation/SoScXMLSeekTarget.cpp
@@ -138,12 +138,12 @@ SoScXMLSeekTarget::cleanClass(void)
   SoScXMLSeekTarget::classTypeId = SoType::badType();
 }
 
-SoScXMLSeekTarget * SoScXMLSeekTarget::theSingleton = NULL;
+SoScXMLSeekTarget * SoScXMLSeekTarget::theSingleton = nullptr;
 
 SoScXMLSeekTarget *
 SoScXMLSeekTarget::constructSingleton(void)
 {
-  assert(SoScXMLSeekTarget::theSingleton == NULL);
+  assert(SoScXMLSeekTarget::theSingleton == nullptr);
   SoScXMLSeekTarget::theSingleton =
     static_cast<SoScXMLSeekTarget *>(SoScXMLSeekTarget::classTypeId.createInstance());
   return SoScXMLSeekTarget::theSingleton;
@@ -152,15 +152,15 @@ SoScXMLSeekTarget::constructSingleton(void)
 void
 SoScXMLSeekTarget::destructSingleton(void)
 {
-  assert(SoScXMLSeekTarget::theSingleton != NULL);
+  assert(SoScXMLSeekTarget::theSingleton != nullptr);
   delete SoScXMLSeekTarget::theSingleton;
-  SoScXMLSeekTarget::theSingleton = NULL;
+  SoScXMLSeekTarget::theSingleton = nullptr;
 }
 
 SoScXMLSeekTarget *
 SoScXMLSeekTarget::singleton(void)
 {
-  assert(SoScXMLSeekTarget::theSingleton != NULL);
+  assert(SoScXMLSeekTarget::theSingleton != nullptr);
   return SoScXMLSeekTarget::theSingleton;
 }
 
@@ -195,9 +195,9 @@ SoScXMLSeekTarget::DONE(void)
 }
 
 SoScXMLSeekTarget::SoScXMLSeekTarget(void)
-: searchaction(NULL),
-  getmatrixaction(NULL),
-  raypickaction(NULL)
+: searchaction(nullptr),
+  getmatrixaction(nullptr),
+  raypickaction(nullptr)
 {
   this->setEventTargetType(SOSCXML_NAVIGATION_TARGETTYPE);
   this->setEventTargetName("Seek");
@@ -210,15 +210,15 @@ SoScXMLSeekTarget::~SoScXMLSeekTarget(void)
 {
   if (this->raypickaction) {
     delete this->raypickaction;
-    this->raypickaction = NULL;
+    this->raypickaction = nullptr;
   }
   if (this->getmatrixaction) {
     delete this->getmatrixaction;
-    this->getmatrixaction = NULL;
+    this->getmatrixaction = nullptr;
   }
   if (this->searchaction) {
     delete this->searchaction;
-    this->searchaction = NULL;
+    this->searchaction = nullptr;
   }
 }
 
diff --git a/coin4/src/navigation/SoScXMLSpinTarget.cpp b/coin4/src/navigation/SoScXMLSpinTarget.cpp
index 5eb5274..462bf05 100644
--- a/coin4/src/navigation/SoScXMLSpinTarget.cpp
+++ b/coin4/src/navigation/SoScXMLSpinTarget.cpp
@@ -107,12 +107,12 @@ SoScXMLSpinTarget::cleanClass(void)
   SoScXMLSpinTarget::classTypeId = SoType::badType();
 }
 
-SoScXMLSpinTarget * SoScXMLSpinTarget::theSingleton = NULL;
+SoScXMLSpinTarget * SoScXMLSpinTarget::theSingleton = nullptr;
 
 SoScXMLSpinTarget *
 SoScXMLSpinTarget::constructSingleton(void)
 {
-  assert(SoScXMLSpinTarget::theSingleton == NULL);
+  assert(SoScXMLSpinTarget::theSingleton == nullptr);
   SoScXMLSpinTarget::theSingleton =
     static_cast<SoScXMLSpinTarget *>(SoScXMLSpinTarget::classTypeId.createInstance());
   return SoScXMLSpinTarget::theSingleton;
@@ -121,15 +121,15 @@ SoScXMLSpinTarget::constructSingleton(void)
 void
 SoScXMLSpinTarget::destructSingleton(void)
 {
-  assert(SoScXMLSpinTarget::theSingleton != NULL);
+  assert(SoScXMLSpinTarget::theSingleton != nullptr);
   delete SoScXMLSpinTarget::theSingleton;
-  SoScXMLSpinTarget::theSingleton = NULL;
+  SoScXMLSpinTarget::theSingleton = nullptr;
 }
 
 SoScXMLSpinTarget *
 SoScXMLSpinTarget::singleton(void)
 {
-  assert(SoScXMLSpinTarget::theSingleton != NULL);
+  assert(SoScXMLSpinTarget::theSingleton != nullptr);
   return SoScXMLSpinTarget::theSingleton;
 }
 
@@ -244,7 +244,7 @@ SoScXMLSpinTarget::processOneEvent(const ScXMLEvent * event)
 void
 SoScXMLSpinTarget::reorientCamera(SoCamera * camera, const SbRotation & rot)
 {
-  if (camera == NULL) return;
+  if (camera == nullptr) return;
 
   // Find global coordinates of focal point.
   SbVec3f direction;
diff --git a/coin4/src/navigation/SoScXMLZoomTarget.cpp b/coin4/src/navigation/SoScXMLZoomTarget.cpp
index 6f74a62..9a898c9 100644
--- a/coin4/src/navigation/SoScXMLZoomTarget.cpp
+++ b/coin4/src/navigation/SoScXMLZoomTarget.cpp
@@ -152,12 +152,12 @@ SoScXMLZoomTarget::cleanClass(void)
   SoScXMLZoomTarget::classTypeId = SoType::badType();
 }
 
-SoScXMLZoomTarget * SoScXMLZoomTarget::theSingleton = NULL;
+SoScXMLZoomTarget * SoScXMLZoomTarget::theSingleton = nullptr;
 
 SoScXMLZoomTarget *
 SoScXMLZoomTarget::constructSingleton(void)
 {
-  assert(SoScXMLZoomTarget::theSingleton == NULL);
+  assert(SoScXMLZoomTarget::theSingleton == nullptr);
   SoScXMLZoomTarget::theSingleton =
     static_cast<SoScXMLZoomTarget *>(SoScXMLZoomTarget::classTypeId.createInstance());
   return SoScXMLZoomTarget::theSingleton;
@@ -166,15 +166,15 @@ SoScXMLZoomTarget::constructSingleton(void)
 void
 SoScXMLZoomTarget::destructSingleton(void)
 {
-  assert(SoScXMLZoomTarget::theSingleton != NULL);
+  assert(SoScXMLZoomTarget::theSingleton != nullptr);
   delete SoScXMLZoomTarget::theSingleton;
-  SoScXMLZoomTarget::theSingleton = NULL;
+  SoScXMLZoomTarget::theSingleton = nullptr;
 }
 
 SoScXMLZoomTarget *
 SoScXMLZoomTarget::singleton(void)
 {
-  assert(SoScXMLZoomTarget::theSingleton != NULL);
+  assert(SoScXMLZoomTarget::theSingleton != nullptr);
   return SoScXMLZoomTarget::theSingleton;
 }
 
diff --git a/coin4/src/nodekits/SoBaseKit.cpp b/coin4/src/nodekits/SoBaseKit.cpp
index 43b1712..81ff81a 100644
--- a/coin4/src/nodekits/SoBaseKit.cpp
+++ b/coin4/src/nodekits/SoBaseKit.cpp
@@ -425,7 +425,7 @@
       rp.apply(viewer->getSceneManager()->getSceneGraph());
 
       SoPickedPoint * point = rp.getPickedPoint();
-      if (point == NULL) {
+      if (point == nullptr) {
         (void)fprintf(stderr, "\n** miss! **\n\n");
         return;
       }
@@ -478,7 +478,7 @@
 
     SoSeparator * root = SoDB::readAll(&input);
 
-    if (root == NULL) {
+    if (root == nullptr) {
       (void) fprintf(stderr, "Unable to read file: %s\n", argv[1]);
       return -1;
     }
@@ -638,7 +638,7 @@ SO_KIT_SOURCE(SoBaseKit);
 SoBaseKit::SoBaseKit(void)
 {
   PRIVATE(this) = new SoBaseKitP(this);
-  PRIVATE(this)->writedata = NULL;
+  PRIVATE(this)->writedata = nullptr;
 
   SO_KIT_INTERNAL_CONSTRUCTOR(SoBaseKit);
 
@@ -877,7 +877,7 @@ SoBaseKit::set(const char * namevaluepairliststring)
     int partNum;
     bool isList;
     int listIdx;
-    if (!SoBaseKit::findPart(partname, kit, partNum, isList, listIdx, true, NULL, true)) {
+    if (!SoBaseKit::findPart(partname, kit, partNum, isList, listIdx, true, nullptr, true)) {
 #if COIN_DEBUG
       SoDebugError::postWarning("SoBaseKit::set",
                                 "part ``%s'' not found",
@@ -946,10 +946,10 @@ SoBaseKit::set(const char * partnamestring, const char * parameterstring)
   bool isList;
   int listIdx;
   SoBaseKit * kit = this;
-  if (SoBaseKit::findPart(partname, kit, partNum, isList, listIdx, true, NULL, true)) {
+  if (SoBaseKit::findPart(partname, kit, partNum, isList, listIdx, true, nullptr, true)) {
     SoNode * node = PRIVATE(kit)->instancelist[partNum]->getValue();
     PRIVATE(kit)->instancelist[partNum]->setDefault(false);
-    assert(node != NULL); // makeifneeded was true in findPart call
+    assert(node != nullptr); // makeifneeded was true in findPart call
     if (isList) {
       assert(node->isOfType(SoNodeKitListPart::getClassTypeId()));
       SoNodeKitListPart * list = (SoNodeKitListPart *) node;
@@ -1078,7 +1078,7 @@ SoBaseKit::rayPick(SoRayPickAction * action)
   for (int i = 0; i < n; i++) {
     SoPickedPoint * pp = pplist[i];
     SoFullPath * path = (SoFullPath*) pp->getPath();
-    if (path->containsNode(this) && pp->getDetail(this) == NULL) {
+    if (path->containsNode(this) && pp->getDetail(this) == nullptr) {
       PRIVATE(this)->addKitDetail(path, pp);
     }
   }
@@ -1098,13 +1098,13 @@ SoBaseKit::search(SoSearchAction * action)
 static bool
 is_default_node(SoNode * node)
 {
-  SoNode * definstance = NULL;
+  SoNode * definstance = nullptr;
   const SoFieldData * fielddata = node->getFieldData();
   int i, n = fielddata->getNumFields();
   for (i = 0; i < n; i++) {
     SoField * field = fielddata->getField(node, i);
     if (field->isConnectionEnabled() && field->isConnected()) break;
-    if (definstance == NULL) {
+    if (definstance == nullptr) {
       definstance = (SoNode *)node->getTypeId().createInstance();
       definstance->ref();
     }
@@ -1156,7 +1156,7 @@ SoBaseKit::write(SoWriteAction * action)
       PRIVATE(this)->writedata->write(out, this);
       // we don't need it any more
       delete PRIVATE(this)->writedata;
-      PRIVATE(this)->writedata = NULL;
+      PRIVATE(this)->writedata = nullptr;
     }
     this->writeFooter(out);
   }
@@ -1263,7 +1263,7 @@ SoBaseKit::countMyFields(SoOutput * out)
 
   <OL>
 
-  <LI> field value is \c NULL and part is \c NULL by default </LI>
+  <LI> field value is \c nullptr and part is \c nullptr by default </LI>
 
   <LI> it is a leaf SoGroup or SoSeparator node with no children </LI>
 
@@ -1290,7 +1290,7 @@ SoBaseKit::setDefaultOnNonWritingFields(void)
 
     SoNode * node = field->getValue();
 
-    if (node == NULL) {
+    if (node == nullptr) {
       // first test listed in API doc above
       if (catalog->isNullByDefault(i)) { field->setDefault(true); }
       continue;
@@ -1336,8 +1336,8 @@ SoBaseKit::forceChildDrivenWriteRefs(SoOutput * out)
 {
   if (SoWriterefCounter::instance(out)->shouldWrite(this)) return true;
 
-  // if NULL we already did this test, found that we shouldn't write,
-  // deleted writedata and set writedata to NULL.
+  // if nullptr we already did this test, found that we shouldn't write,
+  // deleted writedata and set writedata to nullptr.
   if (!PRIVATE(this)->writedata) return false;
 
   const SoNodekitCatalog * catalog = this->getNodekitCatalog();
@@ -1370,7 +1370,7 @@ SoBaseKit::forceChildDrivenWriteRefs(SoOutput * out)
   }
   else {
     delete PRIVATE(this)->writedata;
-    PRIVATE(this)->writedata = NULL;
+    PRIVATE(this)->writedata = nullptr;
     return false;
   }
 }
@@ -1435,7 +1435,7 @@ SoBaseKit::printDiagram(void)
 void
 SoBaseKit::printSubDiagram(const SbName & rootname, int level)
 {
-  const SoNodekitCatalog * parentcatalog = NULL;
+  const SoNodekitCatalog * parentcatalog = nullptr;
   if (this->getTypeId() != SoBaseKit::getClassTypeId()) {
     SoType parenttype = this->getTypeId().getParent();
     SoBaseKit * parentobj = (SoBaseKit *)parenttype.createInstance();
@@ -1551,7 +1551,7 @@ SoNode *
 SoBaseKit::addToCopyDict(void) const
 {
   SoNode * cp = (SoNode*) SoFieldContainer::checkCopy(this);
-  if (cp == NULL) { // not copied?
+  if (cp == nullptr) { // not copied?
     cp = (SoNode*) this->getTypeId().createInstance();
     assert(cp);
     cp->ref();
@@ -1561,7 +1561,7 @@ SoBaseKit::addToCopyDict(void) const
     int n = PRIVATE(this)->instancelist.getLength();
     for (int i = 1; i < n; i++) {
       SoNode * node = PRIVATE(this)->instancelist[i]->getValue();
-      if (node != NULL) node->addToCopyDict();
+      if (node != nullptr) node->addToCopyDict();
     }
   }
   return cp;
@@ -1593,12 +1593,12 @@ SoBaseKit::copyContents(const SoFieldContainer * fromfc,
   SbList <bool> flaglist;
 
   // part 0 is this
-  partlist.append(NULL);
+  partlist.append(nullptr);
   flaglist.append(false);
 
   // initialize temporary lists
   for (i = 1; i < n; i++) {
-    partlist.append(NULL);
+    partlist.append(nullptr);
     flaglist.append(PRIVATE(this)->instancelist[i]->isDefault());
   }
 
@@ -1610,7 +1610,7 @@ SoBaseKit::copyContents(const SoFieldContainer * fromfc,
 
   // reset part fields
   for (i = 1; i < n; i++) {
-    PRIVATE(this)->instancelist[i]->setValue(NULL);
+    PRIVATE(this)->instancelist[i]->setValue(nullptr);
     PRIVATE(this)->instancelist[i]->setDefault(true);
   }
 
@@ -1639,7 +1639,7 @@ SoBaseKit::copyContents(const SoFieldContainer * fromfc,
   the catalog given by \a listname.
 
   If the list part (and its container) was not yet constructed, they
-  will be so if \a makeifneeded is \c true (otherwise, \c NULL will be
+  will be so if \a makeifneeded is \c true (otherwise, \c nullptr will be
   returned).
 */
 SoGroup *
@@ -1650,32 +1650,32 @@ SoBaseKit::getContainerNode(const SbName & listname, bool makeifneeded)
   bool isList;
   int listIdx;
   if (SoBaseKit::findPart(SbString(listname.getString()), kit, partNum,
-                          isList, listIdx, makeifneeded, NULL, true)) {
+                          isList, listIdx, makeifneeded, nullptr, true)) {
     SoNode * node = PRIVATE(kit)->instancelist[partNum]->getValue();
-    if (node == NULL) return NULL;
+    if (node == nullptr) return nullptr;
     assert(node->isOfType(SoNodeKitListPart::getClassTypeId()));
     SoNodeKitListPart * list = (SoNodeKitListPart *)node;
     return list->getContainerNode();
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
   Returns catalog part of the given \a partname.
 
   If the \a partname part is not in the nodekit's catalog, return \c
-  NULL.
+  nullptr.
 
   If the part is specified in the catalog, but has not yet been made,
   the function will either construct the part (if \a makeifneeded is
-  \c true) or just return \c NULL (if \a makeifneeded is \c false).
+  \c true) or just return \c nullptr (if \a makeifneeded is \c false).
 
   If \a leafcheck is \c true, a pointer to the part will only be
-  returned if it's a leaf in the catalog (otherwise \c NULL is
+  returned if it's a leaf in the catalog (otherwise \c nullptr is
   returned).
 
   If \a publiccheck is \c true, a pointer to the part will only be
-  returned if it's a public catalog part (otherwise \c NULL is
+  returned if it's a public catalog part (otherwise \c nullptr is
   returned).
 
 
@@ -1710,20 +1710,20 @@ SoBaseKit::getAnyPart(const SbName & partname, bool makeifneeded,
   SbString partstring(partname.getString());
 
   if (SoBaseKit::findPart(partstring, kit, partNum, isList, listIdx,
-                          makeifneeded, NULL, true)) {
+                          makeifneeded, nullptr, true)) {
 
     if (publiccheck && !kit->getNodekitCatalog()->isPublic(partNum)) {
       SoDebugError::postWarning("SoBaseKit::getAnyPart",
                                 "Part ``%s'' found in %s, but access is private.",
                                 partname.getString(),
                                 this->getTypeId().getName().getString());
-      return NULL;
+      return nullptr;
     }
 
     if (!leafcheck || kit->getNodekitCatalog()->isLeaf(partNum)) {
       if (isList) {
         SoNode * partnode = PRIVATE(kit)->instancelist[partNum]->getValue();
-        if (partnode == NULL) return NULL;
+        if (partnode == nullptr) return nullptr;
         assert(partnode->isOfType(SoNodeKitListPart::getClassTypeId()));
         SoNodeKitListPart * list = (SoNodeKitListPart *) partnode;
         if (listIdx >= 0 && listIdx < list->getNumChildren()) {
@@ -1765,7 +1765,7 @@ SoBaseKit::getAnyPart(const SbName & partname, bool makeifneeded,
                               this->getTypeId().getName().getString());
   }
 #endif // COIN_DEBUG
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -1782,9 +1782,9 @@ SoBaseKit::getAnyPart(const SbName & partname, bool makeifneeded,
   \a pathtoextend is a path through the nodekit instance catalog
   hierarchy, where we should pick up and continue to create the path
   from where \a pathtoextend terminates. If \a pathtoextend is \c
-  NULL, we simply start at the "this" toplevel node.
+  nullptr, we simply start at the "this" toplevel node.
 
-  Returns \c NULL on failure, for any of the possible reasons
+  Returns \c nullptr on failure, for any of the possible reasons
   described above (part ends in non-leaf or private catalog entry,
   part is not syntactically valid or refers to non-existing catalog
   entries).
@@ -1806,7 +1806,7 @@ SoBaseKit::createPathToAnyPart(const SbName & partname, bool makeifneeded,
         SoDebugError::postWarning("SoBaseKit::createPathToAnyPart",
                                   "pathtoextend is illegal");
 #endif // COIN_DEBUG
-        return NULL;
+        return nullptr;
       }
       path->append(this); // this should be safe now
     }
@@ -1827,7 +1827,7 @@ SoBaseKit::createPathToAnyPart(const SbName & partname, bool makeifneeded,
     if ((leafcheck && ! catalog->isLeaf(partNum)) ||
         (publiccheck && ! catalog->isPublic(partNum))) {
       path->unref();
-      return NULL;
+      return nullptr;
     }
 
     SoNode * node = PRIVATE(kit)->instancelist[partNum]->getValue();
@@ -1843,7 +1843,7 @@ SoBaseKit::createPathToAnyPart(const SbName & partname, bool makeifneeded,
                                     listIdx, partname.getString());
 #endif // COIN_DEBUG
           path->unref();
-          return NULL;
+          return nullptr;
         }
         else if (listIdx == numlistchildren) {
           if (!list->canCreateDefaultChild()) {
@@ -1870,7 +1870,7 @@ SoBaseKit::createPathToAnyPart(const SbName & partname, bool makeifneeded,
     }
   }
   path->unref();
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -1890,7 +1890,7 @@ SoBaseKit::setAnyPart(const SbName & partname, SoNode * from, bool anypart)
   // to create intermediate parts, but not the leaf part. For now we
   // just supply makeifneeded = true, and then immediately overwrite
   // the part here. pederb, 2004-06-07
-  if (SoBaseKit::findPart(partstring, kit, partNum, isList, listIdx, true, NULL, true)) {
+  if (SoBaseKit::findPart(partstring, kit, partNum, isList, listIdx, true, nullptr, true)) {
     if (anypart || kit->getNodekitCatalog()->isPublic(partNum)) {
       if (isList) {
         SoNode * partnode = PRIVATE(kit)->instancelist[partNum]->getValue();
@@ -1973,10 +1973,10 @@ SoBaseKit::createFieldList(void)
   // only do this if the catalog has been created
   if (catalog) {
     PRIVATE(this)->instancelist.truncate(0);
-    PRIVATE(this)->instancelist.append(NULL); // first catalog entry is "this"
+    PRIVATE(this)->instancelist.append(nullptr); // first catalog entry is "this"
     for (int i = 1; i < catalog->getNumEntries(); i++) {
       PRIVATE(this)->instancelist.append((SoSFNode *)this->getField(catalog->getName(i)));
-      assert(PRIVATE(this)->instancelist[i] != NULL);
+      assert(PRIVATE(this)->instancelist[i] != nullptr);
     }
   }
 }
@@ -1997,7 +1997,7 @@ SoBaseKit::createDefaultParts(void)
     for (int i = 1; i < PRIVATE(this)->instancelist.getLength(); i++) {
       if (!catalog->isNullByDefault(i)) {
         SoNode * old = PRIVATE(this)->instancelist[i]->getValue();
-        if ((old == NULL || ! old->isOfType(catalog->getDefaultType(i)) )) {
+        if ((old == nullptr || ! old->isOfType(catalog->getDefaultType(i)) )) {
           this->makePart(i);
           PRIVATE(this)->instancelist[i]->setDefault(true);
         }
@@ -2008,7 +2008,7 @@ SoBaseKit::createDefaultParts(void)
 
 /*!
   In Open Inventor, this method returns a pointer to a private class.
-  It will always return \c NULL in Coin.
+  It will always return \c nullptr in Coin.
 
   \sa createNodekitPartsList()
 */
@@ -2017,7 +2017,7 @@ SoBaseKit::getNodekitPartsList(void) const
 {
   assert(0 &&
          "SoBaseKit::getNodekitPartsList() obsoleted in Coin");
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -2072,15 +2072,15 @@ SoBaseKit::readInstance(SoInput * in, unsigned short COIN_UNUSED_ARG(flags))
 
   // Dummy first element to get indices to match instancelist (where
   // the dummy "this" catalog entry is first).
-  nodelist.append(NULL);
+  nodelist.append(nullptr);
   defaultlist.append(false);
 
-  // copy all parts into nodelist, and then set all parts to NULL
+  // copy all parts into nodelist, and then set all parts to nullptr
   // and default before reading
   for (i = 1; i < PRIVATE(this)->instancelist.getLength(); i++) {
     nodelist.append(PRIVATE(this)->instancelist[i]->getValue());
     defaultlist.append(PRIVATE(this)->instancelist[i]->isDefault());
-    PRIVATE(this)->instancelist[i]->setValue(NULL);
+    PRIVATE(this)->instancelist[i]->setValue(nullptr);
     PRIVATE(this)->instancelist[i]->setDefault(true);
   }
 
@@ -2105,8 +2105,8 @@ SoBaseKit::readInstance(SoInput * in, unsigned short COIN_UNUSED_ARG(flags))
       if (!PRIVATE(this)->instancelist[i]->isDefault()) { // we've read a part
         nodelist.set(i, PRIVATE(this)->instancelist[i]->getValue());
         defaultlist[i] = false;
-        // set to NULL again so that setPart() will not get confused
-        PRIVATE(this)->instancelist[i]->setValue(NULL);
+        // set to nullptr again so that setPart() will not get confused
+        PRIVATE(this)->instancelist[i]->setValue(nullptr);
       }
     }
 
@@ -2150,10 +2150,10 @@ SoBaseKit::readInstance(SoInput * in, unsigned short COIN_UNUSED_ARG(flags))
 // kit might change during this search.
 //
 // compoundname parts are created during this search, so it might be necessary
-// to do a nodekit cleanup if part is not public, or if part is set to NULL.
+// to do a nodekit cleanup if part is not public, or if part is set to nullptr.
 //
 //
-// if path != NULL, kit-nodes will be appended to the path during the search
+// if path != nullptr, kit-nodes will be appended to the path during the search
 // The actual part is not added to the path. The head of the path should
 // be set to the kit-node performing the search.
 //
@@ -2184,12 +2184,12 @@ SoBaseKit::findPart(const SbString & partname, SoBaseKit *& kit, int & partnum,
   const char * startbracket = strchr(stringptr, '[');
 
   if (periodptr && (startbracket > periodptr))
-    startbracket = NULL; // will handle later
+    startbracket = nullptr; // will handle later
 
   islist = false; // set to false first
   SbString firstpartname;
   if (startbracket) { // get index
-    long int listindex = strtol(startbracket+1, NULL, 10);
+    long int listindex = strtol(startbracket+1, nullptr, 10);
     if (listindex == LONG_MIN || listindex == LONG_MAX) {
 #if COIN_DEBUG
       SoDebugError::postWarning("SoBaseKit::findPart",
@@ -2212,13 +2212,13 @@ SoBaseKit::findPart(const SbString & partname, SoBaseKit *& kit, int & partnum,
   if (partnum == SO_CATALOG_NAME_NOT_FOUND) {
     if (recsearch) { // search leaf nodekits for this part?
       SoBaseKit * orgkit = kit;
-      assert(path == NULL); // should not do recsearch when creating path
+      assert(path == nullptr); // should not do recsearch when creating path
       const SoNodekitCatalog * catalog = orgkit->getNodekitCatalog();
       for (int i = 1; i < PRIVATE(orgkit)->instancelist.getLength(); i++) {
         if (catalog->isLeaf(i) &&
             catalog->getType(i).isDerivedFrom(SoBaseKit::getClassTypeId())) {
           kit = (SoBaseKit *)PRIVATE(orgkit)->instancelist[i]->getValue();
-          bool didexist = kit != NULL;
+          bool didexist = kit != nullptr;
           if (!didexist) {
             orgkit->makePart(i);
             kit = (SoBaseKit *)PRIVATE(orgkit)->instancelist[i]->getValue();
@@ -2229,7 +2229,7 @@ SoBaseKit::findPart(const SbString & partname, SoBaseKit *& kit, int & partnum,
           }
           else if (!didexist) {
             // we created this part, remove it
-            orgkit->setPart(i, NULL);
+            orgkit->setPart(i, nullptr);
           }
         }
       }
@@ -2243,7 +2243,7 @@ SoBaseKit::findPart(const SbString & partname, SoBaseKit *& kit, int & partnum,
   SoSFNode * nodefield = PRIVATE(kit)->instancelist[partnum];
   assert(nodefield);
 
-  if (makeifneeded && nodefield->getValue() == NULL) {
+  if (makeifneeded && nodefield->getValue() == nullptr) {
     kit->makePart(partnum);
   }
 
@@ -2253,7 +2253,7 @@ SoBaseKit::findPart(const SbString & partname, SoBaseKit *& kit, int & partnum,
     int parent = catalog->getParentPartNumber(partnum);
     while (parent > 0) {
       SoNode * node = PRIVATE(kit)->instancelist[parent]->getValue();
-      if (node == NULL) {
+      if (node == nullptr) {
         assert(makeifneeded == false);
         break;
       }
@@ -2267,13 +2267,13 @@ SoBaseKit::findPart(const SbString & partname, SoBaseKit *& kit, int & partnum,
     }
   }
 
-  if (periodptr == NULL) {
+  if (periodptr == nullptr) {
     // singlename or singlelistname found, do not recurse any more
     return true; // all info has been found, just return true
   }
   else { // recurse
     SoNode * node = nodefield->getValue();
-    if (node == NULL) return false;
+    if (node == nullptr) return false;
     const ptrdiff_t startidx = periodptr - stringptr + 1;
     SbString newpartname = partname.getSubString((int)startidx);
     if (islist) {
@@ -2363,22 +2363,22 @@ SoBaseKit::setPart(const int partnum, SoNode * node)
   }
   int parentIdx = catalog->getParentPartNumber(partnum);
   assert(parentIdx >= 0 && parentIdx < PRIVATE(this)->instancelist.getLength());
-  SoNode * parent = NULL;
+  SoNode * parent = nullptr;
   if (parentIdx == 0) parent = this;
   else parent = PRIVATE(this)->instancelist[parentIdx]->getValue();
-  if (parent == NULL) {
+  if (parent == nullptr) {
     this->makePart(parentIdx);
     parent = PRIVATE(this)->instancelist[parentIdx]->getValue();
   }
-  assert(parent != NULL);
+  assert(parent != nullptr);
   SoChildList * childlist = parent->getChildren();
-  assert(childlist != NULL);
+  assert(childlist != nullptr);
 
   // if parent is a node derived from SoGroup, use the SoGroup access
   // functions to add/remove/insert children instead of SoChildList
   // directly. This is needed for VRML group nodes to work properly
   // inside node kits. pederb, 2004-06-23
-  SoGroup * parentgroup = NULL;
+  SoGroup * parentgroup = nullptr;
   if (parent->isOfType(SoGroup::getClassTypeId())) {
     parentgroup = (SoGroup*) parent;
   }
@@ -2401,7 +2401,7 @@ SoBaseKit::setPart(const int partnum, SoNode * node)
     return false;
   }
 
-  if (oldnode != NULL) { // part exists, replace
+  if (oldnode != nullptr) { // part exists, replace
     int oldIdx = childlist->find(oldnode);
     assert(oldIdx >= 0);
 
@@ -2453,7 +2453,7 @@ SoBaseKit::getRightSiblingIndex(const int partnum)
   int sibling = catalog->getRightSiblingPartNumber(partnum);
 
   // iterate until no more siblings or until we find an existing one
-  while (sibling >= 0 && PRIVATE(this)->instancelist[sibling]->getValue() == NULL) {
+  while (sibling >= 0 && PRIVATE(this)->instancelist[sibling]->getValue() == nullptr) {
     sibling = catalog->getRightSiblingPartNumber(sibling);
   }
   return sibling;
@@ -2525,7 +2525,7 @@ SoBaseKitP::testParentWrite(void)
     SoSFNode * field = this->instancelist[i];
     if (field->isDefault()) { // we might not write
       SoNode * node = field->getValue();
-      // don't write if NULL, of course
+      // don't write if nullptr, of course
       if (node) {
         int parent = catalog->getParentPartNumber(i);
         if (parent > 0) {
@@ -2564,7 +2564,7 @@ SoBaseKitP::copyParts(const SoBaseKit * srckit, SbList <SoNode*> & partlist,
     if (dstnode && catalog->getParentPartNumber(i) == 0) {
       SoNode * srcnode = srcfields[i]->getValue();
       assert(dstnode != srcnode);
-      assert(srcnode != NULL);
+      assert(srcnode != nullptr);
       assert(srcnode->getTypeId() == dstnode->getTypeId());
       srcnode->assertAlive();
       dstnode->assertAlive();
diff --git a/coin4/src/nodekits/SoInteractionKit.cpp b/coin4/src/nodekits/SoInteractionKit.cpp
index 9fe3761..7f6d0ab 100644
--- a/coin4/src/nodekits/SoInteractionKit.cpp
+++ b/coin4/src/nodekits/SoInteractionKit.cpp
@@ -172,7 +172,7 @@ public:
 #endif // DOXYGEN_SKIP_THIS
 
 
-static SbList <SoNode*> * defaultdraggerparts = NULL;
+static SbList <SoNode*> * defaultdraggerparts = nullptr;
 
 
 //
@@ -194,7 +194,7 @@ static void
 interactionkit_cleanup(void)
 {
   delete defaultdraggerparts;
-  defaultdraggerparts = NULL;
+  defaultdraggerparts = nullptr;
 }
 
 #define PRIVATE(obj) ((obj)->pimpl)
@@ -232,7 +232,7 @@ SoInteractionKit::SoInteractionKit(void)
 
   SO_KIT_INIT_INSTANCE();
 
-  PRIVATE(this)->connectedseparator = NULL;
+  PRIVATE(this)->connectedseparator = nullptr;
   PRIVATE(this)->fieldsensor = new SoFieldSensor(SoInteractionKit::fieldSensorCB, PRIVATE(this));
   PRIVATE(this)->fieldsensor->setPriority(0);
 
@@ -262,7 +262,7 @@ SoInteractionKit::initClass(void)
 
 /*!
   Sets a part in the kit as a surrogate path. The \a partname part is
-  set to \c NULL, and the surrogate path is remembered. Following
+  set to \c nullptr, and the surrogate path is remembered. Following
   picks on the surrogate path will be regarded as a pick on \a
   partname.
 */
@@ -374,7 +374,7 @@ SoInteractionKit::isPathSurrogateInMySubgraph(const SoPath * path)
 void
 SoInteractionKit::setSwitchValue(SoNode * node, const int newVal)
 {
-  if (node == NULL) return;
+  if (node == nullptr) return;
   assert(node->isOfType(SoSwitch::getClassTypeId()));
   SoSwitch * mySwitch = (SoSwitch *)node;
   if (mySwitch->whichChild.getValue() != newVal) {
@@ -410,7 +410,7 @@ SoInteractionKit::readInstance(SoInput * in, unsigned short flags)
 {
   bool ret = inherited::readInstance(in, flags); // will handle fields
   if (ret) {
-    // remove surrogate paths where part != NULL and not an empty
+    // remove surrogate paths where part != nullptr and not an empty
     // group or separator
     int n = PRIVATE(this)->surrogatenamelist.getLength();
     for (int i = 0; i < n; i++) {
@@ -458,7 +458,7 @@ SoInteractionKit::readDefaultParts(const char * fileName,
   // seem to remember that SGI Inventor works this way. 20020322 mortene.
 
   SoInput input;
-  SoNode * root = NULL;
+  SoNode * root = nullptr;
 
   const char * draggerdir = coin_getenv("SO_DRAGGER_DIR");
 
@@ -632,7 +632,7 @@ SoInteractionKit::setAnySurrogatePath(const SbName & partname,
         // replace with empty group to keep switch numbering
         kit->setPart(partNum, (SoNode *)type.createInstance());
       }
-      else { // set to NULL and update switch numbering
+      else { // set to nullptr and update switch numbering
         SoSwitch * sw = (SoSwitch *)parent;
         int whichChild = sw->whichChild.getValue();
         int partIdx = sw->findChild(node);
@@ -642,12 +642,12 @@ SoInteractionKit::setAnySurrogatePath(const SbName & partname,
         else if (partIdx < whichChild) {
           sw->whichChild.setValue(whichChild-1);
         }
-        kit->setPart(partNum, NULL);
+        kit->setPart(partNum, nullptr);
       }
     }
     else {
-      // set part to NULL
-      kit->setPart(partNum, NULL);
+      // set part to nullptr
+      kit->setPart(partNum, nullptr);
     }
     // add the path
     ((SoInteractionKit *)kit)->pimpl->addSurrogatePath(path, catalog->getName(partNum));
@@ -839,7 +839,7 @@ SoInteractionKitP::connectFields(const bool onoff)
     this->connectedseparator->renderCulling.disconnect();
     this->connectedseparator->pickCulling.disconnect();
     this->connectedseparator->unref();
-    this->connectedseparator = NULL;
+    this->connectedseparator = nullptr;
   }
   if (onoff) {
     SoSeparator * sep = (SoSeparator*) this->kit->topSeparator.getValue();
diff --git a/coin4/src/nodekits/SoNodeKitListPart.cpp b/coin4/src/nodekits/SoNodeKitListPart.cpp
index 59bd31f..1a32795 100644
--- a/coin4/src/nodekits/SoNodeKitListPart.cpp
+++ b/coin4/src/nodekits/SoNodeKitListPart.cpp
@@ -74,12 +74,12 @@
 #include "tidbitsp.h"
 #include "nodes/SoSubNodeP.h"
 
-static SoTypeList * sonodekitlistpart_deflist = NULL;
+static SoTypeList * sonodekitlistpart_deflist = nullptr;
 
 static void sonodekitlistpart_atexit_cleanup(void)
 {
   delete sonodekitlistpart_deflist;
-  sonodekitlistpart_deflist = NULL;
+  sonodekitlistpart_deflist = nullptr;
 }
 
 /*!
@@ -99,7 +99,7 @@ SoNodeKitListPart::SoNodeKitListPart(void)
 
   SO_NODE_ADD_FIELD(containerTypeName,(SoGroup::getClassTypeId().getName().getString()));
   SO_NODE_ADD_FIELD(childTypeNames,(SoNode::getClassTypeId().getName().getString()));
-  SO_NODE_ADD_FIELD(containerNode,(NULL));
+  SO_NODE_ADD_FIELD(containerNode,(nullptr));
 
   this->containerNode.setValue(new SoGroup);
   // to avoid notification problems (container node is in the scene
@@ -120,7 +120,7 @@ SoNodeKitListPart::SoNodeKitListPart(void)
 SoNodeKitListPart::~SoNodeKitListPart()
 {
   delete this->children;
-  this->containerNode.setValue(NULL);
+  this->containerNode.setValue(nullptr);
 }
 
 /*!
@@ -603,7 +603,7 @@ SoNodeKitListPart::syncInternalData(void)
   }
 
   // Set up container node, if necessary.
-  if (this->containerNode.getValue() == NULL) {
+  if (this->containerNode.getValue() == nullptr) {
     SoType containerType = SoType::fromName(this->containerTypeName.getValue());
     this->containerNode.setValue((SoNode*)containerType.createInstance());
     this->containerNode.setDefault(true);
diff --git a/coin4/src/nodekits/SoNodeKitPath.cpp b/coin4/src/nodekits/SoNodeKitPath.cpp
index f874689..475d919 100644
--- a/coin4/src/nodekits/SoNodeKitPath.cpp
+++ b/coin4/src/nodekits/SoNodeKitPath.cpp
@@ -106,7 +106,7 @@ SoNodeKitPath::getTail(void) const
   SoDebugError::postInfo("SoNodeKitPath::getTail",
                          "no nodekit in path");
 #endif // debug
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -127,7 +127,7 @@ SoNodeKitPath::getNode(const int idx) const
                          "index %d out of bounds", idx);
 #endif // COIN_DEBUG
 
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -146,7 +146,7 @@ SoNodeKitPath::getNodeFromTail(const int idx) const
   SoDebugError::postInfo("SoNodeKitPath::getNodeFromTail",
                          "index %d out of bounds", idx);
 #endif // COIN_DEBUG
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -202,7 +202,7 @@ SoNodeKitPath::append(SoBaseKit * childKit)
   if (this->getLength() == 0) this->setHead(childKit);
   else {
     SoBaseKit * tail = (SoBaseKit *) this->getTail();
-    assert(tail != NULL);
+    assert(tail != nullptr);
     SoSearchAction * sa = this->getSearchAction();
     sa->setNode(childKit);
     bool oldSearch = tail->isSearchingChildren();
@@ -280,7 +280,7 @@ void
 SoNodeKitPath::clean(void)
 {
   delete SoNodeKitPath::searchAction;
-  SoNodeKitPath::searchAction = NULL;
+  SoNodeKitPath::searchAction = nullptr;
 }
 
 //
@@ -289,7 +289,7 @@ SoNodeKitPath::clean(void)
 SoSearchAction *
 SoNodeKitPath::getSearchAction(void)
 {
-  if (SoNodeKitPath::searchAction == NULL) {
+  if (SoNodeKitPath::searchAction == nullptr) {
     SoNodeKitPath::searchAction = new SoSearchAction();
     searchAction->setInterest(SoSearchAction::FIRST);
     searchAction->setSearchingAll(false);
diff --git a/coin4/src/nodekits/SoSeparatorKit.cpp b/coin4/src/nodekits/SoSeparatorKit.cpp
index d65936b..809be13 100644
--- a/coin4/src/nodekits/SoSeparatorKit.cpp
+++ b/coin4/src/nodekits/SoSeparatorKit.cpp
@@ -168,7 +168,7 @@ SoSeparatorKit::SoSeparatorKit(void)
   SO_KIT_ADD_CATALOG_LIST_ENTRY(childList, SoSeparator, true, topSeparator, "", SoShapeKit, true);
   SO_KIT_ADD_LIST_ITEM_TYPE(childList, SoSeparatorKit);
 
-  PRIVATE(this)->connectedseparator = NULL;
+  PRIVATE(this)->connectedseparator = nullptr;
   PRIVATE(this)->fieldsensor = new SoFieldSensor(SoSeparatorKitP::sensorCB, PRIVATE(this));
   PRIVATE(this)->fieldsensor->setPriority(0);
 
@@ -242,7 +242,7 @@ SoSeparatorKitP::connectFields(const bool onoff)
     this->connectedseparator->renderCulling.disconnect();
     this->connectedseparator->pickCulling.disconnect();
     this->connectedseparator->unref();
-    this->connectedseparator = NULL;
+    this->connectedseparator = nullptr;
   }
   if (onoff) {
     SoSeparator * sep = (SoSeparator*) this->kit->topSeparator.getValue();
diff --git a/coin4/src/nodekits/SoSubKitP.h b/coin4/src/nodekits/SoSubKitP.h
index 8ff6f45..d1858a0 100644
--- a/coin4/src/nodekits/SoSubKitP.h
+++ b/coin4/src/nodekits/SoSubKitP.h
@@ -52,7 +52,7 @@
   do { \
     SO_NODE_INTERNAL_CONSTRUCTOR(_class_); \
     SoBase::staticDataLock(); \
-    if (_class_::classcatalog == NULL) { \
+    if (_class_::classcatalog == nullptr) { \
       SoType mytype = SoType::fromName(SO__QUOTE(_class_)); \
       if (_class_::parentcatalogptr) \
         _class_::classcatalog = (*_class_::parentcatalogptr)->clone(mytype); \
diff --git a/coin4/src/nodes/SoBaseColor.cpp b/coin4/src/nodes/SoBaseColor.cpp
index bb114fc..54882d8 100644
--- a/coin4/src/nodes/SoBaseColor.cpp
+++ b/coin4/src/nodes/SoBaseColor.cpp
@@ -73,7 +73,7 @@ class SoBaseColorP {
 #ifdef COIN_THREADSAFE
     colorpacker_storage(sizeof(void*), alloc_colorpacker, free_colorpacker),
 #endif // COIN_THREADSAFE
-    vbo(NULL) { }
+    vbo(nullptr) { }
   ~SoBaseColorP() { delete this->vbo; }
 
 #ifdef COIN_THREADSAFE
@@ -168,12 +168,12 @@ SoBaseColor::doAction(SoAction * action)
       SoBase::staticDataLock();
       if (SoGLVBOElement::shouldCreateVBO(state, num)) {
         setvbo = true;
-        if (PRIVATE(this)->vbo == NULL) {
+        if (PRIVATE(this)->vbo == nullptr) {
           PRIVATE(this)->vbo = new SoVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW);
         }
       }
       else if (PRIVATE(this)->vbo) {
-        PRIVATE(this)->vbo->setBufferData(NULL, 0, 0);
+        PRIVATE(this)->vbo->setBufferData(nullptr, 0, 0);
       }
       // don't fill in any data in the VBO. Data will be filled in
       // using the ColorPacker right before the VBO is used
diff --git a/coin4/src/nodes/SoBumpMap.cpp b/coin4/src/nodes/SoBumpMap.cpp
index b1d330d..1c10e2a 100644
--- a/coin4/src/nodes/SoBumpMap.cpp
+++ b/coin4/src/nodes/SoBumpMap.cpp
@@ -202,7 +202,7 @@ SoBumpMap::SoBumpMap(void)
   SO_NODE_INTERNAL_CONSTRUCTOR(SoBumpMap);
 
   SO_NODE_ADD_FIELD(filename, (""));
-  SO_NODE_ADD_FIELD(image, (SbVec2s(0, 0), 0, NULL));
+  SO_NODE_ADD_FIELD(image, (SbVec2s(0, 0), 0, nullptr));
   SO_NODE_ADD_FIELD(wrapS, (REPEAT));
   SO_NODE_ADD_FIELD(wrapT, (REPEAT));
 
@@ -226,7 +226,7 @@ SoBumpMap::SoBumpMap(void)
 */
 SoBumpMap::~SoBumpMap()
 {
-  PRIVATE(this)->glimage->unref(NULL);
+  PRIVATE(this)->glimage->unref(nullptr);
   delete PRIVATE(this)->filenamesensor;
   delete PRIVATE(this);
 }
@@ -303,7 +303,7 @@ SoBumpMap::GLRender(SoGLRenderAction * action)
       SoShapeStyleElement::setBumpmapEnabled(state, true);
     }
     else {
-      SoBumpMapElement::set(state, this, NULL);
+      SoBumpMapElement::set(state, this, nullptr);
       SoShapeStyleElement::setBumpmapEnabled(state, false);
     }
   }
diff --git a/coin4/src/nodes/SoCallback.cpp b/coin4/src/nodes/SoCallback.cpp
index 03adca5..ecc11cb 100644
--- a/coin4/src/nodes/SoCallback.cpp
+++ b/coin4/src/nodes/SoCallback.cpp
@@ -70,7 +70,7 @@ SoCallback::SoCallback(void)
 {
   SO_NODE_INTERNAL_CONSTRUCTOR(SoCallback);
 
-  this->cbfunc = NULL;
+  this->cbfunc = nullptr;
 }
 
 /*!
@@ -90,7 +90,7 @@ SoCallback::initClass(void)
 /*!
   Set up the \a function to call at traversal of this node. \a
   userdata will be passed back as the first argument of the callback
-  \a function. Setting \a function to NULL removes the previously set 
+  \a function. Setting \a function to nullptr removes the previously set 
   callback function.
 
   If you want a callback only for a specific action, you must (in your
diff --git a/coin4/src/nodes/SoCoordinate3.cpp b/coin4/src/nodes/SoCoordinate3.cpp
index 3283244..ea6e808 100644
--- a/coin4/src/nodes/SoCoordinate3.cpp
+++ b/coin4/src/nodes/SoCoordinate3.cpp
@@ -64,7 +64,7 @@
 
 class SoCoordinate3P {
  public:
-  SoCoordinate3P() : vbo(NULL) { }
+  SoCoordinate3P() : vbo(nullptr) { }
   ~SoCoordinate3P() { delete this->vbo; }
   SoVBO * vbo;
 };
@@ -129,7 +129,7 @@ SoCoordinate3::GLRender(SoGLRenderAction * action)
   if (SoGLVBOElement::shouldCreateVBO(state, num)) {
     bool dirty = false;
     setvbo = true;
-    if (PRIVATE(this)->vbo == NULL) {
+    if (PRIVATE(this)->vbo == nullptr) {
       PRIVATE(this)->vbo = new SoVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW); 
       dirty =  true;
     }
@@ -144,10 +144,10 @@ SoCoordinate3::GLRender(SoGLRenderAction * action)
   }
   else if (PRIVATE(this)->vbo && PRIVATE(this)->vbo->getBufferDataId()) {
     // clear buffers to deallocate VBO memory
-    PRIVATE(this)->vbo->setBufferData(NULL, 0, 0);
+    PRIVATE(this)->vbo->setBufferData(nullptr, 0, 0);
   }
   SoBase::staticDataUnlock();
-  SoGLVBOElement::setVertexVBO(state, setvbo ? PRIVATE(this)->vbo : NULL);
+  SoGLVBOElement::setVertexVBO(state, setvbo ? PRIVATE(this)->vbo : nullptr);
 }
 
 // Doc from superclass.
diff --git a/coin4/src/nodes/SoCoordinate4.cpp b/coin4/src/nodes/SoCoordinate4.cpp
index c96aa4c..24f7df0 100644
--- a/coin4/src/nodes/SoCoordinate4.cpp
+++ b/coin4/src/nodes/SoCoordinate4.cpp
@@ -71,7 +71,7 @@
 
 class SoCoordinate4P {
  public:
-  SoCoordinate4P() : vbo(NULL) { }
+  SoCoordinate4P() : vbo(nullptr) { }
   ~SoCoordinate4P() { delete this->vbo; }
   SoVBO * vbo;
 };
@@ -141,7 +141,7 @@ SoCoordinate4::GLRender(SoGLRenderAction * action)
   if (SoGLVBOElement::shouldCreateVBO(state, num)) {
     bool dirty = false;
     setvbo = true;
-    if (PRIVATE(this)->vbo == NULL) {
+    if (PRIVATE(this)->vbo == nullptr) {
       PRIVATE(this)->vbo = new SoVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW); 
       dirty =  true;
     }
@@ -156,7 +156,7 @@ SoCoordinate4::GLRender(SoGLRenderAction * action)
   }
   else if (PRIVATE(this)->vbo && PRIVATE(this)->vbo->getBufferDataId()) {
     // clear buffers to deallocate VBO memory
-    PRIVATE(this)->vbo->setBufferData(NULL, 0, 0);
+    PRIVATE(this)->vbo->setBufferData(nullptr, 0, 0);
   }
   SoBase::staticDataUnlock();
   if (setvbo) {
diff --git a/coin4/src/nodes/SoEventCallback.cpp b/coin4/src/nodes/SoEventCallback.cpp
index 0604d3b..c2fd8b4 100644
--- a/coin4/src/nodes/SoEventCallback.cpp
+++ b/coin4/src/nodes/SoEventCallback.cpp
@@ -98,8 +98,8 @@ SoEventCallback::SoEventCallback(void)
 {
   SO_NODE_INTERNAL_CONSTRUCTOR(SoEventCallback);
 
-  this->heaction = NULL;
-  this->path = NULL;
+  this->heaction = nullptr;
+  this->path = nullptr;
 }
 
 /*!
@@ -121,7 +121,7 @@ SoEventCallback::initClass(void)
 
 /*!
   Sets the path that must be picked before the registered callbacks
-  are invoked. If \c NULL, callbacks will be invoked for every event
+  are invoked. If \c nullptr, callbacks will be invoked for every event
   that matches the callback event type.
 
   \sa getPath()
@@ -131,7 +131,7 @@ SoEventCallback::setPath(SoPath * pathptr)
 {
   if (this->path) {
     this->path->unref();
-    this->path = NULL;
+    this->path = nullptr;
   }
   if (pathptr) {
 #if COIN_DEBUG
@@ -218,7 +218,7 @@ SoEventCallback::getAction(void) const
 const SoEvent *
 SoEventCallback::getEvent(void) const
 {
-  return (this->heaction ? this->heaction->getEvent() : NULL);
+  return (this->heaction ? this->heaction->getEvent() : nullptr);
 }
 
 /*!
@@ -230,7 +230,7 @@ SoEventCallback::getEvent(void) const
 const SoPickedPoint *
 SoEventCallback::getPickedPoint(void) const
 {
-  return this->heaction ? this->heaction->getPickedPoint() : NULL;
+  return this->heaction ? this->heaction->getPickedPoint() : nullptr;
 }
 
 
@@ -351,9 +351,9 @@ SoEventCallback::handleEvent(SoHandleEventAction * action)
   // SoHandleEventAction is applied to the scene graph while the
   // callbacks above are still processing, a new pointer will
   // overwrite the previous one (which is a problem that may cause
-  // hard-to-find errors), and then it will be overwritten with a NULL
+  // hard-to-find errors), and then it will be overwritten with a nullptr
   // pointer below, which causes getAction(), getEvent() etc to return
-  // NULL values.
+  // nullptr values.
   //
   // The fundamental design flaw here, as I see it, is that the
   // callback invocations should pass on the SoHandleEventAction
@@ -374,5 +374,5 @@ SoEventCallback::handleEvent(SoHandleEventAction * action)
                               "and should be avoided");
   }
 
-  this->heaction = NULL;
+  this->heaction = nullptr;
 }
diff --git a/coin4/src/nodes/SoExtSelection.cpp b/coin4/src/nodes/SoExtSelection.cpp
index 4b8e6e2..697604a 100644
--- a/coin4/src/nodes/SoExtSelection.cpp
+++ b/coin4/src/nodes/SoExtSelection.cpp
@@ -782,18 +782,18 @@ SoExtSelection::SoExtSelection(void)
   PRIVATE(this)->lassopatternanimate = true;
   PRIVATE(this)->lassopattern = 0xf0f0;
 
-  PRIVATE(this)->filterCB = NULL;
-  PRIVATE(this)->triangleFilterCB = NULL;
-  PRIVATE(this)->lineFilterCB = NULL;
-  PRIVATE(this)->pointFilterCB = NULL;
+  PRIVATE(this)->filterCB = nullptr;
+  PRIVATE(this)->triangleFilterCB = nullptr;
+  PRIVATE(this)->lineFilterCB = nullptr;
+  PRIVATE(this)->pointFilterCB = nullptr;
 
   PRIVATE(this)->drawcallbackcounter=0;
   PRIVATE(this)->drawcounter=0;
   PRIVATE(this)->visitedshapepaths = new SoPathList();
   PRIVATE(this)->somefacesvisible = false;
 
-  PRIVATE(this)->renderer = NULL;
-  PRIVATE(this)->lassorenderer = NULL;
+  PRIVATE(this)->renderer = nullptr;
+  PRIVATE(this)->lassorenderer = nullptr;
 
 }
 
@@ -849,7 +849,7 @@ SoExtSelection::isUsingOverlay(void)
 
 /*!
   Returns the scene graph for overlay rendering. Will always return
-  NULL in Coin, as this method has been obsoleted.
+  nullptr in Coin, as this method has been obsoleted.
 
   (It is probably used in TGS Inventor from the SoXt / SoWin
   libraries' So[Xt|Win]RenderArea class to fetch the overlay graph to
@@ -859,7 +859,7 @@ SoSeparator *
 SoExtSelection::getOverlaySceneGraph(void)
 {
   COIN_OBSOLETED();
-  return NULL;
+  return nullptr;
 }
 
 // *************************************************************************
@@ -1272,7 +1272,7 @@ SoExtSelection::getLassoCoordsDC (int &COIN_UNUSED_ARG(numCoords))
 {
   // FIXME: Implement this for TGS compatibility...
   COIN_STUB_ONCE();
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -1285,7 +1285,7 @@ SoExtSelection::getLassoCoordsWC (int &COIN_UNUSED_ARG(numCoords))
 {
   // FIXME: Implement this for TGS compatibility...
   COIN_STUB_ONCE();
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -1308,7 +1308,7 @@ SoExtSelection::getSelectionPathList () const
   new path to be used when selecting. The new returned path should
   not be ref'd. SoExtSelection will ref() and unref() it.
 
-  To cancel the selection, return NULL from the callback.
+  To cancel the selection, return nullptr from the callback.
 
   if \a callonlyifselectable is true, the callback will only be
   invoked when the path to the new node pass through the
@@ -1398,7 +1398,7 @@ void
 SoExtSelectionP::timercallback(void * data, SoSensor * COIN_UNUSED_ARG(sensor))
 {
   SoExtSelection * ext = (SoExtSelection *)data;
-  if (ext == NULL) return;
+  if (ext == nullptr) return;
   if (ext->isOverlayLassoAnimated()) {
     int pat = ext->getOverlayLassoPattern();
     int pat2 = pat << 1;
@@ -2241,7 +2241,7 @@ SoExtSelectionP::doSelect(const SoPath * path)
     newpath = this->filterCB(this->filterCBData, path);
   }
 
-  if (newpath == NULL) { return; }
+  if (newpath == nullptr) { return; }
 
 #if COIN_DEBUG && 0 // debug
   SoDebugError::postInfo("SoExtSelectionP::doSelect",
@@ -2656,11 +2656,11 @@ SoExtSelectionP::performSelection(SoHandleEventAction * action)
       vp = SbViewportRegion(newsize[0],newsize[1]);
     }
     // only (re)allocate the renderers if the viewport has changed
-    if (this->renderer == NULL || this->renderer->getViewportRegion() != vp) {
+    if (this->renderer == nullptr || this->renderer->getViewportRegion() != vp) {
       delete this->renderer;
       this->renderer = new SoOffscreenRenderer(vp);
     }
-    if (this->lassorenderer == NULL || this->lassorenderer->getViewportRegion() != vp) {
+    if (this->lassorenderer == nullptr || this->lassorenderer->getViewportRegion() != vp) {
       delete this->lassorenderer;
       this->lassorenderer = new SoOffscreenRenderer(vp);
     }
@@ -2696,7 +2696,7 @@ SoExtSelectionP::performSelection(SoHandleEventAction * action)
       // Debugging: if the envvar is set, the contents of the
       // offscreen buffer are stored to disk for investigation.
       static bool chkenv = false;
-      static const char * dumpfilename = NULL;
+      static const char * dumpfilename = nullptr;
       if (chkenv == false) {
         dumpfilename = coin_getenv("COIN_EXTSELECTION_SAVE_OFFSCREENBUFFER");
         chkenv = true;
diff --git a/coin4/src/nodes/SoFile.cpp b/coin4/src/nodes/SoFile.cpp
index 3417c3d..8cebfca 100644
--- a/coin4/src/nodes/SoFile.cpp
+++ b/coin4/src/nodes/SoFile.cpp
@@ -250,9 +250,9 @@ SoFile::readNamedFile(SoInput * in)
     if (!readok) { // actual read error
       break;
     }
-    if (n == NULL) { // this is what happens on EOF, not valid
+    if (n == nullptr) { // this is what happens on EOF, not valid
                      // identifiers, or when children have been given
-                     // the NULL keyword
+                     // the nullptr keyword
 
       break; 
     }
diff --git a/coin4/src/nodes/SoGroup.cpp b/coin4/src/nodes/SoGroup.cpp
index cad47e9..55fff81 100644
--- a/coin4/src/nodes/SoGroup.cpp
+++ b/coin4/src/nodes/SoGroup.cpp
@@ -70,7 +70,7 @@
     sa.apply(root);
     SoPath * p = sa.getPath();
     assert(p && "not found");
-    if (p->getLength() < 2) { return NULL; } // no parent
+    if (p->getLength() < 2) { return nullptr; } // no parent
     return (SoGroup *)p->getNodeFromTail(1);
   }
   \endcode
@@ -109,7 +109,7 @@
 	(mbe->getState() == SoButtonEvent::DOWN)) {
       if (global_pointlightmanip) {
 	global_root->removeChild(global_pointlightmanip);
-	global_pointlightmanip = NULL;
+	global_pointlightmanip = nullptr;
       }
     }
   }
@@ -227,7 +227,7 @@ public:
   static void childGLRenderProfiler(SoGroup * thisp, SoNode * child, SoGLRenderAction * action);
 };
 
-SoGroupP::GLRenderFunc * SoGroupP::glrenderfunc = NULL;
+SoGroupP::GLRenderFunc * SoGroupP::glrenderfunc = nullptr;
 
 // *************************************************************************
 
@@ -240,7 +240,7 @@ SO_NODE_SOURCE(SoGroup);
 */
 SoGroup::SoGroup(void)
 {
-  this->pimpl = NULL; // just set to NULL for now
+  this->pimpl = nullptr; // just set to nullptr for now
   SO_NODE_INTERNAL_CONSTRUCTOR(SoGroup);
 
   this->children = new SoChildList(this);
@@ -349,7 +349,7 @@ SoGroup::readChildren(SoInput * in)
   for (unsigned int i=0; !in->isBinary() || (i < numchildren); i++) {
     SoBase * child;
     if (SoBase::read(in, child, SoNode::getClassTypeId())) {
-      if (child == NULL) {
+      if (child == nullptr) {
 	if (in->eof()) {
 	  SoReadError::post(in, "Premature end of file");
 	  return false;
@@ -442,7 +442,7 @@ SoGroup::setOperation(const SoNotRec::OperationType opType,
 void
 SoGroup::addChild(SoNode * node)
 {
-  assert(node != NULL);
+  assert(node != nullptr);
   this->setOperation(SoNotRec::GROUP_ADDCHILD, node);
   this->getChildren()->append(node);
   this->setOperation();
@@ -467,7 +467,7 @@ SoGroup::insertChild(SoNode * child, int newchildindex)
     return;
   }
 #endif // COIN_DEBUG
-  this->setOperation(SoNotRec::GROUP_INSERTCHILD, child, NULL, newchildindex);
+  this->setOperation(SoNotRec::GROUP_INSERTCHILD, child, nullptr, newchildindex);
   this->getChildren()->insert(child, newchildindex);
   this->setOperation();
 }
@@ -491,7 +491,7 @@ SoGroup::removeChild(int childindex)
 #endif // COIN_DEBUG
   this->setOperation(SoNotRec::GROUP_REMOVECHILD,
 		     this->getChild(childindex),
-		     NULL, childindex);
+		     nullptr, childindex);
   this->getChildren()->remove(childindex);
   this->setOperation();
 }
diff --git a/coin4/src/nodes/SoLevelOfDetail.cpp b/coin4/src/nodes/SoLevelOfDetail.cpp
index 1c48959..f4d28ad 100644
--- a/coin4/src/nodes/SoLevelOfDetail.cpp
+++ b/coin4/src/nodes/SoLevelOfDetail.cpp
@@ -184,7 +184,7 @@ static void
 so_lod_construct_data(void * closure)
 {
   so_lod_static_data * data = (so_lod_static_data*) closure;
-  data->bboxaction = NULL;
+  data->bboxaction = nullptr;
 }
 
 static void
@@ -194,7 +194,7 @@ so_lod_destruct_data(void * closure)
   delete data->bboxaction;
 }
 
-static SbStorage * so_lod_storage = NULL;
+static SbStorage * so_lod_storage = nullptr;
 
 // called from atexit
 static void
@@ -206,10 +206,10 @@ so_lod_cleanup(void)
 static SoGetBoundingBoxAction *
 so_lod_get_bbox_action(void)
 {
-  so_lod_static_data * data = NULL;
+  so_lod_static_data * data = nullptr;
   data = (so_lod_static_data*) so_lod_storage->get();
   
-  if (data->bboxaction == NULL) {
+  if (data->bboxaction == nullptr) {
     // The viewport region will be replaced every time the action is
     // used, so we can just feed it a dummy here.
     data->bboxaction = new SoGetBoundingBoxAction(SbViewportRegion());
@@ -292,7 +292,7 @@ void
 SoLevelOfDetail::commonConstructor(void)
 {
   PRIVATE(this) = new SoLevelOfDetailP;
-  PRIVATE(this)->bboxcache = NULL;
+  PRIVATE(this)->bboxcache = nullptr;
 
   SO_NODE_INTERNAL_CONSTRUCTOR(SoLevelOfDetail);
 
diff --git a/coin4/src/nodes/SoLinearProfile.cpp b/coin4/src/nodes/SoLinearProfile.cpp
index 12720c4..220c0dd 100644
--- a/coin4/src/nodes/SoLinearProfile.cpp
+++ b/coin4/src/nodes/SoLinearProfile.cpp
@@ -66,7 +66,7 @@ static void
 so_linearprofile_construct_data(void * closure)
 {
   so_linearprofile_data * data = (so_linearprofile_data*) closure;
-  data->coordlist = NULL;
+  data->coordlist = nullptr;
 }
 
 static void
@@ -87,9 +87,9 @@ so_linearprofile_cleanup(void)
 static SbList <float> *
 so_linearprofile_get_coordlist(void)
 {
-  so_linearprofile_data * data = NULL;
+  so_linearprofile_data * data = nullptr;
   data = (so_linearprofile_data*) so_linearprofile_storage->get();
-  if (data->coordlist == NULL) {
+  if (data->coordlist == nullptr) {
     data->coordlist = new SbList<float>;
   }
   return data->coordlist;
@@ -264,7 +264,7 @@ SoLinearProfile::getVertices(SoState * state, int32_t & numvertices,
     numvertices = n;
   }
   else {
-    vertices = NULL;
+    vertices = nullptr;
     numvertices = 0;
   }
 }
diff --git a/coin4/src/nodes/SoLocateHighlight.cpp b/coin4/src/nodes/SoLocateHighlight.cpp
index 3f2195f..d3f7a83 100644
--- a/coin4/src/nodes/SoLocateHighlight.cpp
+++ b/coin4/src/nodes/SoLocateHighlight.cpp
@@ -148,7 +148,7 @@ public:
   static void atexit_cleanup(void) {
     if (SoLocateHighlightP::currenthighlight) {
       SoLocateHighlightP::currenthighlight->unref();
-      SoLocateHighlightP::currenthighlight = NULL;
+      SoLocateHighlightP::currenthighlight = nullptr;
     }
   }
 #ifdef COIN_THREADSAFE
@@ -165,7 +165,7 @@ private:
 
 };
 
-SoFullPath * SoLocateHighlightP::currenthighlight = NULL;
+SoFullPath * SoLocateHighlightP::currenthighlight = nullptr;
 
 // *************************************************************************
 
@@ -325,7 +325,7 @@ SoLocateHighlight::turnoffcurrent(SoAction * action)
   }
   if (SoLocateHighlightP::currenthighlight) {
     SoLocateHighlightP::currenthighlight->unref();
-    SoLocateHighlightP::currenthighlight = NULL;
+    SoLocateHighlightP::currenthighlight = nullptr;
   }
 }
 
diff --git a/coin4/src/nodes/SoMaterial.cpp b/coin4/src/nodes/SoMaterial.cpp
index e1a8269..2004edf 100644
--- a/coin4/src/nodes/SoMaterial.cpp
+++ b/coin4/src/nodes/SoMaterial.cpp
@@ -283,7 +283,7 @@ public:
 #ifdef COIN_THREADSAFE
     colorpacker_storage(sizeof(void*), alloc_colorpacker, free_colorpacker),
 #endif // COIN_THREADSAFE
-    vbo(NULL) { }
+    vbo(nullptr) { }
   ~SoMaterialP() { delete this->vbo; }
 
   int materialtype;
@@ -530,12 +530,12 @@ SoMaterial::doAction(SoAction * action)
       bool setvbo = false;
       if (SoGLVBOElement::shouldCreateVBO(state, numdiffuse)) {
         setvbo = true;
-        if (PRIVATE(this)->vbo == NULL) {
+        if (PRIVATE(this)->vbo == nullptr) {
           PRIVATE(this)->vbo = new SoVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW);
         }
       }
       else if (PRIVATE(this)->vbo) {
-        PRIVATE(this)->vbo->setBufferData(NULL, 0, 0);
+        PRIVATE(this)->vbo->setBufferData(nullptr, 0, 0);
       }
       // don't fill in any data in the VBO. Data will be filled in
       // using the ColorPacker right before the VBO is used
diff --git a/coin4/src/nodes/SoNode.cpp b/coin4/src/nodes/SoNode.cpp
index 4618181..4999b3c 100644
--- a/coin4/src/nodes/SoNode.cpp
+++ b/coin4/src/nodes/SoNode.cpp
@@ -81,13 +81,13 @@
 
   // myviewer will let go of it's reference to the root node, thereby
   // decreasing it's referencecount by 1
-  myviewer->setSceneGraph(NULL);
+  myviewer->setSceneGraph(nullptr);
 
   // root's refcount goes from +1 to 0, and it will self-destruct controllably
   root->unref();
   // avoid dangling pointer, in case "root" is attempted used again
   // (not really necessary, but good for smoking out bugs early)
-  root = NULL;
+  root = nullptr;
   \endcode
 
   For full information and tutorial-style introductions to all API
@@ -280,10 +280,10 @@
 uint32_t SoNode::nextUniqueId = 1;
 int SoNode::nextActionMethodIndex = 0;
 SoType SoNode::classTypeId STATIC_SOTYPE_INIT;
-static void * sonode_mutex = NULL;
+static void * sonode_mutex = nullptr;
 
 typedef SbHash<int16_t, uint32_t> Int16ToUInt32Map;
-static Int16ToUInt32Map * compatibility_dict = NULL;
+static Int16ToUInt32Map * compatibility_dict = nullptr;
 
 static void init_action_methods(void);
 
@@ -508,7 +508,7 @@ SoNode::initClass(void)
 
   CC_MUTEX_CONSTRUCT(sonode_mutex);
   SoNode::classTypeId =
-    SoType::createType(inherited::getClassTypeId(), "Node", NULL,
+    SoType::createType(inherited::getClassTypeId(), "Node", nullptr,
                        SoNode::nextActionMethodIndex++);
 
   // initialize the compatibility dict
@@ -754,7 +754,7 @@ SoNode *
 SoNode::getByName(const SbName & name)
 {
   SoBase * b = SoBase::getNamedBase(name, SoNode::getClassTypeId());
-  if (!b) return NULL;
+  if (!b) return nullptr;
   return (SoNode *)b;
 }
 
@@ -1293,7 +1293,7 @@ SoNode::audioRender(SoAudioRenderAction * COIN_UNUSED_ARG(action))
 SoChildList *
 SoNode::getChildren(void) const
 {
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -1459,7 +1459,7 @@ SoNode::getNextNodeId(void)
 const SoFieldData **
 SoNode::getFieldDataPtr(void)
 {
-  return NULL;
+  return nullptr;
 }
 
 // Doc in super.
diff --git a/coin4/src/nodes/SoNormal.cpp b/coin4/src/nodes/SoNormal.cpp
index 469ce97..6c9861f 100644
--- a/coin4/src/nodes/SoNormal.cpp
+++ b/coin4/src/nodes/SoNormal.cpp
@@ -68,7 +68,7 @@
 
 class SoNormalP {
  public:
-  SoNormalP() : vbo(NULL) { }
+  SoNormalP() : vbo(nullptr) { }
   ~SoNormalP() { delete this->vbo; }
 
   SoVBO * vbo;
@@ -86,7 +86,7 @@ SoNormal::SoNormal(void)
   PRIVATE(this) = new SoNormalP;
   SO_NODE_INTERNAL_CONSTRUCTOR(SoNormal);
 
-  SO_NODE_ADD_FIELD(vector, (NULL));
+  SO_NODE_ADD_FIELD(vector, (nullptr));
 }
 
 /*!
@@ -127,7 +127,7 @@ SoNormal::GLRender(SoGLRenderAction * action)
   if (SoGLVBOElement::shouldCreateVBO(state, num)) {
     setvbo = true;
     bool dirty = false;
-    if (PRIVATE(this)->vbo == NULL) {
+    if (PRIVATE(this)->vbo == nullptr) {
       PRIVATE(this)->vbo = new SoVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW); 
       dirty =  true;
     }
@@ -142,10 +142,10 @@ SoNormal::GLRender(SoGLRenderAction * action)
   }
   else if (PRIVATE(this)->vbo && PRIVATE(this)->vbo->getBufferDataId()) {
     // clear buffers to deallocate VBO memory
-    PRIVATE(this)->vbo->setBufferData(NULL, 0, 0);
+    PRIVATE(this)->vbo->setBufferData(nullptr, 0, 0);
   }
   SoBase::staticDataUnlock();
-  SoGLVBOElement::setNormalVBO(state, setvbo? PRIVATE(this)->vbo : NULL);
+  SoGLVBOElement::setNormalVBO(state, setvbo? PRIVATE(this)->vbo : nullptr);
 }
 
 // Doc in superclass.
diff --git a/coin4/src/nodes/SoNurbsProfile.cpp b/coin4/src/nodes/SoNurbsProfile.cpp
index b0b563c..3f6edfe 100644
--- a/coin4/src/nodes/SoNurbsProfile.cpp
+++ b/coin4/src/nodes/SoNurbsProfile.cpp
@@ -178,8 +178,8 @@ static void
 so_nurbsprofile_construct_data(void * closure)
 {
   so_nurbsprofile_data * data = (so_nurbsprofile_data*) closure;
-  data->coordlist = NULL;
-  data->tmplist = NULL;
+  data->coordlist = nullptr;
+  data->tmplist = nullptr;
 }
 
 static void
@@ -201,17 +201,17 @@ so_nurbsprofile_cleanup(void)
 static SbList <float> *
 so_nurbsprofile_get_coordlist(const bool tmplist)
 {
-  so_nurbsprofile_data * data = NULL;
+  so_nurbsprofile_data * data = nullptr;
   data = (so_nurbsprofile_data*) so_nurbsprofile_storage->get();
 
   if (tmplist) {
-    if (data->tmplist == NULL) {
+    if (data->tmplist == nullptr) {
       data->tmplist = new SbList<float>;
     }
     return data->tmplist;
   }
   else {
-    if (data->coordlist == NULL) {
+    if (data->coordlist == nullptr) {
       data->coordlist = new SbList<float>;
     }
     return data->coordlist;
@@ -230,7 +230,7 @@ SoNurbsProfile::SoNurbsProfile(void)
   SO_NODE_INTERNAL_CONSTRUCTOR(SoNurbsProfile);
 
   SO_NODE_ADD_FIELD(knotVector, (0.0f));
-  this->nurbsrenderer = NULL;
+  this->nurbsrenderer = nullptr;
 }
 
 /*!
@@ -350,7 +350,7 @@ SoNurbsProfile::getVertices(SoState * state, int32_t & numvertices,
   this->getTrimCurve(state, numpoints, points, floatspervec, numknots, knotvector);
   if (numpoints == 0 || numknots == 0) {
     numvertices = 0;
-    vertices = NULL;
+    vertices = nullptr;
     return;
   }
 
@@ -374,7 +374,7 @@ SoNurbsProfile::getVertices(SoState * state, int32_t & numvertices,
     // we will write into this array in the GLU callback
     coordListNurbsProfile->truncate(0);
 
-    if (this->nurbsrenderer == NULL) {
+    if (this->nurbsrenderer == nullptr) {
       this->nurbsrenderer = GLUWrapper()->gluNewNurbsRenderer();
       GLUWrapper()->gluNurbsCallback(this->nurbsrenderer, (GLenum) GLU_NURBS_VERTEX,
                                      (gluNurbsCallback_cb_t)nurbsprofile_tess_vertex);
diff --git a/coin4/src/nodes/SoPackedColor.cpp b/coin4/src/nodes/SoPackedColor.cpp
index 9d2fde3..3cb1291 100644
--- a/coin4/src/nodes/SoPackedColor.cpp
+++ b/coin4/src/nodes/SoPackedColor.cpp
@@ -79,7 +79,7 @@
 
 class SoPackedColorP {
  public:
-  SoPackedColorP() : vbo(NULL) { }
+  SoPackedColorP() : vbo(nullptr) { }
   ~SoPackedColorP() { delete this->vbo; }
   bool transparent;
   bool checktransparent;
@@ -151,7 +151,7 @@ SoPackedColor::doAction(SoAction * action)
       if (SoGLVBOElement::shouldCreateVBO(state, num)) {
         bool dirty = false;
         setvbo = true;
-        if (PRIVATE(this)->vbo == NULL) {
+        if (PRIVATE(this)->vbo == nullptr) {
           PRIVATE(this)->vbo = new SoVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW);
           dirty = true;
         }
@@ -182,7 +182,7 @@ SoPackedColor::doAction(SoAction * action)
         }
       }
       else if (PRIVATE(this)->vbo) {
-        PRIVATE(this)->vbo->setBufferData(NULL, 0, 0);
+        PRIVATE(this)->vbo->setBufferData(nullptr, 0, 0);
       }
       SoBase::staticDataUnlock();
       if (setvbo) {
diff --git a/coin4/src/nodes/SoPathSwitch.cpp b/coin4/src/nodes/SoPathSwitch.cpp
index c8dad6f..c321dbe 100644
--- a/coin4/src/nodes/SoPathSwitch.cpp
+++ b/coin4/src/nodes/SoPathSwitch.cpp
@@ -55,7 +55,7 @@
 /*!
   \var SoSFPath SoPathSwitch::path
 
-  The path that must match the current action path. A \c NULL path
+  The path that must match the current action path. A \c nullptr path
   will never match. An empty path will always match. The path should
   go up to (not including) the SoPathSwitch node, but need not go all
   the way back to the root node.
@@ -79,7 +79,7 @@ SoPathSwitch::SoPathSwitch(void)
 static bool 
 is_matching_paths(const SoPath * currentpath, const SoPath * pathswitchpath)
 {
-  if (pathswitchpath == NULL) return false;
+  if (pathswitchpath == nullptr) return false;
 
   const SoFullPath * current = (const SoFullPath*) currentpath;
   const SoFullPath * swpath = (const SoFullPath *) pathswitchpath;
@@ -126,7 +126,7 @@ void
 SoPathSwitch::commonConstructor(void)
 {
   SO_NODE_INTERNAL_CONSTRUCTOR(SoPathSwitch);
-  SO_NODE_ADD_FIELD(path, (NULL));
+  SO_NODE_ADD_FIELD(path, (nullptr));
 }
 
 /*!
diff --git a/coin4/src/nodes/SoSceneTexture2.cpp b/coin4/src/nodes/SoSceneTexture2.cpp
index 9ae09f6..d1b293a 100644
--- a/coin4/src/nodes/SoSceneTexture2.cpp
+++ b/coin4/src/nodes/SoSceneTexture2.cpp
@@ -55,8 +55,8 @@
   \code
     SceneTexture2 {
         size 256 256
-        scene NULL
-        sceneTransparencyType NULL
+        scene nullptr
+        sceneTransparencyType nullptr
         type RGBA_UNSIGNED_BYTE
         backgroundColor 0 0 0 0
         transparencyFunction NONE
@@ -200,7 +200,7 @@
   \var SoSFNode SoSceneTexture2::sceneTransparencyType
 
   Used for overriding the transparency type for the sub scene graph.
-  Should contain an instance of the SoTransparecyType node, or NULL to
+  Should contain an instance of the SoTransparecyType node, or nullptr to
   inherit the transparency type from the current viewer.
 
   Please note that if you want to render the texture using frame
@@ -344,8 +344,8 @@ class SoSceneTexture2P {
         this->cachecontext = cachecontext;
         this->fbo_frameBuffer = GL_INVALID_VALUE;
         this->fbo_depthBuffer = GL_INVALID_VALUE;
-        this->fbo_texture = NULL;
-        this->fbo_depthmap = NULL;
+        this->fbo_texture = nullptr;
+        this->fbo_depthmap = nullptr;
         this->fbo_size.setValue(-1,-1);
         this->fbo_mipmap = false;
     }
@@ -444,8 +444,8 @@ SoSceneTexture2::SoSceneTexture2(void)
 
   SO_NODE_INTERNAL_CONSTRUCTOR(SoSceneTexture2);
   SO_NODE_ADD_FIELD(size, (256, 256));
-  SO_NODE_ADD_FIELD(scene, (NULL));
-  SO_NODE_ADD_FIELD(sceneTransparencyType, (NULL));
+  SO_NODE_ADD_FIELD(scene, (nullptr));
+  SO_NODE_ADD_FIELD(sceneTransparencyType, (nullptr));
   SO_NODE_ADD_FIELD(backgroundColor, (0.0f, 0.0f, 0.0f, 0.0f));
   SO_NODE_ADD_FIELD(transparencyFunction, (NONE));
 
@@ -572,7 +572,7 @@ SoSceneTexture2::GLRender(SoGLRenderAction * action)
                                       this->blendColor.getValue());
 
     SoGLMultiTextureEnabledElement::set(state, this, unit,
-                                        PRIVATE(this)->glimage != NULL &&
+                                        PRIVATE(this)->glimage != nullptr &&
                                         quality > 0.0f);
   }
   else {
@@ -665,28 +665,28 @@ SoSceneTexture2::write(SoWriteAction * action)
 SoSceneTexture2P::SoSceneTexture2P(SoSceneTexture2 * apiptr)
 {
   this->api = apiptr;
-  this->glcontext = NULL;
+  this->glcontext = nullptr;
   this->buffervalid = false;
   this->glimagevalid = false;
-  this->glimage = NULL;
+  this->glimage = nullptr;
   this->glimagecontext = 0;
-  this->glaction = NULL;
+  this->glaction = nullptr;
   this->glcontextsize.setValue(-1,-1);
   this->glrectangle = false;
-  this->offscreenbuffer = NULL;
+  this->offscreenbuffer = nullptr;
   this->offscreenbuffersize = 0;
   this->canrendertotexture = false;
   this->contextid = -1;
-  this->fbodata = NULL;
+  this->fbodata = nullptr;
 }
 
 SoSceneTexture2P::~SoSceneTexture2P()
 {
-  this->deleteFrameBufferObjects(NULL, NULL);
+  this->deleteFrameBufferObjects(nullptr, nullptr);
   delete this->fbodata;
 
-  if (this->glimage) this->glimage->unref(NULL);
-  if (this->glcontext != NULL) {
+  if (this->glimage) this->glimage->unref(nullptr);
+  if (this->glcontext != nullptr) {
     cc_glglue_context_destruct(this->glcontext);
   }
   delete[] this->offscreenbuffer;
@@ -748,11 +748,11 @@ SoSceneTexture2P::updateFrameBuffer(SoState * state, const float COIN_UNUSED_ARG
     fbodata->cachecontext = cachecontext;
     
     if (this->glimage) {
-      this->glimage->unref(NULL);
-      this->glimage = NULL;
+      this->glimage->unref(nullptr);
+      this->glimage = nullptr;
       this->glimagecontext = 0;
     }
-    if (this->glimage == NULL) {
+    if (this->glimage == nullptr) {
       this->glimage = new SoGLImage;
       this->glimagecontext = SoGLCacheContextElement::get(state);
       uint32_t flags = this->glimage->getFlags();
@@ -791,12 +791,12 @@ SoSceneTexture2P::updateFrameBuffer(SoState * state, const float COIN_UNUSED_ARG
 
     // FIXME: for some reason we need to do this every frame. Investigate why.
     if (PUBLIC(this)->type.getValue() == SoSceneTexture2::DEPTH) {
-      assert(fbodata->fbo_depthmap != NULL);
+      assert(fbodata->fbo_depthmap != nullptr);
       this->glimage->setGLDisplayList(fbodata->fbo_depthmap, state,
                                       SoGLImage::CLAMP, SoGLImage::CLAMP);
     }
     else {
-      assert(fbodata->fbo_texture != NULL);
+      assert(fbodata->fbo_texture != nullptr);
       this->glimage->setGLDisplayList(fbodata->fbo_texture, state);
     }
   }
@@ -846,7 +846,7 @@ SoSceneTexture2P::updateFrameBuffer(SoState * state, const float COIN_UNUSED_ARG
   SoGLRenderAction::SoGLRenderAbortCB * old_func;
   void * old_userdata;
   glaction->getAbortCallback(old_func, old_userdata);
-  glaction->setAbortCallback(NULL, NULL);
+  glaction->setAbortCallback(nullptr, nullptr);
   glaction->switchToNodeTraversal(scene);
   glaction->setAbortCallback(old_func, old_userdata);
 
@@ -901,18 +901,18 @@ SoSceneTexture2P::updatePBuffer(SoState * state, const float quality)
   if ((this->glcontext && this->glcontextsize != size) || (size == SbVec2s(0,0))) {
     if (this->glimage) {
       this->glimage->unref(state);
-      this->glimage = NULL;
+      this->glimage = nullptr;
       this->glimagecontext = 0;
     }
     if (this->glcontext) {
       cc_glglue_context_destruct(this->glcontext);
       this->glcontextsize.setValue(-1,-1);
-      this->glcontext = NULL;
+      this->glcontext = nullptr;
     }
     if (this->glaction) {
       // Note: Recreating the glaction (below) will also get us a new contextid.
       delete this->glaction;
-      this->glaction = NULL;
+      this->glaction = nullptr;
     }
     this->glimagevalid = false;
   }
@@ -923,7 +923,7 @@ SoSceneTexture2P::updatePBuffer(SoState * state, const float quality)
   size[0] = (short) coin_geq_power_of_two(size[0]);
   size[1] = (short) coin_geq_power_of_two(size[1]);
 
-  if (this->glcontext == NULL) {
+  if (this->glcontext == nullptr) {
     this->glcontextsize = size;
      // disabled until an pbuffer extension is available to create a
     // render-to-texture pbuffer that has a non power of two size.
@@ -970,8 +970,8 @@ SoSceneTexture2P::updatePBuffer(SoState * state, const float quality)
   }
 
   if (!this->buffervalid) {
-    assert(this->glaction != NULL);
-    assert(this->glcontext != NULL);
+    assert(this->glaction != nullptr);
+    assert(this->glcontext != nullptr);
     this->glaction->setTransparencyType((SoGLRenderAction::TransparencyType)
                                         SoShapeStyleElement::getTransparencyType(state));
 
@@ -998,11 +998,11 @@ SoSceneTexture2P::updatePBuffer(SoState * state, const float quality)
     
     cc_glglue_context_reinstate_previous(this->glcontext);
   }
-  if (!this->glimagevalid || (this->glimage == NULL)) {
+  if (!this->glimagevalid || (this->glimage == nullptr)) {
     // just delete old glimage
     if (this->glimage) {
       this->glimage->unref(state);
-      this->glimage = NULL;
+      this->glimage = nullptr;
     }
     this->glimage = new SoGLImage;
     this->glimagecontext = SoGLCacheContextElement::get(state);
@@ -1137,8 +1137,8 @@ SoSceneTexture2P::createFramebufferObjects(const cc_glglue * glue, SoState * sta
   fbo_data * fbodata = this->fbodata;
   assert(fbodata);  
 
-  assert(fbodata->fbo_texture == NULL);
-  assert(fbodata->fbo_depthmap == NULL);
+  assert(fbodata->fbo_texture == nullptr);
+  assert(fbodata->fbo_depthmap == nullptr);
   assert(fbodata->fbo_frameBuffer == GL_INVALID_VALUE);
   assert(fbodata->fbo_depthBuffer == GL_INVALID_VALUE);
 
@@ -1174,7 +1174,7 @@ SoSceneTexture2P::createFramebufferObjects(const cc_glglue * glue, SoState * sta
                fbodata->fbo_size[0], fbodata->fbo_size[1],
                0, /* border */
                format,
-               gltype, NULL);
+               gltype, nullptr);
 
   // for mipmaps
   // FIXME: add support for CLAMP_TO_BORDER in SoSceneTexture2 and SoTextureImageElement
@@ -1215,7 +1215,7 @@ SoSceneTexture2P::createFramebufferObjects(const cc_glglue * glue, SoState * sta
                  fbodata->fbo_size[0], fbodata->fbo_size[1],
                  0, /* border */
                  GL_DEPTH_COMPONENT,
-                 GL_UNSIGNED_BYTE, NULL);
+                 GL_UNSIGNED_BYTE, nullptr);
 
     if (SoGLDriverDatabase::isSupported(glue, "GL_ARB_texture_border_clamp") ||
         SoGLDriverDatabase::isSupported(glue, "GL_SGIS_texture_border_clamp")) {
@@ -1239,7 +1239,7 @@ SoSceneTexture2P::createFramebufferObjects(const cc_glglue * glue, SoState * sta
     fbodata->fbo_depthmap->close(state);
   }
 
-  if (fbodata->fbo_texture != NULL) {
+  if (fbodata->fbo_texture != nullptr) {
     // attach texture to framebuffer color object
     cc_glglue_glFramebufferTexture2D(glue,
                                      GL_FRAMEBUFFER_EXT,
@@ -1275,11 +1275,11 @@ SoSceneTexture2P::deleteFrameBufferObjects(const cc_glglue * glue, SoState * sta
   
   if (fbodata->fbo_texture) {
     fbodata->fbo_texture->unref(state);
-    fbodata->fbo_texture = NULL;
+    fbodata->fbo_texture = nullptr;
   }
   if (fbodata->fbo_depthmap) {
     fbodata->fbo_depthmap->unref(state);
-    fbodata->fbo_depthmap = NULL;
+    fbodata->fbo_depthmap = nullptr;
   }
   if (glue && state && SoGLCacheContextElement::get(state) == fbodata->cachecontext) {
     if (fbodata->fbo_frameBuffer != GL_INVALID_VALUE) {
diff --git a/coin4/src/nodes/SoSceneTextureCubeMap.cpp b/coin4/src/nodes/SoSceneTextureCubeMap.cpp
index 9edbca3..2a2ce2d 100644
--- a/coin4/src/nodes/SoSceneTextureCubeMap.cpp
+++ b/coin4/src/nodes/SoSceneTextureCubeMap.cpp
@@ -173,7 +173,7 @@ SoSceneTextureCubeMap::SoSceneTextureCubeMap(void)
   SO_NODE_CONSTRUCTOR(SoSceneTextureCubeMap);
 
   SO_NODE_ADD_FIELD(size, (256, 256));
-  SO_NODE_ADD_FIELD(scene, (NULL));
+  SO_NODE_ADD_FIELD(scene, (nullptr));
   SO_NODE_ADD_FIELD(backgroundColor, (0.0f, 0.0f, 0.0f));
   SO_NODE_ADD_FIELD(transparencyFunction, (NONE));
 
@@ -341,28 +341,28 @@ SoSceneTextureCubeMap::notify(SoNotList * list)
 SoSceneTextureCubeMapP::SoSceneTextureCubeMapP(SoSceneTextureCubeMap * apiptr)
 {
   this->api = apiptr;
-  this->glimage = NULL;
+  this->glimage = nullptr;
   this->glimagevalid = false;
-  this->glcontext = NULL;
+  this->glcontext = nullptr;
   this->pbuffervalid = false;
-  this->glaction = NULL;
+  this->glaction = nullptr;
   this->glcontextsize.setValue(-1,-1);
   this->glrectangle = false;
-  this->offscreenbuffer = NULL;
+  this->offscreenbuffer = nullptr;
   this->offscreenbuffersize = 0;
   this->canrendertotexture = false;
   this->contextid = -1;
-  this->cachedScene = NULL;
-  this->cachedCamera = NULL;
+  this->cachedScene = nullptr;
+  this->cachedCamera = nullptr;
   this->hadSceneCamera = false;
   this->hasSceneChanged = true;
 }
 
 SoSceneTextureCubeMapP::~SoSceneTextureCubeMapP()
 {
-  if (this->glimage) this->glimage->unref(NULL);
+  if (this->glimage) this->glimage->unref(nullptr);
   this->destroyCamera();
-  if (this->glcontext != NULL) {
+  if (this->glcontext != nullptr) {
     cc_glglue_context_destruct(this->glcontext);
   }
   delete[] this->offscreenbuffer;
@@ -380,16 +380,16 @@ SoSceneTextureCubeMapP::updatePBuffer(SoState * state, const float quality)
       (size == SbVec2s(0,0))) {
     if (this->glimage) {
       this->glimage->unref(state);
-      this->glimage = NULL;
+      this->glimage = nullptr;
     }
     if (this->glcontext) {
       cc_glglue_context_destruct(this->glcontext);
       this->glcontextsize.setValue(-1,-1);
-      this->glcontext = NULL;
+      this->glcontext = nullptr;
     }
     if (this->glaction) {
       delete this->glaction; 
-      this->glaction = NULL;
+      this->glaction = nullptr;
     }
     this->glimagevalid = false;
   }
@@ -400,7 +400,7 @@ SoSceneTextureCubeMapP::updatePBuffer(SoState * state, const float quality)
   size[0] = (short) coin_geq_power_of_two(size[0]);
   size[1] = (short) coin_geq_power_of_two(size[1]);
 
-  if (this->glcontext == NULL) {
+  if (this->glcontext == nullptr) {
     this->glcontextsize = size;
     // disabled until an pbuffer extension is available to create a
     // render-to-texture pbuffer that has a non power of two size.
@@ -455,8 +455,8 @@ SoSceneTextureCubeMapP::updatePBuffer(SoState * state, const float quality)
   }
 
   if (!this->pbuffervalid) {
-    assert(this->glaction != NULL);
-    assert(this->glcontext != NULL);
+    assert(this->glaction != nullptr);
+    assert(this->glcontext != nullptr);
     this->glaction->setTransparencyType((SoGLRenderAction::TransparencyType)
                                         SoShapeStyleElement::getTransparencyType(state));
 
@@ -491,11 +491,11 @@ SoSceneTextureCubeMapP::updatePBuffer(SoState * state, const float quality)
     cc_glglue_context_reinstate_previous(this->glcontext);
   }
 
-  if (!this->glimagevalid || (this->glimage == NULL)) {
+  if (!this->glimagevalid || (this->glimage == nullptr)) {
     // just delete old glimage
     if (this->glimage) {
       this->glimage->unref(state);
-      this->glimage = NULL;
+      this->glimage = nullptr;
     }
     this->glimage = new SoGLCubeMapImage;
     uint32_t flags = this->glimage->getFlags();
@@ -552,11 +552,11 @@ SoSceneTextureCubeMapP::destroyCamera(void)
 {
   if (this->cachedCamera) {
     this->cachedCamera->unref();
-    this->cachedCamera = NULL;
+    this->cachedCamera = nullptr;
   }
   if (this->cachedScene) {
     this->cachedScene->unref();
-    this->cachedScene = NULL;
+    this->cachedScene = nullptr;
   }
 }
 
@@ -571,8 +571,8 @@ SoSceneTextureCubeMapP::findCamera(void)
 
   SoPath * path = sa.getPath();
 
-  if (path == NULL)
-    return NULL;
+  if (path == nullptr)
+    return nullptr;
   else
     return (SoCamera *)path->getTail();
 }
@@ -585,7 +585,7 @@ SoSceneTextureCubeMapP::ensureCamera(void)
 
   this->hasSceneChanged = false;
   SoCamera * camera    = this->findCamera();
-  bool     hasCamera = (camera != NULL); // does the scene provide a camera?
+  bool     hasCamera = (camera != nullptr); // does the scene provide a camera?
 
   if (hasCamera) {
     if (this->cachedCamera != camera) {
@@ -594,7 +594,7 @@ SoSceneTextureCubeMapP::ensureCamera(void)
       this->cachedCamera->ref();
     }
   }
-  else if (this->hadSceneCamera || this->cachedCamera == NULL) {
+  else if (this->hadSceneCamera || this->cachedCamera == nullptr) {
     // create default camera:
     static int didwarn = 0;
     if (!didwarn) {
@@ -623,7 +623,7 @@ SoSceneTextureCubeMapP::ensureCamera(void)
       this->cachedScene->ref();
     }
   }
-  else if (this->cachedScene == NULL || this->hadSceneCamera) {
+  else if (this->cachedScene == nullptr || this->hadSceneCamera) {
     if (this->cachedScene) this->cachedScene->unref();
     SoSeparator * root = new SoSeparator();
     root->addChild(this->cachedCamera);
diff --git a/coin4/src/nodes/SoSelection.cpp b/coin4/src/nodes/SoSelection.cpp
index 44caf98..7622f53 100644
--- a/coin4/src/nodes/SoSelection.cpp
+++ b/coin4/src/nodes/SoSelection.cpp
@@ -46,7 +46,7 @@
 
   \code
   extern SoSeparator * make_scenegraph( void );
-  static SoSelection * selection = NULL;
+  static SoSelection * selection = nullptr;
 
   // Callback function triggered for selection / deselection.
   void made_selection( void * userdata, SoPath * path )
@@ -266,7 +266,7 @@ static void
 soselection_cleanup(void)
 {
   delete soselection_searchAction;
-  soselection_searchAction = NULL;
+  soselection_searchAction = nullptr;
 }
 
 // *************************************************************************
@@ -340,11 +340,11 @@ SoSelection::init(void)
   this->finishCBList = new SoCallbackList;
   this->changeCBList = new SoCallbackList;
 
-  this->pickCBFunc = NULL;
-  this->pickCBData = NULL;
+  this->pickCBFunc = nullptr;
+  this->pickCBData = nullptr;
   this->callPickCBOnlyIfSelectable = false;
 
-  this->mouseDownPickPath = NULL;
+  this->mouseDownPickPath = nullptr;
   this->pickMatching = true;
 }
 
@@ -622,12 +622,12 @@ SoSelection::removeFinishCallback(SoSelectionClassCB * f, void * userData)
   Possible return values from the callback:
 
   <ul>
-  <li> NULL: simulate that nothing was picked. This will clear the
+  <li> nullptr: simulate that nothing was picked. This will clear the
     selection for the SINGLE policy. The handle event action will be
     halted.</li>
   <li> A path: the path will be selected/deselected. The handle event
     action will be halted. </li>
-  <li> A path containing only the Selection node: as NULL, but action
+  <li> A path containing only the Selection node: as nullptr, but action
     will not be halted. </li>
   <li> An empty path or a path not containing the Selection node: the
     pick will be ignored. </li>
@@ -726,7 +726,7 @@ SoSelection::performSingleSelection(SoPath * path)
 {
   // Make a copy of the path from the selection node down, to use for
   // comparisons versus already selected paths.
-  SoPath * cmppath = path ? this->copyFromThis(path) : NULL;
+  SoPath * cmppath = path ? this->copyFromThis(path) : nullptr;
   if (cmppath) { cmppath->ref(); }
 
   const int nrsel = this->getNumSelected();
@@ -775,7 +775,7 @@ SoSelection::performToggleSelection(SoPath * path)
 SoPath *
 SoSelection::copyFromThis(const SoPath * path) const
 {
-  SoPath * newpath = NULL;
+  SoPath * newpath = nullptr;
   path->ref();
   int i = path->findNode(this);
   if (i >= 0) {
@@ -845,7 +845,7 @@ SoSelection::handleEvent(SoHandleEventAction * action)
   if (SO_MOUSE_PRESS_EVENT(event, BUTTON1)) {
     if (this->mouseDownPickPath) {
       this->mouseDownPickPath->unref();
-      this->mouseDownPickPath = NULL;
+      this->mouseDownPickPath = nullptr;
     }
     const SoPickedPoint * pp = action->getPickedPoint();
     if (pp) {
@@ -889,7 +889,7 @@ SoSelection::handleEvent(SoHandleEventAction * action)
     }
     if (this->mouseDownPickPath) {
       this->mouseDownPickPath->unref();
-      this->mouseDownPickPath = NULL;
+      this->mouseDownPickPath = nullptr;
     }
   }
 }
@@ -897,11 +897,11 @@ SoSelection::handleEvent(SoHandleEventAction * action)
 
 // Uses a static search action to find path to node from this. If the
 // node is found, the returned path will be ref'ed. It's the caller's
-// responsibility to unref the returned path when != NULL.
+// responsibility to unref the returned path when != nullptr.
 SoPath *
 SoSelection::searchNode(SoNode * node) const
 {
-  if (soselection_searchAction == NULL) {
+  if (soselection_searchAction == nullptr) {
     soselection_searchAction = new SoSearchAction;
     soselection_searchAction->setInterest(SoSearchAction::FIRST);
     coin_atexit((coin_atexit_f*) soselection_cleanup, CC_ATEXIT_NORMAL);
@@ -928,11 +928,11 @@ SoSelection::getSelectionPath(SoHandleEventAction * action, bool & ignorepick,
 
   haltaction = false;
   ignorepick = false;
-  if (this->pickMatching && this->mouseDownPickPath == NULL) {
-    return NULL;
+  if (this->pickMatching && this->mouseDownPickPath == nullptr) {
+    return nullptr;
   }
   const SoPickedPoint * pp = action->getPickedPoint();
-  SoPath * selectionpath = NULL;
+  SoPath * selectionpath = nullptr;
   if (pp) {
     selectionpath = pp->getPath();
     // if there's no pickCBFunc we can just test against
@@ -940,7 +940,7 @@ SoSelection::getSelectionPath(SoHandleEventAction * action, bool & ignorepick,
     if (this->pickMatching && !this->pickCBFunc) {
       if (*(this->mouseDownPickPath) != *selectionpath) {
         ignorepick = true;
-        return NULL;
+        return nullptr;
       }
     }
     // if we have a pickCBFunc we have to get the pick filter path
@@ -951,7 +951,7 @@ SoSelection::getSelectionPath(SoHandleEventAction * action, bool & ignorepick,
 
       // From the SoSelection man-pages:
       // Possible return values from pickCBFunc:
-      // 1) NULL - behave as if nothing was picked, halt action
+      // 1) nullptr - behave as if nothing was picked, halt action
       // 2) path through the selection node - select/deselect path
       // 3) path containing only the selection node - as 1, but do not halt action 
       // 4) path not through the selection node - ignore event
@@ -960,7 +960,7 @@ SoSelection::getSelectionPath(SoHandleEventAction * action, bool & ignorepick,
             selectionpath->getNode(0) == this) {
           selectionpath->ref();
           selectionpath->unref();
-          selectionpath = NULL;
+          selectionpath = nullptr;
         }
         else if (selectionpath->findNode(this) >= 0) {
           if (*(this->mouseDownPickPath) == *selectionpath) {
@@ -971,18 +971,18 @@ SoSelection::getSelectionPath(SoHandleEventAction * action, bool & ignorepick,
             // mouse release didn't match mouse down
             selectionpath->ref();
             selectionpath->unref();
-            selectionpath = NULL;
+            selectionpath = nullptr;
             ignorepick = true;
           }
         }
         else { // path with this not in the path (most probably an empty path)
           selectionpath->ref();
           selectionpath->unref();
-          selectionpath = NULL;
+          selectionpath = nullptr;
           ignorepick = true;
         }
       }
-      else { // pickCBFunc returned NULL
+      else { // pickCBFunc returned nullptr
         haltaction = true;
       }
     }
diff --git a/coin4/src/nodes/SoSeparator.cpp b/coin4/src/nodes/SoSeparator.cpp
index 9db8a90..35f60f7 100644
--- a/coin4/src/nodes/SoSeparator.cpp
+++ b/coin4/src/nodes/SoSeparator.cpp
@@ -277,7 +277,7 @@ static void
 soseparator_storage_construct(void * data)
 {
   soseparator_storage * ptr = (soseparator_storage*) data;
-  ptr->glcachelist = NULL;
+  ptr->glcachelist = nullptr;
 }
 
 static void
@@ -296,7 +296,7 @@ public:
       new SbStorage(sizeof(soseparator_storage),
                     soseparator_storage_construct,
                     soseparator_storage_destruct);
-    this->pub = NULL;
+    this->pub = nullptr;
   }
   ~SoSeparatorP() {
     delete this->glcachestorage;
@@ -329,7 +329,7 @@ public:
   SoGLCacheList * getGLCacheList(bool createifnull);
 
   void invalidateGLCaches(void) {
-    glcachestorage->applyToAll(invalidate_gl_cache, NULL);
+    glcachestorage->applyToAll(invalidate_gl_cache, nullptr);
   }
 
   void lock(void) {
@@ -357,7 +357,7 @@ SoSeparatorP::getGLCacheList(bool createifnull)
 {
   soseparator_storage * ptr =
     (soseparator_storage*) this->glcachestorage->get();
-  if (createifnull && ptr->glcachelist == NULL) {
+  if (createifnull && ptr->glcachelist == nullptr) {
     ptr->glcachelist = new SoGLCacheList(SoSeparator::getNumRenderCaches());
   }
   return ptr->glcachelist;
@@ -416,7 +416,7 @@ SoSeparator::commonConstructor(void)
     maxcaches = -2; // so we don't request the envvar later if it is not set
     const char * maxcachesstr = coin_getenv("IV_SEPARATOR_MAX_CACHES");
     if (maxcachesstr) {
-      maxcaches = strtol(maxcachesstr, NULL, 10);
+      maxcaches = strtol(maxcachesstr, nullptr, 10);
       if ((maxcaches == LONG_MIN) || (maxcaches == LONG_MAX) || (maxcaches < 0)) {
         SoDebugError::post("SoSeparator::commonConstructor",
                            "Environment variable IV_SEPARATOR_MAX_CACHES "
@@ -428,7 +428,7 @@ SoSeparator::commonConstructor(void)
     }
   }
 
-  PRIVATE(this)->bboxcache = NULL;
+  PRIVATE(this)->bboxcache = nullptr;
   PRIVATE(this)->bboxcache_usecount = 0;
   PRIVATE(this)->bboxcache_destroycount = 0;
 
@@ -644,7 +644,7 @@ SoSeparator::GLRenderBelowPath(SoGLRenderAction * action)
   state->push();
   bool didcull = false;
 
-  SoGLCacheList * createcache = NULL;
+  SoGLCacheList * createcache = nullptr;
   if ((this->renderCaching.getValue() != OFF) &&
       (SoSeparator::getNumRenderCaches() > 0)) {
 
@@ -694,7 +694,7 @@ SoSeparator::GLRenderBelowPath(SoGLRenderAction * action)
     false : this->cullTest(state);
   if (createcache || !outsidefrustum) {
     int n = this->children->getLength();
-    SoNode ** childarray = (n!=0)? reinterpret_cast<SoNode**>(this->children->getArrayPtr()) : NULL;
+    SoNode ** childarray = (n!=0)? reinterpret_cast<SoNode**>(this->children->getArrayPtr()) : nullptr;
     action->pushCurPath();
     for (int i = 0; i < n && !action->hasTerminated(); i++) {
       action->popPushCurPath(i, childarray[i]);
diff --git a/coin4/src/nodes/SoSubNodeP.h b/coin4/src/nodes/SoSubNodeP.h
index 49c9b47..34fb0c1 100644
--- a/coin4/src/nodes/SoSubNodeP.h
+++ b/coin4/src/nodes/SoSubNodeP.h
@@ -79,7 +79,7 @@
 #define SO_NODE_INTERNAL_INIT_ABSTRACT_CLASS(_class_, _fileformats_) \
   do { \
     const char * classname = SO__QUOTE(_class_); \
-    PRIVATE_INTERNAL_COMMON_INIT_CODE(_class_, &classname[2], NULL, inherited); \
+    PRIVATE_INTERNAL_COMMON_INIT_CODE(_class_, &classname[2], nullptr, inherited); \
     SoNode::setCompatibilityTypes(_class_::getClassTypeId(), _fileformats_); \
   } while (0)
 
diff --git a/coin4/src/nodes/SoSurroundScale.cpp b/coin4/src/nodes/SoSurroundScale.cpp
index baa8bac..b5dfb13 100644
--- a/coin4/src/nodes/SoSurroundScale.cpp
+++ b/coin4/src/nodes/SoSurroundScale.cpp
@@ -78,7 +78,7 @@
   main(int argc, char **argv)
   {
     QWidget * window = SoQt::init(argv[0]);
-    if (window == NULL) exit(1);
+    if (window == nullptr) exit(1);
 
     SoSeparator * root = new SoSeparator;
     root->ref();
@@ -407,7 +407,7 @@ SoSurroundScale::updateMySurroundParams(SoAction * action,
   SoPath * applypath = curpath->copy(0, curpathlen - numtocontainer);
   applypath->ref();
 
-  SoPath * resetpath = NULL;
+  SoPath * resetpath = nullptr;
   // if numtoreset is out of range, just ignore it and don't use a
   // reset path
   if ((numtoreset >= 0) && (numtoreset < numtocontainer)) {
diff --git a/coin4/src/nodes/SoTexture2.cpp b/coin4/src/nodes/SoTexture2.cpp
index c703b31..f121f09 100644
--- a/coin4/src/nodes/SoTexture2.cpp
+++ b/coin4/src/nodes/SoTexture2.cpp
@@ -375,11 +375,11 @@ public:
 
   static void cleanup(void) {
     delete SoTexture2P::mutex;
-    SoTexture2P::mutex = NULL;
+    SoTexture2P::mutex = nullptr;
   }
 };
 
-SbMutex * SoTexture2P::mutex = NULL;
+SbMutex * SoTexture2P::mutex = nullptr;
 
 #define PRIVATE(p) ((p)->pimpl)
 
@@ -407,7 +407,7 @@ SoTexture2::SoTexture2(void)
   SO_NODE_INTERNAL_CONSTRUCTOR(SoTexture2);
 
   SO_NODE_ADD_FIELD(filename, (""));
-  SO_NODE_ADD_FIELD(image, (SbVec2s(0, 0), 0, NULL));
+  SO_NODE_ADD_FIELD(image, (SbVec2s(0, 0), 0, nullptr));
   SO_NODE_ADD_FIELD(wrapS, (REPEAT));
   SO_NODE_ADD_FIELD(wrapT, (REPEAT));
   SO_NODE_ADD_FIELD(model, (MODULATE));
@@ -426,7 +426,7 @@ SoTexture2::SoTexture2(void)
   SO_NODE_DEFINE_ENUM_VALUE(Model, REPLACE);
   SO_NODE_SET_SF_ENUM_TYPE(model, Model);
 
-  PRIVATE(this)->glimage = NULL;
+  PRIVATE(this)->glimage = nullptr;
   PRIVATE(this)->glimagevalid = false;
   PRIVATE(this)->readstatus = 1;
 
@@ -444,7 +444,7 @@ SoTexture2::SoTexture2(void)
 */
 SoTexture2::~SoTexture2()
 {
-  if (PRIVATE(this)->glimage) PRIVATE(this)->glimage->unref(NULL);
+  if (PRIVATE(this)->glimage) PRIVATE(this)->glimage->unref(nullptr);
   delete PRIVATE(this)->filenamesensor;
   delete PRIVATE(this);
 }
@@ -588,7 +588,7 @@ SoTexture2::GLRender(SoGLRenderAction * action)
   int maxunits = cc_glglue_max_texture_units(glue);
   if (unit < maxunits) {
     SoGLMultiTextureImageElement::set(state, this, unit,
-                                      PRIVATE(this)->glimagevalid ? PRIVATE(this)->glimage : NULL,
+                                      PRIVATE(this)->glimagevalid ? PRIVATE(this)->glimage : nullptr,
                                       glmodel,
                                       this->blendColor.getValue());
     
@@ -755,7 +755,7 @@ SoTexture2::filenameSensorCB(void * data, SoSensor *)
   else if (thisp->filename.getValue() == "") {
     // setting filename to "" should reset the node to its initial state
     thisp->setReadStatus(0);
-    thisp->image.setValue(SbVec2s(0,0), 0, NULL);
+    thisp->image.setValue(SbVec2s(0,0), 0, nullptr);
     thisp->image.setDefault(true);
     thisp->filename.setDefault(true);
   }
diff --git a/coin4/src/nodes/SoTexture3.cpp b/coin4/src/nodes/SoTexture3.cpp
index 17ee9ad..73ebaab 100644
--- a/coin4/src/nodes/SoTexture3.cpp
+++ b/coin4/src/nodes/SoTexture3.cpp
@@ -181,7 +181,7 @@ SoTexture3::SoTexture3(void)
   SO_NODE_INTERNAL_CONSTRUCTOR(SoTexture3);
 
   SO_NODE_ADD_FIELD(filenames, (""));
-  SO_NODE_ADD_FIELD(images, (SbVec3s(0, 0, 0), 0, NULL));
+  SO_NODE_ADD_FIELD(images, (SbVec3s(0, 0, 0), 0, nullptr));
   SO_NODE_ADD_FIELD(wrapR, (REPEAT));
   SO_NODE_ADD_FIELD(wrapS, (REPEAT));
   SO_NODE_ADD_FIELD(wrapT, (REPEAT));
@@ -201,7 +201,7 @@ SoTexture3::SoTexture3(void)
   SO_NODE_DEFINE_ENUM_VALUE(Model, BLEND);
   SO_NODE_SET_SF_ENUM_TYPE(model, Model);
 
-  this->glimage = NULL;
+  this->glimage = nullptr;
   this->glimagevalid = false;
   this->readstatus = 1;
 
@@ -218,7 +218,7 @@ SoTexture3::SoTexture3(void)
 */
 SoTexture3::~SoTexture3()
 {
-  if (this->glimage) this->glimage->unref(NULL);
+  if (this->glimage) this->glimage->unref(nullptr);
   delete this->filenamesensor;
 }
 
@@ -297,13 +297,13 @@ SoTexture3::GLRender(SoGLRenderAction * action)
 //        SoTextureScalePolicyElement::DONT_SCALE;
 
 //      if (needbig &&
-//          (this->glimage == NULL ||
+//          (this->glimage == nullptr ||
 //           this->glimage->getTypeId() != SoGLBigImage::getClassTypeId())) {
 //        if (this->glimage) this->glimage->unref(state);
 //        this->glimage = new SoGLBigImage();
 //      }
 //      else if (!needbig &&
-//               (this->glimage == NULL ||
+//               (this->glimage == nullptr ||
 //                this->glimage->getTypeId() != SoGLImage::getClassTypeId())) {
 //        if (this->glimage) this->glimage->unref(state);
 //        this->glimage = new SoGLImage();
@@ -333,7 +333,7 @@ SoTexture3::GLRender(SoGLRenderAction * action)
     SoGLMultiTextureEnabledElement::set(state, this, unit, false);
   }
   SoGLMultiTextureImageElement::set(state, this, unit,
-                                    this->glimagevalid ? this->glimage : NULL,
+                                    this->glimagevalid ? this->glimage : nullptr,
                                     (SoMultiTextureImageElement::Model) model.getValue(),
                                     this->blendColor.getValue());
   
@@ -467,7 +467,7 @@ SoTexture3::loadFilenames(SoInput * in)
                               size[1],
                               size[2]*numImages);
           volumenc = nc;
-          this->images.setValue(volumeSize, nc, NULL);
+          this->images.setValue(volumeSize, nc, nullptr);
         }
         else { // Verify size & components
           if (size[0] != volumeSize[0] ||
diff --git a/coin4/src/nodes/SoTextureCoordinate2.cpp b/coin4/src/nodes/SoTextureCoordinate2.cpp
index d65a674..adb3294 100644
--- a/coin4/src/nodes/SoTextureCoordinate2.cpp
+++ b/coin4/src/nodes/SoTextureCoordinate2.cpp
@@ -132,7 +132,7 @@ Separator {
 
 class SoTextureCoordinate2P {
  public:
-  SoTextureCoordinate2P() : vbo(NULL) { }
+  SoTextureCoordinate2P() : vbo(nullptr) { }
   ~SoTextureCoordinate2P() { delete this->vbo; }
   SoVBO * vbo;
 };
@@ -148,7 +148,7 @@ SoTextureCoordinate2::SoTextureCoordinate2(void)
 {
   PRIVATE(this) = new SoTextureCoordinate2P;
   SO_NODE_INTERNAL_CONSTRUCTOR(SoTextureCoordinate2);
-  SO_NODE_ADD_FIELD(point, (NULL));
+  SO_NODE_ADD_FIELD(point, (nullptr));
 }
 
 /*!
@@ -192,7 +192,7 @@ SoTextureCoordinate2::GLRender(SoGLRenderAction * action)
   int maxunits = cc_glglue_max_texture_units(glue);
   
   if (unit < maxunits) {
-    SoGLMultiTextureCoordinateElement::setTexGen(action->getState(), this, unit, NULL);
+    SoGLMultiTextureCoordinateElement::setTexGen(action->getState(), this, unit, nullptr);
     SoMultiTextureCoordinateElement::set2(action->getState(), this, unit,
                                           point.getNum(),
                                           point.getValues(0));
@@ -204,7 +204,7 @@ SoTextureCoordinate2::GLRender(SoGLRenderAction * action)
   if (SoGLVBOElement::shouldCreateVBO(state, num)) {
     setvbo = true;
     bool dirty = false;
-    if (PRIVATE(this)->vbo == NULL) {
+    if (PRIVATE(this)->vbo == nullptr) {
       PRIVATE(this)->vbo = new SoVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW); 
       dirty =  true;
     }
@@ -219,10 +219,10 @@ SoTextureCoordinate2::GLRender(SoGLRenderAction * action)
   }
   else if (PRIVATE(this)->vbo && PRIVATE(this)->vbo->getBufferDataId()) {
     // clear buffers to deallocate VBO memory
-    PRIVATE(this)->vbo->setBufferData(NULL, 0, 0);
+    PRIVATE(this)->vbo->setBufferData(nullptr, 0, 0);
   }
   SoBase::staticDataUnlock();
-  SoGLVBOElement::setTexCoordVBO(state, 0, setvbo ? PRIVATE(this)->vbo : NULL);
+  SoGLVBOElement::setTexCoordVBO(state, 0, setvbo ? PRIVATE(this)->vbo : nullptr);
 }
 
 // Documented in superclass.
diff --git a/coin4/src/nodes/SoTextureCoordinate3.cpp b/coin4/src/nodes/SoTextureCoordinate3.cpp
index 5e92038..b29ad42 100644
--- a/coin4/src/nodes/SoTextureCoordinate3.cpp
+++ b/coin4/src/nodes/SoTextureCoordinate3.cpp
@@ -88,7 +88,7 @@
 
 class SoTextureCoordinate3P {
  public:
-  SoTextureCoordinate3P() : vbo(NULL) { }
+  SoTextureCoordinate3P() : vbo(nullptr) { }
   ~SoTextureCoordinate3P() { delete this->vbo; }
   SoVBO * vbo;
 };
@@ -104,7 +104,7 @@ SoTextureCoordinate3::SoTextureCoordinate3(void)
 {
   PRIVATE(this) = new SoTextureCoordinate3P;
   SO_NODE_INTERNAL_CONSTRUCTOR(SoTextureCoordinate3);
-  SO_NODE_ADD_FIELD(point, (NULL));
+  SO_NODE_ADD_FIELD(point, (nullptr));
 }
 
 /*!
@@ -148,7 +148,7 @@ SoTextureCoordinate3::GLRender(SoGLRenderAction * action)
   int maxunits = cc_glglue_max_texture_units(glue);
   
   if (unit < maxunits) {
-    SoGLMultiTextureCoordinateElement::setTexGen(action->getState(), this, unit, NULL);
+    SoGLMultiTextureCoordinateElement::setTexGen(action->getState(), this, unit, nullptr);
     SoMultiTextureCoordinateElement::set3(action->getState(), this, unit,
                                           this->point.getNum(),
                                           this->point.getValues(0));
@@ -160,7 +160,7 @@ SoTextureCoordinate3::GLRender(SoGLRenderAction * action)
   if (SoGLVBOElement::shouldCreateVBO(state, num)) {
     setvbo = true;
     bool dirty = false;
-    if (PRIVATE(this)->vbo == NULL) {
+    if (PRIVATE(this)->vbo == nullptr) {
       PRIVATE(this)->vbo = new SoVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW); 
       dirty =  true;
     }
@@ -175,10 +175,10 @@ SoTextureCoordinate3::GLRender(SoGLRenderAction * action)
   }
   else if (PRIVATE(this)->vbo && PRIVATE(this)->vbo->getBufferDataId()) {
     // clear buffers to deallocate VBO memory
-    PRIVATE(this)->vbo->setBufferData(NULL, 0, 0);
+    PRIVATE(this)->vbo->setBufferData(nullptr, 0, 0);
   }
   SoBase::staticDataUnlock();
-  SoGLVBOElement::setVertexVBO(state, setvbo ? PRIVATE(this)->vbo : NULL);
+  SoGLVBOElement::setVertexVBO(state, setvbo ? PRIVATE(this)->vbo : nullptr);
 }
 
 // Documented in superclass.
diff --git a/coin4/src/nodes/SoTextureCoordinateCube.cpp b/coin4/src/nodes/SoTextureCoordinateCube.cpp
index c2cf106..f8434d4 100644
--- a/coin4/src/nodes/SoTextureCoordinateCube.cpp
+++ b/coin4/src/nodes/SoTextureCoordinateCube.cpp
@@ -78,8 +78,8 @@ static void
 so_texcoordcube_construct_data(void * closure)
 {
   so_texcoordcube_data * data = (so_texcoordcube_data *) closure;
-  data->currentshape = NULL;
-  data->currentstate = NULL;
+  data->currentshape = nullptr;
+  data->currentstate = nullptr;
   data->origo = SbVec3f(0,0,0);
 }
 
@@ -103,7 +103,7 @@ public:
   SbVec4f calculateTextureCoordinate(SbVec3f point, SbVec3f n);
 
   so_texcoordcube_data * so_texcoord_get_data() {
-    so_texcoordcube_data * data = NULL;
+    so_texcoordcube_data * data = nullptr;
     data = (so_texcoordcube_data *) this->so_texcoord_storage->get();
     assert(data && "Error retrieving thread data.");
     return data;
@@ -266,7 +266,7 @@ SoTextureCoordinateCube::doAction(SoAction * action)
   so_texcoordcube_data * data = PRIVATE(this)->so_texcoord_get_data();
   
   data->currentstate = action->getState();
-  data->currentshape = NULL;
+  data->currentshape = nullptr;
 
   int unit = SoTextureUnitElement::get(data->currentstate);
   SoMultiTextureCoordinateElement::setFunction(data->currentstate, this,
@@ -281,7 +281,7 @@ SoTextureCoordinateCube::GLRender(SoGLRenderAction * action)
   so_texcoordcube_data * data = PRIVATE(this)->so_texcoord_get_data();
 
   data->currentstate = action->getState();
-  data->currentshape = NULL;
+  data->currentshape = nullptr;
 
   int unit = SoTextureUnitElement::get(data->currentstate);
   const cc_glglue * glue = cc_glglue_instance(SoGLCacheContextElement::get(action->getState()));
diff --git a/coin4/src/nodes/SoTextureCoordinateCylinder.cpp b/coin4/src/nodes/SoTextureCoordinateCylinder.cpp
index ee89dd3..c8bfbb2 100644
--- a/coin4/src/nodes/SoTextureCoordinateCylinder.cpp
+++ b/coin4/src/nodes/SoTextureCoordinateCylinder.cpp
@@ -76,8 +76,8 @@ static void
 so_texcoordcylinder_construct_data(void * closure)
 {
   so_texcoordcylinder_data * data = (so_texcoordcylinder_data *) closure;
-  data->currentshape = NULL;
-  data->currentstate = NULL;
+  data->currentshape = nullptr;
+  data->currentstate = nullptr;
   data->origo = SbVec3f(0,0,0);
 }
 
@@ -97,7 +97,7 @@ public:
   SbVec4f calculateTextureCoordinate(SbVec3f point, SbVec3f n);
   
   so_texcoordcylinder_data * so_texcoord_get_data() {
-    so_texcoordcylinder_data * data = NULL;
+    so_texcoordcylinder_data * data = nullptr;
     data = (so_texcoordcylinder_data *) this->so_texcoord_storage->get();
     assert(data && "Error retrieving thread data.");
     return data;
@@ -254,7 +254,7 @@ SoTextureCoordinateCylinder::doAction(SoAction * action)
   so_texcoordcylinder_data * data = pimpl->so_texcoord_get_data();
 
   data->currentstate = action->getState();      
-  data->currentshape = NULL;  
+  data->currentshape = nullptr;  
   
   int unit = SoTextureUnitElement::get(data->currentstate);
   SoMultiTextureCoordinateElement::setFunction(data->currentstate, this,
@@ -269,7 +269,7 @@ SoTextureCoordinateCylinder::GLRender(SoGLRenderAction * action)
   so_texcoordcylinder_data * data = pimpl->so_texcoord_get_data();
 
   data->currentstate = action->getState();      
-  data->currentshape = NULL;  
+  data->currentshape = nullptr;  
   
   int unit = SoTextureUnitElement::get(data->currentstate);
   const cc_glglue * glue = cc_glglue_instance(SoGLCacheContextElement::get(action->getState()));
diff --git a/coin4/src/nodes/SoTextureCoordinateDefault.cpp b/coin4/src/nodes/SoTextureCoordinateDefault.cpp
index 3438fee..59c652b 100644
--- a/coin4/src/nodes/SoTextureCoordinateDefault.cpp
+++ b/coin4/src/nodes/SoTextureCoordinateDefault.cpp
@@ -87,7 +87,7 @@ SoTextureCoordinateDefault::GLRender(SoGLRenderAction * action)
 {
   /*int unit = */SoTextureUnitElement::get(action->getState());
   SoGLMultiTextureCoordinateElement::setTexGen(action->getState(),
-                                               this, 0, NULL);
+                                               this, 0, nullptr);
   SoTextureCoordinateDefault::doAction((SoAction *)action);
 }
 
diff --git a/coin4/src/nodes/SoTextureCoordinateEnvironment.cpp b/coin4/src/nodes/SoTextureCoordinateEnvironment.cpp
index c8b39a3..6fe33f3 100644
--- a/coin4/src/nodes/SoTextureCoordinateEnvironment.cpp
+++ b/coin4/src/nodes/SoTextureCoordinateEnvironment.cpp
@@ -88,7 +88,7 @@ public:
   static void cleanup_func(void);
 };
 
-SbVec4f * SoTextureCoordinateEnvironmentP::dummy_texcoords = NULL;
+SbVec4f * SoTextureCoordinateEnvironmentP::dummy_texcoords = nullptr;
 
 void
 SoTextureCoordinateEnvironmentP::cleanup_func(void)
@@ -186,7 +186,7 @@ SoTextureCoordinateEnvironment::GLRender(SoGLRenderAction * action)
                                                  action->getState());
     SoGLMultiTextureCoordinateElement::setTexGen(action->getState(),
                                                  this, unit, handleTexgen, 
-                                                 NULL,
+                                                 nullptr,
                                                  generate,
                                                  action->getState());
   }
diff --git a/coin4/src/nodes/SoTextureCoordinateNormalMap.cpp b/coin4/src/nodes/SoTextureCoordinateNormalMap.cpp
index 5afa0d2..769d877 100644
--- a/coin4/src/nodes/SoTextureCoordinateNormalMap.cpp
+++ b/coin4/src/nodes/SoTextureCoordinateNormalMap.cpp
@@ -87,7 +87,7 @@ public:
   static void cleanup_func(void);
 };
 
-SbVec4f * SoTextureCoordinateNormalMapP::dummy_texcoords = NULL;
+SbVec4f * SoTextureCoordinateNormalMapP::dummy_texcoords = nullptr;
 
 void
 SoTextureCoordinateNormalMapP::cleanup_func(void)
@@ -156,7 +156,7 @@ SoTextureCoordinateNormalMap::GLRender(SoGLRenderAction * action)
                                                action->getState());
   SoGLMultiTextureCoordinateElement::setTexGen(action->getState(),
                                                this, unit, handleTexgen, 
-                                               NULL,
+                                               nullptr,
                                                generate,
                                                action->getState());
   
diff --git a/coin4/src/nodes/SoTextureCoordinateReflectionMap.cpp b/coin4/src/nodes/SoTextureCoordinateReflectionMap.cpp
index 2b575aa..861d4ef 100644
--- a/coin4/src/nodes/SoTextureCoordinateReflectionMap.cpp
+++ b/coin4/src/nodes/SoTextureCoordinateReflectionMap.cpp
@@ -68,7 +68,7 @@ public:
   static void cleanup_func(void);
 };
 
-SbVec4f * SoTextureCoordinateReflectionMapP::dummy_texcoords = NULL;
+SbVec4f * SoTextureCoordinateReflectionMapP::dummy_texcoords = nullptr;
 
 void
 SoTextureCoordinateReflectionMapP::cleanup_func(void)
diff --git a/coin4/src/nodes/SoTextureCoordinateSphere.cpp b/coin4/src/nodes/SoTextureCoordinateSphere.cpp
index 0a421d7..326809b 100644
--- a/coin4/src/nodes/SoTextureCoordinateSphere.cpp
+++ b/coin4/src/nodes/SoTextureCoordinateSphere.cpp
@@ -76,8 +76,8 @@ static void
 so_texcoordsphere_construct_data(void * closure)
 {
   so_texcoordsphere_data * data = (so_texcoordsphere_data *) closure;
-  data->currentshape = NULL;
-  data->currentstate = NULL;
+  data->currentshape = nullptr;
+  data->currentstate = nullptr;
   data->origo = SbVec3f(0,0,0);
 }
 
@@ -97,7 +97,7 @@ public:
   SbVec4f calculateTextureCoordinate(SbVec3f point, SbVec3f n);
 
   so_texcoordsphere_data * so_texcoord_get_data() {
-    so_texcoordsphere_data * data = NULL;
+    so_texcoordsphere_data * data = nullptr;
     data = (so_texcoordsphere_data *) this->so_texcoord_storage->get();
     assert(data && "Error retrieving thread data.");
     return data;
@@ -221,7 +221,7 @@ SoTextureCoordinateSphere::doAction(SoAction * action)
   so_texcoordsphere_data * data = PRIVATE(this)->so_texcoord_get_data();
   
   data->currentstate = action->getState();
-  data->currentshape = NULL;
+  data->currentshape = nullptr;
   
   int unit = SoTextureUnitElement::get(data->currentstate);
   SoMultiTextureCoordinateElement::setFunction(data->currentstate, this,
@@ -236,7 +236,7 @@ SoTextureCoordinateSphere::GLRender(SoGLRenderAction * action)
   so_texcoordsphere_data * data = PRIVATE(this)->so_texcoord_get_data();
 
   data->currentstate = action->getState();
-  data->currentshape = NULL;
+  data->currentshape = nullptr;
 
   int unit = SoTextureUnitElement::get(data->currentstate);
   const cc_glglue * glue = cc_glglue_instance(SoGLCacheContextElement::get(action->getState()));
diff --git a/coin4/src/nodes/SoTextureCubeMap.cpp b/coin4/src/nodes/SoTextureCubeMap.cpp
index 817a680..f13ddbb 100644
--- a/coin4/src/nodes/SoTextureCubeMap.cpp
+++ b/coin4/src/nodes/SoTextureCubeMap.cpp
@@ -262,12 +262,12 @@ SoTextureCubeMap::SoTextureCubeMap(void)
   SO_NODE_INTERNAL_CONSTRUCTOR(SoTextureCubeMap);
 
   SO_NODE_ADD_FIELD(filenames, (""));
-  SO_NODE_ADD_FIELD(imagePosX, (SbVec2s(0, 0), 0, NULL));
-  SO_NODE_ADD_FIELD(imageNegX, (SbVec2s(0, 0), 0, NULL));
-  SO_NODE_ADD_FIELD(imagePosY, (SbVec2s(0, 0), 0, NULL));
-  SO_NODE_ADD_FIELD(imageNegY, (SbVec2s(0, 0), 0, NULL));
-  SO_NODE_ADD_FIELD(imagePosZ, (SbVec2s(0, 0), 0, NULL));
-  SO_NODE_ADD_FIELD(imageNegZ, (SbVec2s(0, 0), 0, NULL));
+  SO_NODE_ADD_FIELD(imagePosX, (SbVec2s(0, 0), 0, nullptr));
+  SO_NODE_ADD_FIELD(imageNegX, (SbVec2s(0, 0), 0, nullptr));
+  SO_NODE_ADD_FIELD(imagePosY, (SbVec2s(0, 0), 0, nullptr));
+  SO_NODE_ADD_FIELD(imageNegY, (SbVec2s(0, 0), 0, nullptr));
+  SO_NODE_ADD_FIELD(imagePosZ, (SbVec2s(0, 0), 0, nullptr));
+  SO_NODE_ADD_FIELD(imageNegZ, (SbVec2s(0, 0), 0, nullptr));
   SO_NODE_ADD_FIELD(wrapS, (REPEAT));
   SO_NODE_ADD_FIELD(wrapT, (REPEAT));
   SO_NODE_ADD_FIELD(model, (MODULATE));
@@ -288,7 +288,7 @@ SoTextureCubeMap::SoTextureCubeMap(void)
   this->filenames.setNum(0);
   this->filenames.setDefault(0);
 
-  PRIVATE(this)->glimage = NULL;
+  PRIVATE(this)->glimage = nullptr;
   PRIVATE(this)->glimagevalid = false;
   PRIVATE(this)->readstatus = 1;
 
@@ -307,7 +307,7 @@ SoTextureCubeMap::SoTextureCubeMap(void)
 */
 SoTextureCubeMap::~SoTextureCubeMap()
 {
-  if (PRIVATE(this)->glimage) PRIVATE(this)->glimage->unref(NULL);
+  if (PRIVATE(this)->glimage) PRIVATE(this)->glimage->unref(nullptr);
   delete PRIVATE(this)->filenames_sensor;
   delete PRIVATE(this);
 }
@@ -433,7 +433,7 @@ SoTextureCubeMap::GLRender(SoGLRenderAction * action)
   int maxunits = cc_glglue_max_texture_units(glue);
   if (unit < maxunits) {
     SoGLMultiTextureImageElement::set(state, this, unit,
-                                      PRIVATE(this)->glimagevalid ? PRIVATE(this)->glimage : NULL,
+                                      PRIVATE(this)->glimagevalid ? PRIVATE(this)->glimage : nullptr,
                                       glmodel,
                                       this->blendColor.getValue());
     if (quality > 0.0f && PRIVATE(this)->glimagevalid) {
@@ -634,7 +634,7 @@ SoTextureCubeMap::filenameSensorCB(void * data, SoSensor * COIN_UNUSED_ARG(s))
 SoSFImage * 
 SoTextureCubeMap::getImageField(const int idx)
 {
-  SoSFImage * img = NULL;
+  SoSFImage * img = nullptr;
   switch (idx) {
   default:
   case 0: img = &this->imageNegX; break;
diff --git a/coin4/src/nodes/SoUnknownNode.cpp b/coin4/src/nodes/SoUnknownNode.cpp
index e50c99e..0b43baa 100644
--- a/coin4/src/nodes/SoUnknownNode.cpp
+++ b/coin4/src/nodes/SoUnknownNode.cpp
@@ -90,7 +90,7 @@ SoUnknownNode::SoUnknownNode(void)
   this->classfielddata = new SoFieldData;
 
   this->isBuiltIn = false;
-  PRIVATE(this)->privatechildren = NULL;
+  PRIVATE(this)->privatechildren = nullptr;
   PRIVATE(this)->alternate = new SoChildList(this, 1);
 }
 
@@ -342,9 +342,9 @@ SoUnknownNode::copyContents(const SoFieldContainer * from,
       dstfield->copyConnection(dstfield);
     }
   }
-  if (PRIVATE(src)->privatechildren == NULL) return;
+  if (PRIVATE(src)->privatechildren == nullptr) return;
 
-  if (PRIVATE(this)->privatechildren == NULL) {
+  if (PRIVATE(this)->privatechildren == nullptr) {
     PRIVATE(this)->privatechildren = new SoChildList(this);
   }
 
diff --git a/coin4/src/nodes/SoVertexAttribute.cpp b/coin4/src/nodes/SoVertexAttribute.cpp
index c19074d..d03c68c 100644
--- a/coin4/src/nodes/SoVertexAttribute.cpp
+++ b/coin4/src/nodes/SoVertexAttribute.cpp
@@ -176,11 +176,11 @@ SoVertexAttribute::SoVertexAttribute(void)
   PRIVATE(this)->attributedata = new SoVertexAttributeData;
   PRIVATE(this)->attributedata->name = SbName::empty();
   PRIVATE(this)->attributedata->index = -1;
-  PRIVATE(this)->attributedata->state = NULL;
-  PRIVATE(this)->attributedata->data = NULL;
+  PRIVATE(this)->attributedata->state = nullptr;
+  PRIVATE(this)->attributedata->data = nullptr;
   PRIVATE(this)->attributedata->shaderobj = 0;
-  PRIVATE(this)->attributedata->nodeid = NULL;
-  PRIVATE(this)->attributedata->vbo = NULL;
+  PRIVATE(this)->attributedata->nodeid = nullptr;
+  PRIVATE(this)->attributedata->vbo = nullptr;
 }
 
 SoVertexAttribute::~SoVertexAttribute(void)
@@ -266,7 +266,7 @@ SoVertexAttribute::GLRender(SoGLRenderAction * action)
   if (SoGLVBOElement::shouldCreateVBO(state, num)) {
     bool dirty = false;
     setvbo = true;
-    if (PRIVATE(this)->attributedata->vbo == NULL) {
+    if (PRIVATE(this)->attributedata->vbo == nullptr) {
       PRIVATE(this)->attributedata->vbo = new SoVBO;
       dirty = true;
     }
@@ -283,7 +283,7 @@ SoVertexAttribute::GLRender(SoGLRenderAction * action)
   else if (PRIVATE(this)->attributedata->vbo &&
            PRIVATE(this)->attributedata->vbo->getBufferDataId()) {
     // clear buffers to deallocate VBO memory
-    PRIVATE(this)->attributedata->vbo->setBufferData(NULL, 0, 0);
+    PRIVATE(this)->attributedata->vbo->setBufferData(nullptr, 0, 0);
   }
   SoBase::staticDataUnlock();
 }
@@ -337,7 +337,7 @@ SoVertexAttribute::readInstance(SoInput * in, unsigned short COIN_UNUSED_ARG(fla
       err = !this->typeName.read(in, typenamekey);
       if (!err) {
         if (PRIVATE(this)->valuesfield.get()) {
-          PRIVATE(this)->valuesfield.reset(NULL);
+          PRIVATE(this)->valuesfield.reset(nullptr);
         }
         SoType datatype = SoType::fromName(this->typeName.getValue());
         PRIVATE(this)->valuesfield.reset((SoMField *)datatype.createInstance());
diff --git a/coin4/src/nodes/SoVertexProperty.cpp b/coin4/src/nodes/SoVertexProperty.cpp
index 5a670fa..8a53417 100644
--- a/coin4/src/nodes/SoVertexProperty.cpp
+++ b/coin4/src/nodes/SoVertexProperty.cpp
@@ -211,9 +211,9 @@
 class SoVertexPropertyP {
  public:
   SoVertexPropertyP(void) 
-    : vertexvbo(NULL),
-      normalvbo(NULL),
-      colorvbo(NULL)
+    : vertexvbo(nullptr),
+      normalvbo(nullptr),
+      colorvbo(nullptr)
   {
     this->checktransparent = false;
     this->transparent = false;
@@ -415,7 +415,7 @@ SoVertexProperty::updateVertex(SoState * state, bool glrender, bool vbo)
     if (glrender) {
       if (vbo) {
         bool dirty = false;
-        if (PRIVATE(this)->vertexvbo == NULL) {
+        if (PRIVATE(this)->vertexvbo == nullptr) {
           PRIVATE(this)->vertexvbo = new SoVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW); 
           dirty =  true;
         }
@@ -430,9 +430,9 @@ SoVertexProperty::updateVertex(SoState * state, bool glrender, bool vbo)
       }
       else if (PRIVATE(this)->vertexvbo && PRIVATE(this)->vertexvbo->getBufferDataId()) {
         // clear buffers to deallocate VBO memory
-        PRIVATE(this)->vertexvbo->setBufferData(NULL, 0, 0);
+        PRIVATE(this)->vertexvbo->setBufferData(nullptr, 0, 0);
       }
-      SoGLVBOElement::setVertexVBO(state, vbo ? PRIVATE(this)->vertexvbo : NULL);
+      SoGLVBOElement::setVertexVBO(state, vbo ? PRIVATE(this)->vertexvbo : nullptr);
     }
   }
 }
@@ -443,8 +443,8 @@ SoVertexProperty::updateTexCoord(SoState * state, bool glrender, bool vbo)
   const int numvertex = this->vertex.getNum();
   int num = this->texCoord3.getNum();
   int dim = 3;
-  const SbVec3f * tc3 = num ? this->texCoord3.getValues(0) : NULL;
-  const SbVec2f * tc2 = NULL;
+  const SbVec3f * tc3 = num ? this->texCoord3.getValues(0) : nullptr;
+  const SbVec2f * tc2 = nullptr;
   if (num == 0) {
     num = this->texCoord.getNum();
     dim = 2;
@@ -469,7 +469,7 @@ SoVertexProperty::updateTexCoord(SoState * state, bool glrender, bool vbo)
           // it's important to call this _before_ setting the coordinates
           // on the state.
           SoGLMultiTextureCoordinateElement::setTexGen(state,
-                                                       this, unit, NULL);
+                                                       this, unit, nullptr);
         }
         if (dim == 2) {
           SoMultiTextureCoordinateElement::set2(state, this, unit, numperunit,
@@ -484,12 +484,12 @@ SoVertexProperty::updateTexCoord(SoState * state, bool glrender, bool vbo)
           bool setvbo = false;
 
           if (i >= PRIVATE(this)->texcoordvbo.getLength()) {
-            PRIVATE(this)->texcoordvbo.append(NULL);
+            PRIVATE(this)->texcoordvbo.append(nullptr);
           }
           if ((numperunit == numvertex) && vbo) {
             bool dirty = false;
             setvbo = true;
-            if (PRIVATE(this)->texcoordvbo[i] == NULL) {
+            if (PRIVATE(this)->texcoordvbo[i] == nullptr) {
               PRIVATE(this)->texcoordvbo[i] = new SoVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW); 
               dirty =  true;
             }
@@ -512,9 +512,9 @@ SoVertexProperty::updateTexCoord(SoState * state, bool glrender, bool vbo)
           else if (PRIVATE(this)->texcoordvbo[i] && 
                    PRIVATE(this)->texcoordvbo[i]->getBufferDataId()) {
             // clear buffers to deallocate VBO memory
-            PRIVATE(this)->texcoordvbo[i]->setBufferData(NULL, 0, 0);
+            PRIVATE(this)->texcoordvbo[i]->setBufferData(nullptr, 0, 0);
           }
-          SoGLVBOElement::setTexCoordVBO(state, 0, setvbo ? PRIVATE(this)->texcoordvbo[i] : NULL);
+          SoGLVBOElement::setTexCoordVBO(state, 0, setvbo ? PRIVATE(this)->texcoordvbo[i] : nullptr);
         }
       }
     }
@@ -537,7 +537,7 @@ SoVertexProperty::updateNormal(SoState * state, uint32_t overrideflags, bool glr
       if ((num == numvertex) && vbo) {
         bool dirty = false;
         setvbo = true;
-        if (PRIVATE(this)->normalvbo == NULL) {
+        if (PRIVATE(this)->normalvbo == nullptr) {
           PRIVATE(this)->normalvbo = new SoVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW); 
           dirty =  true;
         }
@@ -552,9 +552,9 @@ SoVertexProperty::updateNormal(SoState * state, uint32_t overrideflags, bool glr
       }
       else if (PRIVATE(this)->normalvbo && PRIVATE(this)->normalvbo->getBufferDataId()) {
         // clear buffers to deallocate VBO memory
-        PRIVATE(this)->normalvbo->setBufferData(NULL, 0, 0);
+        PRIVATE(this)->normalvbo->setBufferData(nullptr, 0, 0);
       }
-      SoGLVBOElement::setNormalVBO(state, setvbo ? PRIVATE(this)->normalvbo : NULL);
+      SoGLVBOElement::setNormalVBO(state, setvbo ? PRIVATE(this)->normalvbo : nullptr);
     }
   }
   if (this->normal.getNum() > 0 && !TEST_OVERRIDE(NORMAL_BINDING, overrideflags)) {
@@ -586,7 +586,7 @@ SoVertexProperty::updateMaterial(SoState * state, uint32_t overrideflags, bool g
       if ((num == numvertex) && vbo) {
         bool dirty = false;
         setvbo = true;
-        if (PRIVATE(this)->colorvbo == NULL) {
+        if (PRIVATE(this)->colorvbo == nullptr) {
           PRIVATE(this)->colorvbo = new SoVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW);
           dirty = true;
         }
@@ -616,9 +616,9 @@ SoVertexProperty::updateMaterial(SoState * state, uint32_t overrideflags, bool g
         }
       }
       else if (PRIVATE(this)->colorvbo) {
-        PRIVATE(this)->colorvbo->setBufferData(NULL, 0, 0);
+        PRIVATE(this)->colorvbo->setBufferData(nullptr, 0, 0);
       }
-      SoGLVBOElement::setColorVBO(state, setvbo ? PRIVATE(this)->colorvbo : NULL);
+      SoGLVBOElement::setColorVBO(state, setvbo ? PRIVATE(this)->colorvbo : nullptr);
     }
   }
   if (num && !TEST_OVERRIDE(MATERIAL_BINDING, overrideflags)) {
diff --git a/coin4/src/nodes/SoWWWAnchor.cpp b/coin4/src/nodes/SoWWWAnchor.cpp
index 8077699..4a4ad9e 100644
--- a/coin4/src/nodes/SoWWWAnchor.cpp
+++ b/coin4/src/nodes/SoWWWAnchor.cpp
@@ -129,18 +129,18 @@ class SoWWWAnchorP {
   static void * highlightdata;
 
   static void atexit_cleanup() {
-    SoWWWAnchorP::fetchfunc = NULL;
-    SoWWWAnchorP::fetchdata = NULL;
-    SoWWWAnchorP::highlightfunc = NULL;
-    SoWWWAnchorP::highlightdata = NULL;
+    SoWWWAnchorP::fetchfunc = nullptr;
+    SoWWWAnchorP::fetchdata = nullptr;
+    SoWWWAnchorP::highlightfunc = nullptr;
+    SoWWWAnchorP::highlightdata = nullptr;
   }
 };
 
 // static members
-SoWWWAnchorCB * SoWWWAnchorP::fetchfunc = NULL;
-void * SoWWWAnchorP::fetchdata = NULL;
-SoWWWAnchorCB * SoWWWAnchorP::highlightfunc = NULL;
-void * SoWWWAnchorP::highlightdata = NULL;
+SoWWWAnchorCB * SoWWWAnchorP::fetchfunc = nullptr;
+void * SoWWWAnchorP::fetchdata = nullptr;
+SoWWWAnchorCB * SoWWWAnchorP::highlightfunc = nullptr;
+void * SoWWWAnchorP::highlightdata = nullptr;
 
 #endif // DOXYGEN_SKIP_THIS
 
@@ -225,7 +225,7 @@ SoWWWAnchor::handleEvent(SoHandleEventAction * action)
       SbString s = this->getFullURLName();
       if (this->map.getValue() == POINT) {
         const SoPickedPoint * pp = action->getPickedPoint();
-        const SbVec3f point = pp->getObjectPoint(NULL);
+        const SbVec3f point = pp->getObjectPoint(nullptr);
         SbString temp;
         temp.sprintf("?%g%%2c%g%%2c%g", point[0], point[1], point[2]);
         s.operator+=(temp);
diff --git a/coin4/src/nodes/SoWWWInline.cpp b/coin4/src/nodes/SoWWWInline.cpp
index 3b0fdd1..6dc7f3c 100644
--- a/coin4/src/nodes/SoWWWInline.cpp
+++ b/coin4/src/nodes/SoWWWInline.cpp
@@ -44,7 +44,7 @@
         name "<Undefined file>"
         bboxCenter 0 0 0
         bboxSize 0 0 0
-        alternateRep NULL
+        alternateRep nullptr
     }
   \endcode
 
@@ -144,10 +144,10 @@
 // *************************************************************************
 
 // static members
-SoWWWInlineFetchURLCB * SoWWWInline::fetchurlcb = NULL;
-void * SoWWWInline::fetchurlcbdata = NULL;
-SbColor * SoWWWInline::bboxcolor = NULL;
-static SbStorage * wwwinline_colorpacker_storage = NULL;
+SoWWWInlineFetchURLCB * SoWWWInline::fetchurlcb = nullptr;
+void * SoWWWInline::fetchurlcbdata = nullptr;
+SbColor * SoWWWInline::bboxcolor = nullptr;
+static SbStorage * wwwinline_colorpacker_storage = nullptr;
 SoWWWInline::BboxVisibility SoWWWInline::bboxvisibility = SoWWWInline::UNTIL_LOADED;
 bool SoWWWInline::readassofile = false;
 
@@ -167,12 +167,12 @@ void
 SoWWWInline::cleanup(void)
 {
   delete SoWWWInline::bboxcolor;
-  SoWWWInline::bboxcolor = NULL;
+  SoWWWInline::bboxcolor = nullptr;
   delete wwwinline_colorpacker_storage;
-  wwwinline_colorpacker_storage = NULL;
+  wwwinline_colorpacker_storage = nullptr;
 
-  SoWWWInline::fetchurlcb = NULL;
-  SoWWWInline::fetchurlcbdata = NULL;
+  SoWWWInline::fetchurlcb = nullptr;
+  SoWWWInline::fetchurlcbdata = nullptr;
   SoWWWInline::bboxvisibility = SoWWWInline::UNTIL_LOADED;
   SoWWWInline::readassofile = false;
 }
@@ -218,11 +218,11 @@ SoWWWInline::SoWWWInline()
   SO_NODE_ADD_FIELD(name, (SoWWWInlineP::UNDEFINED_FILE));
   SO_NODE_ADD_FIELD(bboxCenter, (0.0f, 0.0f, 0.0f));
   SO_NODE_ADD_FIELD(bboxSize, (0.0f, 0.0f, 0.0f));
-  SO_NODE_ADD_FIELD(alternateRep, (NULL));
+  SO_NODE_ADD_FIELD(alternateRep, (nullptr));
 
   // Instantiated dynamically to avoid problems on platforms with
   // systemloaders that hate static constructors in C++ libraries.
-  if (SoWWWInline::bboxcolor == NULL) {
+  if (SoWWWInline::bboxcolor == nullptr) {
     SoWWWInline::bboxcolor = new SbColor(0.8f, 0.8f, 0.8f);
     wwwinline_colorpacker_storage = new SbStorage(sizeof(void*), alloc_colorpacker, free_colorpacker);
     coin_atexit((coin_atexit_f *)SoWWWInline::cleanup, CC_ATEXIT_NORMAL);
@@ -274,7 +274,7 @@ SoWWWInline::copyChildren(void) const
 {
   SoChildList * children = this->getChildren();
 
-  if (children->getLength() == 0) return NULL;
+  if (children->getLength() == 0) return nullptr;
   assert(children->getLength() == 1);
   SoNode * rootcopy = (*children)[0]->copy();
   assert(rootcopy->isOfType(SoGroup::getClassTypeId()));
@@ -348,7 +348,7 @@ SoNode *
 SoWWWInline::getChildData(void) const
 {
   if (PRIVATE(this)->children->getLength()) { return (*PRIVATE(this)->children)[0]; }
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -723,7 +723,7 @@ SoWWWInlineP::readNamedFile()
   Read children, either using the URL callback or by reading from
   local file directly.
 
-       fetchURLCB is NULL:   Use alternaterep. NB! Always uses alternate rep 
+       fetchURLCB is nullptr:   Use alternaterep. NB! Always uses alternate rep 
                              in this case.
   else name not set:         Do nothing
   else readassofile is true: Assume name points to a local file and load
diff --git a/coin4/src/profiler/SbProfilingData.cpp b/coin4/src/profiler/SbProfilingData.cpp
index 4d72663..bf109f4 100644
--- a/coin4/src/profiler/SbProfilingData.cpp
+++ b/coin4/src/profiler/SbProfilingData.cpp
@@ -82,7 +82,7 @@ struct SbNameProfilingData {
 // inlined methods
 
 SbNodeProfilingData::SbNodeProfilingData(void)
-: node(NULL), /* nodename(NULL), */ nodetype(0),
+: node(nullptr), /* nodename(nullptr), */ nodetype(0),
   parentidx(-1), childidx(0),
   traversaltime(0.0), memorysize(0), texturesize(0), traversalcount(0)
 {
@@ -549,7 +549,7 @@ SbProfilingData::getIndexCreate(const SoFullPath * fullpath, int COIN_UNUSED_ARG
 
     SbNodeProfilingData data;
     SoNode * rootnode = fullpath->getNode(0);
-    assert(rootnode != NULL);
+    assert(rootnode != nullptr);
     data.node = static_cast<SbProfilingNodeKey>(rootnode);
     data.nodetype = static_cast<SbProfilingNodeTypeKey>(rootnode->getTypeId().getKey());
     data.nodename = static_cast<SbProfilingNodeNameKey>(rootnode->getName().getString());
diff --git a/coin4/src/profiler/SoNodeVisualize.cpp b/coin4/src/profiler/SoNodeVisualize.cpp
index c71ead8..da502b2 100644
--- a/coin4/src/profiler/SoNodeVisualize.cpp
+++ b/coin4/src/profiler/SoNodeVisualize.cpp
@@ -129,7 +129,7 @@ namespace {
       for (it = this->nodemap.begin(), end = this->nodemap.end();
            it != end; ++it) {
         it->second->unref();
-        it->second = NULL;
+        it->second = nullptr;
       }
       this->nodemap.clear();
     }
@@ -228,16 +228,16 @@ SoNodeVisualize::SoNodeVisualize(void)
   SoRotation *rot=static_cast<SoRotation*>(this->getAnyPart("rotation",true));
   rot->rotation.setValue(SbVec3f(0, 1, 0), 1.5707963f);
 
-  this->parent=NULL;
+  this->parent=nullptr;
   this->dirty=true;
-  this->node=NULL;
+  this->node=nullptr;
 
 }
 
 SoNodeVisualize*
 SoNodeVisualize::visualize(SoNode * node) {
   this->node=node;
-  if (node!=NULL) {
+  if (node!=nullptr) {
     SoType type = node->getTypeId();
     //FIXME: Exhange all the named textures, with images
     //FIXME: Make the images better fitting for its shape
@@ -304,7 +304,7 @@ SoNodeVisualize::setupChildCatalog(SoNode * node,int depth) {
   lineS->coordIndex.finishEditing();
 
   //The lineSet should not have any vertex property yet
-  assert(lineS->vertexProperty.getValue()==NULL);
+  assert(lineS->vertexProperty.getValue()==nullptr);
 
   //Lets assign a vertex property with the proper length
   SoVertexProperty *vp=new SoVertexProperty();
@@ -370,7 +370,7 @@ SoNodeVisualize::recalculate() {
     SoIndexedLineSet * lineS =
       static_cast<SoIndexedLineSet*>(this->getAnyPart("lines",false));
 
-    assert(lineS->vertexProperty.getValue()!=NULL &&
+    assert(lineS->vertexProperty.getValue()!=nullptr &&
            "No vertexProperty available from setupChildCatalog");
 
     //Sets up the vertices of the lines between the nodes
@@ -434,7 +434,7 @@ SoNodeVisualize::traverse(SoProfilerStats * stats)
   //this->getChildrenGeometry()
   assert(stats && "Stats not set.");
   SoMaterial * material = static_cast<SoMaterial *>(this->color.getValue());
-  if (material == NULL) {
+  if (material == nullptr) {
     material = new SoMaterial;
     material->diffuseColor = SbVec3f(1.0f, 1.0f, 0.0f);
     material->transparency = 0.0f;
@@ -447,7 +447,7 @@ SoNodeVisualize::traverse(SoProfilerStats * stats)
   float transparency = material->transparency[0];
 
   float green = 0.0f;
-  if ((parent != NULL) && (this->node != NULL)) {
+  if ((parent != nullptr) && (this->node != nullptr)) {
     const unsigned long CRITICAL = 10;
 
     /*SoNode * parent = */this->parent->node;
@@ -513,7 +513,7 @@ SoNodeVisualize::recalculateWidth() {
 
   //If we have no childgeometry, or it is invisible, we occupy a 1x1 box
   if ((numGeometryChildren == 0) ||
-      (childrenswitch == NULL) ||
+      (childrenswitch == nullptr) ||
       (childrenswitch->whichChild.getValue() == SO_SWITCH_NONE))
     return SbVec2s(1,1);
 
@@ -643,7 +643,7 @@ SoNodeVisualize::handleEvent(SoHandleEventAction * action)
 
   //REVIEW: BFG - Not sure what I'm doing here, the getDetail is
   //from an example source
-  if (path->containsNode(shape) && pp->getDetail(shape) == NULL) {
+  if (path->containsNode(shape) && pp->getDetail(shape) == nullptr) {
     SbVec3f point = pp->getPoint();
     this->clicked();
   }
@@ -719,7 +719,7 @@ SoNodeVisualize::nodeNumChildren() {
 */
 void
 SoNodeVisualize::reset() {
-  this->node=NULL;
+  this->node=nullptr;
   SoSeparator * sep=static_cast<SoSeparator*>(this->getAnyPart("childGeometry",true));
   sep->removeAllChildren();
 }
diff --git a/coin4/src/profiler/SoProfiler.cpp b/coin4/src/profiler/SoProfiler.cpp
index d030ec9..50cdb91 100644
--- a/coin4/src/profiler/SoProfiler.cpp
+++ b/coin4/src/profiler/SoProfiler.cpp
@@ -298,7 +298,7 @@ SoProfilerP::parseCoinProfilerVariable(void)
   // - [nocaching - implies on] // todo
 
   const char * env = coin_getenv(SoDBP::EnvVars::COIN_PROFILER);
-  if (env == NULL) return;
+  if (env == nullptr) return;
   std::vector<std::string> parameters;
   tokenize(env, ":", parameters);
   if ((parameters.size() == 1) &&
@@ -332,7 +332,7 @@ void
 SoProfilerP::parseCoinProfilerOverlayVariable(void)
 {
   const char * env = coin_getenv(SoDBP::EnvVars::COIN_PROFILER_OVERLAY);
-  if (env == NULL) return;
+  if (env == nullptr) return;
   std::vector<std::string> parameters;
   tokenize(env, ":", parameters);
 
@@ -537,7 +537,7 @@ SoProfilerP::parseCoinProfilerOverlayVariable(void)
 void
 SoProfilerP::dumpToConsole(const SbProfilingData & data)
 {
-  SoProfilingReportGenerator::ReportCB * callback = NULL;
+  SoProfilingReportGenerator::ReportCB * callback = nullptr;
   if (profiler::console::onstdout) {
     callback = SoProfilingReportGenerator::stdoutCB;
   }
@@ -576,7 +576,7 @@ SoProfilerP::dumpToConsole(const SbProfilingData & data)
                                        profiler::console::lines,
                                        SoProfilerP::shouldOutputHeaderOnConsole(),
                                        callback,
-                                       NULL);
+                                       nullptr);
 
   SoProfilingReportGenerator::freeCriteria(sortsettings);
   SoProfilingReportGenerator::freeCriteria(printsettings);
diff --git a/coin4/src/profiler/SoProfilerElement.cpp b/coin4/src/profiler/SoProfilerElement.cpp
index 41ac22f..029e28d 100644
--- a/coin4/src/profiler/SoProfilerElement.cpp
+++ b/coin4/src/profiler/SoProfilerElement.cpp
@@ -57,7 +57,7 @@ SoProfilerElement::get(SoState * state)
 {
   assert(state);
   if (!state->isElementEnabled(SoProfilerElement::classStackIndex)) {
-    return NULL;
+    return nullptr;
   }
 
   SoElement * elt = state->getElementNoPush(SoProfilerElement::classStackIndex);
@@ -123,7 +123,7 @@ SoProfilerElement::setTimingProfile(SoNode * node, SbTime t, SoNode * parent)
   this->data.accumulateTraversalTime(parent ? parent->getTypeId() : SoType::badType(),
                                      node->getTypeId(), t);
 
-  if (parent == NULL) return;
+  if (parent == nullptr) return;
   this->data.setChildTiming(parent, node, t);
 }
 */
diff --git a/coin4/src/profiler/SoProfilerTopEngine.cpp b/coin4/src/profiler/SoProfilerTopEngine.cpp
index 73fee8a..fb6651a 100644
--- a/coin4/src/profiler/SoProfilerTopEngine.cpp
+++ b/coin4/src/profiler/SoProfilerTopEngine.cpp
@@ -41,15 +41,15 @@
 
 class SoProfilerTopEngineP {
 public:
-  SoProfilerTopEngineP(void) : datasize(0), data(NULL) { }
+  SoProfilerTopEngineP(void) : datasize(0), data(nullptr) { }
   ~SoProfilerTopEngineP(void) {
     if (data) {
       delete [] data;
-      data = NULL;
+      data = nullptr;
     }
     //if (tmpdata) {
     //  delete [] tmpdata;
-    //  tmpdata = NULL;
+    //  tmpdata = nullptr;
     //}
   }
 
@@ -260,7 +260,7 @@ SoProfilerTopEngine::evaluate(void)
   const bool have_counts = (this->statisticsCounts.getNum() == inputsize);
   const bool have_maxtimings = (this->statisticsTimingsMax.getNum() == inputsize);
   const bool have_olddata =
-    ((PRIVATE(this)->datasize == inputsize) && (PRIVATE(this)->data != NULL));
+    ((PRIVATE(this)->datasize == inputsize) && (PRIVATE(this)->data != nullptr));
   /*const int olddatasize = */PRIVATE(this)->datasize;
   SoProfilerTopEngineP::StatDataItem * const olddata = PRIVATE(this)->data;
 
@@ -453,7 +453,7 @@ SoProfilerTopEngine::evaluate(void)
 
   if (olddata) {
     delete [] olddata;
-    // olddata = NULL;
+    // olddata = nullptr;
   }
 }
 
diff --git a/coin4/src/profiler/SoProfilerTopKit.cpp b/coin4/src/profiler/SoProfilerTopKit.cpp
index 148636a..1a4c0d5 100644
--- a/coin4/src/profiler/SoProfilerTopKit.cpp
+++ b/coin4/src/profiler/SoProfilerTopKit.cpp
@@ -51,9 +51,9 @@ class SoProfilerTopKitP
 {
 public:
   SoProfilerTopKitP()
-    : geometryEngine(NULL),
-      topListEngine(NULL),
-      last_stats(NULL)
+    : geometryEngine(nullptr),
+      topListEngine(nullptr),
+      last_stats(nullptr)
   { }
 
   SoProfilerTopKit * master;
@@ -105,7 +105,7 @@ SoProfilerTopKitP::attachToStats()
   SoProfilerStats * statsNode =
     (SoProfilerStats *)PUBLIC(this)->getPart("profilingStats",
                                              false);
-  if (statsNode == NULL)
+  if (statsNode == nullptr)
     return ;
 
   this->topListEngine->statisticsNames.connectFrom(&statsNode->renderedNodeType);
diff --git a/coin4/src/profiler/SoProfilerVisualizeKit.cpp b/coin4/src/profiler/SoProfilerVisualizeKit.cpp
index 58dcabb..a281171 100644
--- a/coin4/src/profiler/SoProfilerVisualizeKit.cpp
+++ b/coin4/src/profiler/SoProfilerVisualizeKit.cpp
@@ -80,7 +80,7 @@ namespace {
     SoProfilerVisualizeKit * kit = (SoProfilerVisualizeKit*)data;
     kit->statsTrigger.disconnect();
     SoNode * node = kit->stats.getValue();
-    if (node != NULL) {
+    if (node != nullptr) {
       if (node->isOfType(SoProfilerStats::getClassTypeId())) {
         SoProfilerStats * statsnode = (SoProfilerStats *)node;
         kit->statsTrigger.connectFrom(&statsnode->profilingUpdate);
@@ -101,7 +101,7 @@ namespace {
 
   void statsTriggerCB(void * data, SoSensor * s) {
     SoProfilerVisualizeKit * kit = (SoProfilerVisualizeKit*)data;
-    if (kit->stats.getValue() != NULL)
+    if (kit->stats.getValue() != nullptr)
       cacheSensorCB(data, s);
   }
 };
@@ -135,13 +135,13 @@ SoProfilerVisualizeKit::SoProfilerVisualizeKit()
   SO_KIT_ADD_CATALOG_ENTRY(visualtree, SoNodeVisualize, true, top, "", true);
   SO_KIT_INIT_INSTANCE();
 
-  SO_KIT_ADD_FIELD(stats, (NULL));
+  SO_KIT_ADD_FIELD(stats, (nullptr));
   SO_KIT_ADD_FIELD(statsTrigger, ());
-  SO_KIT_ADD_FIELD(root, (NULL));
-  SO_KIT_ADD_FIELD(separatorsWithGLCaches, (NULL));
+  SO_KIT_ADD_FIELD(root, (nullptr));
+  SO_KIT_ADD_FIELD(separatorsWithGLCaches, (nullptr));
 
   this->separatorsWithGLCaches.setNum(0);
-  this->separatorsWithGLCaches.setDefault(NULL);
+  this->separatorsWithGLCaches.setDefault(false);
   PRIVATE(this)->cacheSensor.reset(new SoFieldSensor(cacheSensorCB, this));
   PRIVATE(this)->cacheSensor->attach(&this->separatorsWithGLCaches);
   PRIVATE(this)->rootSensor.reset(new SoFieldSensor(rootChangedCB, this));
diff --git a/coin4/src/profiler/SoProfilingReportGenerator.cpp b/coin4/src/profiler/SoProfilingReportGenerator.cpp
index 76cb61b..142c3ee 100644
--- a/coin4/src/profiler/SoProfilingReportGenerator.cpp
+++ b/coin4/src/profiler/SoProfilingReportGenerator.cpp
@@ -92,14 +92,14 @@ public:
 
 };
 
-SbMutex * SoProfilingReportGeneratorP::mutex = NULL;
+SbMutex * SoProfilingReportGeneratorP::mutex = nullptr;
 
 // *************************************************************************
 
 class SbProfilingReportSortCriteria {
 public:
   SbProfilingReportSortCriteria(void)
-    : numfunctions(0), functions(NULL)
+    : numfunctions(0), functions(nullptr)
   {
   }
 
@@ -219,7 +219,7 @@ SoProfilingReportGenerator::freeCriteria(SbProfilingReportSortCriteria * criteri
 class SbProfilingReportPrintCriteria {
 public:
   SbProfilingReportPrintCriteria(void)
-    : numfunctions(0), functions(NULL), needstringlengths(false)
+    : numfunctions(0), functions(nullptr), needstringlengths(false)
   {
   }
   ~SbProfilingReportPrintCriteria(void) {
@@ -354,13 +354,13 @@ SoProfilingReportGenerator::freeCriteria(SbProfilingReportPrintCriteria * criter
 
 // *************************************************************************
 
-static const SbProfilingData * profdata = NULL;
-static const int * arraystart = NULL;
-static const int * arrayend = NULL;
+static const SbProfilingData * profdata = nullptr;
+static const int * arraystart = nullptr;
+static const int * arrayend = nullptr;
 static SoProfilingReportGenerator::DataCategorization sortcategory = SoProfilingReportGenerator::TYPES;
-static SbProfilingReportSortCriteria * sortingconfig = NULL;
-static SbList<SbProfilingNodeNameKey> * namekeys = NULL;
-static SbList<SbProfilingNodeTypeKey> * typekeys = NULL;
+static SbProfilingReportSortCriteria * sortingconfig = nullptr;
+static SbList<SbProfilingNodeNameKey> * namekeys = nullptr;
+static SbList<SbProfilingNodeTypeKey> * typekeys = nullptr;
 static int longestnamelength = 0;
 static int longesttypenamelength = 0;
 
@@ -391,7 +391,7 @@ gencompare(const void * ptr1, const void * ptr2)
 void
 SoProfilingReportGenerator::init(void)
 {
-  assert(SoProfilingReportGeneratorP::mutex == NULL);
+  assert(SoProfilingReportGeneratorP::mutex == nullptr);
   SoProfilingReportGeneratorP::mutex = new SbMutex;
 }
 
@@ -443,8 +443,8 @@ SoProfilingReportGenerator::generate(const SbProfilingData & data,
     int c = 0;
     const int numindexes = data.getNumNodeEntries();
     if (numindexes == 0) {
-      profdata = NULL;
-      sortingconfig = NULL;
+      profdata = nullptr;
+      sortingconfig = nullptr;
       return;
     }
     boost::scoped_array<int> indexarray;
@@ -486,7 +486,7 @@ SoProfilingReportGenerator::generate(const SbProfilingData & data,
   }
   else if (categorization == NAMES) {
     int c = 0;
-    if (namekeys == NULL) {
+    if (namekeys == nullptr) {
       namekeys = new SbList<SbProfilingNodeNameKey>;
     } else {
       namekeys->truncate(0);
@@ -495,8 +495,8 @@ SoProfilingReportGenerator::generate(const SbProfilingData & data,
 
     const int numindexes = namekeys->getLength();
     if (numindexes == 0) {
-      profdata = NULL;
-      sortingconfig = NULL;
+      profdata = nullptr;
+      sortingconfig = nullptr;
       return;
     }
     boost::scoped_array<int> indexarray;
@@ -539,7 +539,7 @@ SoProfilingReportGenerator::generate(const SbProfilingData & data,
   }
   else if (categorization == TYPES) {
     int c = 0;
-    if (typekeys == NULL) {
+    if (typekeys == nullptr) {
       typekeys = new SbList<SbProfilingNodeTypeKey>;
     } else {
       typekeys->truncate(0);
@@ -548,8 +548,8 @@ SoProfilingReportGenerator::generate(const SbProfilingData & data,
 
     const int numindexes = typekeys->getLength();
     if (numindexes == 0) {
-      profdata = NULL;
-      sortingconfig = NULL;
+      profdata = nullptr;
+      sortingconfig = nullptr;
       return;
     }
     boost::scoped_array<int> indexarray;
@@ -594,10 +594,10 @@ SoProfilingReportGenerator::generate(const SbProfilingData & data,
     assert(!"no such data categorization implemented");
   }
 
-  profdata = NULL;
-  sortingconfig = NULL;
-  arraystart = NULL;
-  arrayend = NULL;
+  profdata = nullptr;
+  sortingconfig = nullptr;
+  arraystart = nullptr;
+  arrayend = nullptr;
 }
 
 #undef OUTPUT_PADDING
diff --git a/coin4/src/profiler/SoScrollingGraphKit.cpp b/coin4/src/profiler/SoScrollingGraphKit.cpp
index 36206f6..cfbb1da 100644
--- a/coin4/src/profiler/SoScrollingGraphKit.cpp
+++ b/coin4/src/profiler/SoScrollingGraphKit.cpp
@@ -67,7 +67,7 @@ public:
 
 class Datum {
 public:
-  Datum(void) : next(NULL) { }
+  Datum(void) : next(nullptr) { }
   SbTime when;
   SbList<float> datum;
   Datum * next;
@@ -79,7 +79,7 @@ public:
 
 class SoScrollingGraphKitP {
 public:
-  SoScrollingGraphKitP(void) : kit(NULL), first(NULL), last(NULL) {
+  SoScrollingGraphKitP(void) : kit(nullptr), first(nullptr), last(nullptr) {
     this->cachedmaxvalue = 0.0f;
     this->cachedrealmaxvalue = 0.0f;
   }
@@ -87,7 +87,7 @@ public:
     SbList<const char *> keys;
     this->graphs.makeKeyList(keys);
     for (int c = 0; c < keys.getLength(); ++c) {
-      Graph * obj = NULL;
+      Graph * obj = nullptr;
       if (this->graphs.get(keys[c], obj)) { delete obj; }
     }
     this->graphs.clear();
@@ -246,7 +246,7 @@ SoScrollingGraphKitP::pullStatistics(void)
 void
 SoScrollingGraphKitP::addDatum(Datum * newDatum)
 {
-  if (this->first == NULL) {
+  if (this->first == nullptr) {
     this->first = this->last = newDatum;
   } else {
     this->last->next = newDatum;
@@ -254,7 +254,7 @@ SoScrollingGraphKitP::addDatum(Datum * newDatum)
   }
 
   SbTime maxtime(this->kit->seconds.getValue());
-  while ((this->first->next != NULL) &&
+  while ((this->first->next != nullptr) &&
          ((newDatum->when - this->first->next->when) > maxtime)) {
     Datum * datum = this->first;
     this->first = this->first->next;
@@ -266,7 +266,7 @@ Graph *
 SoScrollingGraphKitP::getGraph(const SbName & key)
 {
   assert(key != SbName::empty());
-  Graph * graph = NULL;
+  Graph * graph = nullptr;
   if (!this->graphs.get(key.getString(), graph)) {
     graph = new Graph;
     graph->key = key;
@@ -289,12 +289,12 @@ SoScrollingGraphKitP::getGraph(int idx)
   SbList<const char *> keys;
   this->graphs.makeKeyList(keys);
   for (int i = 0; i < keys.getLength(); ++i) {
-    Graph * graph = NULL;
+    Graph * graph = nullptr;
     this->graphs.get(keys[i], graph);
     if (graph->index == idx) return graph;
   }
   assert(!"serious problem - did not find graph index data");
-  return NULL;
+  return nullptr;
 }
 
 
@@ -310,7 +310,7 @@ new_node(const char * buffer)
     assert(!"node field arguments error");
     node->ref();
     node->unref();
-    return NULL;
+    return nullptr;
   }
   return node;
 }
diff --git a/coin4/src/rendering/CoinOffscreenGLCanvas.cpp b/coin4/src/rendering/CoinOffscreenGLCanvas.cpp
index b25adbc..2aecce2 100644
--- a/coin4/src/rendering/CoinOffscreenGLCanvas.cpp
+++ b/coin4/src/rendering/CoinOffscreenGLCanvas.cpp
@@ -24,6 +24,7 @@
 #include "CoinOffscreenGLCanvas.h"
 
 #include <limits.h>
+#include <cstdlib> // atoi
 
 #include <Inventor/C/glue/gl.h>
 #include <Inventor/errors/SoDebugError.h>
@@ -46,8 +47,8 @@ unsigned int CoinOffscreenGLCanvas::tilesizeroof = UINT_MAX;
 CoinOffscreenGLCanvas::CoinOffscreenGLCanvas(void)
 {
   this->size = SbVec2s(0, 0);
-  this->context = NULL;
-  this->current_hdc = NULL;
+  this->context = nullptr;
+  this->current_hdc = nullptr;
 }
 
 CoinOffscreenGLCanvas::~CoinOffscreenGLCanvas()
@@ -170,7 +171,7 @@ CoinOffscreenGLCanvas::tryActivateGLContext(void)
 {
   if (this->size == SbVec2s(0, 0)) { return 0; }
 
-  if (this->context == NULL) {
+  if (this->context == nullptr) {
 #if defined(HAVE_WGL)
     /* NOTE: This discrepancy between the different glue flavors is due to a
     driver bug that causes the coordinates fed to the gl_FragCoord fragment
@@ -188,10 +189,10 @@ CoinOffscreenGLCanvas::tryActivateGLContext(void)
                              "Tried to create offscreen context of dimensions "
                              "<%d, %d> -- %s",
                              this->size[0], this->size[1],
-                             this->context == NULL ? "failed" : "succeeded");
+                             this->context == nullptr ? "failed" : "succeeded");
     }
 
-    if (this->context == NULL) { return 0; }
+    if (this->context == nullptr) { return 0; }
 
     // Set up mapping from GL context to SoGLRenderAction context id.
     this->renderid = SoGLCacheContextElement::getUniqueCacheContext();
@@ -295,9 +296,9 @@ CoinOffscreenGLCanvas::destructContext(void)
 
   cc_glglue_context_destruct(this->context);
 
-  this->context = NULL;
+  this->context = nullptr;
   this->renderid = 0;
-  this->current_hdc = NULL;
+  this->current_hdc = nullptr;
 }
 
 // *************************************************************************
diff --git a/coin4/src/rendering/SoGL.cpp b/coin4/src/rendering/SoGL.cpp
index 2b6aece..70af101 100644
--- a/coin4/src/rendering/SoGL.cpp
+++ b/coin4/src/rendering/SoGL.cpp
@@ -138,9 +138,9 @@ sogl_render_cone(const float radius,
                  const unsigned int flagsin,
                  SoState * state)
 {
-  const bool * unitenabled = NULL;
+  const bool * unitenabled = nullptr;
   int maxunit = 0;
-  const cc_glglue * glue = NULL;
+  const cc_glglue * glue = nullptr;
 
   int flags = flagsin;
 
@@ -308,9 +308,9 @@ sogl_render_cylinder(const float radius,
                      const unsigned int flagsin,
                      SoState * state)
 {
-  const bool * unitenabled = NULL;
+  const bool * unitenabled = nullptr;
   int maxunit = 0;
-  const cc_glglue * glue = NULL;
+  const cc_glglue * glue = nullptr;
 
   int flags = flagsin;
 
@@ -482,9 +482,9 @@ sogl_render_sphere(const float radius,
                    const unsigned int flagsin,
                    SoState * state)
 {
-  const bool * unitenabled = NULL;
+  const bool * unitenabled = nullptr;
   int maxunit = 0;
-  const cc_glglue * glue = NULL;
+  const cc_glglue * glue = nullptr;
 
   unsigned int flags = flagsin;
 
@@ -794,9 +794,9 @@ sogl_render_cube(const float width,
                  const unsigned int flagsin,
                  SoState * state)
 {
-  const bool * unitenabled = NULL;
+  const bool * unitenabled = nullptr;
   int maxunit = 0;
-  const cc_glglue * glue = NULL;
+  const cc_glglue * glue = nullptr;
 
   int flags = flagsin;
 
@@ -882,8 +882,8 @@ namespace { namespace SoGL { namespace IndexedLineSet {
                        const int32_t *texindices,
                        const int drawAsPoints)
   {
-    const SbVec3f * coords3d = NULL;
-    const SbVec4f * coords4d = NULL;
+    const SbVec3f * coords3d = nullptr;
+    const SbVec4f * coords4d = nullptr;
     const bool is3d = coords->is3D();
     if (is3d) {
       coords3d = coords->getArrayPtr3();
@@ -900,10 +900,10 @@ namespace { namespace SoGL { namespace IndexedLineSet {
     else glVertex4fv((const GLfloat*) (coords4d + _idx_));
 
     if ((AttributeBinding)MaterialBinding == PER_VERTEX_INDEXED) {
-      if (matindices == NULL) matindices = indices;
+      if (matindices == nullptr) matindices = indices;
     }
     if ((AttributeBinding)NormalBinding == PER_VERTEX_INDEXED) {
-      if (normindices == NULL) normindices = indices;
+      if (normindices == nullptr) normindices = indices;
     }
 
     int matnr = 0;
@@ -1270,13 +1270,13 @@ namespace { namespace SoGL { namespace FaceSet {
   {
 
     // just in case someone forgot
-    if (matindices == NULL) matindices = vertexindices;
-    if (normalindices == NULL) normalindices = vertexindices;
+    if (matindices == nullptr) matindices = vertexindices;
+    if (normalindices == nullptr) normalindices = vertexindices;
 
     int texidx = 0;
 
-    const SbVec3f * coords3d = NULL;
-    const SbVec4f * coords4d = NULL;
+    const SbVec3f * coords3d = nullptr;
+    const SbVec4f * coords4d = nullptr;
     const bool is3d = vertexlist->is3D();
     if (is3d) {
       coords3d = vertexlist->getArrayPtr3();
@@ -1786,8 +1786,8 @@ namespace { namespace SoGL { namespace TriStripSet {
   {
 
     // just in case someone forgot...
-    if (matindices == NULL) matindices = vertexindices;
-    if (normalindices == NULL) normalindices = vertexindices;
+    if (matindices == nullptr) matindices = vertexindices;
+    if (normalindices == nullptr) normalindices = vertexindices;
 
     int texidx = 0;
     const int32_t *viptr = vertexindices;
@@ -1796,8 +1796,8 @@ namespace { namespace SoGL { namespace TriStripSet {
     int32_t v1, v2, v3;
     int numverts = vertexlist->getNum();
 
-    const SbVec3f * coords3d = NULL;
-    const SbVec4f * coords4d = NULL;
+    const SbVec3f * coords3d = nullptr;
+    const SbVec4f * coords4d = nullptr;
     const bool is3d = vertexlist->is3D();
     if (is3d) {
       coords3d = vertexlist->getArrayPtr3();
@@ -1818,7 +1818,7 @@ namespace { namespace SoGL { namespace TriStripSet {
         (AttributeBinding)NormalBinding == PER_VERTEX_INDEXED ||
         (AttributeBinding)NormalBinding == PER_TRIANGLE_INDEXED ||
         (AttributeBinding)NormalBinding == PER_STRIP_INDEXED) {
-      assert(normals && "Aborting rendering of tristrip; got NULL normals");
+      assert(normals && "Aborting rendering of tristrip; got nullptr normals");
     }
 
     SbVec3f dummynormal(0.0f, 0.0f, 1.0f);
@@ -2403,15 +2403,15 @@ sogl_autocache_update(SoState * state, const int numprimitives, bool didusevbo)
 
 // **************************************************************************
 
-static SoOffscreenRenderer * offscreenrenderer = NULL;
-static SoCallback * offscreencallback = NULL;
+static SoOffscreenRenderer * offscreenrenderer = nullptr;
+static SoCallback * offscreencallback = nullptr;
 
 static void offscreenrenderer_cleanup(void)
 {
   offscreencallback->unref();
   delete offscreenrenderer;
-  offscreenrenderer = NULL;
-  offscreencallback = NULL;
+  offscreenrenderer = nullptr;
+  offscreencallback = nullptr;
 }
 
 // This is really obsoleted now that we have
@@ -2431,7 +2431,7 @@ void
 sogl_offscreencontext_callback(void (*cb)(void *, SoAction*),
                                void * closure)
 {
-  if (offscreenrenderer == NULL) {
+  if (offscreenrenderer == nullptr) {
     offscreenrenderer = new SoOffscreenRenderer(SbViewportRegion(32, 32));
     offscreencallback = new SoCallback;
     offscreencallback->ref();
diff --git a/coin4/src/rendering/SoGLBigImage.cpp b/coin4/src/rendering/SoGLBigImage.cpp
index 6c266d2..fb7ca04 100644
--- a/coin4/src/rendering/SoGLBigImage.cpp
+++ b/coin4/src/rendering/SoGLBigImage.cpp
@@ -156,7 +156,7 @@ public:
                           const SbVec2s & targetsize);
   void resetAllTls(SoState * state);
   void resetCache(void);
-  static void reset(SoGLBigImageTls * tls, SoState * state = NULL);
+  static void reset(SoGLBigImageTls * tls, SoState * state = nullptr);
   static void unrefOldDL(SoGLBigImageTls * tls, SoState * state, const uint32_t maxage);
   void createCache(const unsigned char * bytes, const SbVec2s size, const int nc);
 };
@@ -177,20 +177,20 @@ soglbigimagetls_construct(void * closure)
   storage->remain.setValue(0, 0);
   storage->dim.setValue(0, 0);
   storage->currentdim.setValue(0, 0);
-  storage->tmpbuf = NULL;
+  storage->tmpbuf = nullptr;
   storage->tmpbufsize = 0;
-  storage->glimagearray = NULL;
-  storage->imagearray = NULL;
-  storage->glimagediv = NULL;
-  storage->glimageage = NULL;
-  storage->averagebuf = NULL;
+  storage->glimagearray = nullptr;
+  storage->imagearray = nullptr;
+  storage->glimagediv = nullptr;
+  storage->glimageage = nullptr;
+  storage->averagebuf = nullptr;
 }
 
 static void
 soglbigimagetls_destruct(void * closure)
 {
   SoGLBigImageTls * tls = (SoGLBigImageTls*) closure;
-  SoGLBigImageP::reset(tls, NULL);
+  SoGLBigImageP::reset(tls, nullptr);
 
   // these are not destructed in reset()
   delete[] tls->tmpbuf;
@@ -262,11 +262,11 @@ SoGLBigImage::setData(const SbImage * image,
 {
   if (createinstate) {
     SoDebugError::postWarning("SoGLBigImage::setData",
-                              "createinstate must be NULL for SoGLBigImage");
+                              "createinstate must be nullptr for SoGLBigImage");
   }
   delete PRIVATE(this);
   PRIVATE(this) = new SoGLBigImageP;
-  inherited::setData(image, wraps, wrapt, quality, border, NULL);
+  inherited::setData(image, wraps, wrapt, quality, border, nullptr);
 }
 
 void
@@ -280,18 +280,18 @@ SoGLBigImage::setData(const SbImage * image,
 {
   if (createinstate) {
     SoDebugError::postWarning("SoGLBigImage::setData",
-                              "createinstate must be NULL for SoGLBigImage");
+                              "createinstate must be nullptr for SoGLBigImage");
   }
   delete PRIVATE(this);
   PRIVATE(this) = new SoGLBigImageP;
-  inherited::setData(image, wraps, wrapt, wrapr, quality, border, NULL);
+  inherited::setData(image, wraps, wrapt, wrapr, quality, border, nullptr);
 }
 
 
 SoGLDisplayList *
 SoGLBigImage::getGLDisplayList(SoState * COIN_UNUSED_ARG(state))
 {
-  return NULL;
+  return nullptr;
 }
 
 int
@@ -349,7 +349,7 @@ SoGLBigImage::initSubImages(const SbVec2s & subimagesize) const
   SbVec2s size(0,0);
   int nc = 0;
 
-  if (this->getImage() != NULL)
+  if (this->getImage() != nullptr)
     (void)(this->getImage()->getValue(size, nc));
 
   tls->dim[0] = size[0] / subimagesize[0];
@@ -394,7 +394,7 @@ SoGLBigImage::applySubImage(SoState * state, const int idx,
   SbVec2s size;
   int numcomponents;
   unsigned char * bytes = this->getImage() ?
-    this->getImage()->getValue(size, numcomponents) : NULL;
+    this->getImage()->getValue(size, numcomponents) : nullptr;
 
   SoGLBigImageTls * tls = PRIVATE(this)->getTls();
 
@@ -408,8 +408,8 @@ SoGLBigImage::applySubImage(SoState * state, const int idx,
     tls->imagearray = new SbImage*[numimages];
     tls->glimageage = new uint32_t[numimages];
     for (int i = 0; i < numimages; i++) {
-      tls->glimagearray[i] = NULL;
-      tls->imagearray[i] = NULL;
+      tls->glimagearray[i] = nullptr;
+      tls->imagearray[i] = nullptr;
       tls->glimagediv[i] = 1;
       tls->glimageage[i] = 0;
     }
@@ -420,7 +420,7 @@ SoGLBigImage::applySubImage(SoState * state, const int idx,
 
     // lock before testing/creating cache to avoid race conditions
     PRIVATE(this)->lock();
-    if (PRIVATE(this)->cache == NULL) {
+    if (PRIVATE(this)->cache == nullptr) {
       PRIVATE(this)->createCache(bytes, size, numcomponents);
     }
     PRIVATE(this)->unlock();
@@ -435,12 +435,12 @@ SoGLBigImage::applySubImage(SoState * state, const int idx,
   }
   div >>= 1;
 
-  if (tls->glimagearray[idx] == NULL ||
+  if (tls->glimagearray[idx] == nullptr ||
       (tls->glimagediv[idx] != div && tls->changecnt < CHANGELIMIT)) {
 
-    if (tls->glimagearray[idx] == NULL) {
+    if (tls->glimagearray[idx] == nullptr) {
       tls->glimagearray[idx] = new SoGLImage();
-      if (tls->imagearray[idx] == NULL) {
+      if (tls->imagearray[idx] == nullptr) {
         tls->imagearray[idx] = new SbImage;
       }
     }
@@ -489,7 +489,7 @@ SoGLBigImage::applySubImage(SoState * state, const int idx,
       }
       tls->imagearray[idx]->setValue(actualsize, numcomponents, tls->tmpbuf);
     }
-    else tls->imagearray[idx]->setValuePtr(SbVec2s(0,0), 0, NULL);
+    else tls->imagearray[idx]->setValuePtr(SbVec2s(0,0), 0, nullptr);
     
     // do not create-in-state, since the same thread might be used to
     // render into more than one context
@@ -497,7 +497,7 @@ SoGLBigImage::applySubImage(SoState * state, const int idx,
                                     SoGLImage::CLAMP_TO_EDGE,
                                     SoGLImage::CLAMP_TO_EDGE,
                                     quality,
-                                    0, NULL);
+                                    0, nullptr);
   }
 
   SoGLDisplayList * dl = tls->glimagearray[idx]->getGLDisplayList(state);
@@ -568,8 +568,8 @@ SoGLBigImage::unrefOldDL(SoState * state, const uint32_t maxage)
 #ifndef DOXYGEN_SKIP_THIS
 
 SoGLBigImageP::SoGLBigImageP(void) :
-  cache(NULL),
-  cachesize(NULL),
+  cache(nullptr),
+  cachesize(nullptr),
   numcachelevels(0)
 {
   this->storage = cc_storage_construct_etc(sizeof(SoGLBigImageTls),
@@ -893,7 +893,7 @@ SoGLBigImageP::createCache(const unsigned char * bytes, const SbVec2s size, cons
                           this->cache[l-1], this->cache[l]);
 #endif // end of low quality downsample
   }
-  this->cache[0] = NULL;
+  this->cache[0] = nullptr;
   this->cachesize[0] = SbVec2s(0, 0);
 }
 
@@ -905,8 +905,8 @@ SoGLBigImageP::resetCache(void)
   }
   delete[] this->cache;
   delete[] this->cachesize;
-  this->cache = NULL;
-  this->cachesize = NULL;
+  this->cache = nullptr;
+  this->cachesize = nullptr;
   this->numcachelevels = 0;
 }
 
@@ -917,11 +917,11 @@ SoGLBigImageP::reset(SoGLBigImageTls * tls, SoState * state)
   for (int i = 0; i < n; i++) {
     if (tls->glimagearray[i]) {
       tls->glimagearray[i]->unref(state);
-      tls->glimagearray[i] = NULL;
+      tls->glimagearray[i] = nullptr;
     }
     if (tls->imagearray[i]) {
       delete tls->imagearray[i];
-      tls->imagearray[i] = NULL;
+      tls->imagearray[i] = nullptr;
     }
   }
   delete[] tls->glimagearray;
@@ -929,11 +929,11 @@ SoGLBigImageP::reset(SoGLBigImageTls * tls, SoState * state)
   delete[] tls->glimageage;
   delete[] tls->glimagediv;
   delete[] tls->averagebuf;
-  tls->glimagearray = NULL;
-  tls->imagearray = NULL;
-  tls->glimageage = NULL;
-  tls->glimagediv = NULL;
-  tls->averagebuf = NULL;
+  tls->glimagearray = nullptr;
+  tls->imagearray = nullptr;
+  tls->glimageage = nullptr;
+  tls->glimagediv = nullptr;
+  tls->averagebuf = nullptr;
   tls->currentdim.setValue(0,0);
 }
 
@@ -949,7 +949,7 @@ SoGLBigImageP::unrefOldDL(SoGLBigImageTls * tls, SoState * state, const uint32_t
                                "Killed image because of old age.");
 #endif // debug
         tls->glimagearray[i]->unref(state);
-        tls->glimagearray[i] = NULL;
+        tls->glimagearray[i] = nullptr;
       }
       else tls->glimageage[i] += 1;
     }
diff --git a/coin4/src/rendering/SoGLCubeMapImage.cpp b/coin4/src/rendering/SoGLCubeMapImage.cpp
index 2f26f4f..c14bf27 100644
--- a/coin4/src/rendering/SoGLCubeMapImage.cpp
+++ b/coin4/src/rendering/SoGLCubeMapImage.cpp
@@ -99,7 +99,7 @@ public:
   class dldata {
   public:
     dldata(void)
-      : dlist(NULL), age(0) { }
+      : dlist(nullptr), age(0) { }
     dldata(SoGLDisplayList *dl)
       : dlist(dl),
         age(0) { }
@@ -118,7 +118,7 @@ public:
       dl = this->dlists[i].dlist;
       if (dl->getContext() == currcontext) return dl;
     }
-    return NULL;
+    return nullptr;
   }
 
   SbList <dldata> dlists;
@@ -151,7 +151,7 @@ public:
 
     while (i < n) {
       if (thisp->dlists[i].dlist->getContext() == (int) context) {
-        thisp->dlists[i].dlist->unref(NULL);
+        thisp->dlists[i].dlist->unref(nullptr);
         thisp->dlists.remove(i);
         n--;
       }
@@ -163,7 +163,7 @@ public:
 
 SoType SoGLCubeMapImageP::classTypeId STATIC_SOTYPE_INIT;
 #ifdef COIN_THREADSAFE
-SbMutex * SoGLCubeMapImageP::mutex = NULL;
+SbMutex * SoGLCubeMapImageP::mutex = nullptr;
 #endif // !COIN_THREADSAFE
 
 #define PRIVATE(obj) (obj->pimpl)
@@ -222,7 +222,7 @@ SoGLCubeMapImage::cleanupClass(void)
 {
 #ifdef COIN_THREADSAFE
   delete SoGLCubeMapImageP::mutex;
-  SoGLCubeMapImageP::mutex = NULL;
+  SoGLCubeMapImageP::mutex = nullptr;
 #endif // COIN_THREADSAFE
   SoGLCubeMapImageP::classTypeId STATIC_SOTYPE_INIT;
 }
@@ -254,7 +254,7 @@ SoGLCubeMapImage::setCubeMapImage(const Target target,
 
   PRIVATE(this)->lock();
   for (int i = 0; i < PRIVATE(this)->dlists.getLength(); i++) {
-    PRIVATE(this)->dlists[i].dlist->unref(NULL);
+    PRIVATE(this)->dlists[i].dlist->unref(nullptr);
   }
   PRIVATE(this)->dlists.truncate(0);
   PRIVATE(this)->unlock();
@@ -264,7 +264,7 @@ SoGLCubeMapImage::setCubeMapImage(const Target target,
   if (bytes) {
     this->SoGLImage::setData(bytes, size, numcomponents,
                              CLAMP_TO_EDGE, CLAMP_TO_EDGE,
-                             0.9f, 0, NULL);
+                             0.9f, 0, nullptr);
   }
 }
 
diff --git a/coin4/src/rendering/SoGLDriverDatabase.cpp b/coin4/src/rendering/SoGLDriverDatabase.cpp
index dee072f..4710e6d 100644
--- a/coin4/src/rendering/SoGLDriverDatabase.cpp
+++ b/coin4/src/rendering/SoGLDriverDatabase.cpp
@@ -154,12 +154,12 @@ const int SoGLDriverDatabaseP::databaseloaderversion = 1;
 SoGLDriverDatabaseP::SoGLDriverDatabaseP()
 {
   this->initFunctions();
-  this->database = NULL;
+  this->database = nullptr;
 }
 
 SoGLDriverDatabaseP::~SoGLDriverDatabaseP()
 {
-  if (this->database != NULL) {
+  if (this->database != nullptr) {
 #if COIN_DEBUG
     cc_xml_doc_write_to_file(this->database, "database_debug.xml");
 #endif
@@ -381,7 +381,7 @@ SoGLDriverDatabaseP::isFast(const cc_glglue * context, const SbName & feature)
 SbName
 SoGLDriverDatabaseP::getComment(const cc_glglue * context, const SbName & feature)
 {
-  const char * comment = NULL;
+  const char * comment = nullptr;
 
   SoGLDriver * driver = this->findGLDriver(context);
 
@@ -398,7 +398,7 @@ SoGLDriverDatabaseP::getComment(const cc_glglue * context, const SbName & featur
 cc_xml_element *
 SoGLDriverDatabaseP::findPlatform(const cc_xml_elt * root, const char * platformstring)
 {
-  cc_xml_element * platform = NULL;
+  cc_xml_element * platform = nullptr;
 
   unsigned int numplatforms = cc_xml_elt_get_num_children_of_type(root, "platform");
 
@@ -433,7 +433,7 @@ SoGLDriverDatabaseP::findPlatform(const cc_xml_elt * root, const char * platform
       }
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 /*
@@ -475,7 +475,7 @@ SoGLDriverDatabaseP::findVendor(const cc_xml_elt * platform, const char * vendor
       }
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 /*
@@ -545,7 +545,7 @@ SoGLDriverDatabaseP::findDriver(const cc_xml_elt * vendor, const cc_glglue * COI
       //oyshole, 20080314
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 /*
@@ -578,7 +578,7 @@ SoGLDriverDatabaseP::findGLDriver(const cc_glglue * context)
   SbName renderer(context->rendererstr);
   SbName versionstring(context->versionstr);
 
-  SoGLDriver * driver = NULL;
+  SoGLDriver * driver = nullptr;
 
   // Check if a driver object has been created for this context. If so
   // use this driver.
@@ -626,7 +626,7 @@ SoGLDriverDatabaseP::findGLDriver(const cc_glglue * context)
 bool
 SoGLDriverDatabaseP::loadFromFile(const SbName & filename)
 {
-  if (this->database != NULL)
+  if (this->database != nullptr)
     cc_xml_doc_delete_x(this->database);
 
   this->database = cc_xml_doc_new();
@@ -635,7 +635,7 @@ SoGLDriverDatabaseP::loadFromFile(const SbName & filename)
 
   if (!result || !checkDocumentVersion(this->database)) {
     cc_xml_doc_delete_x(this->database);
-    this->database = NULL;
+    this->database = nullptr;
   }
   return result;
 }
@@ -646,7 +646,7 @@ SoGLDriverDatabaseP::loadFromFile(const SbName & filename)
 bool
 SoGLDriverDatabaseP::loadFromBuffer(const char * buffer)
 {
-  if (this->database != NULL)
+  if (this->database != nullptr)
     cc_xml_doc_delete_x(this->database);
 
   this->database = cc_xml_doc_new();
@@ -655,7 +655,7 @@ SoGLDriverDatabaseP::loadFromBuffer(const char * buffer)
 
   if (!result || !checkDocumentVersion(this->database)) {
     cc_xml_doc_delete_x(this->database);
-    this->database = NULL;
+    this->database = nullptr;
   }
   return result;
 }
@@ -733,11 +733,11 @@ SoGLDriverDatabaseP::mergeVendor(cc_xml_elt * platform, const cc_xml_elt * vendo
   cc_xml_element * name = cc_xml_elt_get_child_of_type(vendor, "name", 0);
   SbName namestr = cc_xml_elt_get_cdata(name);
 
-  cc_xml_elt * existingvendor = NULL;
+  cc_xml_elt * existingvendor = nullptr;
 
   existingvendor = findVendor(platform, namestr);
 
-  if (existingvendor == NULL) {
+  if (existingvendor == nullptr) {
     // Try Aliases
     unsigned int numaliases = cc_xml_elt_get_num_children_of_type(vendor, "alias");
 
@@ -748,7 +748,7 @@ SoGLDriverDatabaseP::mergeVendor(cc_xml_elt * platform, const cc_xml_elt * vendo
     }
   }
 
-  if (existingvendor == NULL) {
+  if (existingvendor == nullptr) {
     cc_xml_elt_add_child_x(platform, cc_xml_elt_clone(vendor));
     result = true;
   }
@@ -780,11 +780,11 @@ SoGLDriverDatabaseP::mergePlatform(const cc_xml_elt * platform)
 
   cc_xml_elt * root = getDatabaseRoot();
 
-  cc_xml_elt * existingplatform = NULL;
+  cc_xml_elt * existingplatform = nullptr;
 
   existingplatform = findPlatform(root, namestr);
 
-  if (existingplatform == NULL) {
+  if (existingplatform == nullptr) {
     // Try Aliases
     unsigned int numaliases = cc_xml_elt_get_num_children_of_type(platform, "alias");
 
@@ -795,7 +795,7 @@ SoGLDriverDatabaseP::mergePlatform(const cc_xml_elt * platform)
     }
   }
 
-  if (existingplatform == NULL) {
+  if (existingplatform == nullptr) {
     cc_xml_elt_add_child_x(root, cc_xml_elt_clone(platform));
     result = true;
   }
@@ -844,7 +844,7 @@ SoGLDriverDatabaseP::mergeRoot(const cc_xml_elt * root)
 cc_xml_elt *
 SoGLDriverDatabaseP::getDatabaseRoot()
 {
-  if (this->database == NULL)
+  if (this->database == nullptr)
     this->database = cc_xml_doc_new();
 
   cc_xml_elt * root = cc_xml_doc_get_root(this->database);
@@ -980,9 +980,9 @@ SoGLDriverDatabaseP::addFeature(const SbName & feature, const SbName & comment)
 {
   cc_xml_elt * root = getDatabaseRoot();
 
-  cc_xml_elt * featureelement = cc_xml_elt_new_from_data("feature", NULL);
-  cc_xml_elt * nameelement = cc_xml_elt_new_from_data("name", NULL);
-  cc_xml_elt * commentelement = cc_xml_elt_new_from_data("comment", NULL);
+  cc_xml_elt * featureelement = cc_xml_elt_new_from_data("feature", nullptr);
+  cc_xml_elt * nameelement = cc_xml_elt_new_from_data("name", nullptr);
+  cc_xml_elt * commentelement = cc_xml_elt_new_from_data("comment", nullptr);
 
   cc_xml_elt_set_cdata_x(nameelement, feature);
   cc_xml_elt_set_cdata_x(commentelement, comment);
@@ -1158,18 +1158,18 @@ SoGLDriverDatabase::addFeature(const SbName & feature, const SbName & comment)
   pimpl()->addFeature(feature, comment);
 }
 
-static SoGLDriverDatabaseP * pimpl_instance = NULL;
+static SoGLDriverDatabaseP * pimpl_instance = nullptr;
 
 static void sogldriverdatabase_atexit(void)
 {
   delete pimpl_instance;
-  pimpl_instance = NULL;
+  pimpl_instance = nullptr;
 }
 
 SoGLDriverDatabaseP *
 SoGLDriverDatabase::pimpl(void)
 {
-  if (pimpl_instance == NULL) {
+  if (pimpl_instance == nullptr) {
     pimpl_instance = new SoGLDriverDatabaseP;
     cc_coin_atexit((coin_atexit_f*) sogldriverdatabase_atexit);
   }
diff --git a/coin4/src/rendering/SoGLImage.cpp b/coin4/src/rendering/SoGLImage.cpp
index 6e6ad1b..e7ab90e 100644
--- a/coin4/src/rendering/SoGLImage.cpp
+++ b/coin4/src/rendering/SoGLImage.cpp
@@ -242,7 +242,7 @@ static int COIN_ENABLE_CONFORMANT_GL_CLAMP = -1;
 // *************************************************************************
 
 // buffer used for creating mipmap images
-static SbStorage * glimage_bufferstorage = NULL;
+static SbStorage * glimage_bufferstorage = nullptr;
 
 typedef struct {
   unsigned char * buffer;
@@ -255,9 +255,9 @@ static void
 glimage_buffer_construct(void * buffer)
 {
   soglimage_buffer * buf = (soglimage_buffer*) buffer;
-  buf->buffer = NULL;
+  buf->buffer = nullptr;
   buf->buffersize = 0;
-  buf->mipmapbuffer = NULL;
+  buf->mipmapbuffer = nullptr;
   buf->mipmapbuffersize = 0;
 }
 
@@ -273,8 +273,8 @@ glimage_buffer_destruct(void * buffer)
 static unsigned char *
 glimage_get_buffer(const int buffersize, const bool mipmap)
 {
-  soglimage_buffer * buf = NULL;
-  assert(glimage_bufferstorage != NULL);
+  soglimage_buffer * buf = nullptr;
+  assert(glimage_bufferstorage != nullptr);
 
   buf = (soglimage_buffer*)
     glimage_bufferstorage->get();
@@ -659,7 +659,7 @@ public:
   class dldata {
   public:
     dldata(void)
-      : dlist(NULL), age(0) { }
+      : dlist(nullptr), age(0) { }
     dldata(SoGLDisplayList *dl)
       : dlist(dl),
         age(0) { }
@@ -685,8 +685,8 @@ public:
 
 SoType SoGLImageP::classTypeId STATIC_SOTYPE_INIT;
 uint32_t SoGLImageP::current_glimageid = 1;
-SoGLImage::SoGLImageResizeCB * SoGLImageP::resizecb = NULL;
-void * SoGLImageP::resizeclosure = NULL;
+SoGLImage::SoGLImageResizeCB * SoGLImageP::resizecb = nullptr;
+void * SoGLImageP::resizeclosure = nullptr;
 #ifdef COIN_THREADSAFE
 SbMutex * SoGLImageP::mutex;
 #endif // COIN_THREADSAFE
@@ -820,15 +820,15 @@ void
 SoGLImage::cleanupClass(void)
 {
   delete glimage_bufferstorage;
-  glimage_bufferstorage = NULL;
+  glimage_bufferstorage = nullptr;
 #ifdef COIN_THREADSAFE
   delete SoGLImageP::mutex;
-  SoGLImageP::mutex = NULL;
+  SoGLImageP::mutex = nullptr;
 #endif // COIN_THREADSAFE
   SoGLImageP::classTypeId STATIC_SOTYPE_INIT;
 
-  SoGLImageP::resizecb = NULL;
-  SoGLImageP::resizeclosure = NULL;
+  SoGLImageP::resizecb = nullptr;
+  SoGLImageP::resizeclosure = nullptr;
   SoGLImageP::current_glimageid = 1;
 }
 
@@ -879,7 +879,7 @@ SoGLImage::isOfType(SoType type) const
                size[0], size[1],
                0,
                GL_DEPTH_COMPONENT,
-               GL_UNSIGNED_BYTE, NULL);
+               GL_UNSIGNED_BYTE, nullptr);
 
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
@@ -905,7 +905,7 @@ SoGLImage::setGLDisplayList(SoGLDisplayList * dl,
   PRIVATE(this)->unrefDLists(state);
   dl->ref();
   PRIVATE(this)->dlists.append(SoGLImageP::dldata(dl));
-  PRIVATE(this)->image = NULL; // we have no data. Texture is organized outside this image
+  PRIVATE(this)->image = nullptr; // we have no data. Texture is organized outside this image
   PRIVATE(this)->wraps = wraps;
   PRIVATE(this)->wrapt = wrapt;
   PRIVATE(this)->glimageid = SoGLImageP::getNextGLImageId(); // assign an unique id to this image
@@ -995,13 +995,13 @@ SoGLImage::setData(const SbImage * image,
   hardware.
 
   Normally, the OpenGL texture object isn't created until the first
-  time it is needed, but if \a createinstate is != NULL, the texture
+  time it is needed, but if \a createinstate is != nullptr, the texture
   object is created immediately. This is useful if you use a temporary
   buffer to hold the texture data. Be careful when using this feature,
   since the texture data might be needed at a later stage (for
   instance to create a texture object for another context).  It will
   not be possible to create texture objects for other cache contexts
-  when \a createinstate is != NULL.
+  when \a createinstate is != nullptr.
 
   Also if \a createinstate is supplied, and all the attributes are the
   same as the current data in the image, glTexSubImage() will be used
@@ -1009,7 +1009,7 @@ SoGLImage::setData(const SbImage * image,
   This is much faster on most OpenGL drivers, and is very useful, for
   instance when doing animated textures.
 
-  If you supply NULL for \a image, the instance will be reset, causing
+  If you supply nullptr for \a image, the instance will be reset, causing
   all display lists and memory to be freed.
 */
 void
@@ -1024,7 +1024,7 @@ SoGLImage::setData(const SbImage *image,
 {
   PRIVATE(this)->imageage = 0;
 
-  if (image == NULL) {
+  if (image == nullptr) {
     PRIVATE(this)->unrefDLists(createinstate);
     if (PRIVATE(this)->isregistered) SoGLImage::unregisterImage(this);
     PRIVATE(this)->init(); // init to default values
@@ -1041,7 +1041,7 @@ SoGLImage::setData(const SbImage *image,
   // faster for most drivers.
   if (createinstate) { // We need the state for cc_glglue
     const cc_glglue * glw = sogl_glue_instance(createinstate);
-    SoGLDisplayList *dl = NULL;
+    SoGLDisplayList *dl = nullptr;
 
     bool copyok =
       wraps == PRIVATE(this)->wraps &&
@@ -1049,7 +1049,7 @@ SoGLImage::setData(const SbImage *image,
       wrapr == PRIVATE(this)->wrapr &&
       border == PRIVATE(this)->border &&
       border == 0 && // haven't tested with borders yet. Play it safe.
-      (dl = PRIVATE(this)->findDL(createinstate)) != NULL;
+      (dl = PRIVATE(this)->findDL(createinstate)) != nullptr;
 
     SbVec3s size;
     int nc;
@@ -1068,7 +1068,7 @@ SoGLImage::setData(const SbImage *image,
       dl->ref();
       PRIVATE(this)->unrefDLists(createinstate);
       PRIVATE(this)->dlists.append(SoGLImageP::dldata(dl));
-      PRIVATE(this)->image = NULL; // data is temporary, and only for current context
+      PRIVATE(this)->image = nullptr; // data is temporary, and only for current context
       dl->call(createinstate);
 
       bool compress =
@@ -1108,7 +1108,7 @@ SoGLImage::setData(const SbImage *image,
       PRIVATE(this)->unrefDLists(createinstate);
       if (createinstate) {
         PRIVATE(this)->dlists.append(SoGLImageP::dldata(PRIVATE(this)->createGLDisplayList(createinstate)));
-        PRIVATE(this)->image = NULL; // data is assumed to be temporary
+        PRIVATE(this)->image = nullptr; // data is assumed to be temporary
       }
     }
   }
@@ -1177,7 +1177,7 @@ SoGLImage::~SoGLImage()
 {
   SoContextHandler::removeContextDestructionCallback(SoGLImageP::contextCleanup, PRIVATE(this));
   if (PRIVATE(this)->isregistered) SoGLImage::unregisterImage(this);
-  PRIVATE(this)->unrefDLists(NULL);
+  PRIVATE(this)->unrefDLists(nullptr);
   delete PRIVATE(this);
 }
 
@@ -1185,14 +1185,14 @@ SoGLImage::~SoGLImage()
   This class has a private destuctor since we want users to supply
   the current GL state when deleting the image. This is to make sure
   gl texture objects are freed as soon as possible. If you supply
-  NULL to this method, the gl texture objects won't be deleted
+  nullptr to this method, the gl texture objects won't be deleted
   until the next time an GLRenderAction is applied in the image's
   cache context(s).
 */
 void
 SoGLImage::unref(SoState *state)
 {
-  if (PRIVATE(this)->pbuffer) this->setPBuffer(state, NULL);
+  if (PRIVATE(this)->pbuffer) this->setPBuffer(state, nullptr);
   PRIVATE(this)->unrefDLists(state);
   delete this;
 }
@@ -1228,7 +1228,7 @@ SoGLImage::getImage(void) const
 
 /*!
   Returns or creates a SoGLDisplayList to be used for rendering.
-  Returns NULL if no SoDLDisplayList could be created.
+  Returns nullptr if no SoDLDisplayList could be created.
 */
 SoGLDisplayList *
 SoGLImage::getGLDisplayList(SoState *state)
@@ -1237,7 +1237,7 @@ SoGLImage::getGLDisplayList(SoState *state)
   SoGLDisplayList *dl = PRIVATE(this)->findDL(state);
   UNLOCK_GLIMAGE;
 
-  if (dl == NULL) {
+  if (dl == nullptr) {
     dl = PRIVATE(this)->createGLDisplayList(state);
     if (dl) {
       LOCK_GLIMAGE;
@@ -1368,8 +1368,8 @@ void
 SoGLImageP::init(void)
 {
   assert(this->isregistered == false);
-  this->image = NULL;
-  this->pbuffer = NULL;
+  this->image = nullptr;
+  this->pbuffer = nullptr;
   this->glsize.setValue(0,0,0);
   this->glcomp = 0;
   this->wraps = SoGLImage::CLAMP;
@@ -1382,7 +1382,7 @@ SoGLImageP::init(void)
   this->usealphatest = false;
   this->quality = 0.4f;
   this->imageage = 0;
-  this->endframecb = NULL;
+  this->endframecb = nullptr;
   this->glimageid = 0; // glimageid 0 is an empty image
 }
 
@@ -1606,9 +1606,9 @@ SoGLImageP::createGLDisplayList(SoState *state)
   SbVec3s size;
   int numcomponents;
   unsigned char *bytes =
-    this->image ? this->image->getValue(size, numcomponents) : NULL;
+    this->image ? this->image->getValue(size, numcomponents) : nullptr;
 
-  if (!this->pbuffer && !bytes) return NULL;
+  if (!this->pbuffer && !bytes) return nullptr;
 
   uint32_t xsize = size[0];
   uint32_t ysize = size[1];
@@ -1678,9 +1678,9 @@ SoGLImageP::checkTransparency(void)
   SbVec3s size;
   int numcomponents;
   unsigned char *bytes = this->image ?
-    this->image->getValue(size, numcomponents) : NULL;
+    this->image->getValue(size, numcomponents) : nullptr;
 
-  if (bytes == NULL) {
+  if (bytes == nullptr) {
     if (this->glcomp == 2 || this->glcomp == 4) {
       // we must assume it has transparency, and that we
       // can't use alpha testing
@@ -1898,7 +1898,7 @@ SoGLImageP::unrefDLists(SoState *state)
   this->dlists.truncate(0);
 }
 
-// find dl for a context, NULL if not found
+// find dl for a context, nullptr if not found
 SoGLDisplayList *
 SoGLImageP::findDL(SoState *state)
 {
@@ -1909,7 +1909,7 @@ SoGLImageP::findDL(SoState *state)
     dl = this->dlists[i].dlist;
     if (dl->getContext() == currcontext) return dl;
   }
-  return NULL;
+  return nullptr;
 }
 
 void
@@ -2062,7 +2062,7 @@ static void
 regimage_cleanup(void)
 {
   delete glimage_reglist;
-  glimage_reglist = NULL;
+  glimage_reglist = nullptr;
   glimage_maxage = 60;
 }
 
@@ -2177,7 +2177,7 @@ void
 SoGLImage::registerImage(SoGLImage *image)
 {
   LOCK_GLIMAGE;
-  if (glimage_reglist == NULL) {
+  if (glimage_reglist == nullptr) {
     coin_atexit((coin_atexit_f *)regimage_cleanup, CC_ATEXIT_NORMAL);
     glimage_reglist = new SbList<SoGLImage*>;
   }
@@ -2233,7 +2233,7 @@ SoGLImageP::contextCleanup(uint32_t context, void * closure)
 
   while (i < n) {
     if (thisp->dlists[i].dlist->getContext() == (int) context) {
-      thisp->dlists[i].dlist->unref(NULL);
+      thisp->dlists[i].dlist->unref(nullptr);
       thisp->dlists.remove(i);
       n--;
     }
diff --git a/coin4/src/rendering/SoGLNurbs.cpp b/coin4/src/rendering/SoGLNurbs.cpp
index e819d89..a200c76 100644
--- a/coin4/src/rendering/SoGLNurbs.cpp
+++ b/coin4/src/rendering/SoGLNurbs.cpp
@@ -62,26 +62,26 @@ sogl_calculate_nurbs_normals()
 }
 
 namespace {
-  SbStorage * sogl_coordstorage = NULL;
-  SbStorage * sogl_texcoordstorage = NULL;
-  SbStorage * sogl_normalstorage = NULL;
+  SbStorage * sogl_coordstorage = nullptr;
+  SbStorage * sogl_texcoordstorage = nullptr;
+  SbStorage * sogl_normalstorage = nullptr;
 
   void nurbs_coord_cleanup(void)
   {
     delete sogl_coordstorage;
-    sogl_coordstorage = NULL;
+    sogl_coordstorage = nullptr;
   }
 
   void nurbs_texcoord_cleanup(void)
   {
     delete sogl_texcoordstorage;
-    sogl_texcoordstorage = NULL;
+    sogl_texcoordstorage = nullptr;
   }
 
   void nurbs_normal_cleanup(void)
   {
     delete sogl_normalstorage;
-    sogl_normalstorage = NULL;
+    sogl_normalstorage = nullptr;
   }
 
   void sogl_alloc_coords(void * ptr)
@@ -99,7 +99,7 @@ namespace {
   SbList <float> *
   sogl_get_tmpcoordlist(void)
   {
-    if (sogl_coordstorage == NULL) {
+    if (sogl_coordstorage == nullptr) {
       sogl_coordstorage = new SbStorage(sizeof(void*), sogl_alloc_coords, sogl_dealloc_coords);
       coin_atexit((coin_atexit_f *)nurbs_coord_cleanup, CC_ATEXIT_NORMAL);
     }
@@ -110,7 +110,7 @@ namespace {
   SbList <float> *
   sogl_get_tmptexcoordlist(void)
   {
-    if (sogl_texcoordstorage == NULL) {
+    if (sogl_texcoordstorage == nullptr) {
       sogl_texcoordstorage = new SbStorage(sizeof(void*), sogl_alloc_coords, sogl_dealloc_coords);
       coin_atexit((coin_atexit_f *)nurbs_texcoord_cleanup, CC_ATEXIT_NORMAL);
     }
@@ -121,7 +121,7 @@ namespace {
   SbList <float> *
   sogl_get_tmpnormallist(void)
   {
-    if (sogl_normalstorage == NULL) {
+    if (sogl_normalstorage == nullptr) {
       sogl_normalstorage = new SbStorage(sizeof(void*), sogl_alloc_coords, sogl_dealloc_coords);
       coin_atexit((coin_atexit_f *)nurbs_normal_cleanup, CC_ATEXIT_NORMAL);
     }
@@ -837,7 +837,7 @@ namespace {
     char buffer[1024];
     static int fno = 0;
     sprintf(buffer, "normaltest%d.iv", fno++);
-    FILE* fp = NULL;
+    FILE* fp = nullptr;
     fp = fopen(buffer, "w");
     if ( fp ) fprintf(fp,"#Inventor V2.1 ascii\n"
                       "Separator {\n"
@@ -913,7 +913,7 @@ namespace {
       fprintf(fp,	"]\n"
               "}\n");
       fclose(fp);
-      fp = NULL;
+      fp = nullptr;
     }
   }
 
@@ -1062,7 +1062,7 @@ sogl_render_nurbs_surface(SoAction * action, SoShape * shape,
   }
   // generate normal map
   if (calculatenurbsnormals) {
-    GLfloat * ptrnormals = NULL;
+    GLfloat * ptrnormals = nullptr;
 
     SbList <float> * tmpnormallist = sogl_get_tmpnormallist();
     tmpnormallist->truncate(0);
diff --git a/coin4/src/rendering/SoGLNurbs.h b/coin4/src/rendering/SoGLNurbs.h
index bc32ab2..9ef536a 100644
--- a/coin4/src/rendering/SoGLNurbs.h
+++ b/coin4/src/rendering/SoGLNurbs.h
@@ -45,8 +45,8 @@ sogl_render_nurbs_surface(SoAction * action, SoShape * shape,
                           const float * sknotvec, const float * tknotvec,
                           const int numsknot, const int numtknot,
                           const bool glrender,
-                          const int numcoordindex = 0, const int32_t * coordindex = NULL,
-                          const int numtexcoordindex = 0, const int32_t * texcoordindex = NULL);
+                          const int numcoordindex = 0, const int32_t * coordindex = nullptr,
+                          const int numtexcoordindex = 0, const int32_t * texcoordindex = nullptr);
 
 void sogl_render_nurbs_curve(SoAction * action, SoShape * shape,
                              void * nurbsrenderer,
@@ -55,7 +55,7 @@ void sogl_render_nurbs_curve(SoAction * action, SoShape * shape,
                              const int numknots,
                              const bool glrender,
                              const bool drawaspoints = false,
-                             const int numcoordindex = 0, const int32_t * coordindex = NULL);
+                             const int numcoordindex = 0, const int32_t * coordindex = nullptr);
 
 
 
diff --git a/coin4/src/rendering/SoOffscreenGLXData.cpp b/coin4/src/rendering/SoOffscreenGLXData.cpp
index dad0381..9076ad0 100644
--- a/coin4/src/rendering/SoOffscreenGLXData.cpp
+++ b/coin4/src/rendering/SoOffscreenGLXData.cpp
@@ -35,7 +35,7 @@
 
 // *************************************************************************
 
-Display * SoOffscreenGLXData::display = NULL;
+Display * SoOffscreenGLXData::display = nullptr;
 static bool display_initialized = false;
 
 void
@@ -47,7 +47,7 @@ SoOffscreenGLXData::cleanup(void)
   // display cannot also lead to problems though... 20060208 kyrah
 #if 0
   XCloseDisplay(display);
-  display = NULL;
+  display = nullptr;
 #endif
 }
 
@@ -73,14 +73,14 @@ SoOffscreenGLXData::getDisplay(void)
     //
     // mortene@sim.no
 
-    SoOffscreenGLXData::display = XOpenDisplay(NULL);
+    SoOffscreenGLXData::display = XOpenDisplay(nullptr);
 
     if (!SoOffscreenGLXData::display) {
       SoDebugError::post("SoOffscreenGLXData::SoOffscreenGLXData",
                          "Couldn't connect to X11 DISPLAY.");
       // FIXME: will probably cause a crash later? If so, should be
       // more robust. 20020802 mortene.
-      return NULL;
+      return nullptr;
     }
   }
 
diff --git a/coin4/src/rendering/SoOffscreenRenderer.cpp b/coin4/src/rendering/SoOffscreenRenderer.cpp
index ced3e8b..9f3293a 100644
--- a/coin4/src/rendering/SoOffscreenRenderer.cpp
+++ b/coin4/src/rendering/SoOffscreenRenderer.cpp
@@ -368,14 +368,14 @@ class SoOffscreenRendererP {
 public:
   SoOffscreenRendererP(SoOffscreenRenderer * masterptr,
                        const SbViewportRegion & vpr,
-                       SoGLRenderAction * glrenderaction = NULL)
+                       SoGLRenderAction * glrenderaction = nullptr)
   {
     this->master = masterptr;
     this->didreadbuffer = true;
 
     this->backgroundcolor.setValue(0,0,0);
     this->components = SoOffscreenRenderer::RGB;
-    this->buffer = NULL;
+    this->buffer = nullptr;
     this->bufferbytesize = 0;
     this->lastnodewasacamera = false;
 	
@@ -791,7 +791,7 @@ SoOffscreenRendererP::renderFromBase(SoBase * base)
 
   // needed to clear viewport after glViewport() is called from
   // SoGLRenderAction
-  this->renderaction->addPreRenderCallback(pre_render_cb, NULL);
+  this->renderaction->addPreRenderCallback(pre_render_cb, nullptr);
 
   // For debugging purposes, it has been made possible to use an
   // envvar to *force* tiled rendering even when it can be done in a
@@ -830,7 +830,7 @@ SoOffscreenRendererP::renderFromBase(SoBase * base)
     }
 
     // We have to grab cameras using this callback during rendering
-    this->visitedcamera = NULL;
+    this->visitedcamera = nullptr;
     this->renderaction->setAbortCallback(SoOffscreenRendererP::GLRenderAbortCallback, this);
 
     // Render entire scenegraph for each subscreen.
@@ -896,7 +896,7 @@ SoOffscreenRendererP::renderFromBase(SoBase * base)
       }
     }
 
-    this->renderaction->setAbortCallback(NULL, this);
+    this->renderaction->setAbortCallback(nullptr, this);
 
     if (!this->visitedcamera) {
       SoDebugError::postWarning("SoOffscreenRenderer::renderFromBase",
@@ -940,7 +940,7 @@ SoOffscreenRendererP::renderFromBase(SoBase * base)
     }
   }
 
-  this->renderaction->removePreRenderCallback(pre_render_cb, NULL);
+  this->renderaction->removePreRenderCallback(pre_render_cb, nullptr);
 
   // Restore old value.
   (void)SoGLBigImage::setChangeLimit(bigimagechangelimit);
@@ -1049,7 +1049,7 @@ SoOffscreenRenderer::getBuffer(void) const
   unwound to a native C++ type for multiplatform compatibility
   reasons.
 
-  Returned reference will contain a NULL value on other platforms.
+  Returned reference will contain a nullptr value on other platforms.
 
   Important limitation: if the current dimensions of the
   SoOffscreenRenderer instance are larger than what can be rendered
diff --git a/coin4/src/rendering/SoOffscreenWGLData.cpp b/coin4/src/rendering/SoOffscreenWGLData.cpp
index 1cde4b1..1e020c9 100644
--- a/coin4/src/rendering/SoOffscreenWGLData.cpp
+++ b/coin4/src/rendering/SoOffscreenWGLData.cpp
@@ -35,8 +35,8 @@
 SbVec2f
 SoOffscreenWGLData::getResolution(void)
 {
-  HDC devctx = CreateCompatibleDC(NULL);
-  if (devctx == NULL) {
+  HDC devctx = CreateCompatibleDC(nullptr);
+  if (devctx == nullptr) {
     SoDebugError::postWarning("SoOffscreenWGLData::getResolution",
                               "Couldn't create a device context.");
     return SbVec2f(72.0f / 25.4f, 72.0f / 25.4f); // fall back to 72dpi
diff --git a/coin4/src/rendering/SoRenderManager.cpp b/coin4/src/rendering/SoRenderManager.cpp
index bf13f7a..4c25be0 100644
--- a/coin4/src/rendering/SoRenderManager.cpp
+++ b/coin4/src/rendering/SoRenderManager.cpp
@@ -228,14 +228,14 @@ SoRenderManager::SoRenderManager(void)
   PRIVATE(this)->dummynode = new SoInfo;
   PRIVATE(this)->dummynode->ref();
 
-  PRIVATE(this)->rootsensor = NULL;
-  PRIVATE(this)->scene = NULL;
-  PRIVATE(this)->camera = NULL;
-  PRIVATE(this)->rendercb = NULL;
-  PRIVATE(this)->rendercbdata = NULL;
+  PRIVATE(this)->rootsensor = nullptr;
+  PRIVATE(this)->scene = nullptr;
+  PRIVATE(this)->camera = nullptr;
+  PRIVATE(this)->rendercb = nullptr;
+  PRIVATE(this)->rendercbdata = nullptr;
 
-  PRIVATE(this)->stereostencilmask = NULL;
-  PRIVATE(this)->superimpositions = NULL;
+  PRIVATE(this)->stereostencilmask = nullptr;
+  PRIVATE(this)->superimpositions = nullptr;
 
   PRIVATE(this)->doublebuffer = true;
   PRIVATE(this)->deleteaudiorenderaction = true;
@@ -281,7 +281,7 @@ SoRenderManager::~SoRenderManager()
   if (PRIVATE(this)->rootsensor) delete PRIVATE(this)->rootsensor;
   if (PRIVATE(this)->redrawshot) delete PRIVATE(this)->redrawshot;
 
-  if (PRIVATE(this)->superimpositions != NULL) {
+  if (PRIVATE(this)->superimpositions != nullptr) {
     while (PRIVATE(this)->superimpositions->getLength() > 0) {
       this->removeSuperimposition((Superimposition *)(*PRIVATE(this)->superimpositions)[0]);
     }
@@ -292,7 +292,7 @@ SoRenderManager::~SoRenderManager()
 
   if (PRIVATE(this)->scene)
     PRIVATE(this)->scene->unref();
-  this->setCamera(NULL);
+  this->setCamera(nullptr);
 
   delete PRIVATE(this);
 }
@@ -1001,7 +1001,7 @@ SoRenderManager::initStencilBufferForInterleavedStereo(void)
          (s == SoRenderManager::INTERLEAVED_COLUMNS));
 
   // Find out whether or not we need to regenerate the mask data.
-  bool allocnewmask = (PRIVATE(this)->stereostencilmask == NULL);
+  bool allocnewmask = (PRIVATE(this)->stereostencilmask == nullptr);
 
   const SbVec2s neworigin = currentvp.getViewportOriginPixels();
   const SbVec2s newsize = currentvp.getViewportSizePixels();
@@ -1389,12 +1389,12 @@ SoRenderManager::redraw(void)
   scene upon detecting changes in the scene graph.
 
   The automatic redraw is turned on and off by setting either a valid
-  callback function with setRenderCallback(), or by passing \c NULL.
+  callback function with setRenderCallback(), or by passing \c nullptr.
  */
 bool
 SoRenderManager::isAutoRedraw(void) const
 {
-  return PRIVATE(this)->rendercb != NULL;
+  return PRIVATE(this)->rendercb != nullptr;
 }
 
 
@@ -1499,7 +1499,7 @@ SoRenderManager::setGLRenderAction(SoGLRenderAction * const action)
   }
   if (PRIVATE(this)->deleteglaction) {
     delete PRIVATE(this)->glaction;
-    PRIVATE(this)->glaction = NULL;
+    PRIVATE(this)->glaction = nullptr;
   }
 
   // If action change, we need to invalidate state to enable lazy GL
@@ -1622,7 +1622,7 @@ SoRenderManager::setAudioRenderAction(SoAudioRenderAction * const action)
 {
   if (PRIVATE(this)->deleteaudiorenderaction) {
     delete PRIVATE(this)->audiorenderaction;
-    PRIVATE(this)->audiorenderaction = NULL;
+    PRIVATE(this)->audiorenderaction = nullptr;
   }
 
   // If action change, we need to invalidate state to enable lazy GL
diff --git a/coin4/src/rendering/SoRenderManagerP.cpp b/coin4/src/rendering/SoRenderManagerP.cpp
index 8813050..910345f 100644
--- a/coin4/src/rendering/SoRenderManagerP.cpp
+++ b/coin4/src/rendering/SoRenderManagerP.cpp
@@ -45,9 +45,9 @@ int SoRenderManagerRootSensor::debugrootnotifications = -1;
 SoRenderManagerP::SoRenderManagerP(SoRenderManager * publ)
 {
   this->publ = publ;
-  this->getmatrixaction = NULL;
-  this->getbboxaction = NULL;
-  this->searchaction = NULL;
+  this->getmatrixaction = nullptr;
+  this->getbboxaction = nullptr;
+  this->searchaction = nullptr;
 }
 
 SoRenderManagerP::~SoRenderManagerP()
@@ -222,7 +222,7 @@ SoRenderManager::Superimposition::Superimposition(SoNode * scene,
                                                   SoRenderManager * manager,
                                                   uint32_t flags)
 {
-  assert(scene != NULL);
+  assert(scene != nullptr);
   PRIVATE(this) = new SuperimpositionP;
 
   PRIVATE(this)->scene = scene;
diff --git a/coin4/src/rendering/SoVBO.cpp b/coin4/src/rendering/SoVBO.cpp
index 060d568..d37f9ab 100644
--- a/coin4/src/rendering/SoVBO.cpp
+++ b/coin4/src/rendering/SoVBO.cpp
@@ -68,7 +68,7 @@ static SbHash<uint32_t, bool> * vbo_isfast_hash;
 SoVBO::SoVBO(const GLenum target, const GLenum usage)
   : target(target),
     usage(usage),
-    data(NULL),
+    data(nullptr),
     datasize(0),
     dataid(0),
     didalloc(false),
@@ -117,7 +117,7 @@ SoVBO::~SoVBO()
 static void vbo_atexit_cleanup(void)
 {
   delete vbo_isfast_hash;
-  vbo_isfast_hash = NULL;
+  vbo_isfast_hash = nullptr;
   vbo_vertex_count_min_limit = -1;
   vbo_vertex_count_max_limit = -1;
   vbo_render_as_vertex_arrays = -1;
@@ -127,7 +127,7 @@ static void vbo_atexit_cleanup(void)
 void
 SoVBO::init(void)
 {
-  coin_glglue_add_instance_created_callback(context_created, NULL);
+  coin_glglue_add_instance_created_callback(context_created, nullptr);
 
   vbo_isfast_hash = new SbHash<uint32_t, bool> (3);
   coin_atexit(vbo_atexit_cleanup, CC_ATEXIT_NORMAL);
@@ -288,7 +288,7 @@ SoVBO::getBufferData(const GLvoid *& data, intptr_t & size)
 void
 SoVBO::bindBuffer(uint32_t contextid)
 {
-  if ((this->data == NULL) ||
+  if ((this->data == nullptr) ||
       (this->datasize == 0)) {
     assert(0 && "no data in buffer");
     return;
@@ -411,7 +411,7 @@ bool
 SoVBO::isVBOFast(const uint32_t contextid)
 {
   bool result = true;
-  assert(vbo_isfast_hash != NULL);
+  assert(vbo_isfast_hash != nullptr);
   (void) vbo_isfast_hash->get(contextid, result);
   return result;
 }
@@ -433,7 +433,7 @@ SoVBO::testGLPerformance(const uint32_t contextid)
 {
   bool isfast;
   // did we alreay test this for this context?
-  assert(vbo_isfast_hash != NULL);
+  assert(vbo_isfast_hash != nullptr);
   if (vbo_isfast_hash->get(contextid, isfast)) return;
 
   // Run time test disabled. Our old test seemed to be buggy, and
diff --git a/coin4/src/rendering/SoVertexArrayIndexer.cpp b/coin4/src/rendering/SoVertexArrayIndexer.cpp
index 4bdeeb4..75ec26e 100644
--- a/coin4/src/rendering/SoVertexArrayIndexer.cpp
+++ b/coin4/src/rendering/SoVertexArrayIndexer.cpp
@@ -51,8 +51,8 @@
 */
 SoVertexArrayIndexer::SoVertexArrayIndexer(void)
   : target(0),
-    next(NULL),
-    vbo(NULL),
+    next(nullptr),
+    vbo(nullptr),
     use_shorts(true)
 {
 }
@@ -244,7 +244,7 @@ SoVertexArrayIndexer::render(const cc_glglue * glue, const bool renderasvbo, con
   case GL_POINTS:
     // common case
     if (renderasvbo) {
-      if (this->vbo == NULL) {
+      if (this->vbo == nullptr) {
         this->vbo = new SoVBO(GL_ELEMENT_ARRAY_BUFFER);
         if (this->use_shorts) {
           GLushort * dst = reinterpret_cast<GLushort*> 
@@ -263,7 +263,7 @@ SoVertexArrayIndexer::render(const cc_glglue * glue, const bool renderasvbo, con
       cc_glglue_glDrawElements(glue,
                                this->target,
                                this->indexarray.getLength(),
-                               this->use_shorts ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, NULL);
+                               this->use_shorts ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, nullptr);
       cc_glglue_glBindBuffer(glue, GL_ELEMENT_ARRAY_BUFFER, 0);
     }
     else {
@@ -320,7 +320,7 @@ SoVertexArrayIndexer::getNumVertices(void)
 SoVertexArrayIndexer *
 SoVertexArrayIndexer::getNext(void)
 {
-  if (this->next == NULL) {
+  if (this->next == nullptr) {
     this->next = new SoVertexArrayIndexer;
   }
   return this->next;
@@ -474,6 +474,6 @@ GLint *
 SoVertexArrayIndexer::getWriteableIndices(void)
 {
   delete this->vbo;
-  this->vbo = NULL;
+  this->vbo = nullptr;
   return (GLint*) this->indexarray.getArrayPtr();
 }
diff --git a/coin4/src/scxml/SbStringConvert.h b/coin4/src/scxml/SbStringConvert.h
index e8fbca3..8efc546 100644
--- a/coin4/src/scxml/SbStringConvert.h
+++ b/coin4/src/scxml/SbStringConvert.h
@@ -67,7 +67,7 @@ template<typename Type, typename ArgumentType>
 template <typename T>
 struct ScXMLConvert {
     static
-    T fromString(const SbString & str, bool * conversionOk = NULL)
+    T fromString(const SbString & str, bool * conversionOk = nullptr)
     {
       typename SbTypeInfo<T>::PrimitiveType tmpVal[SbTypeInfo<T>::Dimensions];
       SbString substr;
@@ -122,7 +122,7 @@ struct ScXMLConvert {
 
 template<typename T>
 struct PrimitiveConvert {
-  static T fromString(const SbString & str, bool * conversionOk = NULL) {
+  static T fromString(const SbString & str, bool * conversionOk = nullptr) {
       return FromString<T>(str, conversionOk);
   }
   static SbString toString(const T & in) {
@@ -148,7 +148,7 @@ public:
   
   template <typename T>
     static
-    T fromString(const SbString & str, bool * conversionOk = NULL)
+    T fromString(const SbString & str, bool * conversionOk = nullptr)
     {
       return
         IF< SbTypeInfo<T>::isPrimitive, PrimitiveConvert<T>, ScXMLConvert<T> >::RET::fromString(str,conversionOk);
diff --git a/coin4/src/scxml/ScXML.cpp b/coin4/src/scxml/ScXML.cpp
index ecdadf0..a407d4d 100644
--- a/coin4/src/scxml/ScXML.cpp
+++ b/coin4/src/scxml/ScXML.cpp
@@ -155,9 +155,9 @@
 // *************************************************************************
 
 // private static variables
-ScXMLP::NamespaceDict * ScXMLP::namespaces = NULL;
-ScXMLP::TargettypeDict * ScXMLP::targettypes = NULL;
-ScXMLP::TypeDict * ScXMLP::profileevaluators = NULL;
+ScXMLP::NamespaceDict * ScXMLP::namespaces = nullptr;
+ScXMLP::TargettypeDict * ScXMLP::targettypes = nullptr;
+ScXMLP::TypeDict * ScXMLP::profileevaluators = nullptr;
 
 // *************************************************************************
 
@@ -355,7 +355,7 @@ ScXML::readFile(const char * filename)
 {
   ScXMLDocument * doc = ScXMLDocument::readFile(filename);
   if (!doc) {
-    return NULL;
+    return nullptr;
   }
 
   ScXMLStateMachine * statemachine = new SoScXMLStateMachine;
@@ -375,7 +375,7 @@ ScXML::readBuffer(const SbByteBuffer & bufferdata)
 {
   ScXMLDocument * doc = ScXMLDocument::readBuffer(bufferdata);
   if (!doc) {
-    return NULL;
+    return nullptr;
   }
 
   ScXMLStateMachine * statemachine = new SoScXMLStateMachine;
@@ -469,7 +469,7 @@ ScXMLP::getClassType(NamespaceDict * nsdict, const char * xmlns, const char * cl
   const SbName classnamename(classname);
   const char * key = classnamename.getString();
 
-  ScXMLP::TypeDict * typedict = NULL;
+  ScXMLP::TypeDict * typedict = nullptr;
 
   typedict = ScXMLP::getTypeDict(nsdict, xmlns);
   if (typedict) {
@@ -543,7 +543,7 @@ ScXMLP::readXMLData(cc_xml_doc * doc)
   // get a handle on the root element
   cc_xml_elt * root = cc_xml_doc_get_root(doc);
   if (strcmp(cc_xml_elt_get_type(root), "scxml") != 0) {
-    return NULL;
+    return nullptr;
   }
 
   // peek at xmlns attribute to get the correct object types instantiated
@@ -560,7 +560,7 @@ ScXMLP::readXMLData(cc_xml_doc * doc)
   assert(statemachine && statemachine->isOfType(ScXMLStateMachine::getClassTypeId()));
 
   // FIXME
-  ScXMLObject * documentobj = NULL;
+  ScXMLObject * documentobj = nullptr;
   // ScXMLObject * documentobj = ScXMLP::readScXMLDocument(statemachine, root, xmlns);
   assert(documentobj && documentobj->isOfType(ScXMLDocument::getClassTypeId()));
   ScXMLDocument * document = static_cast<ScXMLDocument *>(documentobj);
@@ -572,7 +572,7 @@ ScXMLP::readXMLData(cc_xml_doc * doc)
 
 // *************************************************************************
 
-void * ScXMLP::mutex = NULL;
+void * ScXMLP::mutex = nullptr;
 
 void
 ScXMLP::init(void)
@@ -588,9 +588,9 @@ ScXMLP::cleanup(void)
 {
   cleanup_namespacedict(ScXMLP::namespaces);
   delete ScXMLP::namespaces;
-  ScXMLP::namespaces = NULL;
+  ScXMLP::namespaces = nullptr;
   delete ScXMLP::profileevaluators;
-  ScXMLP::profileevaluators = NULL;
+  ScXMLP::profileevaluators = nullptr;
   cleanup_targettypes();
   CC_MUTEX_DESTRUCT(ScXMLP::mutex);
 }
@@ -633,7 +633,7 @@ ScXMLP::cleanup_targettypes(void)
     it++;
   }
   delete ScXMLP::targettypes;
-  ScXMLP::targettypes = NULL;
+  ScXMLP::targettypes = nullptr;
 }
 
 // *************************************************************************
diff --git a/coin4/src/scxml/ScXMLAbstractStateElt.cpp b/coin4/src/scxml/ScXMLAbstractStateElt.cpp
index 715dfe9..f8d682d 100644
--- a/coin4/src/scxml/ScXMLAbstractStateElt.cpp
+++ b/coin4/src/scxml/ScXMLAbstractStateElt.cpp
@@ -61,13 +61,13 @@ ScXMLAbstractStateElt::cleanClass(void)
 }
 
 ScXMLAbstractStateElt::ScXMLAbstractStateElt(void)
-: id(NULL)
+: id(nullptr)
 {
 }
 
 ScXMLAbstractStateElt::~ScXMLAbstractStateElt(void)
 {
-  this->setIdAttribute(NULL);
+  this->setIdAttribute(nullptr);
 }
 
 void
@@ -87,7 +87,7 @@ ScXMLAbstractStateElt::handleXMLAttributes(void)
   this->setIdAttribute(this->getXMLAttribute("id"));
 
   // validate
-  if ((this->id == NULL) || (std::strcmp(this->id, "") == 0)) {
+  if ((this->id == nullptr) || (std::strcmp(this->id, "") == 0)) {
     SoDebugError::postInfo("ScXMLAbstractStateElt::handleXMLAttributes",
                            "state element must have 'id' attribute");
     return false;
@@ -116,7 +116,7 @@ ScXMLAbstractStateElt::search(const char * attrname, const char * attrvalue) con
       return this;
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 #undef PRIVATE
diff --git a/coin4/src/scxml/ScXMLAnchorElt.cpp b/coin4/src/scxml/ScXMLAnchorElt.cpp
index 2ba7492..05095a7 100644
--- a/coin4/src/scxml/ScXMLAnchorElt.cpp
+++ b/coin4/src/scxml/ScXMLAnchorElt.cpp
@@ -68,7 +68,7 @@ ScXMLAnchorEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
   // handle XML attributes
   if (unlikely(!anchor->handleXMLAttributes())) {
     delete anchor;
-    return NULL;
+    return nullptr;
   }
 
   const int numchildren = cc_xml_elt_get_num_children(xmlelt);
@@ -85,7 +85,7 @@ ScXMLAnchorEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
                        "unexpected XML element '<%s>' found in <anchor>",
                        elementtype);
     delete anchor;
-    return NULL;
+    return nullptr;
   }
 
   return anchor;
@@ -116,15 +116,15 @@ ScXMLAnchorElt::cleanClass(void)
 }
 
 ScXMLAnchorElt::ScXMLAnchorElt(void)
-: type(NULL),
-  snapshot(NULL)
+: type(nullptr),
+  snapshot(nullptr)
 {
 }
 
 ScXMLAnchorElt::~ScXMLAnchorElt(void)
 {
-  this->setTypeAttribute(NULL);
-  this->setSnapshotAttribute(NULL);
+  this->setTypeAttribute(nullptr);
+  this->setSnapshotAttribute(nullptr);
 }
 
 void
@@ -147,7 +147,7 @@ ScXMLAnchorElt::handleXMLAttributes(void)
   this->setTypeAttribute(this->getXMLAttribute("type"));
   this->setSnapshotAttribute(this->getXMLAttribute("snapshot"));
 
-  if (this->type == NULL) {
+  if (this->type == nullptr) {
     return false;
   }
 
@@ -180,7 +180,7 @@ ScXMLAnchorElt::search(const char * attrname, const char * attrvalue) const
       return this;
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 #undef PRIVATE
diff --git a/coin4/src/scxml/ScXMLAssignElt.cpp b/coin4/src/scxml/ScXMLAssignElt.cpp
index e57c697..a72d119 100644
--- a/coin4/src/scxml/ScXMLAssignElt.cpp
+++ b/coin4/src/scxml/ScXMLAssignElt.cpp
@@ -103,7 +103,7 @@ ScXMLAssignEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
   // handle XML attributes
   if (unlikely(!assign->handleXMLAttributes())) {
     delete assign;
-    return NULL;
+    return nullptr;
   }
 
   const int numchildren = cc_xml_elt_get_num_children(xmlelt);
@@ -120,7 +120,7 @@ ScXMLAssignEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
                        "unexpected XML element '<%s>' found in <assign>",
                        elementtype);
     delete assign;
-    return NULL;
+    return nullptr;
   }
 
   return assign;
@@ -160,17 +160,17 @@ ScXMLAssignElt::cleanClass(void)
   Constructor that sets up an empty ScXMLAssignElt object.
 */
 ScXMLAssignElt::ScXMLAssignElt(void)
-: location(NULL),
-  dataID(NULL),
-  expr(NULL)
+: location(nullptr),
+  dataID(nullptr),
+  expr(nullptr)
 {
 }
 
 ScXMLAssignElt::~ScXMLAssignElt(void)
 {
-  this->setLocationAttribute(NULL);
-  this->setDataIDAttribute(NULL);
-  this->setExprAttribute(NULL);
+  this->setLocationAttribute(nullptr);
+  this->setDataIDAttribute(nullptr);
+  this->setExprAttribute(nullptr);
 }
 
 void
@@ -243,7 +243,7 @@ ScXMLAssignElt::search(const char * attrname, const char * attrvalue) const
       return this;
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 void
diff --git a/coin4/src/scxml/ScXMLCommonP.h b/coin4/src/scxml/ScXMLCommonP.h
index 590a912..644c741 100644
--- a/coin4/src/scxml/ScXMLCommonP.h
+++ b/coin4/src/scxml/ScXMLCommonP.h
@@ -35,12 +35,12 @@
 
 #define SCXML__SET_ATTRIBUTE_VALUE(_ptr_, _name_, _value_)              \
   do {                                                                  \
-    if ((_ptr_ != NULL) &&                                              \
+    if ((_ptr_ != nullptr) &&                                              \
         (_ptr_ != this->getXMLAttribute(_name_))) {                     \
       delete [] _ptr_;                                                  \
     }                                                                   \
-    _ptr_ = NULL;                                                       \
-    if (_value_ != NULL) {                                              \
+    _ptr_ = nullptr;                                                       \
+    if (_value_ != nullptr) {                                              \
       if (_value_ == this->getXMLAttribute(_name_)) {                   \
         _ptr_ = const_cast<char *>(_value_);                            \
       } else {                                                          \
@@ -104,7 +104,7 @@ classname::SO__CONCAT(remove,singular)(objtype * obj)                   \
     std::find(objlist.begin(), objlist.end(), obj);                     \
   assert(it != objlist.end());                                          \
   objlist.erase(it);                                                    \
-  obj->setContainer(NULL);                                              \
+  obj->setContainer(nullptr);                                              \
 }                                                                       \
                                                                         \
 void                                                                    \
@@ -112,7 +112,7 @@ classname::SO__CONCAT(clearAll,plural)(void)                            \
 {                                                                       \
   std::vector<objtype *>::iterator it = objlist.begin();                \
   while (it != objlist.end()) {                                         \
-    (*it)->setContainer(NULL);                                          \
+    (*it)->setContainer(nullptr);                                          \
     ++it;                                                               \
   }                                                                     \
   objlist.clear();                                                      \
diff --git a/coin4/src/scxml/ScXMLContentElt.cpp b/coin4/src/scxml/ScXMLContentElt.cpp
index 2986a24..1d400bf 100644
--- a/coin4/src/scxml/ScXMLContentElt.cpp
+++ b/coin4/src/scxml/ScXMLContentElt.cpp
@@ -68,7 +68,7 @@ ScXMLContentEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocu
   // handle XML attributes
   if (unlikely(!content->handleXMLAttributes())) {
     delete content;
-    return NULL;
+    return nullptr;
   }
 
   const int numchildren = cc_xml_elt_get_num_children(xmlelt);
@@ -85,7 +85,7 @@ ScXMLContentEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocu
                        "unexpected XML element '<%s>' found in <content>",
                        elementtype);
     delete content;
-    return NULL;
+    return nullptr;
   }
 
 
diff --git a/coin4/src/scxml/ScXMLDataElt.cpp b/coin4/src/scxml/ScXMLDataElt.cpp
index ed8ee44..3d3515a 100644
--- a/coin4/src/scxml/ScXMLDataElt.cpp
+++ b/coin4/src/scxml/ScXMLDataElt.cpp
@@ -95,7 +95,7 @@ ScXMLDataEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocumen
   // handle XML attributes
   if (unlikely(!data->handleXMLAttributes())) {
     delete data;
-    return NULL;
+    return nullptr;
   }
 
   const int numchildren = cc_xml_elt_get_num_children(xmlelt);
@@ -112,7 +112,7 @@ ScXMLDataEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocumen
                        "unexpected XML element '<%s>' found in <data>",
                        elementtype);
     delete data;
-    return NULL;
+    return nullptr;
   }
 
   return data;
@@ -143,17 +143,17 @@ ScXMLDataElt::cleanClass(void)
 }
 
 ScXMLDataElt::ScXMLDataElt(void)
-: ID(NULL),
-  src(NULL),
-  expr(NULL)
+: ID(nullptr),
+  src(nullptr),
+  expr(nullptr)
 {
 }
 
 ScXMLDataElt::~ScXMLDataElt(void)
 {
-  this->setIDAttribute(NULL);
-  this->setSrcAttribute(NULL);
-  this->setExprAttribute(NULL);
+  this->setIDAttribute(nullptr);
+  this->setSrcAttribute(nullptr);
+  this->setExprAttribute(nullptr);
 }
 
 void
@@ -226,7 +226,7 @@ ScXMLDataElt::search(const char * attrname, const char * attrvalue) const
       return this;
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 void
diff --git a/coin4/src/scxml/ScXMLDataModelElt.cpp b/coin4/src/scxml/ScXMLDataModelElt.cpp
index 021b4dd..3b6910f 100644
--- a/coin4/src/scxml/ScXMLDataModelElt.cpp
+++ b/coin4/src/scxml/ScXMLDataModelElt.cpp
@@ -70,7 +70,7 @@ ScXMLDataModelEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDo
   // handle XML attributes
   if (unlikely(!datamodel->handleXMLAttributes())) {
     delete datamodel;
-    return NULL;
+    return nullptr;
   }
 
   const int numchildren = cc_xml_elt_get_num_children(xmlelt);
@@ -90,7 +90,7 @@ ScXMLDataModelEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDo
       ScXMLElt * dataobj = datareader->read(datamodel, element, doc, sm);
       if (unlikely(!dataobj)) {
         delete datamodel;
-        return NULL;
+        return nullptr;
       }
       assert(dataobj->isOfType(ScXMLDataElt::getClassTypeId()));
       datamodel->addData(static_cast<ScXMLDataElt *>(dataobj));
@@ -101,7 +101,7 @@ ScXMLDataModelEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDo
                          "unexpected XML element '<%s>' found in <datamodel>",
                          elementtype);
       delete datamodel;
-      return NULL;
+      return nullptr;
     }
   }
 
@@ -141,13 +141,13 @@ ScXMLDataModelElt::cleanClass(void)
 }
 
 ScXMLDataModelElt::ScXMLDataModelElt(void)
-: schema(NULL)
+: schema(nullptr)
 {
 }
 
 ScXMLDataModelElt::~ScXMLDataModelElt(void)
 {
-  this->setSchemaAttribute(NULL);
+  this->setSchemaAttribute(nullptr);
 }
 
 void
@@ -201,7 +201,7 @@ ScXMLDataModelElt::search(const char * attrname, const char * attrvalue) const
     }
     ++it;
   }
-  return NULL;
+  return nullptr;
 }
 
 SCXML_LIST_OBJECT_API_IMPL(ScXMLDataModelElt, ScXMLDataElt, PRIVATE(this)->datalist, Data, Data);
diff --git a/coin4/src/scxml/ScXMLDocument.cpp b/coin4/src/scxml/ScXMLDocument.cpp
index 524cab2..98bc46c 100644
--- a/coin4/src/scxml/ScXMLDocument.cpp
+++ b/coin4/src/scxml/ScXMLDocument.cpp
@@ -74,10 +74,10 @@ using std::strlen;
 class ScXMLDocument::PImpl {
 public:
   PImpl(void)
-  : filename(NULL),
-    root(NULL),
-    stateidmap(NULL),
-    dataidmap(NULL)
+  : filename(nullptr),
+    root(nullptr),
+    stateidmap(nullptr),
+    dataidmap(nullptr)
   { }
   ~PImpl(void) { }
 
@@ -262,7 +262,7 @@ void intrusive_ptr_release(cc_xml_doc * doc) {
 ScXMLDocument *
 ScXMLDocument::readFile(const char * filename)
 {
-  ScXMLDocument * scxmldoc = NULL;
+  ScXMLDocument * scxmldoc = nullptr;
 
   if (strncmp(filename, "coin:", 5) == 0) { // is a "resource"
     //size_t buffersize = 0;
@@ -278,12 +278,12 @@ ScXMLDocument::readFile(const char * filename)
 
   boost::intrusive_ptr<cc_xml_doc> xmldoc(cc_xml_doc_new());
   if (unlikely(!cc_xml_doc_read_file_x(xmldoc.get(), filename))) {
-    return NULL;
+    return nullptr;
   }
 
   scxmldoc = ScXMLDocument::readXMLData(xmldoc.get());
   if (unlikely(!scxmldoc)) {
-    return NULL;
+    return nullptr;
   }
 
   scxmldoc->setFilename(filename);
@@ -294,16 +294,16 @@ ScXMLDocument::readFile(const char * filename)
 ScXMLDocument *
 ScXMLDocument::readBuffer(const SbByteBuffer & buffer)
 {
-  if (buffer.size()==0) return NULL;
+  if (buffer.size()==0) return nullptr;
 
   boost::intrusive_ptr<cc_xml_doc> xmldoc(cc_xml_doc_new());
   if (unlikely(!cc_xml_doc_read_buffer_x(xmldoc.get(), buffer.constData(), buffer.size()))) {
-    return NULL;
+    return nullptr;
   }
 
   ScXMLDocument * scxmldoc = ScXMLDocument::readXMLData(xmldoc.get());
   if (unlikely(!scxmldoc)) {
-    return NULL;
+    return nullptr;
   }
 
   scxmldoc->setFilename("<memory buffer>");
@@ -320,15 +320,15 @@ ScXMLDocument::readXMLData(cc_xml_doc * xmldoc)
     SoDebugError::post("ScXMLDocument::readXMLData",
                        "expected root to be an <scxml> element, not '%s'",
                        cc_xml_elt_get_type(root));
-    return NULL;
+    return nullptr;
   }
 
   ScXMLEltReader * reader = ScXMLScxmlElt::getElementReader();
   ScXMLDocument * scxmldoc = new ScXMLDocument;
-  ScXMLElt * elt = reader->read(NULL, root, scxmldoc, NULL);
+  ScXMLElt * elt = reader->read(nullptr, root, scxmldoc, nullptr);
   if (unlikely(!elt)) {
     delete scxmldoc;
-    return NULL;
+    return nullptr;
   }
   assert(elt->isOfType(ScXMLScxmlElt::getClassTypeId()));
   scxmldoc->setRoot(static_cast<ScXMLScxmlElt *>(elt));
@@ -368,7 +368,7 @@ ScXMLDocument::getRoot(void) const
 ScXMLAbstractStateElt *
 ScXMLDocument::getStateById(SbName id) const
 {
-  if (PRIVATE(this)->stateidmap.get() == NULL) {
+  if (PRIVATE(this)->stateidmap.get() == nullptr) {
     ScXMLDocument * thisp = const_cast<ScXMLDocument *>(this);
     PRIVATE(thisp)->stateidmap.reset(new PImpl::StateIdMap);
     PRIVATE(thisp)->dataidmap.reset(new PImpl::DataIdMap);
@@ -379,13 +379,13 @@ ScXMLDocument::getStateById(SbName id) const
   if (it != PRIVATE(this)->stateidmap->end()) {
     return it->second;
   }
-  return NULL;
+  return nullptr;
 }
 
 ScXMLDataElt *
 ScXMLDocument::getDataById(SbName id) const
 {
-  if (PRIVATE(this)->dataidmap.get() == NULL) {
+  if (PRIVATE(this)->dataidmap.get() == nullptr) {
     ScXMLDocument * thisp = const_cast<ScXMLDocument *>(this);
     PRIVATE(thisp)->stateidmap.reset(new PImpl::StateIdMap);
     PRIVATE(thisp)->dataidmap.reset(new PImpl::DataIdMap);
@@ -396,7 +396,7 @@ ScXMLDocument::getDataById(SbName id) const
   if (it != PRIVATE(this)->dataidmap->end()) {
     return it->second;
   }
-  return NULL;
+  return nullptr;
 }
 
 #undef PRIVATE
diff --git a/coin4/src/scxml/ScXMLECMAScriptEvaluator.cpp b/coin4/src/scxml/ScXMLECMAScriptEvaluator.cpp
index 02b2a11..36ad3b8 100644
--- a/coin4/src/scxml/ScXMLECMAScriptEvaluator.cpp
+++ b/coin4/src/scxml/ScXMLECMAScriptEvaluator.cpp
@@ -63,7 +63,7 @@ ScXMLDataObj *
 ScXMLECMAScriptEvaluator::evaluate(const char * COIN_UNUSED_ARG(expression)) const
 {
   // FIXME: not implemented
-  return NULL;
+  return nullptr;
 }
 
 bool
@@ -77,6 +77,6 @@ ScXMLDataObj *
 ScXMLECMAScriptEvaluator::locate(const char * COIN_UNUSED_ARG(location)) const
 {
   // FIXME: not implemented
-  return NULL;
+  return nullptr;
 }
 
diff --git a/coin4/src/scxml/ScXMLElseElt.cpp b/coin4/src/scxml/ScXMLElseElt.cpp
index f0a2fa8..de97f79 100644
--- a/coin4/src/scxml/ScXMLElseElt.cpp
+++ b/coin4/src/scxml/ScXMLElseElt.cpp
@@ -67,7 +67,7 @@ ScXMLElseEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocumen
   // handle XML attributes
   if (unlikely(!elseelt->handleXMLAttributes())) {
     delete elseelt;
-    return NULL;
+    return nullptr;
   }
 
   const int numchildren = cc_xml_elt_get_num_children(xmlelt);
@@ -83,7 +83,7 @@ ScXMLElseEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocumen
     SoDebugError::post("ScXMLElseEltReader::read",
                        "<else> contains unexpected <%s> element", elementtype);
     delete elseelt;
-    return NULL;
+    return nullptr;
   }
 
   return elseelt;
diff --git a/coin4/src/scxml/ScXMLElseIfElt.cpp b/coin4/src/scxml/ScXMLElseIfElt.cpp
index f03004f..f937700 100644
--- a/coin4/src/scxml/ScXMLElseIfElt.cpp
+++ b/coin4/src/scxml/ScXMLElseIfElt.cpp
@@ -73,7 +73,7 @@ ScXMLElseIfEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
   // handle XML attributes
   if (unlikely(!elseifelt->handleXMLAttributes())) {
     delete elseifelt;
-    return NULL;
+    return nullptr;
   }
 
   const int numchildren = cc_xml_elt_get_num_children(xmlelt);
@@ -88,7 +88,7 @@ ScXMLElseIfEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
     SoDebugError::post("ScXMLElseIfEltReader::read",
                        "<elseif> contains unexpected <%s> element", elementtype);
     delete elseifelt;
-    return NULL;
+    return nullptr;
   }
 
   return elseifelt;
@@ -119,13 +119,13 @@ ScXMLElseIfElt::cleanClass(void)
 }
 
 ScXMLElseIfElt::ScXMLElseIfElt(void)
-: cond(NULL)
+: cond(nullptr)
 {
 }
 
 ScXMLElseIfElt::~ScXMLElseIfElt(void)
 {
-  this->setCondAttribute(NULL);
+  this->setCondAttribute(nullptr);
 }
 
 void
@@ -168,7 +168,7 @@ ScXMLElseIfElt::search(const char * attrname, const char * attrvalue) const
       return this;
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 #undef PRIVATE
diff --git a/coin4/src/scxml/ScXMLElt.cpp b/coin4/src/scxml/ScXMLElt.cpp
index 235151c..5209d61 100644
--- a/coin4/src/scxml/ScXMLElt.cpp
+++ b/coin4/src/scxml/ScXMLElt.cpp
@@ -119,13 +119,13 @@ ScXMLElt::cleanClass(void)
 }
 
 ScXMLElt::ScXMLElt(void)
-: containerptr(NULL)
+: containerptr(nullptr)
 {
 }
 
 ScXMLElt::~ScXMLElt(void)
 {
-  this->containerptr = NULL;
+  this->containerptr = nullptr;
 }
 
 /*!
@@ -134,7 +134,7 @@ ScXMLElt::~ScXMLElt(void)
   can be used as a general-purpose attribute dictionary outside of
   that.
 
-  If NULL is passed as the value, the attribute is removed.
+  If nullptr is passed as the value, the attribute is removed.
 */
 void
 ScXMLElt::setXMLAttribute(const char * attribute, const char * value)
@@ -152,7 +152,7 @@ ScXMLElt::setXMLAttribute(const char * attribute, const char * value)
     }
   } else {
     delete [] it->second;
-    it->second = NULL;
+    it->second = nullptr;
     if (!value) {
       PRIVATE(this)->attributemap.erase(it);
     } else {
@@ -164,7 +164,7 @@ ScXMLElt::setXMLAttribute(const char * attribute, const char * value)
 
 /*!
   This method returns the string value set for an attribute, or
-  NULL if not set.
+  nullptr if not set.
 */
 const char *
 ScXMLElt::getXMLAttribute(const char * attribute) const
@@ -175,7 +175,7 @@ ScXMLElt::getXMLAttribute(const char * attribute) const
   if (it != PRIVATE(this)->attributemap.end()) {
     return it->second;
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -197,7 +197,7 @@ ScXMLElt::handleXMLAttributes(void)
   This method searches the SCXML structure for an element with the
   given attributevalue for the given attribute.
 
-  Returns NULL if nothing was found.
+  Returns nullptr if nothing was found.
 
   This function needs to be reimplemented to traverse child elements.
 */
@@ -207,13 +207,13 @@ ScXMLElt::search(const char * attrname, const char * attrvalue) const
   assert(attrname && attrvalue);
   if (strstr(attrname, ":")) { // namespace attribute
     const char * val = this->getXMLAttribute(attrname);
-    if (val != NULL) {
+    if (val != nullptr) {
       if (strcmp(val, attrvalue) == 0) {
         return this;
       }
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -223,7 +223,7 @@ ScXMLElt *
 ScXMLElt::clone(void) const
 {
   SoType elementtype(getTypeId());
-  if (!elementtype.canCreateInstance()) { return NULL; }
+  if (!elementtype.canCreateInstance()) { return nullptr; }
   ScXMLElt * copy = static_cast<ScXMLElt *>(elementtype.createInstance());
   copy->copyContents(this);
   return copy;
diff --git a/coin4/src/scxml/ScXMLEvaluator.cpp b/coin4/src/scxml/ScXMLEvaluator.cpp
index 0e6e732..6e1ae34 100644
--- a/coin4/src/scxml/ScXMLEvaluator.cpp
+++ b/coin4/src/scxml/ScXMLEvaluator.cpp
@@ -110,7 +110,7 @@ ScXMLEvaluator::cleanClass(void)
 }
 
 ScXMLEvaluator::ScXMLEvaluator(void)
-: statemachine(NULL)
+: statemachine(nullptr)
 {
 }
 
@@ -180,7 +180,7 @@ ScXMLDataObj::cleanClass(void)
 }
 
 ScXMLDataObj::ScXMLDataObj(void)
-: container(NULL)
+: container(nullptr)
 {
 }
 
@@ -248,19 +248,19 @@ ScXMLStringDataObj::createFor(const char * strval)
 }
 
 ScXMLStringDataObj::ScXMLStringDataObj(void)
-: value(NULL)
+: value(nullptr)
 {
 }
 
 ScXMLStringDataObj::ScXMLStringDataObj(const char * strval)
-: value(NULL)
+: value(nullptr)
 {
   this->setString(strval);
 }
 
 ScXMLStringDataObj::~ScXMLStringDataObj(void)
 {
-  this->setString(NULL);
+  this->setString(nullptr);
 }
 
 void
@@ -268,7 +268,7 @@ ScXMLStringDataObj::setString(const char * strptr)
 {
   if (this->value) {
     delete [] this->value;
-    this->value = NULL;
+    this->value = nullptr;
   }
   if (strptr) {
     this->value = new char [strlen(strptr) + 1];
@@ -435,19 +435,19 @@ ScXMLSbDataObj::createFor(const char * sbvalue)
 }
 
 ScXMLSbDataObj::ScXMLSbDataObj(void)
-: value(NULL)
+: value(nullptr)
 {
 }
 
 ScXMLSbDataObj::ScXMLSbDataObj(const char * sbvalue)
-: value(NULL)
+: value(nullptr)
 {
   this->setSbValue(sbvalue);
 }
 
 ScXMLSbDataObj::~ScXMLSbDataObj(void)
 {
-  this->setSbValue(NULL);
+  this->setSbValue(nullptr);
 }
 
 void
@@ -455,7 +455,7 @@ ScXMLSbDataObj::setSbValue(const char * sbvalue)
 {
   if (this->value) {
     delete [] this->value;
-    this->value = NULL;
+    this->value = nullptr;
   }
   if (sbvalue) {
     this->value = new char [ strlen(sbvalue) + 1 ];
@@ -530,7 +530,7 @@ ScXMLExprDataObj::cleanClass(void)
 }
 
 ScXMLExprDataObj::ScXMLExprDataObj(void)
-: result(NULL)
+: result(nullptr)
 {
 }
 
@@ -538,7 +538,7 @@ ScXMLExprDataObj::~ScXMLExprDataObj(void)
 {
   if (this->result) {
     delete this->result;
-    this->result = NULL;
+    this->result = nullptr;
   }
 }
 
@@ -547,10 +547,10 @@ ScXMLExprDataObj::evaluate(ScXMLStateMachine * sm)
 {
   if (this->result) {
     delete this->result;
-    this->result = NULL;
+    this->result = nullptr;
   }
   bool ok = this->evaluateNow(sm, this->result);
-  if (!ok) return NULL;
+  if (!ok) return nullptr;
   return this->result;
 }
 
@@ -583,19 +583,19 @@ ScXMLReferenceDataObj::createFor(const char * reference)
 }
 
 ScXMLReferenceDataObj::ScXMLReferenceDataObj(void)
-: reference(NULL)
+: reference(nullptr)
 {
 }
 
 ScXMLReferenceDataObj::ScXMLReferenceDataObj(const char * referencestr)
-: reference(NULL)
+: reference(nullptr)
 {
   this->setReference(referencestr);
 }
 
 ScXMLReferenceDataObj::~ScXMLReferenceDataObj(void)
 {
-  this->setReference(NULL);
+  this->setReference(nullptr);
 }
 
 void
@@ -603,7 +603,7 @@ ScXMLReferenceDataObj::setReference(const char * referencestr)
 {
   if (this->reference) {
     delete [] this->reference;
-    this->reference = NULL;
+    this->reference = nullptr;
   }
   if (referencestr) {
     this->reference = new char [ strlen(referencestr) + 1 ];
@@ -624,7 +624,7 @@ ScXMLReferenceDataObj::evaluateNow(ScXMLStateMachine * sm, ScXMLDataObj *& point
     return false;
   }
 
-  ScXMLConstantDataObj * valueobj = NULL;
+  ScXMLConstantDataObj * valueobj = nullptr;
   if (obj->isOfType(ScXMLExprDataObj::getClassTypeId())) {
     ScXMLExprDataObj * exprobj = static_cast<ScXMLExprDataObj *>(obj);
     ScXMLDataObj * dataobj = exprobj->evaluate(sm);
@@ -697,7 +697,7 @@ ScXMLAndOpExprDataObj::createFor(ScXMLDataObj * lhs, ScXMLDataObj * rhs)
 }
 
 ScXMLAndOpExprDataObj::ScXMLAndOpExprDataObj(void)
-: lhs(NULL), rhs(NULL)
+: lhs(nullptr), rhs(nullptr)
 {
 }
 
@@ -710,11 +710,11 @@ ScXMLAndOpExprDataObj::~ScXMLAndOpExprDataObj(void)
 {
   if (this->lhs) {
     delete this->lhs;
-    this->lhs = NULL;
+    this->lhs = nullptr;
   }
   if (this->rhs) {
     delete this->rhs;
-    this->rhs = NULL;
+    this->rhs = nullptr;
   }
 }
 
@@ -734,7 +734,7 @@ bool
 ScXMLAndOpExprDataObj::evaluateNow(ScXMLStateMachine * sm, ScXMLDataObj *& pointer) const
 {
   assert(this->lhs && this->rhs);
-  ScXMLBoolDataObj * lhsbool = NULL, * rhsbool = NULL;
+  ScXMLBoolDataObj * lhsbool = nullptr, * rhsbool = nullptr;
 
   if (this->lhs->isOfType(ScXMLExprDataObj::getClassTypeId())) {
     ScXMLExprDataObj * lhsexpr = static_cast<ScXMLExprDataObj *>(this->lhs);
@@ -836,7 +836,7 @@ ScXMLOrOpExprDataObj::createFor(ScXMLDataObj * lhs, ScXMLDataObj * rhs)
 }
 
 ScXMLOrOpExprDataObj::ScXMLOrOpExprDataObj(void)
-: lhs(NULL), rhs(NULL)
+: lhs(nullptr), rhs(nullptr)
 {
 }
 
@@ -849,11 +849,11 @@ ScXMLOrOpExprDataObj::~ScXMLOrOpExprDataObj(void)
 {
   if (this->lhs) {
     delete this->lhs;
-    this->lhs = NULL;
+    this->lhs = nullptr;
   }
   if (this->rhs) {
     delete this->rhs;
-    this->rhs = NULL;
+    this->rhs = nullptr;
   }
 }
 
@@ -873,7 +873,7 @@ bool
 ScXMLOrOpExprDataObj::evaluateNow(ScXMLStateMachine * sm, ScXMLDataObj *& pointer) const
 {
   assert(this->lhs && this->rhs);
-  ScXMLBoolDataObj * lhsbool = NULL, * rhsbool = NULL;
+  ScXMLBoolDataObj * lhsbool = nullptr, * rhsbool = nullptr;
 
   if (this->lhs->isOfType(ScXMLExprDataObj::getClassTypeId())) {
     ScXMLExprDataObj * lhsexpr = static_cast<ScXMLExprDataObj *>(lhs);
@@ -960,7 +960,7 @@ ScXMLNotOpExprDataObj::createFor(ScXMLDataObj * rhs)
 }
 
 ScXMLNotOpExprDataObj::ScXMLNotOpExprDataObj(void)
-: rhs(NULL)
+: rhs(nullptr)
 {
 }
 
@@ -973,7 +973,7 @@ ScXMLNotOpExprDataObj::~ScXMLNotOpExprDataObj(void)
 {
   if (this->rhs) {
     delete this->rhs;
-    this->rhs = NULL;
+    this->rhs = nullptr;
   }
 }
 
@@ -987,7 +987,7 @@ bool
 ScXMLNotOpExprDataObj::evaluateNow(ScXMLStateMachine * sm, ScXMLDataObj *& pointer) const
 {
   assert(this->rhs);
-  ScXMLBoolDataObj * rhsbool = NULL;
+  ScXMLBoolDataObj * rhsbool = nullptr;
   if (this->rhs->isOfType(ScXMLExprDataObj::getClassTypeId())) {
     ScXMLExprDataObj * rhsexpr = static_cast<ScXMLExprDataObj *>(rhs);
     ScXMLDataObj * evaled = rhsexpr->evaluate(sm);
@@ -1065,7 +1065,7 @@ ScXMLEqualsOpExprDataObj::createFor(ScXMLDataObj * lhs, ScXMLDataObj * rhs)
 }
 
 ScXMLEqualsOpExprDataObj::ScXMLEqualsOpExprDataObj(void)
-: lhs(NULL), rhs(NULL)
+: lhs(nullptr), rhs(nullptr)
 {
 }
 
@@ -1078,11 +1078,11 @@ ScXMLEqualsOpExprDataObj::~ScXMLEqualsOpExprDataObj(void)
 {
   if (this->lhs) {
     delete this->lhs;
-    this->lhs = NULL;
+    this->lhs = nullptr;
   }
   if (this->rhs) {
     delete this->rhs;
-    this->rhs = NULL;
+    this->rhs = nullptr;
   }
 }
 
@@ -1102,7 +1102,7 @@ bool
 ScXMLEqualsOpExprDataObj::evaluateNow(ScXMLStateMachine * sm, ScXMLDataObj *& pointer) const
 {
   assert(this->lhs && this->rhs);
-  ScXMLDataObj * lhsevaled = NULL, * rhsevaled = NULL;
+  ScXMLDataObj * lhsevaled = nullptr, * rhsevaled = nullptr;
 
   if (this->lhs->isOfType(ScXMLExprDataObj::getClassTypeId())) {
     ScXMLExprDataObj * lhsexpr = static_cast<ScXMLExprDataObj *>(this->lhs);
@@ -1191,7 +1191,7 @@ ScXMLAddOpExprDataObj::createFor(ScXMLDataObj * lhs, ScXMLDataObj * rhs)
 }
 
 ScXMLAddOpExprDataObj::ScXMLAddOpExprDataObj(void)
-: lhs(NULL), rhs(NULL)
+: lhs(nullptr), rhs(nullptr)
 {
 }
 
@@ -1204,11 +1204,11 @@ ScXMLAddOpExprDataObj::~ScXMLAddOpExprDataObj(void)
 {
   if (this->lhs) {
     delete this->lhs;
-    this->lhs = NULL;
+    this->lhs = nullptr;
   }
   if (this->rhs) {
     delete this->rhs;
-    this->rhs = NULL;
+    this->rhs = nullptr;
   }
 }
 
@@ -1228,7 +1228,7 @@ bool
 ScXMLAddOpExprDataObj::evaluateNow(ScXMLStateMachine * sm, ScXMLDataObj *& pointer) const
 {
   assert(this->lhs && this->rhs);
-  ScXMLRealDataObj * lhsreal = NULL, * rhsreal = NULL;
+  ScXMLRealDataObj * lhsreal = nullptr, * rhsreal = nullptr;
 
   if (this->lhs->isOfType(ScXMLExprDataObj::getClassTypeId())) {
     ScXMLExprDataObj * lhsexpr = static_cast<ScXMLExprDataObj *>(this->lhs);
@@ -1298,7 +1298,7 @@ ScXMLSubtractOpExprDataObj::createFor(ScXMLDataObj * lhs, ScXMLDataObj * rhs)
 }
 
 ScXMLSubtractOpExprDataObj::ScXMLSubtractOpExprDataObj(void)
-: lhs(NULL), rhs(NULL)
+: lhs(nullptr), rhs(nullptr)
 {
 }
 
@@ -1311,11 +1311,11 @@ ScXMLSubtractOpExprDataObj::~ScXMLSubtractOpExprDataObj(void)
 {
   if (this->lhs) {
     delete this->lhs;
-    this->lhs = NULL;
+    this->lhs = nullptr;
   }
   if (this->rhs) {
     delete this->rhs;
-    this->rhs = NULL;
+    this->rhs = nullptr;
   }
 }
 
@@ -1335,7 +1335,7 @@ bool
 ScXMLSubtractOpExprDataObj::evaluateNow(ScXMLStateMachine * sm, ScXMLDataObj *& pointer) const
 {
   assert(this->lhs && this->rhs);
-  ScXMLRealDataObj * lhsreal = NULL, * rhsreal = NULL;
+  ScXMLRealDataObj * lhsreal = nullptr, * rhsreal = nullptr;
 
   if (this->lhs->isOfType(ScXMLExprDataObj::getClassTypeId())) {
     ScXMLExprDataObj * lhsexpr = static_cast<ScXMLExprDataObj *>(this->lhs);
@@ -1407,7 +1407,7 @@ ScXMLMultiplyOpExprDataObj::createFor(ScXMLDataObj * lhs, ScXMLDataObj * rhs)
 }
 
 ScXMLMultiplyOpExprDataObj::ScXMLMultiplyOpExprDataObj(void)
-: lhs(NULL), rhs(NULL)
+: lhs(nullptr), rhs(nullptr)
 {
 }
 
@@ -1420,11 +1420,11 @@ ScXMLMultiplyOpExprDataObj::~ScXMLMultiplyOpExprDataObj(void)
 {
   if (this->lhs) {
     delete this->lhs;
-    this->lhs = NULL;
+    this->lhs = nullptr;
   }
   if (this->rhs) {
     delete this->rhs;
-    this->rhs = NULL;
+    this->rhs = nullptr;
   }
 }
 
@@ -1444,7 +1444,7 @@ bool
 ScXMLMultiplyOpExprDataObj::evaluateNow(ScXMLStateMachine * sm, ScXMLDataObj *& pointer) const
 {
   assert(this->lhs && this->rhs);
-  ScXMLRealDataObj * lhsreal = NULL, * rhsreal = NULL;
+  ScXMLRealDataObj * lhsreal = nullptr, * rhsreal = nullptr;
 
   if (this->lhs->isOfType(ScXMLExprDataObj::getClassTypeId())) {
     ScXMLExprDataObj * lhsexpr = static_cast<ScXMLExprDataObj *>(this->lhs);
@@ -1516,7 +1516,7 @@ ScXMLDivideOpExprDataObj::createFor(ScXMLDataObj * lhs, ScXMLDataObj * rhs)
 }
 
 ScXMLDivideOpExprDataObj::ScXMLDivideOpExprDataObj(void)
-: lhs(NULL), rhs(NULL)
+: lhs(nullptr), rhs(nullptr)
 {
 }
 
@@ -1529,11 +1529,11 @@ ScXMLDivideOpExprDataObj::~ScXMLDivideOpExprDataObj(void)
 {
   if (this->lhs) {
     delete this->lhs;
-    this->lhs = NULL;
+    this->lhs = nullptr;
   }
   if (this->rhs) {
     delete this->rhs;
-    this->rhs = NULL;
+    this->rhs = nullptr;
   }
 }
 
@@ -1553,7 +1553,7 @@ bool
 ScXMLDivideOpExprDataObj::evaluateNow(ScXMLStateMachine * sm, ScXMLDataObj *& pointer) const
 {
   assert(this->lhs && this->rhs);
-  ScXMLRealDataObj * lhsreal = NULL, * rhsreal = NULL;
+  ScXMLRealDataObj * lhsreal = nullptr, * rhsreal = nullptr;
 
   if (this->lhs->isOfType(ScXMLExprDataObj::getClassTypeId())) {
     ScXMLExprDataObj * lhsexpr = static_cast<ScXMLExprDataObj *>(this->lhs);
@@ -1627,7 +1627,7 @@ ScXMLNegateOpExprDataObj::createFor(ScXMLDataObj * rhs)
 }
 
 ScXMLNegateOpExprDataObj::ScXMLNegateOpExprDataObj(void)
-: rhs(NULL)
+: rhs(nullptr)
 {
 }
 
@@ -1640,7 +1640,7 @@ ScXMLNegateOpExprDataObj::~ScXMLNegateOpExprDataObj(void)
 {
   if (this->rhs) {
     delete this->rhs;
-    this->rhs = NULL;
+    this->rhs = nullptr;
   }
 }
 
@@ -1654,7 +1654,7 @@ bool
 ScXMLNegateOpExprDataObj::evaluateNow(ScXMLStateMachine * sm, ScXMLDataObj *& pointer) const
 {
   assert(this->rhs);
-  ScXMLRealDataObj * rhsevaled = NULL;
+  ScXMLRealDataObj * rhsevaled = nullptr;
   if (this->rhs->isOfType(ScXMLExprDataObj::getClassTypeId())) {
     ScXMLExprDataObj * rhsexpr = static_cast<ScXMLExprDataObj *>(this->rhs);
     ScXMLDataObj * evaled = rhsexpr->evaluate(sm);
diff --git a/coin4/src/scxml/ScXMLEvent.cpp b/coin4/src/scxml/ScXMLEvent.cpp
index ecf5897..3cf339d 100644
--- a/coin4/src/scxml/ScXMLEvent.cpp
+++ b/coin4/src/scxml/ScXMLEvent.cpp
@@ -118,7 +118,7 @@ ScXMLEvent::getAssociation(const char * key) const
   if (findit != PRIVATE(this)->associations.end()) {
     return findit->second;
   }
-  return NULL;
+  return nullptr;
 }
 
 size_t
diff --git a/coin4/src/scxml/ScXMLEventElt.cpp b/coin4/src/scxml/ScXMLEventElt.cpp
index f9b3819..7bad579 100644
--- a/coin4/src/scxml/ScXMLEventElt.cpp
+++ b/coin4/src/scxml/ScXMLEventElt.cpp
@@ -67,7 +67,7 @@ ScXMLEventEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
   // handle XML attributes
   if (unlikely(!event->handleXMLAttributes())) {
     delete event;
-    return NULL;
+    return nullptr;
   }
 
   const int numchildren = cc_xml_elt_get_num_children(xmlelt);
@@ -83,7 +83,7 @@ ScXMLEventEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
     SoDebugError::post("ScXMLEventEltReader::read",
                        "<event> contains unexpected <%s> element", elementtype);
     delete event;
-    return NULL;
+    return nullptr;
   }
 
   return event;
@@ -115,13 +115,13 @@ ScXMLEventElt::cleanClass(void)
 }
 
 ScXMLEventElt::ScXMLEventElt(void)
-: name(NULL)
+: name(nullptr)
 {
 }
 
 ScXMLEventElt::~ScXMLEventElt(void)
 {
-  this->setNameAttribute(NULL);
+  this->setNameAttribute(nullptr);
 }
 
 void
@@ -165,7 +165,7 @@ ScXMLEventElt::search(const char * attrname, const char * attrvalue) const
       return this;
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 ScXMLEvent *
diff --git a/coin4/src/scxml/ScXMLEventTarget.cpp b/coin4/src/scxml/ScXMLEventTarget.cpp
index 1ebfd5b..d6c5018 100644
--- a/coin4/src/scxml/ScXMLEventTarget.cpp
+++ b/coin4/src/scxml/ScXMLEventTarget.cpp
@@ -59,14 +59,14 @@ class DelayEventData {
   // FIXME: these objects should per spec die with the invoking eventtarget.
 public:
   DelayEventData(void)
-  : targettype(NULL), targetname(NULL), delay(0.0f), alarm(NULL), event(NULL)
+  : targettype(nullptr), targetname(nullptr), delay(0.0f), alarm(nullptr), event(nullptr)
   {
   }
   ~DelayEventData(void)
   {
-    delete [] this->targettype; this->targettype = NULL;
-    delete [] this->targetname; this->targetname = NULL;
-    if (event) { delete this->event; this->event = NULL; }
+    delete [] this->targettype; this->targettype = nullptr;
+    delete [] this->targetname; this->targetname = nullptr;
+    if (event) { delete this->event; this->event = nullptr; }
   }
 
   char * targettype;
@@ -89,10 +89,10 @@ typedef std::pair<const char *, TargetMap *> TargetTypeMapEntry;
 
 class ScXMLEventTarget::PImpl {
 public:
-  PImpl(void) : targetsessionid(NULL) { }
+  PImpl(void) : targetsessionid(nullptr) { }
   ~PImpl(void)
   {
-    delete [] this->targetsessionid; this->targetsessionid = NULL;
+    delete [] this->targetsessionid; this->targetsessionid = nullptr;
     // FIX?ME: clean out queues
   }
 
@@ -138,7 +138,7 @@ ScXMLEventTarget::PImpl::delay_event_alarm_cb(void * userdata, SoSensor * COIN_U
 
 #define PRIVATE(obj) ((obj)->pimpl)
 
-TargetTypeMap * ScXMLEventTarget::PImpl::targettypes = NULL;
+TargetTypeMap * ScXMLEventTarget::PImpl::targettypes = nullptr;
 SbList<ScXMLEventTarget *> ScXMLEventTarget::PImpl::targets;
 
 SCXML_OBJECT_ABSTRACT_SOURCE(ScXMLEventTarget);
@@ -149,7 +149,7 @@ ScXMLEventTarget::initClass(void)
   SCXML_OBJECT_INIT_ABSTRACT_CLASS(ScXMLEventTarget, ScXMLObject, "ScXMLObject");
 
   ScXMLP::lock();
-  assert(ScXMLEventTarget::PImpl::targettypes == NULL);
+  assert(ScXMLEventTarget::PImpl::targettypes == nullptr);
   ScXMLEventTarget::PImpl::targettypes = new TargetTypeMap;
   ScXMLP::unlock();
 }
@@ -160,13 +160,13 @@ ScXMLEventTarget::cleanClass(void)
   int n;
   while ( (n = ScXMLEventTarget::PImpl::targets.getLength())>0) {
     ScXMLEventTarget * target = ScXMLEventTarget::PImpl::targets[n-1];
-    unregisterEventTarget(target,NULL);
+    unregisterEventTarget(target,nullptr);
   }
   
   ScXMLP::lock();
-  assert(ScXMLEventTarget::PImpl::targettypes != NULL);
+  assert(ScXMLEventTarget::PImpl::targettypes != nullptr);
   delete ScXMLEventTarget::PImpl::targettypes;
-  ScXMLEventTarget::PImpl::targettypes = NULL;
+  ScXMLEventTarget::PImpl::targettypes = nullptr;
   ScXMLP::unlock();
   ScXMLEventTarget::classTypeId = SoType::badType();
 }
@@ -187,7 +187,7 @@ ScXMLEventTarget::registerEventTarget(ScXMLEventTarget * target, const char * se
   assert(ScXMLEventTarget::PImpl::targettypes);
   ScXMLP::lock();
   TargetTypeMap::iterator typeit = ScXMLEventTarget::PImpl::targettypes->find(targettypename.getString());
-  TargetMap * targetmap = NULL;
+  TargetMap * targetmap = nullptr;
   if (typeit != ScXMLEventTarget::PImpl::targettypes->end()) {
     targetmap = typeit->second;
   } else {
@@ -197,7 +197,7 @@ ScXMLEventTarget::registerEventTarget(ScXMLEventTarget * target, const char * se
   }
 
   TargetMap::iterator targetit = targetmap->find(targetnamename.getString());
-  SessionMap * sessionmap = NULL;
+  SessionMap * sessionmap = nullptr;
   if (targetit != targetmap->end()) {
     sessionmap = targetit->second;
   } else {
@@ -300,7 +300,7 @@ ScXMLEventTarget::getEventTarget(const char * targettype, const char * targetnam
   const SbName targettypename(targettype);
   const SbName targetnamename(targetname);
   SbName targetsessionid(SbName::empty());
-  if (sessionid != NULL) {
+  if (sessionid != nullptr) {
     targetsessionid = SbName(sessionid);
   }
 
@@ -312,7 +312,7 @@ ScXMLEventTarget::getEventTarget(const char * targettype, const char * targetnam
     //                    "given target type ('%s') not registered 1",
     //                    targettypename.getString());
     ScXMLP::unlock();
-    return NULL;
+    return nullptr;
   }
   TargetMap * targetmap = typeit->second;
 
@@ -322,7 +322,7 @@ ScXMLEventTarget::getEventTarget(const char * targettype, const char * targetnam
     //                    "given target (type '%s' '%s') not registered",
     //                    targettypename.getString(), targetnamename.getString());
     ScXMLP::unlock();
-    return NULL;
+    return nullptr;
   }
   SessionMap * sessionmap = targetit->second;
 
@@ -332,7 +332,7 @@ ScXMLEventTarget::getEventTarget(const char * targettype, const char * targetnam
     //                    "given target (type '%s' '%s') with session '%s' not registered",
     //                    targettypename.getString(), targetnamename.getString(), targetsessionid.getString());
     ScXMLP::unlock();
-    return NULL;
+    return nullptr;
   }
 
   ScXMLEventTarget * target = sessionit->second;
@@ -344,9 +344,9 @@ ScXMLEventTarget::getEventTarget(const char * targettype, const char * targetnam
 /*!
 */
 ScXMLEventTarget::ScXMLEventTarget(void)
-: targetname(NULL),
-  targettype(NULL),
-  currentevent(NULL),
+: targetname(nullptr),
+  targettype(nullptr),
+  currentevent(nullptr),
   isprocessingqueue(false)
 {
 }
@@ -359,9 +359,9 @@ ScXMLEventTarget::~ScXMLEventTarget(void)
     ScXMLEventTarget::unregisterEventTarget(this, PRIVATE(this)->targetsessionid);
   }
   delete [] this->targetname;
-  this->targetname = NULL;
+  this->targetname = nullptr;
   delete [] this->targettype;
-  this->targettype = NULL;
+  this->targettype = nullptr;
 }
 
 /*!
@@ -374,7 +374,7 @@ ScXMLEventTarget::setEventTargetType(const char * targettypestr)
   }
 
   delete [] this->targettype;
-  this->targettype = NULL;
+  this->targettype = nullptr;
 
   if (targettypestr) {
     this->targettype = new char [strlen(targettypestr) + 1];
@@ -407,7 +407,7 @@ ScXMLEventTarget::setEventTargetName(const char * targetnamestr)
   }
 
   delete [] this->targetname;
-  this->targetname = NULL;
+  this->targetname = nullptr;
 
   if (targetnamestr) {
     this->targetname = new char [strlen(targetnamestr) + 1];
@@ -494,7 +494,7 @@ ScXMLEventTarget::processEventQueue(void)
   bool eventsuccess = false;
   bool communicating = true;
   while (communicating) {
-    const ScXMLEvent * event = NULL;
+    const ScXMLEvent * event = nullptr;
     while ((event = this->getNextEvent())) {
       if (this->processOneEvent(event)) {
         eventsuccess = true;
@@ -527,7 +527,7 @@ ScXMLEventTarget::processEventQueue(void)
 const ScXMLEvent *
 ScXMLEventTarget::getNextEvent(void)
 {
-  const ScXMLEvent * nextevent = NULL;
+  const ScXMLEvent * nextevent = nullptr;
   // internal events have first priority
   nextevent = this->getNextInternalEvent();
   if (!nextevent) {
@@ -542,7 +542,7 @@ const ScXMLEvent *
 ScXMLEventTarget::getNextInternalEvent(void)
 {
   ScXMLP::lock();
-  const ScXMLEvent * nextevent = NULL;
+  const ScXMLEvent * nextevent = nullptr;
   if (!PRIVATE(this)->internaleventqueue.empty()) {
     nextevent = PRIVATE(this)->internaleventqueue.front();
     PRIVATE(this)->internaleventqueue.pop_front();
@@ -557,7 +557,7 @@ const ScXMLEvent *
 ScXMLEventTarget::getNextExternalEvent(void)
 {
   ScXMLP::lock();
-  const ScXMLEvent * nextevent = NULL;
+  const ScXMLEvent * nextevent = nullptr;
   if (!PRIVATE(this)->externaleventqueue.empty()) {
     nextevent = PRIVATE(this)->externaleventqueue.front();
     PRIVATE(this)->externaleventqueue.pop_front();
@@ -589,10 +589,10 @@ ScXMLEventTarget::setCurrentEvent(const ScXMLEvent * event)
 /*!
   \fn const ScXMLEvent * ScXMLEventTarget::getCurrentEvent(void) const
 
-  This method returns the current event during event processing, and NULL
+  This method returns the current event during event processing, and nullptr
   when not processing events.
 
-  Event processing is in special cases done with NULL as the current event,
+  Event processing is in special cases done with nullptr as the current event,
   as for instance during state machine initialization.
 */
 
diff --git a/coin4/src/scxml/ScXMLFinalElt.cpp b/coin4/src/scxml/ScXMLFinalElt.cpp
index 270474a..eb8d43f 100644
--- a/coin4/src/scxml/ScXMLFinalElt.cpp
+++ b/coin4/src/scxml/ScXMLFinalElt.cpp
@@ -73,7 +73,7 @@ ScXMLFinalEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
   // handle XML attributes
   if (unlikely(!final->handleXMLAttributes())) {
     delete final;
-    return NULL;
+    return nullptr;
   }
 
   const int numchildren = cc_xml_elt_get_num_children(xmlelt);
@@ -91,7 +91,7 @@ ScXMLFinalEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
         SoDebugError::post("ScXMLFinalEltReader::read",
                            "<final> element can only contain one <onentry> element");
         delete final;
-        return NULL;
+        return nullptr;
       }
 
       ScXMLEltReader * onentryreader = ScXMLOnEntryElt::getElementReader();
@@ -100,7 +100,7 @@ ScXMLFinalEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
 
       if (unlikely(!onentryelt)) {
         delete final;
-        return NULL;
+        return nullptr;
       }
       assert(final->isOfType(ScXMLOnEntryElt::getClassTypeId()));
       final->setOnEntry(static_cast<ScXMLOnEntryElt *>(onentryelt));
@@ -111,7 +111,7 @@ ScXMLFinalEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
         SoDebugError::post("ScXMLFinalEltReader::read",
                            "<final> element can only contain one <onexit> element");
         delete final;
-        return NULL;
+        return nullptr;
       }
 
       ScXMLEltReader * onexitreader = ScXMLOnExitElt::getElementReader();
@@ -120,7 +120,7 @@ ScXMLFinalEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
 
       if (unlikely(!onexitelt)) {
         delete final;
-        return NULL;
+        return nullptr;
       }
       assert(onexitelt->isOfType(ScXMLOnExitElt::getClassTypeId()));
       final->setOnExit(static_cast<ScXMLOnExitElt *>(onexitelt));
@@ -131,7 +131,7 @@ ScXMLFinalEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
                          "unexpected XML element '<%s>' found in <final>",
                          elementtype);
       delete final;
-      return NULL;
+      return nullptr;
     }
   }
 
@@ -142,7 +142,7 @@ ScXMLFinalEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
 
 class ScXMLFinalElt::PImpl {
 public:
-  PImpl(void) : onentry(NULL), onexit(NULL) { }
+  PImpl(void) : onentry(nullptr), onexit(nullptr) { }
 
   boost::scoped_ptr<ScXMLOnEntryElt> onentry;
   boost::scoped_ptr<ScXMLOnExitElt> onexit;
@@ -235,7 +235,7 @@ ScXMLFinalElt::search(const char * attrname, const char * attrvalue) const
       return hit;
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 #undef PRIVATE
diff --git a/coin4/src/scxml/ScXMLFinalizeElt.cpp b/coin4/src/scxml/ScXMLFinalizeElt.cpp
index 8869f10..9b841bd 100644
--- a/coin4/src/scxml/ScXMLFinalizeElt.cpp
+++ b/coin4/src/scxml/ScXMLFinalizeElt.cpp
@@ -67,7 +67,7 @@ ScXMLFinalizeEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDoc
   // handle XML attributes
   if (unlikely(!finalize->handleXMLAttributes())) {
     delete finalize;
-    return NULL;
+    return nullptr;
   }
 
   const int numchildren = cc_xml_elt_get_num_children(xmlelt);
@@ -83,7 +83,7 @@ ScXMLFinalizeEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDoc
     SoDebugError::post("ScXMLFinalizeEltReader::read",
                        "<finalize> contains unexpected <%s> element", elementtype);
     delete finalize;
-    return NULL;
+    return nullptr;
   }
 
   return finalize;
diff --git a/coin4/src/scxml/ScXMLHistoryElt.cpp b/coin4/src/scxml/ScXMLHistoryElt.cpp
index 96be0f2..9949a39 100644
--- a/coin4/src/scxml/ScXMLHistoryElt.cpp
+++ b/coin4/src/scxml/ScXMLHistoryElt.cpp
@@ -71,7 +71,7 @@ ScXMLHistoryEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocu
   // handle XML attributes
   if (unlikely(!history->handleXMLAttributes())) {
     delete history;
-    return NULL;
+    return nullptr;
   }
 
   const int numchildren = cc_xml_elt_get_num_children(xmlelt);
@@ -90,13 +90,13 @@ ScXMLHistoryEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocu
         SoDebugError::post("ScXMLHistoryEltReader::read",
                            "<history> elements can only have one <transition> element");
         delete history;
-        return NULL;
+        return nullptr;
       }
       ScXMLEltReader * transitionreader = ScXMLTransitionElt::getElementReader();
       ScXMLElt * transitionobj = transitionreader->read(history, element, doc, sm);
       if (unlikely(!transitionobj)) {
         delete history;
-        return NULL;
+        return nullptr;
       }
       assert(transitionobj->isOfType(ScXMLTransitionElt::getClassTypeId()));
       history->setTransition(static_cast<ScXMLTransitionElt *>(transitionobj));
@@ -107,7 +107,7 @@ ScXMLHistoryEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocu
                          "unexpected XML element '<%s>' found in <history>",
                          elementtype);
       delete history;
-      return NULL;
+      return nullptr;
     }
   }
 
@@ -118,7 +118,7 @@ ScXMLHistoryEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocu
 
 class ScXMLHistoryElt::PImpl {
 public:
-  PImpl(void) : transitionptr(NULL) { }
+  PImpl(void) : transitionptr(nullptr) { }
 
   boost::scoped_ptr<ScXMLTransitionElt> transitionptr;
 
@@ -143,15 +143,15 @@ ScXMLHistoryElt::cleanClass(void)
 }
 
 ScXMLHistoryElt::ScXMLHistoryElt(void)
-: id(NULL),
-  type(NULL)
+: id(nullptr),
+  type(nullptr)
 {
 }
 
 ScXMLHistoryElt::~ScXMLHistoryElt(void)
 {
-  this->setIdAttribute(NULL);
-  this->setTypeAttribute(NULL);
+  this->setIdAttribute(nullptr);
+  this->setTypeAttribute(nullptr);
 }
 
 void
@@ -218,7 +218,7 @@ ScXMLHistoryElt::search(const char * attrname, const char * attrvalue) const
       return this;
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 SCXML_SINGLE_OBJECT_API_IMPL(ScXMLHistoryElt, ScXMLTransitionElt, PRIVATE(this)->transitionptr, Transition);
diff --git a/coin4/src/scxml/ScXMLIfElt.cpp b/coin4/src/scxml/ScXMLIfElt.cpp
index 3e67d91..be48510 100644
--- a/coin4/src/scxml/ScXMLIfElt.cpp
+++ b/coin4/src/scxml/ScXMLIfElt.cpp
@@ -79,7 +79,7 @@ ScXMLIfEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocument
   // handle XML attributes
   if (unlikely(!ifelt->handleXMLAttributes())) {
     delete ifelt;
-    return NULL;
+    return nullptr;
   }
 
   ScXMLExecutableElt * conditional = ifelt;
@@ -99,13 +99,13 @@ ScXMLIfEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocument
         SoDebugError::post("ScXMLIfEltReader::read",
                            "<if> can not contain <elseif> after and <else> element");
         delete ifelt;
-        return NULL;
+        return nullptr;
       }
       ScXMLEltReader * elseifreader = ScXMLElseIfElt::getElementReader();
       ScXMLElt * elseifelt = elseifreader->read(ifelt, element, doc, sm);
       if (unlikely(!elseifelt)) {
         delete ifelt;
-        return NULL;
+        return nullptr;
       }
       assert(elseifelt->isOfType(ScXMLElseIfElt::getClassTypeId()));
       ifelt->addElseIf(static_cast<ScXMLElseIfElt *>(elseifelt));
@@ -117,13 +117,13 @@ ScXMLIfEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocument
         SoDebugError::post("ScXMLIfEltReader::read",
                            "<if> can not contain multiple <else> elements");
         delete ifelt;
-        return NULL;
+        return nullptr;
       }
       ScXMLEltReader * elsereader = ScXMLElseElt::getElementReader();
       ScXMLElt * elseelt = elsereader->read(ifelt, element, doc, sm);
       if (unlikely(!elseelt)) {
         delete ifelt;
-        return NULL;
+        return nullptr;
       }
       assert(elseelt->isOfType(ScXMLElseElt::getClassTypeId()));
       ifelt->setElse(static_cast<ScXMLElseElt *>(elseelt));
@@ -135,7 +135,7 @@ ScXMLIfEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocument
       ScXMLElt * executableelt = executablereader->read(ifelt, element, doc, sm);
       if (unlikely(!executableelt)) {
         delete ifelt;
-        return NULL;
+        return nullptr;
       }
       assert(executableelt->isOfType(ScXMLIfElt::getClassTypeId()));
       ifelt->addExecutable(conditional, static_cast<ScXMLExecutableElt *>(executableelt));
@@ -145,7 +145,7 @@ ScXMLIfEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocument
       ScXMLElt * executableelt = scriptreader->read(ifelt, element, doc, sm);
       if (unlikely(!executableelt)) {
         delete ifelt;
-        return NULL;
+        return nullptr;
       }
       assert(executableelt->isOfType(ScXMLScriptElt::getClassTypeId()));
       ifelt->addExecutable(conditional, static_cast<ScXMLExecutableElt *>(executableelt));
@@ -155,7 +155,7 @@ ScXMLIfEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocument
       ScXMLElt * executableelt = logreader->read(ifelt, element, doc, sm);
       if (unlikely(!executableelt)) {
         delete ifelt;
-        return NULL;
+        return nullptr;
       }
       assert(executableelt->isOfType(ScXMLLogElt::getClassTypeId()));
       ifelt->addExecutable(conditional, static_cast<ScXMLExecutableElt *>(executableelt));
@@ -165,7 +165,7 @@ ScXMLIfEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocument
       ScXMLElt * executableelt = assignreader->read(ifelt, element, doc, sm);
       if (unlikely(!executableelt)) {
         delete ifelt;
-        return NULL;
+        return nullptr;
       }
       assert(executableelt->isOfType(ScXMLAssignElt::getClassTypeId()));
       ifelt->addExecutable(conditional, static_cast<ScXMLExecutableElt *>(executableelt));
@@ -175,7 +175,7 @@ ScXMLIfEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocument
       ScXMLElt * executableelt = eventreader->read(ifelt, element, doc, sm);
       if (unlikely(!executableelt)) {
         delete ifelt;
-        return NULL;
+        return nullptr;
       }
       assert(executableelt->isOfType(ScXMLEventElt::getClassTypeId()));
       ifelt->addExecutable(conditional, static_cast<ScXMLExecutableElt *>(executableelt));
@@ -185,7 +185,7 @@ ScXMLIfEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocument
       ScXMLElt * executableelt = invokereader->read(ifelt, element, doc, sm);
       if (unlikely(!executableelt)) {
         delete ifelt;
-        return NULL;
+        return nullptr;
       }
       assert(executableelt->isOfType(ScXMLInvokeElt::getClassTypeId()));
       ifelt->addExecutable(conditional, static_cast<ScXMLExecutableElt *>(executableelt));
@@ -195,7 +195,7 @@ ScXMLIfEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocument
       ScXMLElt * executableelt = sendreader->read(ifelt, element, doc, sm);
       if (unlikely(!executableelt)) {
         delete ifelt;
-        return NULL;
+        return nullptr;
       }
       assert(executableelt->isOfType(ScXMLSendElt::getClassTypeId()));
       ifelt->addExecutable(conditional, static_cast<ScXMLExecutableElt *>(executableelt));
@@ -205,7 +205,7 @@ ScXMLIfEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocument
       ScXMLElt * executableelt = validatereader->read(ifelt, element, doc, sm);
       if (unlikely(!executableelt)) {
         delete ifelt;
-        return NULL;
+        return nullptr;
       }
       assert(executableelt->isOfType(ScXMLValidateElt::getClassTypeId()));
       ifelt->addExecutable(conditional, static_cast<ScXMLExecutableElt *>(executableelt));
@@ -215,7 +215,7 @@ ScXMLIfEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocument
       SoDebugError::post("ScXMLIfEltReader::read",
                          "<if> contains unexpected <%s> element", elementtype);
       delete ifelt;
-      return NULL;
+      return nullptr;
     }
   }
 
@@ -226,7 +226,7 @@ ScXMLIfEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocument
 
 class ScXMLIfElt::PImpl {
 public:
-  PImpl(void) : pub(NULL), elseelt(NULL)
+  PImpl(void) : pub(nullptr), elseelt(nullptr)
   {
   }
 
@@ -272,9 +272,9 @@ void
 ScXMLIfElt::PImpl::assureArrayForIdx(int idx)
 {
   while (int(this->executables.size()) < idx) {
-    this->executables.push_back(NULL);
+    this->executables.push_back(nullptr);
   }
-  if (this->executables.at(idx) == NULL) {
+  if (this->executables.at(idx) == nullptr) {
     this->executables.at(idx) = new std::vector<ScXMLExecutableElt *>;
   }
 }
@@ -285,7 +285,7 @@ ScXMLIfElt::PImpl::getArrayForIdx(int idx) const
   if (idx < int(this->executables.size())) {
     return this->executables.at(idx);
   }
-  return NULL;
+  return nullptr;
 }
 
 #undef PUBLIC
@@ -308,14 +308,14 @@ ScXMLIfElt::cleanClass(void)
 }
 
 ScXMLIfElt::ScXMLIfElt(void)
-: cond(NULL)
+: cond(nullptr)
 {
   pimpl->pub = this;
 }
 
 ScXMLIfElt::~ScXMLIfElt(void)
 {
-  this->setCondAttribute(NULL);
+  this->setCondAttribute(nullptr);
 }
 
 void
@@ -403,7 +403,7 @@ ScXMLIfElt::search(const char * attrname, const char * attrvalue) const
       return hit;
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 void
@@ -412,8 +412,8 @@ ScXMLIfElt::execute(ScXMLStateMachine * statemachine) const
   ScXMLEvaluator * evaluator = statemachine->getEvaluator();
   assert(evaluator);
 
-  ScXMLDataObj * res = NULL;
-  ScXMLBoolDataObj * boolres = NULL;
+  ScXMLDataObj * res = nullptr;
+  ScXMLBoolDataObj * boolres = nullptr;
   res = evaluator->evaluate(this->getCondAttribute());
   if (res) {
     if (res->isOfType(ScXMLBoolDataObj::getClassTypeId())) {
@@ -496,16 +496,16 @@ ScXMLIfElt::getExecutable(const ScXMLExecutableElt * conditional, int idx) const
   int condidx = PRIVATE(this)->findIdx(conditional);
   if (unlikely(condidx == -1)) {
     assert(0 && "given conditional not found");
-    return NULL;
+    return nullptr;
   }
   std::vector<ScXMLExecutableElt *> * array = PRIVATE(this)->getArrayForIdx(condidx);
   if (unlikely(!array)) {
     assert(0 && "given conditional has no executables");
-    return NULL;
+    return nullptr;
   }
   if (unlikely(idx >= int(array->size()))) {
     assert(0 && "given idx too large for given conditional");
-    return NULL;
+    return nullptr;
   }
   return array->at(idx);
 }
@@ -562,7 +562,7 @@ ScXMLIfElt::clearAllExecutables(ScXMLExecutableElt * conditional)
     delete array->at(idx);
   }
   delete array;
-  PRIVATE(this)->executables.at(condidx) = NULL;
+  PRIVATE(this)->executables.at(condidx) = nullptr;
 }
 
 #undef PRIVATE
diff --git a/coin4/src/scxml/ScXMLInitialElt.cpp b/coin4/src/scxml/ScXMLInitialElt.cpp
index a13f888..17c057e 100644
--- a/coin4/src/scxml/ScXMLInitialElt.cpp
+++ b/coin4/src/scxml/ScXMLInitialElt.cpp
@@ -71,7 +71,7 @@ ScXMLInitialEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocu
   // handle XML attributes
   if (unlikely(!initial->handleXMLAttributes())) {
     delete initial;
-    return NULL;
+    return nullptr;
   }
 
   const int numchildren = cc_xml_elt_get_num_children(xmlelt);
@@ -90,14 +90,14 @@ ScXMLInitialEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocu
         SoDebugError::post("ScXMLInitialEltReader::read",
                            "<initial> can only contain one <transition> element");
         delete initial;
-        return NULL;
+        return nullptr;
       }
       ScXMLEltReader * transitionreader = ScXMLTransitionElt::getElementReader();
       assert(transitionreader);
       ScXMLElt * transitionobj = transitionreader->read(initial, element, doc, sm);
       if (unlikely(!transitionobj)) {
         delete initial;
-        return NULL;
+        return nullptr;
       }
 
       assert(transitionobj->isOfType(ScXMLTransitionElt::getClassTypeId()));
@@ -107,7 +107,7 @@ ScXMLInitialEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocu
                            "<initial> must contain a conditionless <transition> element");
         delete transitionelt;
         delete initial;
-        return NULL;
+        return nullptr;
       }
       initial->setTransition(transitionelt);
     }
@@ -117,7 +117,7 @@ ScXMLInitialEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocu
                          "unexpected XML element '<%s>' found in <initial>",
                          elementtype);
       delete initial;
-      return NULL;
+      return nullptr;
     }
   }
 
@@ -128,7 +128,7 @@ ScXMLInitialEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocu
 
 class ScXMLInitialElt::PImpl {
 public:
-  PImpl(void) : transitionptr(NULL) { }
+  PImpl(void) : transitionptr(nullptr) { }
 
   boost::scoped_ptr<ScXMLTransitionElt> transitionptr;
 };
@@ -184,7 +184,7 @@ ScXMLInitialElt::search(const char * attrname, const char * attrvalue) const
       return hit;
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 SCXML_SINGLE_OBJECT_API_IMPL(ScXMLInitialElt, ScXMLTransitionElt, PRIVATE(this)->transitionptr, Transition);
diff --git a/coin4/src/scxml/ScXMLInvokeElt.cpp b/coin4/src/scxml/ScXMLInvokeElt.cpp
index 4040d03..09ef4f6 100644
--- a/coin4/src/scxml/ScXMLInvokeElt.cpp
+++ b/coin4/src/scxml/ScXMLInvokeElt.cpp
@@ -90,7 +90,7 @@ ScXMLInvokeEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
   // handle XML attributes
   if (unlikely(!invoke->handleXMLAttributes())) {
     delete invoke;
-    return NULL;
+    return nullptr;
   }
 
   const int numchildren = cc_xml_elt_get_num_children(xmlelt);
@@ -110,7 +110,7 @@ ScXMLInvokeEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
       ScXMLElt * paramobj = paramreader->read(invoke, element, doc, sm);
       if (unlikely(!paramobj)) {
         delete invoke;
-        return NULL;
+        return nullptr;
       }
 
       assert(paramobj->isOfType(ScXMLParamElt::getClassTypeId()));
@@ -123,7 +123,7 @@ ScXMLInvokeEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
         SoDebugError::post("ScXMLInvokeEltReader::read",
                            "<invoke> elements can only have one <finalize> child");
         delete invoke;
-        return NULL;
+        return nullptr;
       }
 
       ScXMLEltReader * finalizereader = ScXMLFinalizeElt::getElementReader();
@@ -131,7 +131,7 @@ ScXMLInvokeEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
       ScXMLElt * finalizeobj = finalizereader->read(invoke, element, doc, sm);
       if (unlikely(!finalizeobj)) {
         delete invoke;
-        return NULL;
+        return nullptr;
       }
 
       assert(finalizeobj->isOfType(ScXMLFinalizeElt::getClassTypeId()));
@@ -144,7 +144,7 @@ ScXMLInvokeEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
         SoDebugError::post("ScXMLInvokeEltReader::read",
                            "<invoke> elements can only have one <content> child");
         delete invoke;
-        return NULL;
+        return nullptr;
       }
 
       ScXMLEltReader * contentreader = ScXMLContentElt::getElementReader();
@@ -152,7 +152,7 @@ ScXMLInvokeEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
       ScXMLElt * contentobj = contentreader->read(invoke, element, doc, sm);
       if (unlikely(!contentobj)) {
         delete invoke;
-        return NULL;
+        return nullptr;
       }
 
       assert(contentobj->isOfType(ScXMLContentElt::getClassTypeId()));
@@ -163,7 +163,7 @@ ScXMLInvokeEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
     SoDebugError::post("ScXMLInvokeEltReader::read",
                        "<invoke> contains unexpected <%s> element", elementtype);
     delete invoke;
-    return NULL;
+    return nullptr;
    }
 
 
@@ -174,7 +174,7 @@ ScXMLInvokeEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
 
 class ScXMLInvokeElt::PImpl {
 public:
-  PImpl(void) : finalizeptr(NULL), contentptr(NULL) { }
+  PImpl(void) : finalizeptr(nullptr), contentptr(nullptr) { }
   ~PImpl(void)
   {
     SCXML__CLEAR_STD_VECTOR(this->paramlist, ScXMLParamElt *);
@@ -204,17 +204,17 @@ ScXMLInvokeElt::cleanClass(void)
 }
 
 ScXMLInvokeElt::ScXMLInvokeElt(void)
-: targettype(NULL),
-  src(NULL),
-  srcexpr(NULL)
+: targettype(nullptr),
+  src(nullptr),
+  srcexpr(nullptr)
 {
 }
 
 ScXMLInvokeElt::~ScXMLInvokeElt(void)
 {
-  this->setTargetTypeAttribute(NULL);
-  this->setSrcAttribute(NULL);
-  this->setSrcExprAttribute(NULL);
+  this->setTargetTypeAttribute(nullptr);
+  this->setSrcAttribute(nullptr);
+  this->setSrcExprAttribute(nullptr);
 }
 
 void
@@ -333,7 +333,7 @@ ScXMLInvokeElt::search(const char * attrname, const char * attrvalue) const
     }
   }
 
-  return NULL;
+  return nullptr;
 }
 
 SCXML_LIST_OBJECT_API_IMPL(ScXMLInvokeElt, ScXMLParamElt, PRIVATE(this)->paramlist, Param, Params);
diff --git a/coin4/src/scxml/ScXMLLogElt.cpp b/coin4/src/scxml/ScXMLLogElt.cpp
index 45025b6..25754b1 100644
--- a/coin4/src/scxml/ScXMLLogElt.cpp
+++ b/coin4/src/scxml/ScXMLLogElt.cpp
@@ -70,7 +70,7 @@ ScXMLLogEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocument
   // handle XML attributes
   if (unlikely(!log->handleXMLAttributes())) {
     delete log;
-    return NULL;
+    return nullptr;
   }
 
   const int numchildren = cc_xml_elt_get_num_children(xmlelt);
@@ -86,7 +86,7 @@ ScXMLLogEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocument
     SoDebugError::post("ScXMLElseEltReader::read",
                        "<log> contains unexpected <%s> element", elementtype);
     delete log;
-    return NULL;
+    return nullptr;
   }
 
   return log;
@@ -116,17 +116,17 @@ ScXMLLogElt::cleanClass(void)
 }
 
 ScXMLLogElt::ScXMLLogElt(void)
-: label(NULL),
-  expr(NULL),
-  level(NULL)
+: label(nullptr),
+  expr(nullptr),
+  level(nullptr)
 {
 }
 
 ScXMLLogElt::~ScXMLLogElt(void)
 {
-  this->setLabelAttribute(NULL);
-  this->setExprAttribute(NULL);
-  this->setLevelAttribute(NULL);
+  this->setLabelAttribute(nullptr);
+  this->setExprAttribute(nullptr);
+  this->setLevelAttribute(nullptr);
 }
 
 void
@@ -199,7 +199,7 @@ ScXMLLogElt::search(const char * attrname, const char * attrvalue) const
       return this;
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 void
diff --git a/coin4/src/scxml/ScXMLMinimumEvaluator.cpp b/coin4/src/scxml/ScXMLMinimumEvaluator.cpp
index 94a04f9..b48714c 100644
--- a/coin4/src/scxml/ScXMLMinimumEvaluator.cpp
+++ b/coin4/src/scxml/ScXMLMinimumEvaluator.cpp
@@ -119,12 +119,12 @@ ScXMLMinimumEvaluator::setAtLocation(const char * COIN_UNUSED_ARG(location), ScX
 }
 
 /*!
-  Returns NULL. The minimum profile does not implement the data module.
+  Returns nullptr. The minimum profile does not implement the data module.
 */
 ScXMLDataObj *
 ScXMLMinimumEvaluator::locate(const char * COIN_UNUSED_ARG(location)) const
 {
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -175,12 +175,12 @@ ScXMLInExprDataObj::createFor(const char * stateid)
 }
 
 ScXMLInExprDataObj::ScXMLInExprDataObj(void)
-: stateid(NULL)
+: stateid(nullptr)
 {
 }
 
 ScXMLInExprDataObj::ScXMLInExprDataObj(const char * stateidstr)
-: stateid(NULL)
+: stateid(nullptr)
 {
   this->setStateId(stateidstr);
 }
@@ -194,7 +194,7 @@ ScXMLInExprDataObj::setStateId(const char * stateidstr)
 {
   if (this->stateid) {
     delete [] this->stateid;
-    this->stateid = NULL;
+    this->stateid = nullptr;
   }
   if (stateidstr) {
     this->stateid = new char [strlen(stateidstr) + 1];
@@ -206,7 +206,7 @@ bool
 ScXMLInExprDataObj::evaluateNow(ScXMLStateMachine * sm, ScXMLDataObj *& pointer) const
 {
   assert(sm);
-  assert(pointer == NULL);
+  assert(pointer == nullptr);
   if (this->stateid) {
     sm->queueInternalEvent("error.eval.minimum.In.NO_STATE");
     return false;
@@ -259,7 +259,7 @@ ScXMLAppendOpExprDataObj::createFor(ScXMLDataObj * lhs, ScXMLDataObj * rhs)
 }
 
 ScXMLAppendOpExprDataObj::ScXMLAppendOpExprDataObj(void)
-: lhs(NULL), rhs(NULL)
+: lhs(nullptr), rhs(nullptr)
 {
 }
 
@@ -272,11 +272,11 @@ ScXMLAppendOpExprDataObj::~ScXMLAppendOpExprDataObj(void)
 {
   if (this->lhs) {
     delete this->lhs;
-    this->lhs = NULL;
+    this->lhs = nullptr;
   }
   if (this->rhs) {
     delete this->rhs;
-    this->rhs = NULL;
+    this->rhs = nullptr;
   }
 }
 
@@ -296,7 +296,7 @@ bool
 ScXMLAppendOpExprDataObj::evaluateNow(ScXMLStateMachine * sm, ScXMLDataObj *& pointer) const
 {
   assert(this->lhs && this->rhs);
-  ScXMLStringDataObj * lhsevaled = NULL, * rhsevaled = NULL;
+  ScXMLStringDataObj * lhsevaled = nullptr, * rhsevaled = nullptr;
 
   if (this->lhs->isOfType(ScXMLExprDataObj::getClassTypeId())) {
     ScXMLExprDataObj * lhsexpr = static_cast<ScXMLExprDataObj *>(this->lhs);
@@ -367,8 +367,8 @@ BOOST_AUTO_TEST_CASE(MimimumExpressions)
   boost::scoped_ptr<ScXMLStateMachine> sm(new ScXMLStateMachine);
   boost::scoped_ptr<ScXMLEvaluator> evaluator(new ScXMLMinimumEvaluator);
 
-  ScXMLDataObj * res = NULL;
-  ScXMLBoolDataObj * boolobj = NULL;
+  ScXMLDataObj * res = nullptr;
+  ScXMLBoolDataObj * boolobj = nullptr;
 
   //FIXME, this test is not finished. BFG 20090831
 
diff --git a/coin4/src/scxml/ScXMLObject.cpp b/coin4/src/scxml/ScXMLObject.cpp
index 06e8b19..3c8ef95 100644
--- a/coin4/src/scxml/ScXMLObject.cpp
+++ b/coin4/src/scxml/ScXMLObject.cpp
@@ -109,13 +109,13 @@ ScXMLObject::cleanClass(void)
 }
 
 ScXMLObject::ScXMLObject(void)
-: containerptr(NULL)
+: containerptr(nullptr)
 {
 }
 
 ScXMLObject::~ScXMLObject(void)
 {
-  this->containerptr = NULL;
+  this->containerptr = nullptr;
 }
 
 /*!
diff --git a/coin4/src/scxml/ScXMLOnEntryElt.cpp b/coin4/src/scxml/ScXMLOnEntryElt.cpp
index 137b7e2..431f800 100644
--- a/coin4/src/scxml/ScXMLOnEntryElt.cpp
+++ b/coin4/src/scxml/ScXMLOnEntryElt.cpp
@@ -72,7 +72,7 @@ ScXMLOnEntryEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocu
   // handle XML attributes
   if (unlikely(!onentry->handleXMLAttributes())) {
     delete onentry;
-    return NULL;
+    return nullptr;
   }
 
   const int numchildren = cc_xml_elt_get_num_children(xmlelt);
@@ -92,7 +92,7 @@ ScXMLOnEntryEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocu
       ScXMLElt * logobj = logreader->read(onentry, element, doc, sm);
       if (unlikely(!logobj)) {
         delete onentry;
-        return NULL;
+        return nullptr;
       }
       assert(logobj->isOfType(ScXMLLogElt::getClassTypeId()));
       onentry->addExecutable(static_cast<ScXMLLogElt *>(logobj));
@@ -104,7 +104,7 @@ ScXMLOnEntryEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocu
       ScXMLElt * eventobj = eventreader->read(onentry, element, doc, sm);
       if (unlikely(!eventobj)) {
         delete onentry;
-        return NULL;
+        return nullptr;
       }
       assert(eventobj->isOfType(ScXMLEventElt::getClassTypeId()));
       onentry->addExecutable(static_cast<ScXMLEventElt *>(eventobj));
@@ -116,7 +116,7 @@ ScXMLOnEntryEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocu
       ScXMLElt * assignobj = assignreader->read(onentry, element, doc, sm);
       if (unlikely(!assignobj)) {
         delete onentry;
-        return NULL;
+        return nullptr;
       }
       assert(assignobj->isOfType(ScXMLAssignElt::getClassTypeId()));
       onentry->addExecutable(static_cast<ScXMLAssignElt *>(assignobj));
@@ -128,7 +128,7 @@ ScXMLOnEntryEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocu
       ScXMLElt * sendobj = sendreader->read(onentry, element, doc, sm);
       if (unlikely(!sendobj)) {
         delete onentry;
-        return NULL;
+        return nullptr;
       }
       assert(sendobj->isOfType(ScXMLSendElt::getClassTypeId()));
       onentry->addExecutable(static_cast<ScXMLSendElt *>(sendobj));
@@ -140,7 +140,7 @@ ScXMLOnEntryEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocu
       ScXMLElt * ifobj = ifreader->read(onentry, element, doc, sm);
       if (unlikely(!ifobj)) {
         delete onentry;
-        return NULL;
+        return nullptr;
       }
       assert(ifobj->isOfType(ScXMLIfElt::getClassTypeId()));
       onentry->addExecutable(static_cast<ScXMLIfElt *>(ifobj));
@@ -152,7 +152,7 @@ ScXMLOnEntryEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocu
       ScXMLElt * scriptobj = scriptreader->read(onentry, element, doc, sm);
       if (unlikely(!scriptobj)) {
         delete onentry;
-        return NULL;
+        return nullptr;
       }
       assert(scriptobj->isOfType(ScXMLScriptElt::getClassTypeId()));
       onentry->addExecutable(static_cast<ScXMLScriptElt *>(scriptobj));
@@ -164,7 +164,7 @@ ScXMLOnEntryEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocu
       ScXMLElt * invokeobj = invokereader->read(onentry, element, doc, sm);
       if (unlikely(!invokeobj)) {
         delete onentry;
-        return NULL;
+        return nullptr;
       }
       assert(invokeobj->isOfType(ScXMLInvokeElt::getClassTypeId()));
       onentry->addExecutable(static_cast<ScXMLInvokeElt *>(invokeobj));
@@ -174,7 +174,7 @@ ScXMLOnEntryEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocu
                          "unexpected XML element '<%s>' found in <onentry>",
                          elementtype);
       delete onentry;
-      return NULL;
+      return nullptr;
     }
   }
   return onentry;
@@ -237,7 +237,7 @@ ScXMLOnEntryElt::search(const char * attrname, const char * attrvalue) const
   if (hit) {
     return hit;
   }
-  return NULL;
+  return nullptr;
 }
 
 // executable content
diff --git a/coin4/src/scxml/ScXMLOnExitElt.cpp b/coin4/src/scxml/ScXMLOnExitElt.cpp
index f897105..3f702d2 100644
--- a/coin4/src/scxml/ScXMLOnExitElt.cpp
+++ b/coin4/src/scxml/ScXMLOnExitElt.cpp
@@ -72,7 +72,7 @@ ScXMLOnExitEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
   // handle XML attributes
   if (unlikely(!onexit->handleXMLAttributes())) {
     delete onexit;
-    return NULL;
+    return nullptr;
   }
 
   const int numchildren = cc_xml_elt_get_num_children(xmlelt);
@@ -92,7 +92,7 @@ ScXMLOnExitEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
       ScXMLElt * logobj = logreader->read(onexit, element, doc, sm);
       if (unlikely(!logobj)) {
         delete onexit;
-        return NULL;
+        return nullptr;
       }
       assert(logobj->isOfType(ScXMLLogElt::getClassTypeId()));
       onexit->addExecutable(static_cast<ScXMLLogElt *>(logobj));
@@ -104,7 +104,7 @@ ScXMLOnExitEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
       ScXMLElt * eventobj = eventreader->read(onexit, element, doc, sm);
       if (unlikely(!eventobj)) {
         delete onexit;
-        return NULL;
+        return nullptr;
       }
       assert(eventobj->isOfType(ScXMLEventElt::getClassTypeId()));
       onexit->addExecutable(static_cast<ScXMLEventElt *>(eventobj));
@@ -116,7 +116,7 @@ ScXMLOnExitEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
       ScXMLElt * assignobj = assignreader->read(onexit, element, doc, sm);
       if (unlikely(!assignobj)) {
         delete onexit;
-        return NULL;
+        return nullptr;
       }
       assert(assignobj->isOfType(ScXMLAssignElt::getClassTypeId()));
       onexit->addExecutable(static_cast<ScXMLAssignElt *>(assignobj));
@@ -128,7 +128,7 @@ ScXMLOnExitEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
       ScXMLElt * sendobj = sendreader->read(onexit, element, doc, sm);
       if (unlikely(!sendobj)) {
         delete onexit;
-        return NULL;
+        return nullptr;
       }
       assert(sendobj->isOfType(ScXMLSendElt::getClassTypeId()));
       onexit->addExecutable(static_cast<ScXMLSendElt *>(sendobj));
@@ -140,7 +140,7 @@ ScXMLOnExitEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
       ScXMLElt * ifobj = ifreader->read(onexit, element, doc, sm);
       if (unlikely(!ifobj)) {
         delete onexit;
-        return NULL;
+        return nullptr;
       }
       assert(ifobj->isOfType(ScXMLIfElt::getClassTypeId()));
       onexit->addExecutable(static_cast<ScXMLIfElt *>(ifobj));
@@ -152,7 +152,7 @@ ScXMLOnExitEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
       ScXMLElt * scriptobj = scriptreader->read(onexit, element, doc, sm);
       if (unlikely(!scriptobj)) {
         delete onexit;
-        return NULL;
+        return nullptr;
       }
       assert(scriptobj->isOfType(ScXMLScriptElt::getClassTypeId()));
       onexit->addExecutable(static_cast<ScXMLScriptElt *>(scriptobj));
@@ -164,7 +164,7 @@ ScXMLOnExitEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
       ScXMLElt * invokeobj = invokereader->read(onexit, element, doc, sm);
       if (unlikely(!invokeobj)) {
         delete onexit;
-        return NULL;
+        return nullptr;
       }
       assert(invokeobj->isOfType(ScXMLInvokeElt::getClassTypeId()));
       onexit->addExecutable(static_cast<ScXMLInvokeElt *>(invokeobj));
@@ -174,7 +174,7 @@ ScXMLOnExitEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
                          "unexpected XML element '<%s>' found in <onexit>",
                          elementtype);
       delete onexit;
-      return NULL;
+      return nullptr;
     }
   }
   return onexit;
@@ -237,7 +237,7 @@ ScXMLOnExitElt::search(const char * attrname, const char * attrvalue) const
   if (hit) {
     return hit;
   }
-  return NULL;
+  return nullptr;
 }
 
 // *************************************************************************
diff --git a/coin4/src/scxml/ScXMLParallelElt.cpp b/coin4/src/scxml/ScXMLParallelElt.cpp
index a1bcd9e..1c75d8f 100644
--- a/coin4/src/scxml/ScXMLParallelElt.cpp
+++ b/coin4/src/scxml/ScXMLParallelElt.cpp
@@ -100,11 +100,11 @@ ScXMLParallelEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDoc
     SoDebugError::post("ScXMLParallelEltReader::read",
                        "invalid XML attributes");
     delete parallel;
-    return NULL;
+    return nullptr;
   }
 
   const char * extref = parallel->getSrcAttribute();
-  if ((extref != NULL) && (extref[0] != '\0')) {
+  if ((extref != nullptr) && (extref[0] != '\0')) {
     SbString reference(extref);
     char * eltnameref = const_cast<char *>(strchr(reference.getString(), '#'));
     if (eltnameref) {
@@ -296,13 +296,13 @@ ScXMLParallelEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDoc
         SoDebugError::post("ScXMLParallelEltReader::read",
                            "<parallel> elements can only have one <onentry> element");
         delete parallel;
-        return NULL;
+        return nullptr;
       }
       ScXMLEltReader * onentryreader = ScXMLOnEntryElt::getElementReader();
       ScXMLElt * onentryobj = onentryreader->read(parallel, element, doc, sm);
       if (unlikely(!onentryobj)) {
         delete parallel;
-        return NULL;
+        return nullptr;
       }
       assert(onentryobj->isOfType(ScXMLOnEntryElt::getClassTypeId()));
       parallel->setOnEntry(static_cast<ScXMLOnEntryElt *>(onentryobj));
@@ -314,13 +314,13 @@ ScXMLParallelEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDoc
         SoDebugError::post("ScXMLParallelEltReader::read",
                            "<parallel> elements can only have one <onexit> element");
         delete parallel;
-        return NULL;
+        return nullptr;
       }
       ScXMLEltReader * onexitreader = ScXMLOnExitElt::getElementReader();
       ScXMLElt * onexitobj = onexitreader->read(parallel, element, doc, sm);
       if (unlikely(!onexitobj)) {
         delete parallel;
-        return NULL;
+        return nullptr;
       }
       assert(onexitobj->isOfType(ScXMLOnExitElt::getClassTypeId()));
       parallel->setOnExit(static_cast<ScXMLOnExitElt *>(onexitobj));
@@ -332,7 +332,7 @@ ScXMLParallelEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDoc
       ScXMLElt * transitionobj = transitionreader->read(parallel, element, doc, sm);
       if (unlikely(!transitionobj)) {
         delete parallel;
-        return NULL;
+        return nullptr;
       }
       assert(transitionobj->isOfType(ScXMLTransitionElt::getClassTypeId()));
       parallel->addTransition(static_cast<ScXMLTransitionElt *>(transitionobj));
@@ -344,13 +344,13 @@ ScXMLParallelEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDoc
         SoDebugError::post("ScXMLInitialEltReader::read",
                            "<parallel> elements can contain only one <initial> element");
         delete parallel;
-        return NULL;
+        return nullptr;
       }
       ScXMLEltReader * initialreader = ScXMLInitialElt::getElementReader();
       ScXMLElt * initialobj = initialreader->read(parallel, element, doc, sm);
       if (unlikely(!initialobj)) {
         delete parallel;
-        return NULL;
+        return nullptr;
       }
       assert(initialobj->isOfType(ScXMLInitialElt::getClassTypeId()));
       parallel->setInitial(static_cast<ScXMLInitialElt *>(initialobj));
@@ -362,7 +362,7 @@ ScXMLParallelEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDoc
       ScXMLElt * stateobj = statereader->read(parallel, element, doc, sm);
       if (unlikely(!stateobj)) {
         delete parallel;
-        return NULL;
+        return nullptr;
       }
       assert(stateobj->isOfType(ScXMLStateElt::getClassTypeId()));
       parallel->addState(static_cast<ScXMLStateElt *>(stateobj));
@@ -374,7 +374,7 @@ ScXMLParallelEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDoc
       ScXMLElt * parallelobj = parallelreader->read(parallel, element, doc, sm);
       if (unlikely(!parallelobj)) {
         delete parallel;
-        return NULL;
+        return nullptr;
       }
       assert(parallelobj->isOfType(ScXMLParallelElt::getClassTypeId()));
       parallel->addParallel(static_cast<ScXMLParallelElt *>(parallelobj));
@@ -386,7 +386,7 @@ ScXMLParallelEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDoc
       ScXMLElt * finalobj = finalreader->read(parallel, element, doc, sm);
       if (unlikely(!finalobj)) {
         delete parallel;
-        return NULL;
+        return nullptr;
       }
       assert(finalobj->isOfType(ScXMLFinalElt::getClassTypeId()));
       parallel->addFinal(static_cast<ScXMLFinalElt *>(finalobj));
@@ -398,7 +398,7 @@ ScXMLParallelEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDoc
       ScXMLElt * historyobj = historyreader->read(parallel, element, doc, sm);
       if (unlikely(!historyobj)) {
         delete parallel;
-        return NULL;
+        return nullptr;
       }
       assert(historyobj->isOfType(ScXMLHistoryElt::getClassTypeId()));
       parallel->addHistory(static_cast<ScXMLHistoryElt *>(historyobj));
@@ -410,7 +410,7 @@ ScXMLParallelEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDoc
       ScXMLElt * anchorobj = anchorreader->read(parallel, element, doc, sm);
       if (unlikely(!anchorobj)) {
         delete parallel;
-        return NULL;
+        return nullptr;
       }
       assert(anchorobj->isOfType(ScXMLAnchorElt::getClassTypeId()));
       parallel->addAnchor(static_cast<ScXMLAnchorElt *>(anchorobj));
@@ -422,13 +422,13 @@ ScXMLParallelEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDoc
         SoDebugError::post("ScXMLParallelEltReader::read",
                            "<parallel> elements can only have one <datamodel> element");
         delete parallel;
-        return NULL;
+        return nullptr;
       }
       ScXMLEltReader * datamodelreader = ScXMLDataModelElt::getElementReader();
       ScXMLElt * datamodelobj = datamodelreader->read(parallel, element, doc, sm);
       if (unlikely(!datamodelobj)) {
         delete parallel;
-        return NULL;
+        return nullptr;
       }
       assert(datamodelobj->isOfType(ScXMLDataModelElt::getClassTypeId()));
       parallel->setDataModel(static_cast<ScXMLDataModelElt *>(datamodelobj));
@@ -445,7 +445,7 @@ ScXMLParallelEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDoc
       } else {
         SoDebugError::post("ScXML::readFile", "error reading <%s> element", elementtype);
         delete state;
-        return NULL;
+        return nullptr;
       }
     }
 #endif
@@ -455,7 +455,7 @@ ScXMLParallelEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDoc
                          "unexpected XML element '<%s>' found in <parallel>",
                          elementtype);
       delete parallel;
-      return NULL;
+      return nullptr;
     }
   }
 
@@ -467,12 +467,12 @@ ScXMLParallelEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDoc
 class ScXMLParallelElt::PImpl {
 public:
   PImpl(void)
-  : onentryptr(NULL),
-    onexitptr(NULL),
-    initialptr(NULL),
-    datamodelptr(NULL),
-    invokeptr(NULL)
-    //srcref(NULL)
+  : onentryptr(nullptr),
+    onexitptr(nullptr),
+    initialptr(nullptr),
+    datamodelptr(nullptr),
+    invokeptr(nullptr)
+    //srcref(nullptr)
   {
   }
 
@@ -523,13 +523,13 @@ ScXMLParallelElt::cleanClass(void)
 }
 
 ScXMLParallelElt::ScXMLParallelElt(void)
-: src(NULL)
+: src(nullptr)
 {
 }
 
 ScXMLParallelElt::~ScXMLParallelElt(void)
 {
-  this->setSrcAttribute(NULL);
+  this->setSrcAttribute(nullptr);
 }
 
 void
@@ -539,7 +539,7 @@ ScXMLParallelElt::setSrcAttribute(const char * srcstr)
     // FIXME: remove externally sources states?
   }
   SCXML__SET_ATTRIBUTE_VALUE(this->src, "src", srcstr);
-  if ((this->src != NULL) && (strcmp(this->src, "") != 0)) {
+  if ((this->src != nullptr) && (strcmp(this->src, "") != 0)) {
     // FIXME: scan string for #
     // FIXME: load externally referenced states
   }
@@ -715,7 +715,7 @@ ScXMLParallelElt::search(const char * attrname, const char * attrvalue) const
       return hit;
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 SCXML_SINGLE_OBJECT_API_IMPL(ScXMLParallelElt, ScXMLOnEntryElt, PRIVATE(this)->onentryptr, OnEntry);
@@ -749,7 +749,7 @@ ScXMLParallelElt::isAtomicState(void) const
 {
   return ((PRIVATE(this)->statelist.size() == 0) &&
           (PRIVATE(this)->parallellist.size() == 0) &&
-          (PRIVATE(this)->invokeptr.get() != NULL));
+          (PRIVATE(this)->invokeptr.get() != nullptr));
 }
 
 #undef PRIVATE
diff --git a/coin4/src/scxml/ScXMLParamElt.cpp b/coin4/src/scxml/ScXMLParamElt.cpp
index 04877d1..6b0817c 100644
--- a/coin4/src/scxml/ScXMLParamElt.cpp
+++ b/coin4/src/scxml/ScXMLParamElt.cpp
@@ -67,7 +67,7 @@ ScXMLParamEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
   // handle XML attributes
   if (unlikely(!param->handleXMLAttributes())) {
     delete param;
-    return NULL;
+    return nullptr;
   }
 
   const int numchildren = cc_xml_elt_get_num_children(xmlelt);
@@ -83,7 +83,7 @@ ScXMLParamEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
     SoDebugError::post("ScXMLParamEltReader::read",
                        "<param> contains unexpected <%s> element", elementtype);
     delete param;
-    return NULL;
+    return nullptr;
    }
 
   return param;
@@ -113,15 +113,15 @@ ScXMLParamElt::cleanClass(void)
 }
 
 ScXMLParamElt::ScXMLParamElt(void)
-: name(NULL),
-  expr(NULL)
+: name(nullptr),
+  expr(nullptr)
 {
 }
 
 ScXMLParamElt::~ScXMLParamElt(void)
 {
-  this->setNameAttribute(NULL);
-  this->setExprAttribute(NULL);
+  this->setNameAttribute(nullptr);
+  this->setExprAttribute(nullptr);
 }
 
 void
@@ -179,7 +179,7 @@ ScXMLParamElt::search(const char * attrname, const char * attrvalue) const
       return this;
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 #undef PRIVATE
diff --git a/coin4/src/scxml/ScXMLScriptElt.cpp b/coin4/src/scxml/ScXMLScriptElt.cpp
index 994940d..c5544cc 100644
--- a/coin4/src/scxml/ScXMLScriptElt.cpp
+++ b/coin4/src/scxml/ScXMLScriptElt.cpp
@@ -68,7 +68,7 @@ ScXMLScriptEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
   // handle XML attributes
   if (unlikely(!script->handleXMLAttributes())) {
     delete script;
-    return NULL;
+    return nullptr;
   }
 
   const int numchildren = cc_xml_elt_get_num_children(xmlelt);
@@ -84,7 +84,7 @@ ScXMLScriptEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocum
     SoDebugError::post("ScXMLScriptEltReader::read",
                        "<script> contains unexpected <%s> element", elementtype);
     delete script;
-    return NULL;
+    return nullptr;
    }
 
   return script;
diff --git a/coin4/src/scxml/ScXMLScxmlElt.cpp b/coin4/src/scxml/ScXMLScxmlElt.cpp
index d6139e3..3e78d6a 100644
--- a/coin4/src/scxml/ScXMLScxmlElt.cpp
+++ b/coin4/src/scxml/ScXMLScxmlElt.cpp
@@ -100,7 +100,7 @@ ScXMLScxmlEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
     SoDebugError::post("ScXMLScxmlEltReader::read",
                        "error: invalid XML attributes");
     delete scxml;
-    return NULL;
+    return nullptr;
   }
 
 #if 0
@@ -139,14 +139,14 @@ ScXMLScxmlEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
         SoDebugError::post("ScXMLScxmlEltReader::read",
                            "<scxml> can only contain one <initial> element");
         delete scxml;
-        return NULL;
+        return nullptr;
       }
       ScXMLEltReader * initialreader = ScXMLInitialElt::getElementReader();
       assert(initialreader);
       ScXMLElt * initialobj = initialreader->read(scxml, element, doc, sm);
       if (unlikely(!initialobj)) {
         delete scxml;
-        return NULL;
+        return nullptr;
       }
       assert(initialobj->isOfType(ScXMLInitialElt::getClassTypeId()));
       scxml->setInitial(static_cast<ScXMLInitialElt *>(initialobj));
@@ -159,7 +159,7 @@ ScXMLScxmlEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
       ScXMLElt * stateobj = statereader->read(scxml, element, doc, sm);
       if (unlikely(!stateobj)) {
         delete scxml;
-        return NULL;
+        return nullptr;
       }
       assert(stateobj->isOfType(ScXMLStateElt::getClassTypeId()));
       scxml->addState(static_cast<ScXMLStateElt *>(stateobj));
@@ -172,7 +172,7 @@ ScXMLScxmlEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
       ScXMLElt * parallelobj = parallelreader->read(scxml, element, doc, sm);
       if (unlikely(!parallelobj)) {
         delete scxml;
-        return NULL;
+        return nullptr;
       }
       assert(parallelobj->isOfType(ScXMLParallelElt::getClassTypeId()));
       scxml->addParallel(static_cast<ScXMLParallelElt *>(parallelobj));
@@ -185,7 +185,7 @@ ScXMLScxmlEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
       ScXMLElt * finalobj = finalreader->read(scxml, element, doc, sm);
       if (unlikely(!finalobj)) {
         delete scxml;
-        return NULL;
+        return nullptr;
       }
       assert(finalobj->isOfType(ScXMLFinalElt::getClassTypeId()));
       scxml->addFinal(static_cast<ScXMLFinalElt *>(finalobj));
@@ -193,18 +193,18 @@ ScXMLScxmlEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
 
     else if (strcmp(elementtype, "datamodel") == 0) {
       // <datamodel> - zero or one time
-      if (unlikely(scxml->getDataModel() != NULL)) {
+      if (unlikely(scxml->getDataModel() != nullptr)) {
         SoDebugError::post("ScXMLScxmlEltReader::read",
                            "<scxml> can only contain one <datamodel> element");
         delete scxml;
-        return NULL;
+        return nullptr;
       }
       ScXMLEltReader * datamodelreader = ScXMLDataModelElt::getElementReader();
       assert(datamodelreader);
       ScXMLElt * datamodelobj = datamodelreader->read(scxml, element, doc, sm);
       if (unlikely(!datamodelobj)) {
         delete scxml;
-        return NULL;
+        return nullptr;
       }
       assert(datamodelobj->isOfType(ScXMLDataModelElt::getClassTypeId()));
       scxml->setDataModel(static_cast<ScXMLDataModelElt *>(datamodelobj));
@@ -217,7 +217,7 @@ ScXMLScxmlEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
       ScXMLElt * scriptobj = scriptreader->read(scxml, element, doc, sm);
       if (unlikely(!scriptobj)) {
         delete scxml;
-        return NULL;
+        return nullptr;
       }
       assert(scriptobj->isOfType(ScXMLScriptElt::getClassTypeId()));
       scxml->addScript(static_cast<ScXMLScriptElt *>(scriptobj));
@@ -228,7 +228,7 @@ ScXMLScxmlEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
                          "unexpected XML element '<%s>' found in <scxml>",
                          elementtype);
       delete scxml;
-      return NULL;
+      return nullptr;
     }
   }
 
@@ -275,23 +275,23 @@ ScXMLScxmlElt::cleanClass(void)
 
 ScXMLScxmlElt::ScXMLScxmlElt(void)
 : referenced(false),
-  initial(NULL),
-  name(NULL),
-  xmlns(NULL),
-  version(NULL),
-  profile(NULL),
-  exmode(NULL)
+  initial(nullptr),
+  name(nullptr),
+  xmlns(nullptr),
+  version(nullptr),
+  profile(nullptr),
+  exmode(nullptr)
 {
 }
 
 ScXMLScxmlElt::~ScXMLScxmlElt(void)
 {
-  this->setInitialAttribute(NULL);
-  this->setNameAttribute(NULL);
-  // this->setXMLNSAttribute(NULL);
-  this->setVersionAttribute(NULL);
-  this->setProfileAttribute(NULL);
-  this->setExModeAttribute(NULL);
+  this->setInitialAttribute(nullptr);
+  this->setNameAttribute(nullptr);
+  // this->setXMLNSAttribute(nullptr);
+  this->setVersionAttribute(nullptr);
+  this->setProfileAttribute(nullptr);
+  this->setExModeAttribute(nullptr);
 }
 
 void
@@ -315,7 +315,7 @@ ScXMLScxmlElt::setInitialAttribute(const char * initialstr)
   {
     delete [] this->initial;
   }
-  this->initial = NULL;
+  this->initial = nullptr;
   if (initialstr) {
     if (initialstr == this->getXMLAttribute("initial")) {
       this->initial = const_cast<char *>(initialstr);
@@ -444,7 +444,7 @@ ScXMLScxmlElt::handleXMLAttributes(void)
   }
 
 #if 0
-  if (!this->referenced && this->initial == NULL) {
+  if (!this->referenced && this->initial == nullptr) {
     // requirement for root document, but not for referenced documents
     return false;
   }
@@ -571,7 +571,7 @@ ScXMLScxmlElt::search(const char * attrname, const char * attrvalue) const
     }
   }
 
-  return NULL;
+  return nullptr;
 }
 
 void
diff --git a/coin4/src/scxml/ScXMLSendElt.cpp b/coin4/src/scxml/ScXMLSendElt.cpp
index 266faa4..31210a2 100644
--- a/coin4/src/scxml/ScXMLSendElt.cpp
+++ b/coin4/src/scxml/ScXMLSendElt.cpp
@@ -145,7 +145,7 @@ ScXMLSendEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocumen
   // handle XML attributes
   if (unlikely(!send->handleXMLAttributes())) {
     delete send;
-    return NULL;
+    return nullptr;
   }
 
   const int numchildren = cc_xml_elt_get_num_children(xmlelt);
@@ -161,7 +161,7 @@ ScXMLSendEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocumen
     SoDebugError::post("ScXMLSendEltReader::read",
                        "<send> contains unexpected <%s> element", elementtype);
     delete send;
-    return NULL;
+    return nullptr;
    }
 
   return send;
@@ -192,25 +192,25 @@ ScXMLSendElt::cleanClass(void)
 }
 
 ScXMLSendElt::ScXMLSendElt(void)
-: event(NULL),
-  target(NULL),
-  targettype(NULL),
-  sendid(NULL),
-  delay(NULL),
-  namelist(NULL),
-  hints(NULL)
+: event(nullptr),
+  target(nullptr),
+  targettype(nullptr),
+  sendid(nullptr),
+  delay(nullptr),
+  namelist(nullptr),
+  hints(nullptr)
 {
 }
 
 ScXMLSendElt::~ScXMLSendElt(void)
 {
-  this->setEventAttribute(NULL);
-  this->setTargetAttribute(NULL);
-  this->setTargetTypeAttribute(NULL);
-  this->setSendIDAttribute(NULL);
-  this->setDelayAttribute(NULL);
-  this->setNameListAttribute(NULL);
-  this->setHintsAttribute(NULL);
+  this->setEventAttribute(nullptr);
+  this->setTargetAttribute(nullptr);
+  this->setTargetTypeAttribute(nullptr);
+  this->setSendIDAttribute(nullptr);
+  this->setDelayAttribute(nullptr);
+  this->setNameListAttribute(nullptr);
+  this->setHintsAttribute(nullptr);
 }
 
 void
@@ -343,7 +343,7 @@ ScXMLSendElt::search(const char * attrname, const char * attrvalue) const
       return this;
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 namespace {
@@ -377,7 +377,7 @@ ScXMLSendElt::createEvent(ScXMLEventTarget * host) const
     event->setEventName("error.Fetch");
     host->queueInternalEvent(event);
     delete event;
-    return NULL;
+    return nullptr;
   }
 
   event->setEventName(this->event);
diff --git a/coin4/src/scxml/ScXMLStateElt.cpp b/coin4/src/scxml/ScXMLStateElt.cpp
index 2903b06..305bf09 100644
--- a/coin4/src/scxml/ScXMLStateElt.cpp
+++ b/coin4/src/scxml/ScXMLStateElt.cpp
@@ -101,12 +101,12 @@ ScXMLStateEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
     SoDebugError::post("ScXMLStateEltReader::read",
                        "invalid XML attributes");
     delete state;
-    return NULL;
+    return nullptr;
   }
 
   // handle external reference
   const char * extref = state->getSrcAttribute();
-  if ((extref != NULL) && (extref[0] != '\0')) {
+  if ((extref != nullptr) && (extref[0] != '\0')) {
     SbString reference(extref);
     char * eltnameref = const_cast<char *>(strchr(reference.getString(), '#'));
     if (eltnameref) {
@@ -299,7 +299,7 @@ ScXMLStateEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
       ScXMLElt * stateobj = statereader->read(state, element, doc, sm);
       if (unlikely(!stateobj)) {
         delete state;
-        return NULL;
+        return nullptr;
       }
 
       assert(stateobj->isOfType(ScXMLStateElt::getClassTypeId()));
@@ -312,7 +312,7 @@ ScXMLStateEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
         SoDebugError::post("ScXMLStateEltReader::read",
                            "<state> elements can only contain one <onentry> element");
         delete state;
-        return NULL;
+        return nullptr;
       }
 
       ScXMLEltReader * onentryreader = ScXMLOnEntryElt::getElementReader();
@@ -320,7 +320,7 @@ ScXMLStateEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
       ScXMLElt * onentryobj = onentryreader->read(state, element, doc, sm);
       if (unlikely(!onentryobj)) {
         delete state;
-        return NULL;
+        return nullptr;
       }
 
       assert(onentryobj->isOfType(ScXMLOnEntryElt::getClassTypeId()));
@@ -333,7 +333,7 @@ ScXMLStateEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
         SoDebugError::post("ScXMLStateEltReader::read",
                            "<state> elements can only contain one <onexit> element");
         delete state;
-        return NULL;
+        return nullptr;
       }
 
       ScXMLEltReader * onexitreader = ScXMLOnExitElt::getElementReader();
@@ -341,7 +341,7 @@ ScXMLStateEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
       ScXMLElt * onexitobj = onexitreader->read(state, element, doc, sm);
       if (unlikely(!onexitobj)) {
         delete state;
-        return NULL;
+        return nullptr;
       }
 
       assert(onexitobj->isOfType(ScXMLOnExitElt::getClassTypeId()));
@@ -355,7 +355,7 @@ ScXMLStateEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
       ScXMLElt * transitionobj = transitionreader->read(state, element, doc, sm);
       if (unlikely(!transitionobj)) {
         delete state;
-        return NULL;
+        return nullptr;
       }
 
       assert(transitionobj->isOfType(ScXMLTransitionElt::getClassTypeId()));
@@ -370,7 +370,7 @@ ScXMLStateEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
       ScXMLElt * initialobj = initialreader->read(state, element, doc, sm);
       if (unlikely(!initialobj)) {
         delete state;
-        return NULL;
+        return nullptr;
       }
 
       assert(initialobj->isOfType(ScXMLInitialElt::getClassTypeId()));
@@ -384,7 +384,7 @@ ScXMLStateEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
       ScXMLElt * parallelobj = parallelreader->read(state, element, doc, sm);
       if (unlikely(!parallelobj)) {
         delete state;
-        return NULL;
+        return nullptr;
       }
 
       assert(parallelobj->isOfType(ScXMLParallelElt::getClassTypeId()));
@@ -398,7 +398,7 @@ ScXMLStateEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
       ScXMLElt * finalobj = finalreader->read(state, element, doc, sm);
       if (unlikely(!finalobj)) {
         delete state;
-        return NULL;
+        return nullptr;
       }
 
       assert(finalobj->isOfType(ScXMLFinalElt::getClassTypeId()));
@@ -412,7 +412,7 @@ ScXMLStateEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
       ScXMLElt * historyobj = historyreader->read(state, element, doc, sm);
       if (unlikely(!historyobj)) {
         delete state;
-        return NULL;
+        return nullptr;
       }
 
       assert(historyobj->isOfType(ScXMLHistoryElt::getClassTypeId()));
@@ -426,7 +426,7 @@ ScXMLStateEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
       ScXMLElt * anchorobj = anchorreader->read(state, element, doc, sm);
       if (unlikely(!anchorobj)) {
         delete state;
-        return NULL;
+        return nullptr;
       }
 
       assert(anchorobj->isOfType(ScXMLAnchorElt::getClassTypeId()));
@@ -439,7 +439,7 @@ ScXMLStateEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
         SoDebugError::post("ScXMLStateEltReader::read",
                            "<state> elements can only contain one <datamodel> element");
         delete state;
-        return NULL;
+        return nullptr;
       }
 
       ScXMLEltReader * datamodelreader = ScXMLDataModelElt::getElementReader();
@@ -447,7 +447,7 @@ ScXMLStateEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
       ScXMLElt * datamodelobj = datamodelreader->read(state, element, doc, sm);
       if (unlikely(!datamodelobj)) {
         delete state;
-        return NULL;
+        return nullptr;
       }
 
       assert(datamodelobj->isOfType(ScXMLDataModelElt::getClassTypeId()));
@@ -464,7 +464,7 @@ ScXMLStateEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
       } else {
         SoDebugError::post("ScXML::readFile", "error reading <%s> element", elementtype);
         delete state;
-        return NULL;
+        return nullptr;
       }
     }
 #endif
@@ -473,7 +473,7 @@ ScXMLStateEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
                          "unexpected XML element '<%s>' found in <state>",
                          elementtype);
       delete state;
-      return NULL;
+      return nullptr;
     }
   }
   return state;
@@ -484,12 +484,12 @@ ScXMLStateEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDocume
 class ScXMLStateElt::PImpl {
 public:
   PImpl(void)
-  : onentryptr(NULL),
-    onexitptr(NULL),
-    initialptr(NULL),
-    datamodelptr(NULL),
-    invokeptr(NULL)
-    //srcref(NULL)
+  : onentryptr(nullptr),
+    onexitptr(nullptr),
+    initialptr(nullptr),
+    datamodelptr(nullptr),
+    invokeptr(nullptr)
+    //srcref(nullptr)
   {
   }
 
@@ -543,8 +543,8 @@ ScXMLStateElt::cleanClass(void)
   Constructor.
 */
 ScXMLStateElt::ScXMLStateElt(void)
-: src(NULL),
-  initial(NULL)
+: src(nullptr),
+  initial(nullptr)
 {
 }
 
@@ -553,8 +553,8 @@ ScXMLStateElt::ScXMLStateElt(void)
 */
 ScXMLStateElt::~ScXMLStateElt(void)
 {
-  this->setSrcAttribute(NULL);
-  this->setInitialAttribute(NULL);
+  this->setSrcAttribute(nullptr);
+  this->setInitialAttribute(nullptr);
 }
 
 /*!
@@ -571,7 +571,7 @@ ScXMLStateElt::setSrcAttribute(const char * srcstr)
 
   SCXML__SET_ATTRIBUTE_VALUE(this->src, "src", srcstr);
 
-  if ((this->src != NULL) && (strcmp(this->src, "") != 0)) {
+  if ((this->src != nullptr) && (strcmp(this->src, "") != 0)) {
     // FIXME: scan string for #
     // FIXME: load/import [externally] referenced states
   }
@@ -779,7 +779,7 @@ ScXMLStateElt::search(const char * attrname, const char * attrvalue) const
       return hit;
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 SCXML_SINGLE_OBJECT_API_IMPL(ScXMLStateElt, ScXMLOnEntryElt,
@@ -824,7 +824,7 @@ ScXMLStateElt::isAtomicState(void) const
 {
   return ((PRIVATE(this)->statelist.size() == 0) &&
           (PRIVATE(this)->parallellist.size() == 0) &&
-          (PRIVATE(this)->invokeptr.get() != NULL));
+          (PRIVATE(this)->invokeptr.get() != nullptr));
 }
 
 #undef PRIVATE
diff --git a/coin4/src/scxml/ScXMLStateMachine.cpp b/coin4/src/scxml/ScXMLStateMachine.cpp
index f67e0b1..b986771 100644
--- a/coin4/src/scxml/ScXMLStateMachine.cpp
+++ b/coin4/src/scxml/ScXMLStateMachine.cpp
@@ -79,13 +79,13 @@ struct EventInfo {
 class ScXMLStateMachine::PImpl {
 public:
   PImpl(void)
-    : pub(NULL),
+    : pub(nullptr),
       active(false), finished(false),
       name(SbName::empty()), sessionid(SbName::empty()),
       loglevel(3),
-      description(NULL),
-      evaluator(NULL),
-      initializer(NULL)
+      description(nullptr),
+      evaluator(nullptr),
+      initializer(nullptr)
   {
   }
 
@@ -93,7 +93,7 @@ public:
   {
     if (this->description) {
       delete this->description;
-      this->description = NULL;
+      this->description = nullptr;
     }
   }
 
@@ -140,7 +140,7 @@ public:
   static SbHash<const char *, ScXMLStateMachine *> * sessiondictionary;
 }; // ScXMLStateMachine::PImpl
 
-SbHash<const char *, ScXMLStateMachine *> * ScXMLStateMachine::PImpl::sessiondictionary = NULL;
+SbHash<const char *, ScXMLStateMachine *> * ScXMLStateMachine::PImpl::sessiondictionary = nullptr;
 long ScXMLStateMachine::PImpl::nextsessionid = 0;
 
 // *************************************************************************
@@ -164,7 +164,7 @@ ScXMLStateMachine::cleanClass(void)
 {
   ScXMLStateMachine::PImpl::nextsessionid = 0;
   delete ScXMLStateMachine::PImpl::sessiondictionary;
-  ScXMLStateMachine::PImpl::sessiondictionary = NULL;
+  ScXMLStateMachine::PImpl::sessiondictionary = nullptr;
   ScXMLStateMachine::classTypeId = SoType::badType();
 }
 
@@ -172,12 +172,12 @@ ScXMLStateMachine *
 ScXMLStateMachine::getStateMachineForSessionId(const SbName & sessionid)
 {
   if (sessionid == SbName::empty()) {
-    return NULL;
+    return nullptr;
   }
   const char * id = sessionid.getString();
-  ScXMLStateMachine * statemachine = NULL;
+  ScXMLStateMachine * statemachine = nullptr;
   if (!ScXMLStateMachine::PImpl::sessiondictionary->get(id, statemachine)) {
-    return NULL;
+    return nullptr;
   }
   return statemachine;
 }
@@ -222,7 +222,7 @@ ScXMLStateMachine::setDescription(ScXMLDocument * document)
 {
   assert(!PRIVATE(this)->active);
   PRIVATE(this)->description = document;
-  PRIVATE(this)->initializer.reset(NULL);
+  PRIVATE(this)->initializer.reset(nullptr);
   PRIVATE(this)->active = false;
   PRIVATE(this)->finished = false;
   PRIVATE(this)->activestatelist.clear();
@@ -310,7 +310,7 @@ ScXMLStateMachine::initialize(void)
   PRIVATE(this)->active = true;
   PRIVATE(this)->finished = false;
   PRIVATE(this)->activestatelist.clear();
-  this->processOneEvent(NULL); // process the 'initial' initializer
+  this->processOneEvent(nullptr); // process the 'initial' initializer
   this->processEventQueue(); // process any pending events from the initial-processing
 }
 
@@ -333,7 +333,7 @@ ScXMLStateMachine::processOneEvent(const ScXMLEvent * event)
                              event->getEventName().getString());
     else
       SoDebugError::postInfo("ScXMLStateMachine::processOneEvent",
-                             "NULL event");
+                             "nullptr event");
   }
 
   if (0 /* debug */) {
@@ -348,7 +348,7 @@ ScXMLStateMachine::processOneEvent(const ScXMLEvent * event)
 
   PImpl::TransitionList transitions;
   if (PRIVATE(this)->activestatelist.size() == 0) {
-    if (PRIVATE(this)->initializer.get() == NULL) {
+    if (PRIVATE(this)->initializer.get() == nullptr) {
       PRIVATE(this)->initializer.reset(new ScXMLTransitionElt);
       // FIXME
       if (PRIVATE(this)->description->getRoot()->getInitial()) {
@@ -356,12 +356,12 @@ ScXMLStateMachine::processOneEvent(const ScXMLEvent * event)
         PRIVATE(this)->initializer->setTargetAttribute(PRIVATE(this)->description->getRoot()->getInitialAttribute());
       }
     }
-    transitions.push_back(PImpl::StateTransition(static_cast<ScXMLElt*>(NULL), PRIVATE(this)->initializer.get()));
+    transitions.push_back(PImpl::StateTransition(static_cast<ScXMLElt*>(nullptr), PRIVATE(this)->initializer.get()));
   } else {
     for (int c = 0; c < static_cast<int>(PRIVATE(this)->activestatelist.size()); ++c) {
       // containers are also active states and must be checked
       ScXMLElt * stateobj = PRIVATE(this)->activestatelist.at(c);
-      while (stateobj != NULL) {
+      while (stateobj != nullptr) {
         PRIVATE(this)->findTransitions(transitions, stateobj, event);
         stateobj = stateobj->getContainer();
       }
@@ -372,7 +372,7 @@ ScXMLStateMachine::processOneEvent(const ScXMLEvent * event)
   if (transitions.size() == 0) {
     if (this->getEvaluator())
       this->getEvaluator()->clearTemporaryVariables();
-    this->setCurrentEvent(NULL);
+    this->setCurrentEvent(nullptr);
     return false;
   }
 
@@ -432,7 +432,7 @@ ScXMLStateMachine::processOneEvent(const ScXMLEvent * event)
     std::vector<ScXMLElt *> sourcestates;
 
     ScXMLElt * sourcestate = transit->first;
-    if (sourcestate != NULL) { // ignore sourcestate NULL (initializer)
+    if (sourcestate != nullptr) { // ignore sourcestate nullptr (initializer)
       // find all activestate object contained within source state
       std::vector<ScXMLElt *>::iterator activeit =
         PRIVATE(this)->activestatelist.begin();
@@ -604,7 +604,7 @@ ScXMLStateMachine::processOneEvent(const ScXMLEvent * event)
 
   if (this->getEvaluator())
     this->getEvaluator()->clearTemporaryVariables();
-  this->setCurrentEvent(NULL);
+  this->setCurrentEvent(nullptr);
   return true; // transitions have been taken
 }
 
@@ -632,10 +632,10 @@ ScXMLStateMachine::isFinished(void) const
 
 
 /*!
-  This method returns the current event during event processing, and NULL
+  This method returns the current event during event processing, and nullptr
   when not processing events.
 
-  Event processing is in special cases done with NULL as the current event,
+  Event processing is in special cases done with nullptr as the current event,
   as for instance during state machine initialization.
 */
 
@@ -828,7 +828,7 @@ ScXMLStateMachine::getVariable(const char * name) const
     return PRIVATE(this)->varstring.getString();
     // return PRIVATE(this)->name.getString();
   }
-  return NULL;
+  return nullptr;
 }
 
 // *************************************************************************
diff --git a/coin4/src/scxml/ScXMLTransitionElt.cpp b/coin4/src/scxml/ScXMLTransitionElt.cpp
index 5724477..6ac9dc7 100644
--- a/coin4/src/scxml/ScXMLTransitionElt.cpp
+++ b/coin4/src/scxml/ScXMLTransitionElt.cpp
@@ -137,7 +137,7 @@ ScXMLTransitionEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLD
   // handle XML attributes
   if (unlikely(!transition->handleXMLAttributes())) {
     delete transition;
-    return NULL;
+    return nullptr;
   }
 
   const int numchildren = cc_xml_elt_get_num_children(xmlelt);
@@ -157,7 +157,7 @@ ScXMLTransitionEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLD
       ScXMLElt * logobj = logreader->read(transition, element, doc, sm);
       if (unlikely(!logobj)) {
         delete transition;
-        return NULL;
+        return nullptr;
       }
       assert(logobj->isOfType(ScXMLLogElt::getClassTypeId()));
       transition->addExecutable(static_cast<ScXMLLogElt *>(logobj));
@@ -169,7 +169,7 @@ ScXMLTransitionEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLD
       ScXMLElt * eventobj = eventreader->read(transition, element, doc, sm);
       if (unlikely(!eventobj)) {
         delete transition;
-        return NULL;
+        return nullptr;
       }
       assert(eventobj->isOfType(ScXMLEventElt::getClassTypeId()));
       transition->addExecutable(static_cast<ScXMLEventElt *>(eventobj));
@@ -181,7 +181,7 @@ ScXMLTransitionEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLD
       ScXMLElt * assignobj = assignreader->read(transition, element, doc, sm);
       if (unlikely(!assignobj)) {
         delete transition;
-        return NULL;
+        return nullptr;
       }
       assert(assignobj->isOfType(ScXMLAssignElt::getClassTypeId()));
       transition->addExecutable(static_cast<ScXMLAssignElt *>(assignobj));
@@ -193,7 +193,7 @@ ScXMLTransitionEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLD
       ScXMLElt * sendobj = sendreader->read(transition, element, doc, sm);
       if (unlikely(!sendobj)) {
         delete transition;
-        return NULL;
+        return nullptr;
       }
       assert(sendobj->isOfType(ScXMLSendElt::getClassTypeId()));
       transition->addExecutable(static_cast<ScXMLSendElt *>(sendobj));
@@ -205,7 +205,7 @@ ScXMLTransitionEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLD
       ScXMLElt * ifobj = ifreader->read(transition, element, doc, sm);
       if (unlikely(!ifobj)) {
         delete transition;
-        return NULL;
+        return nullptr;
       }
       assert(ifobj->isOfType(ScXMLIfElt::getClassTypeId()));
       transition->addExecutable(static_cast<ScXMLIfElt *>(ifobj));
@@ -217,7 +217,7 @@ ScXMLTransitionEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLD
       ScXMLElt * scriptobj = scriptreader->read(transition, element, doc, sm);
       if (unlikely(!scriptobj)) {
         delete transition;
-        return NULL;
+        return nullptr;
       }
       assert(scriptobj->isOfType(ScXMLScriptElt::getClassTypeId()));
       transition->addExecutable(static_cast<ScXMLScriptElt *>(scriptobj));
@@ -229,7 +229,7 @@ ScXMLTransitionEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLD
       ScXMLElt * invokeobj = invokereader->read(transition, element, doc, sm);
       if (unlikely(!invokeobj)) {
         delete transition;
-        return NULL;
+        return nullptr;
       }
       assert(invokeobj->isOfType(ScXMLInvokeElt::getClassTypeId()));
       transition->addExecutable(static_cast<ScXMLInvokeElt *>(invokeobj));
@@ -239,7 +239,7 @@ ScXMLTransitionEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLD
                          "unexpected XML element '<%s>' found in <transition>",
                          elementtype);
       delete transition;
-      return NULL;
+      return nullptr;
     }
   }
   return transition;
@@ -277,10 +277,10 @@ ScXMLTransitionElt::cleanClass(void)
 }
 
 ScXMLTransitionElt::ScXMLTransitionElt(void)
-: event(NULL),
-  cond(NULL),
-  target(NULL),
-  anchor(NULL),
+: event(nullptr),
+  cond(nullptr),
+  target(nullptr),
+  anchor(nullptr),
   needprefixmatching(false),
   eventkey(SbName::empty()),
   targetkey(SbName::empty())
@@ -289,10 +289,10 @@ ScXMLTransitionElt::ScXMLTransitionElt(void)
 
 ScXMLTransitionElt::~ScXMLTransitionElt(void)
 {
-  this->setEventAttribute(NULL);
-  this->setCondAttribute(NULL);
-  this->setTargetAttribute(NULL);
-  this->setAnchorAttribute(NULL);
+  this->setEventAttribute(nullptr);
+  this->setCondAttribute(nullptr);
+  this->setTargetAttribute(nullptr);
+  this->setAnchorAttribute(nullptr);
 }
 
 void
@@ -301,7 +301,7 @@ ScXMLTransitionElt::setEventAttribute(const char * eventstr)
   if (this->event && this->event != this->getXMLAttribute("event")) {
     delete [] this->event;
   }
-  this->event = NULL;
+  this->event = nullptr;
   this->eventkey = SbName::empty();
   this->needprefixmatching = false;
 
@@ -312,7 +312,7 @@ ScXMLTransitionElt::setEventAttribute(const char * eventstr)
     // more succeeding tokens - we need in other words not implement
     // any form of generic pattern matching here...
     const char * ptr = strstr(eventstr, ".*");
-    if ((ptr != NULL) && (strlen(ptr) == 2)) {
+    if ((ptr != nullptr) && (strlen(ptr) == 2)) {
       this->needprefixmatching = true;
       // we'll chop off the pattern matching key and use the boolean
       const int len = strlen(eventstr) - 1;
@@ -418,7 +418,7 @@ ScXMLTransitionElt::search(const char * attrname, const char * attrvalue) const
       return this;
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 
@@ -431,7 +431,7 @@ ScXMLTransitionElt::search(const char * attrname, const char * attrvalue) const
 bool
 ScXMLTransitionElt::isConditionLess(void) const
 {
-  if (this->cond == NULL) return true;
+  if (this->cond == nullptr) return true;
   if (strlen(this->cond) == 0) return true;
   return false;
 }
@@ -448,7 +448,7 @@ ScXMLTransitionElt::isConditionLess(void) const
 bool
 ScXMLTransitionElt::isTargetLess(void) const
 {
-  return (this->target == NULL);
+  return (this->target == nullptr);
 }
 
 /*!
@@ -464,7 +464,7 @@ ScXMLTransitionElt::isTargetLess(void) const
 bool
 ScXMLTransitionElt::isSelfReferencing(void) const
 {
-  if (this->target != NULL && this->getContainer()) {
+  if (this->target != nullptr && this->getContainer()) {
     const char * containerid = this->getContainer()->getXMLAttribute("id");
     if (strcmp(containerid, this->target) == 0) return true;
   }
diff --git a/coin4/src/scxml/ScXMLValidateElt.cpp b/coin4/src/scxml/ScXMLValidateElt.cpp
index 1824be0..3334e34 100644
--- a/coin4/src/scxml/ScXMLValidateElt.cpp
+++ b/coin4/src/scxml/ScXMLValidateElt.cpp
@@ -68,7 +68,7 @@ ScXMLValidateEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDoc
   // handle XML attributes
   if (unlikely(!validate->handleXMLAttributes())) {
     delete validate;
-    return NULL;
+    return nullptr;
   }
 
   const int numchildren = cc_xml_elt_get_num_children(xmlelt);
@@ -84,7 +84,7 @@ ScXMLValidateEltReader::read(ScXMLElt * container, cc_xml_elt * xmlelt, ScXMLDoc
     SoDebugError::post("ScXMLValidateEltReader::read",
                        "<validate> contains unexpected <%s> element", elementtype);
     delete validate;
-    return NULL;
+    return nullptr;
   }
 
   return validate;
@@ -114,14 +114,14 @@ ScXMLValidateElt::cleanClass(void)
 }
 
 ScXMLValidateElt::ScXMLValidateElt(void)
-: location(NULL),
-  schema(NULL)
+: location(nullptr),
+  schema(nullptr)
 {
 }
 ScXMLValidateElt::~ScXMLValidateElt(void)
 {
-  this->setLocationAttribute(NULL);
-  this->setSchemaAttribute(NULL);
+  this->setLocationAttribute(nullptr);
+  this->setSchemaAttribute(nullptr);
 }
 
 void
@@ -179,7 +179,7 @@ ScXMLValidateElt::search(const char * attrname, const char * attrvalue) const
       return this;
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 void
diff --git a/coin4/src/scxml/ScXMLXPathEvaluator.cpp b/coin4/src/scxml/ScXMLXPathEvaluator.cpp
index 6068337..f254045 100644
--- a/coin4/src/scxml/ScXMLXPathEvaluator.cpp
+++ b/coin4/src/scxml/ScXMLXPathEvaluator.cpp
@@ -63,7 +63,7 @@ ScXMLDataObj *
 ScXMLXPathEvaluator::evaluate(const char * COIN_UNUSED_ARG(expression)) const
 {
   // FIXME: not implemented
-  return NULL;
+  return nullptr;
 }
 
 bool
@@ -77,6 +77,6 @@ ScXMLDataObj *
 ScXMLXPathEvaluator::locate(const char * COIN_UNUSED_ARG(location)) const
 {
   // FIXME: not implemented
-  return NULL;
+  return nullptr;
 }
 
diff --git a/coin4/src/scxml/eval-minimum-tab.cpp b/coin4/src/scxml/eval-minimum-tab.cpp
index 9ef8f3a..c68a931 100644
--- a/coin4/src/scxml/eval-minimum-tab.cpp
+++ b/coin4/src/scxml/eval-minimum-tab.cpp
@@ -131,7 +131,7 @@
 #include <Inventor/scxml/ScXMLMinimumEvaluator.h>
 
 namespace {
-static ScXMLDataObj * root = NULL;
+static ScXMLDataObj * root = nullptr;
 }
 
 
@@ -1603,6 +1603,6 @@ scxml_minimum_get_root_obj(void)
 void
 scxml_minimum_clear_root_obj(void)
 {
-  root = NULL;
+  root = nullptr;
 }
 
diff --git a/coin4/src/scxml/eval-minimum-tab.y b/coin4/src/scxml/eval-minimum-tab.y
index c0ae185..5d0e016 100644
--- a/coin4/src/scxml/eval-minimum-tab.y
+++ b/coin4/src/scxml/eval-minimum-tab.y
@@ -38,7 +38,7 @@
 #include <Inventor/scxml/ScXMLMinimumEvaluator.h>
 
 namespace {
-static ScXMLDataObj * root = NULL;
+static ScXMLDataObj * root = nullptr;
 }
 %}
 
@@ -90,5 +90,5 @@ scxml_minimum_get_root_obj(void)
 void
 scxml_minimum_clear_root_obj(void)
 {
-  root = NULL;
+  root = nullptr;
 }
diff --git a/coin4/src/scxml/eval-minimum.cpp b/coin4/src/scxml/eval-minimum.cpp
index aaa9dc9..f5830ab 100644
--- a/coin4/src/scxml/eval-minimum.cpp
+++ b/coin4/src/scxml/eval-minimum.cpp
@@ -277,14 +277,14 @@ static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
  * future we want to put the buffer states in a more general
  * "scanner state".
  *
- * Returns the top of the stack, or NULL.
+ * Returns the top of the stack, or nullptr.
  */
 #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
-                          : NULL)
+                          : nullptr)
 
 /* Same as previous macro, but useful when we know that the buffer stack is not
- * NULL or when we need an lvalue. For internal use only.
+ * nullptr or when we need an lvalue. For internal use only.
  */
 #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
 
@@ -1379,7 +1379,7 @@ static void scxml_minimum__load_buffer_state  (void)
  */
 void scxml_minimum_push_buffer_state (YY_BUFFER_STATE new_buffer )
 {
-    	if (new_buffer == NULL)
+    	if (new_buffer == nullptr)
 		return;
 
 	scxml_minimum_ensure_buffer_stack();
@@ -1413,7 +1413,7 @@ void scxml_minimum_pop_buffer_state (void)
 		return;
 
 	scxml_minimum__delete_buffer(YY_CURRENT_BUFFER );
-	YY_CURRENT_BUFFER_LVALUE = NULL;
+	YY_CURRENT_BUFFER_LVALUE = nullptr;
 	if ((yy_buffer_stack_top) > 0)
 		--(yy_buffer_stack_top);
 
@@ -1697,13 +1697,13 @@ int scxml_minimum_lex_destroy  (void)
     /* Pop the buffer stack, destroying each element. */
 	while(YY_CURRENT_BUFFER){
 		scxml_minimum__delete_buffer(YY_CURRENT_BUFFER  );
-		YY_CURRENT_BUFFER_LVALUE = NULL;
+		YY_CURRENT_BUFFER_LVALUE = nullptr;
 		scxml_minimum_pop_buffer_state();
 	}
 
 	/* Destroy the stack itself. */
 	scxml_minimum_free((yy_buffer_stack) );
-	(yy_buffer_stack) = NULL;
+	(yy_buffer_stack) = nullptr;
 
     /* Reset the globals. This is important in a non-reentrant scanner so the next time
      * scxml_minimum_lex() is called, initialization will occur. */
diff --git a/coin4/src/sensors/SoDataSensor.cpp b/coin4/src/sensors/SoDataSensor.cpp
index bb1d9f7..82f97fe 100644
--- a/coin4/src/sensors/SoDataSensor.cpp
+++ b/coin4/src/sensors/SoDataSensor.cpp
@@ -54,17 +54,17 @@
   Default constructor.
 */
 SoDataSensor::SoDataSensor(void)
-  : cbfunc(NULL),
-    cbdata(NULL),
+  : cbfunc(nullptr),
+    cbdata(nullptr),
     findpath(false),
-    triggerfield(NULL),
-    triggernode(NULL),
-    triggerpath(NULL),
+    triggerfield(nullptr),
+    triggernode(nullptr),
+    triggerpath(nullptr),
     triggeroperationtype(SoNotRec::UNSPECIFIED),
     triggerindex(-1),
     triggerfieldnumindices(0),
-    triggergroupchild(NULL),
-    triggergroupprevchild(NULL)
+    triggergroupchild(nullptr),
+    triggergroupprevchild(nullptr)
 {
 }
 
@@ -76,17 +76,17 @@ SoDataSensor::SoDataSensor(void)
 */
 SoDataSensor::SoDataSensor(SoSensorCB * func, void * data)
   : inherited(func, data),
-    cbfunc(NULL),
-    cbdata(NULL),
+    cbfunc(nullptr),
+    cbdata(nullptr),
     findpath(false),
-    triggerfield(NULL),
-    triggernode(NULL),
-    triggerpath(NULL),
+    triggerfield(nullptr),
+    triggernode(nullptr),
+    triggerpath(nullptr),
     triggeroperationtype(SoNotRec::UNSPECIFIED),
     triggerindex(-1),
     triggerfieldnumindices(0),
-    triggergroupchild(NULL),
-    triggergroupprevchild(NULL)
+    triggergroupchild(nullptr),
+    triggergroupprevchild(nullptr)
 {
 }
 
@@ -114,9 +114,9 @@ SoDataSensor::setDeleteCallback(SoSensorCB * function, void * data)
 
 /*!
   Returns a pointer to the node causing the sensor to trigger, or \c
-  NULL if there was no such node.
+  nullptr if there was no such node.
 
-  \c NULL will also be returned for sensors which are not immediate
+  \c nullptr will also be returned for sensors which are not immediate
   sensors (i.e. with priority equal to 0), as the result could
   otherwise be misleading (non-immediate sensors could have been
   scheduled and rescheduled multiple times, so there wouldn't be a
@@ -136,9 +136,9 @@ SoDataSensor::getTriggerNode(void) const
 
 /*!
   Returns a pointer to the field causing the sensor to trigger, or \c
-  NULL if the change didn't start at a field.
+  nullptr if the change didn't start at a field.
 
-  Only valid for immediate sensors (will return \c NULL otherwise),
+  Only valid for immediate sensors (will return \c nullptr otherwise),
   for the same reason as described for SoDataSensor::getTriggerNode().
 
   The result is only valid within the scope of a trigger(), so if you
@@ -241,7 +241,7 @@ SoDataSensor::getTriggerFieldNumIndices(void) const
 
 /*!
   Returns a pointer to the actual child node in the node that caused
-  the sensor to trigger, or \c NULL if there was no such node.
+  the sensor to trigger, or \c nullptr if there was no such node.
 
   Please note that this method is an extension to the original SGI
   Inventor API.
@@ -257,7 +257,7 @@ SoDataSensor::getTriggerGroupChild(void) const
 /*!
   Returns a pointer to the actual child node for a
   SoNotRec::GROUP_REPLACECHILD type of operation in the node that is
-  about to be replaced and caused the sensor to trigger, or \c NULL if
+  about to be replaced and caused the sensor to trigger, or \c nullptr if
   there was no such node.
 
   Please note that this method is an extension to the original SGI
@@ -276,15 +276,15 @@ void
 SoDataSensor::trigger(void)
 {
   inherited::trigger();
-  this->triggerfield = NULL;
-  this->triggernode = NULL;
+  this->triggerfield = nullptr;
+  this->triggernode = nullptr;
   if (this->triggerpath) this->triggerpath->unref();
-  this->triggerpath = NULL;
+  this->triggerpath = nullptr;
   this->triggeroperationtype = SoNotRec::UNSPECIFIED;
   this->triggerindex = -1;
   this->triggerfieldnumindices = 0;
-  this->triggergroupchild = NULL;
-  this->triggergroupprevchild = NULL;
+  this->triggergroupchild = nullptr;
+  this->triggergroupprevchild = nullptr;
 }
 
 /*!
@@ -301,17 +301,17 @@ SoDataSensor::trigger(void)
 void
 SoDataSensor::notify(SoNotList * l)
 {
-  if (this->triggerpath != NULL) {
+  if (this->triggerpath != nullptr) {
     this->triggerpath->unref();
-    this->triggerpath = NULL;
+    this->triggerpath = nullptr;
   }
-  this->triggerfield = NULL;
-  this->triggernode = NULL;
+  this->triggerfield = nullptr;
+  this->triggernode = nullptr;
 
   if (this->getPriority() == 0) {
     this->triggerfield = l->getLastField();
     SoNotRec * record = l->getFirstRecAtNode();
-    this->triggernode = (SoNode *) (record ? record->getBase() : NULL);
+    this->triggernode = (SoNode *) (record ? record->getBase() : nullptr);
 
     if (this->findpath && this->triggernode) {
       const SoNotRec * record = l->getLastRec();
@@ -332,8 +332,8 @@ SoDataSensor::notify(SoNotList * l)
     this->triggeroperationtype = record ? record->getOperationType() : SoNotRec::UNSPECIFIED;
     this->triggerindex = record ? record->getIndex() : -1;
     this->triggerfieldnumindices = record ? record->getFieldNumIndices() : 0;
-    this->triggergroupchild = (SoNode *) (record ? record->getGroupChild() : NULL);
-    this->triggergroupprevchild = (SoNode *) (record ? record->getGroupPrevChild() : NULL);
+    this->triggergroupchild = (SoNode *) (record ? record->getGroupChild() : nullptr);
+    this->triggergroupprevchild = (SoNode *) (record ? record->getGroupPrevChild() : nullptr);
   }
   this->schedule();
 }
diff --git a/coin4/src/sensors/SoFieldSensor.cpp b/coin4/src/sensors/SoFieldSensor.cpp
index 2395373..04e4d3f 100644
--- a/coin4/src/sensors/SoFieldSensor.cpp
+++ b/coin4/src/sensors/SoFieldSensor.cpp
@@ -42,7 +42,7 @@
  */
 SoFieldSensor::SoFieldSensor(void)
 {
-  this->convict = NULL;
+  this->convict = nullptr;
 }
 
 /*!
@@ -54,7 +54,7 @@ SoFieldSensor::SoFieldSensor(void)
 SoFieldSensor::SoFieldSensor(SoSensorCB * func, void * data)
   : inherited(func, data)
 {
-  this->convict = NULL;
+  this->convict = nullptr;
 }
 
 /*!
@@ -99,7 +99,7 @@ SoFieldSensor::detach(void)
 {
   if (this->convict) {
     this->convict->removeAuditor(this, SoNotRec::SENSOR);
-    this->convict = NULL;
+    this->convict = nullptr;
     if (this->isScheduled()) this->unschedule();
   }
 }
@@ -142,12 +142,12 @@ SoFieldSensor::dyingReference(void)
 
   this->invokeDeleteCallback();
 
-  if (this->getAttachedField() != NULL &&
+  if (this->getAttachedField() != nullptr &&
       this->getAttachedField()->getContainer() == dyingcontainer) {
     // sensor is attached, and to the same field-container
     this->detach();
     // FIXME: we could maybe do an exception for the globalfield-container,
-    // and for loose fields I assume have NULL for getContainer() - those cases
+    // and for loose fields I assume have nullptr for getContainer() - those cases
     // should be checked at the field-pointer level instead.
   }
 }
diff --git a/coin4/src/sensors/SoNodeSensor.cpp b/coin4/src/sensors/SoNodeSensor.cpp
index b752d68..dcc2150 100644
--- a/coin4/src/sensors/SoNodeSensor.cpp
+++ b/coin4/src/sensors/SoNodeSensor.cpp
@@ -46,7 +46,7 @@
 */
 SoNodeSensor::SoNodeSensor(void)
 {
-  this->convict = NULL;
+  this->convict = nullptr;
 }
 
 /*!
@@ -58,7 +58,7 @@ SoNodeSensor::SoNodeSensor(void)
 SoNodeSensor::SoNodeSensor(SoSensorCB * func, void * data)
   : inherited(func, data)
 {
-  this->convict = NULL;
+  this->convict = nullptr;
 }
 
 /*!
@@ -86,7 +86,7 @@ SoNodeSensor::~SoNodeSensor(void)
 void
 SoNodeSensor::attach(SoNode * node)
 {
-  if (this->convict != NULL) {
+  if (this->convict != nullptr) {
     this->detach();
     SoDebugError::postWarning("SoNodeSensor::attach", 
                               "Attaching node sensor that is already attached.", 
@@ -106,7 +106,7 @@ void
 SoNodeSensor::detach(void)
 {
   if (this->convict) this->convict->removeAuditor(this, SoNotRec::SENSOR);
-  this->convict = NULL;
+  this->convict = nullptr;
 }
 
 /*!
diff --git a/coin4/src/sensors/SoPathSensor.cpp b/coin4/src/sensors/SoPathSensor.cpp
index 34e56ad..65e7da5 100644
--- a/coin4/src/sensors/SoPathSensor.cpp
+++ b/coin4/src/sensors/SoPathSensor.cpp
@@ -105,8 +105,8 @@ void
 SoPathSensor::commonConstructor(void)
 {
   PRIVATE(this) = new SoPathSensorP;
-  PRIVATE(this)->path = NULL;
-  PRIVATE(this)->headnode = NULL;
+  PRIVATE(this)->path = nullptr;
+  PRIVATE(this)->headnode = nullptr;
   PRIVATE(this)->triggerfilter = PATH_AND_NODES;
 }
 
@@ -154,11 +154,11 @@ SoPathSensor::detach(void)
 {
   if (PRIVATE(this)->path) {
     PRIVATE(this)->path->removeAuditor(this, SoNotRec::SENSOR);
-    PRIVATE(this)->path = NULL;
+    PRIVATE(this)->path = nullptr;
   }
   if (PRIVATE(this)->headnode) {
     PRIVATE(this)->headnode->removeAuditor(this, SoNotRec::SENSOR);
-    PRIVATE(this)->headnode = NULL;
+    PRIVATE(this)->headnode = nullptr;
   }
   // unschedule so that we don't trigger a new callback
   if (this->isScheduled()) this->unschedule();
diff --git a/coin4/src/sensors/SoSensor.cpp b/coin4/src/sensors/SoSensor.cpp
index 1e20322..9221571 100644
--- a/coin4/src/sensors/SoSensor.cpp
+++ b/coin4/src/sensors/SoSensor.cpp
@@ -53,7 +53,7 @@
 
 /*! \file SoSensor.h */
 #include <Inventor/sensors/SoSensor.h>
-#include <stdlib.h> // NULL
+#include <stdlib.h> // nullptr
 #include <coindefs.h> // COIN_OBSOLETED()
 #include "misc/SbHash.h"
 
@@ -110,7 +110,7 @@ unsigned int SbHashFunc(const SoSensor * key) {
   Constructor.
  */
 SoSensor::SoSensor(void)
-  : func(NULL), funcData(NULL)
+  : func(nullptr), funcData(nullptr)
 {
 }
 
@@ -206,7 +206,7 @@ SoSensor *
 SoSensor::getNextInQueue(void) const
 {
   COIN_OBSOLETED();
-  return NULL;
+  return nullptr;
 }
 
 /*!
diff --git a/coin4/src/sensors/SoSensorManager.cpp b/coin4/src/sensors/SoSensorManager.cpp
index 4fbf2e0..4230d72 100644
--- a/coin4/src/sensors/SoSensorManager.cpp
+++ b/coin4/src/sensors/SoSensorManager.cpp
@@ -243,8 +243,8 @@ SoSensorManager::SoSensorManager(void)
 {
   PRIVATE(this) = new SoSensorManagerP;
 
-  PRIVATE(this)->queueChangedCB = NULL;
-  PRIVATE(this)->queueChangedCBData = NULL;
+  PRIVATE(this)->queueChangedCB = nullptr;
+  PRIVATE(this)->queueChangedCBData = nullptr;
 
   PRIVATE(this)->processingtimerqueue = false;
   PRIVATE(this)->processingdelayqueue = false;
diff --git a/coin4/src/shaders/SoGLARBShaderProgram.cpp b/coin4/src/shaders/SoGLARBShaderProgram.cpp
index 67edbca..f6a0838 100644
--- a/coin4/src/shaders/SoGLARBShaderProgram.cpp
+++ b/coin4/src/shaders/SoGLARBShaderProgram.cpp
@@ -38,8 +38,8 @@
 
 SoGLARBShaderProgram::SoGLARBShaderProgram(void)
 {
-  this->fragmentShader = NULL;
-  this->vertexShader = NULL;
+  this->fragmentShader = nullptr;
+  this->vertexShader = nullptr;
 }
 
 void
@@ -57,8 +57,8 @@ SoGLARBShaderProgram::addShaderObject(SoGLARBShaderObject * shaderObject)
 void
 SoGLARBShaderProgram::removeShaderObjects(void)
 {
-  this->vertexShader = NULL;
-  this->fragmentShader = NULL;
+  this->vertexShader = nullptr;
+  this->fragmentShader = nullptr;
 }
 
 void
diff --git a/coin4/src/shaders/SoGLCgShaderObject.cpp b/coin4/src/shaders/SoGLCgShaderObject.cpp
index 61dde64..916a70e 100644
--- a/coin4/src/shaders/SoGLCgShaderObject.cpp
+++ b/coin4/src/shaders/SoGLCgShaderObject.cpp
@@ -32,14 +32,14 @@
 
 // *************************************************************************
 
-CGcontext SoGLCgShaderObject::cgContext = NULL;
+CGcontext SoGLCgShaderObject::cgContext = nullptr;
 int SoGLCgShaderObject::instanceCount = 0;
 
 SoGLCgShaderObject::SoGLCgShaderObject(const uint32_t cachecontext)
   : SoGLShaderObject(cachecontext)
 {
   SoGLCgShaderObject::instanceCount++;
-  this->cgProgram = NULL;
+  this->cgProgram = nullptr;
 }
 
 SoGLCgShaderObject::~SoGLCgShaderObject()
@@ -78,7 +78,7 @@ SoGLCgShaderObject::load(const char* sourceString)
   this->cgProfile = getProfile();
   //cgGLSetOptimalOptions(this->cgProfile);
 
-  glue_cgSetErrorCallback(NULL);
+  glue_cgSetErrorCallback(nullptr);
   glue_cgGetError(); // remove last error from stack
 
   this->cgProgram =
@@ -87,7 +87,7 @@ SoGLCgShaderObject::load(const char* sourceString)
                          sourceString,
                          this->cgProfile,
                          "main", // entry's function name
-                         NULL); // argument names
+                         nullptr); // argument names
   errorCode = glue_cgGetError();
 
   if (errorCode == CG_NO_ERROR) {
@@ -110,7 +110,7 @@ SoGLCgShaderObject::unload(void)
 {
   if (glue_cgIsProgram(this->cgProgram)) {
     glue_cgDestroyProgram(this->cgProgram);
-    this->cgProgram = NULL;
+    this->cgProgram = nullptr;
   }
 }
 
diff --git a/coin4/src/shaders/SoGLCgShaderParameter.cpp b/coin4/src/shaders/SoGLCgShaderParameter.cpp
index 39380b1..81e30ca 100644
--- a/coin4/src/shaders/SoGLCgShaderParameter.cpp
+++ b/coin4/src/shaders/SoGLCgShaderParameter.cpp
@@ -35,7 +35,7 @@
 
 SoGLCgShaderParameter::SoGLCgShaderParameter(void)
 {
-  this->cgParameter = NULL;
+  this->cgParameter = nullptr;
   this->cacheType = CG_UNKNOWN_TYPE;
   this->cacheName = "";
   this->cacheSize = 0;
diff --git a/coin4/src/shaders/SoGLCgShaderProgram.cpp b/coin4/src/shaders/SoGLCgShaderProgram.cpp
index 5a45a51..51be0fa 100644
--- a/coin4/src/shaders/SoGLCgShaderProgram.cpp
+++ b/coin4/src/shaders/SoGLCgShaderProgram.cpp
@@ -32,8 +32,8 @@
 
 SoGLCgShaderProgram::SoGLCgShaderProgram(void)
 {
-  this->fragmentShader = NULL;
-  this->vertexShader = NULL;
+  this->fragmentShader = nullptr;
+  this->vertexShader = nullptr;
 }
 
 SoGLCgShaderProgram::~SoGLCgShaderProgram()
@@ -55,8 +55,8 @@ SoGLCgShaderProgram::addShaderObject(SoGLCgShaderObject * shaderObject)
 void
 SoGLCgShaderProgram::removeShaderObjects(void)
 {
-  this->vertexShader = NULL;
-  this->fragmentShader = NULL;
+  this->vertexShader = nullptr;
+  this->fragmentShader = nullptr;
 }
 
 void
diff --git a/coin4/src/shaders/SoGLSLShaderObject.cpp b/coin4/src/shaders/SoGLSLShaderObject.cpp
index 93f4970..26e34de 100644
--- a/coin4/src/shaders/SoGLSLShaderObject.cpp
+++ b/coin4/src/shaders/SoGLSLShaderObject.cpp
@@ -98,7 +98,7 @@ SoGLSLShaderObject::load(const char* srcStr)
   if (this->shaderHandle == 0) return;
   this->programid = soglshaderobject_idcounter++;
 
-  this->glctx->glShaderSourceARB(this->shaderHandle, 1, (const COIN_GLchar **)&srcStr, NULL);
+  this->glctx->glShaderSourceARB(this->shaderHandle, 1, (const COIN_GLchar **)&srcStr, nullptr);
   this->glctx->glCompileShaderARB(this->shaderHandle);
 
   if (SoGLSLShaderObject::didOpenGLErrorOccur("SoGLSLShaderObject::load()")) {
diff --git a/coin4/src/shaders/SoGLSLShaderParameter.h b/coin4/src/shaders/SoGLSLShaderParameter.h
index 8dbe8e9..2f10902 100644
--- a/coin4/src/shaders/SoGLSLShaderParameter.h
+++ b/coin4/src/shaders/SoGLSLShaderParameter.h
@@ -30,7 +30,7 @@
 
 // *************************************************************************
 
-#include <stddef.h> // NULL
+#include <stddef.h> // nullptr
 
 #include <Inventor/SbString.h>
 
@@ -80,7 +80,7 @@ private:
   int32_t programid;
 
   bool isValid(const SoGLShaderObject * shader, const char * name,
-                 GLenum type, int * num = NULL);
+                 GLenum type, int * num = nullptr);
 };
 
 #endif /* ! COIN_SOGLSLSHADERPARAMETER_H */
diff --git a/coin4/src/shaders/SoGLSLShaderProgram.cpp b/coin4/src/shaders/SoGLSLShaderProgram.cpp
index 8bf6e77..dea894a 100644
--- a/coin4/src/shaders/SoGLSLShaderProgram.cpp
+++ b/coin4/src/shaders/SoGLSLShaderProgram.cpp
@@ -83,7 +83,7 @@ SoGLSLShaderProgram::deletePrograms(void)
 void
 SoGLSLShaderProgram::addShaderObject(SoGLSLShaderObject *shaderObject)
 {
-  if (shaderObject!=NULL) {
+  if (shaderObject!=nullptr) {
     if (this->indexOfShaderObject(shaderObject) < 0) {
       this->shaderObjects.append(shaderObject);
     }
@@ -187,7 +187,7 @@ SoGLSLShaderProgram::ensureLinking(const cc_glglue * g)
 int
 SoGLSLShaderProgram::indexOfShaderObject(SoGLSLShaderObject *shaderObject)
 {
-  if (shaderObject == NULL) return -1;
+  if (shaderObject == nullptr) return -1;
 
   int cnt = this->shaderObjects.getLength();
   for (int i=0; i<cnt; i++) {
@@ -249,7 +249,7 @@ SoGLSLShaderProgram::updateCoinParameter(SoState * state, const SbName & name, c
 {
   const int n = this->shaderObjects.getLength();
   for (int i = 0; i < n; i++) {
-    this->shaderObjects[i]->updateCoinParameter(state, name, NULL, value);
+    this->shaderObjects[i]->updateCoinParameter(state, name, nullptr, value);
   }
 }
 
diff --git a/coin4/src/shaders/SoGLShaderProgram.cpp b/coin4/src/shaders/SoGLShaderProgram.cpp
index 22b53ef..474ea16 100644
--- a/coin4/src/shaders/SoGLShaderProgram.cpp
+++ b/coin4/src/shaders/SoGLShaderProgram.cpp
@@ -40,8 +40,8 @@ SoGLShaderProgram::SoGLShaderProgram(void)
   this->glslShaderProgram = new SoGLSLShaderProgram;
 
   this->isenabled = false;
-  this->enablecb = NULL;
-  this->enablecbclosure = NULL;
+  this->enablecb = nullptr;
+  this->enablecbclosure = nullptr;
 }
 
 SoGLShaderProgram::~SoGLShaderProgram()
diff --git a/coin4/src/shaders/SoGLShaderProgramElement.cpp b/coin4/src/shaders/SoGLShaderProgramElement.cpp
index 9e321fc..adba831 100644
--- a/coin4/src/shaders/SoGLShaderProgramElement.cpp
+++ b/coin4/src/shaders/SoGLShaderProgramElement.cpp
@@ -42,14 +42,14 @@ SoGLShaderProgramElement::initClass(void)
 
 SoGLShaderProgramElement::~SoGLShaderProgramElement()
 {
-  this->shaderProgram = NULL;
+  this->shaderProgram = nullptr;
 }
 
 void
 SoGLShaderProgramElement::init(SoState *state)
 {
   inherited::init(state);
-  this->shaderProgram = NULL;
+  this->shaderProgram = nullptr;
   this->enabled = false;
 }
 
@@ -131,7 +131,7 @@ SoGLShaderProgramElement::pop(SoState * state, const SoElement * prevTopElement)
       else this->shaderProgram->disable(state);
     }
   }
-  elem->shaderProgram = NULL;
+  elem->shaderProgram = nullptr;
 }
 
 
diff --git a/coin4/src/shaders/SoShader.cpp b/coin4/src/shaders/SoShader.cpp
index 7c6fa02..e2d6a55 100644
--- a/coin4/src/shaders/SoShader.cpp
+++ b/coin4/src/shaders/SoShader.cpp
@@ -198,9 +198,9 @@
 
 // *************************************************************************
 
-static const char * SO_SHADER_DIR = NULL;
-static SbHash<const char *, char *> * shader_dict = NULL;
-static SbHash<const char *, char *> * shader_builtin_dict = NULL;
+static const char * SO_SHADER_DIR = nullptr;
+static SbHash<const char *, char *> * shader_dict = nullptr;
+static SbHash<const char *, char *> * shader_builtin_dict = nullptr;
 
 static void
 soshader_cleanup(void)
@@ -315,7 +315,7 @@ SoShader::init(void)
 const char *
 SoShader::getNamedScript(const SbName & name, const Type type)
 {
-  char * shader = NULL;
+  char * shader = nullptr;
 
   if (SO_SHADER_DIR) {
     SbString filename(SO_SHADER_DIR);
@@ -358,7 +358,7 @@ SoShader::getNamedScript(const SbName & name, const Type type)
         fclose(fp);
       }
       else {
-        shader_dict->put(shadername, NULL);
+        shader_dict->put(shadername, nullptr);
         SoDebugError::postWarning("SoShader::getNamedScript",
                                   "Unable to find shader: %s",
                                   filename.getString());
diff --git a/coin4/src/shaders/SoShaderObject.cpp b/coin4/src/shaders/SoShaderObject.cpp
index ddfae1d..6527ecb 100644
--- a/coin4/src/shaders/SoShaderObject.cpp
+++ b/coin4/src/shaders/SoShaderObject.cpp
@@ -133,9 +133,9 @@ public:
   void GLRender(SoGLRenderAction *action);
 
   SoGLShaderObject * getGLShaderObject(const uint32_t cachecontext) {
-    SoGLShaderObject * obj = NULL;
+    SoGLShaderObject * obj = nullptr;
     if (this->glshaderobjects.get(cachecontext, obj)) return obj;
-    return NULL;
+    return nullptr;
   }
   void setGLShaderObject(SoGLShaderObject * obj, const uint32_t cachecontext) {
     SoGLShaderObject * oldshader;
@@ -149,7 +149,7 @@ public:
     SbList <uint32_t> keylist;
     this->glshaderobjects.makeKeyList(keylist);
     for (int i = 0; i < keylist.getLength(); i++) {
-      SoGLShaderObject * glshader = NULL;
+      SoGLShaderObject * glshader = nullptr;
       (void) this->glshaderobjects.get(keylist[i], glshader);
       SoGLCacheContextElement::scheduleDeleteCallback(glshader->getCacheContext(),
                                                       really_delete_object, glshader);
@@ -181,7 +181,7 @@ public:
     SbList <uint32_t> keylist;
     this->glshaderobjects.makeKeyList(keylist);
     for (int i = 0; i < keylist.getLength(); i++) {
-      SoGLShaderObject * glshader = NULL;
+      SoGLShaderObject * glshader = nullptr;
       (void) this->glshaderobjects.get(keylist[i], glshader);
       glshader->setParametersDirty(true);
     }
@@ -250,7 +250,7 @@ SoShaderObject::SoShaderObject(void)
   SO_NODE_SET_SF_ENUM_TYPE(sourceType, SourceType);
 
   SO_NODE_ADD_FIELD(sourceProgram, (""));
-  SO_NODE_ADD_FIELD(parameter, (NULL));
+  SO_NODE_ADD_FIELD(parameter, (nullptr));
   this->parameter.setNum(0);
   this->parameter.setDefault(true);
 
@@ -401,7 +401,7 @@ SoShaderObjectP::GLRender(SoGLRenderAction * action)
   if (this->owner->sourceProgram.isDefault() ||
       this->owner->sourceProgram.getValue().getLength() == 0) { return; }
 
-  if (shaderobject == NULL) {
+  if (shaderobject == nullptr) {
     if (this->shouldload) {
       this->checkType(); // set this->cachedSourceType
       this->readSource(); // set this->cachedSourceProgram
@@ -626,7 +626,7 @@ SoShaderObjectP::updateParameters(const uint32_t cachecontext, int start, int nu
   if (start < 0 || num < 0) return;
 
   SoGLShaderObject * shaderobject = this->getGLShaderObject(cachecontext);
-  if ((shaderobject == NULL) || !shaderobject->getParametersDirty()) return;
+  if ((shaderobject == nullptr) || !shaderobject->getParametersDirty()) return;
 
   int cnt = this->owner->parameter.getNum();
   int end = start+num;
@@ -655,32 +655,32 @@ SoShaderObjectP::updateCoinParameters(const uint32_t cachecontext, SoState * sta
       if (name == "coin_texunit0_model") {
         SoMultiTextureImageElement::Model model;
         SbColor dummy;
-        bool tex = SoGLMultiTextureImageElement::get(state, model, dummy) != NULL;
-        shaderobject->updateCoinParameter(state, name, NULL, tex ? model : 0);
+        bool tex = SoGLMultiTextureImageElement::get(state, model, dummy) != nullptr;
+        shaderobject->updateCoinParameter(state, name, nullptr, tex ? model : 0);
       }
       else if (name == "coin_texunit1_model") {
         SoMultiTextureImageElement::Model model;
         SbColor dummy;
-        bool tex = SoGLMultiTextureImageElement::get(state, 1, model, dummy) != NULL;
-        shaderobject->updateCoinParameter(state, name, NULL, tex ? model : 0);
+        bool tex = SoGLMultiTextureImageElement::get(state, 1, model, dummy) != nullptr;
+        shaderobject->updateCoinParameter(state, name, nullptr, tex ? model : 0);
       }
       else if (name == "coin_texunit2_model") {
         SoMultiTextureImageElement::Model model;
         SbColor dummy;
-        bool tex = SoGLMultiTextureImageElement::get(state, 2, model, dummy) != NULL;
-        shaderobject->updateCoinParameter(state, name, NULL, tex ? model : 0);
+        bool tex = SoGLMultiTextureImageElement::get(state, 2, model, dummy) != nullptr;
+        shaderobject->updateCoinParameter(state, name, nullptr, tex ? model : 0);
       }
       else if (name == "coin_texunit3_model") {
         SoMultiTextureImageElement::Model model;
         SbColor dummy;
-        bool tex = SoGLMultiTextureImageElement::get(state, 3, model, dummy) != NULL;
-        shaderobject->updateCoinParameter(state, name, NULL, tex ? model : 0);
+        bool tex = SoGLMultiTextureImageElement::get(state, 3, model, dummy) != nullptr;
+        shaderobject->updateCoinParameter(state, name, nullptr, tex ? model : 0);
       }
       else if (name == "coin_light_model") {
-        shaderobject->updateCoinParameter(state, name, NULL, SoLazyElement::getLightModel(state));
+        shaderobject->updateCoinParameter(state, name, nullptr, SoLazyElement::getLightModel(state));
       }
       else if (name == "coin_two_sided_lighting") {
-        shaderobject->updateCoinParameter(state, name, NULL, SoLazyElement::getTwoSidedLighting(state));
+        shaderobject->updateCoinParameter(state, name, nullptr, SoLazyElement::getTwoSidedLighting(state));
       }
     }
   }
@@ -693,7 +693,7 @@ SoShaderObjectP::updateAllParameters(const uint32_t cachecontext)
   if (!this->owner->isActive.getValue()) return;
 
   SoGLShaderObject * shaderobject = this->getGLShaderObject(cachecontext);
-  if ((shaderobject == NULL) || !shaderobject->getParametersDirty()) return;
+  if ((shaderobject == nullptr) || !shaderobject->getParametersDirty()) return;
 
   int i, cnt = this->owner->parameter.getNum();
 
@@ -713,7 +713,7 @@ SoShaderObjectP::updateStateMatrixParameters(const uint32_t cachecontext)
   if (!this->owner->isActive.getValue()) return;
 
   SoGLShaderObject * shaderobject = this->getGLShaderObject(cachecontext);
-  if (shaderobject == NULL) return;
+  if (shaderobject == nullptr) return;
 
   int i, cnt = this->owner->parameter.getNum();
   for (i= 0; i <cnt; i++) {
diff --git a/coin4/src/shaders/SoShaderParameter.cpp b/coin4/src/shaders/SoShaderParameter.cpp
index 33611e0..413a27e 100644
--- a/coin4/src/shaders/SoShaderParameter.cpp
+++ b/coin4/src/shaders/SoShaderParameter.cpp
@@ -153,7 +153,7 @@ SoUniformShaderParameter::getGLShaderParameter(const uint32_t cachecontext)
 {
   SoGLShaderParameter * glparam;
   if (PRIVATE(this)->glparams.get(cachecontext, glparam)) return glparam;
-  return NULL;
+  return nullptr;
 }
 
 
@@ -423,7 +423,7 @@ void SoShaderParameterArray2f::updateParameter(SoGLShaderObject *shader)
   this->ensureParameter(shader);
 
   int     num    = this->value.getNum();
-  float * buffer = NULL;
+  float * buffer = nullptr;
 
   if (num > 0) {
     buffer = new float[2*num];
@@ -467,7 +467,7 @@ void SoShaderParameterArray3f::updateParameter(SoGLShaderObject *shader)
   this->ensureParameter(shader);
 
   int     num    = this->value.getNum();
-  float * buffer = NULL;
+  float * buffer = nullptr;
 
   if (num > 0) {
     buffer = new float[3*num];
@@ -511,7 +511,7 @@ void SoShaderParameterArray4f::updateParameter(SoGLShaderObject *shader)
   this->ensureParameter(shader);
 
   int     num    = this->value.getNum();
-  float * buffer = NULL;
+  float * buffer = nullptr;
 
   if (num > 0) {
     buffer = new float[4*num];
@@ -594,7 +594,7 @@ void SoShaderParameterMatrixArray::updateParameter(SoGLShaderObject *shader)
   this->ensureParameter(shader);
 
   int     num    = this->value.getNum();
-  float * buffer = NULL;
+  float * buffer = nullptr;
 
   if (num > 0) {
     buffer = new float[16*num];
diff --git a/coin4/src/shaders/SoShaderProgram.cpp b/coin4/src/shaders/SoShaderProgram.cpp
index 1d913cc..2f12a72 100644
--- a/coin4/src/shaders/SoShaderProgram.cpp
+++ b/coin4/src/shaders/SoShaderProgram.cpp
@@ -256,14 +256,14 @@ SoShaderProgram::SoShaderProgram(void)
 {
   SO_NODE_INTERNAL_CONSTRUCTOR(SoShaderProgram);
 
-  SO_NODE_ADD_FIELD(shaderObject, (NULL));
+  SO_NODE_ADD_FIELD(shaderObject, (nullptr));
   this->shaderObject.setNum(0);
   this->shaderObject.setDefault(true);
 
 
   PRIVATE(this) = new SoShaderProgramP(this);
-  PRIVATE(this)->enablecb = NULL;
-  PRIVATE(this)->enablecbclosure = NULL;
+  PRIVATE(this)->enablecb = nullptr;
+  PRIVATE(this)->enablecbclosure = nullptr;
 }
 
 /*!
@@ -345,7 +345,7 @@ SoShaderProgramP::GLRender(SoGLRenderAction * action)
 
   int i, cnt = PUBLIC(this)->shaderObject.getNum();
   if (cnt == 0) {
-    SoGLShaderProgramElement::set(state, PUBLIC(this), NULL);
+    SoGLShaderProgramElement::set(state, PUBLIC(this), nullptr);
     return;
   }
   // FIXME: (Martin 2004-09-21) find an alternative to invalidating the cache
diff --git a/coin4/src/shadows/SoShadowCulling.cpp b/coin4/src/shadows/SoShadowCulling.cpp
index 753e18a..57efca1 100644
--- a/coin4/src/shadows/SoShadowCulling.cpp
+++ b/coin4/src/shadows/SoShadowCulling.cpp
@@ -124,16 +124,16 @@ SoShadowCulling::GLRender(SoGLRenderAction * action)
     SoGLShadowCullingElement::set(state, this, mode);
     
     if (mode == NO_CULLING) {
-      SoShapeHintsElement::set(state, NULL, 
+      SoShapeHintsElement::set(state, nullptr, 
                                SoShapeHintsElement::UNKNOWN_ORDERING,
                                SoShapeHintsElement::UNKNOWN_SHAPE_TYPE,
                                SoShapeHintsElement::UNKNOWN_FACE_TYPE);
-      SoOverrideElement::setShapeHintsOverride(state, NULL, true);
+      SoOverrideElement::setShapeHintsOverride(state, nullptr, true);
     }
     else {
       // FIXME: need to restore the previous ShapeHints settings in some way,
       // or require that this node is used only inside a separator
-      SoOverrideElement::setShapeHintsOverride(state, NULL, false);
+      SoOverrideElement::setShapeHintsOverride(state, nullptr, false);
     }
   }
 }
diff --git a/coin4/src/shadows/SoShadowDirectionalLight.cpp b/coin4/src/shadows/SoShadowDirectionalLight.cpp
index 2f71f17..8cbcceb 100644
--- a/coin4/src/shadows/SoShadowDirectionalLight.cpp
+++ b/coin4/src/shadows/SoShadowDirectionalLight.cpp
@@ -97,7 +97,7 @@
 /*!
   \var SoSFNode SoShadowGroup::shadowMapScene
 
-  The shadow map scene graph. If this is NULL (the default), the node
+  The shadow map scene graph. If this is nullptr (the default), the node
   will behave as a normal SoDirectionalLight node.
 
 */
@@ -142,7 +142,7 @@ SO_NODE_SOURCE(SoShadowDirectionalLight);
 SoShadowDirectionalLight::SoShadowDirectionalLight(void)
 {
   SO_NODE_INTERNAL_CONSTRUCTOR(SoShadowDirectionalLight);
-  SO_NODE_ADD_FIELD(shadowMapScene, (NULL));
+  SO_NODE_ADD_FIELD(shadowMapScene, (nullptr));
   SO_NODE_ADD_FIELD(maxShadowDistance, (-1.0f));
   SO_NODE_ADD_FIELD(bboxCenter, (0.0f, 0.0f, 0.0f));
   SO_NODE_ADD_FIELD(bboxSize, (-1.0f, -1.0f, -1.0f));
diff --git a/coin4/src/shadows/SoShadowGroup.cpp b/coin4/src/shadows/SoShadowGroup.cpp
index 96adb1a..c3a655d 100644
--- a/coin4/src/shadows/SoShadowGroup.cpp
+++ b/coin4/src/shadows/SoShadowGroup.cpp
@@ -367,10 +367,10 @@ public:
     const int TEXSIZE = coin_geq_power_of_two((int) (sg->precision.getValue() * SbMin(maxsize, maxtexsize)));
 
     this->lightid = -1;
-    this->vsm_program = NULL;
-    this->vsm_farval = NULL;
-    this->vsm_nearval = NULL;
-    this->gaussmap = NULL;
+    this->vsm_program = nullptr;
+    this->vsm_farval = nullptr;
+    this->vsm_nearval = nullptr;
+    this->gaussmap = nullptr;
     this->texunit = -1;
     this->bboxnode = new SoSeparator;
     this->bboxnode->ref();
@@ -603,15 +603,15 @@ public:
     matrixaction(SbViewportRegion(SbVec2s(100,100))),
     shadowlightsvalid(false),
     needscenesearch(true),
-    shaderprogram(NULL),
-    vertexshader(NULL),
-    fragmentshader(NULL),
-    vertexshadercache(NULL),
-    fragmentshadercache(NULL),
-    texunit0(NULL),
-    texunit1(NULL),
-    lightmodel(NULL),
-    twosided(NULL),
+    shaderprogram(nullptr),
+    vertexshader(nullptr),
+    fragmentshader(nullptr),
+    vertexshadercache(nullptr),
+    fragmentshadercache(nullptr),
+    texunit0(nullptr),
+    texunit1(nullptr),
+    lightmodel(nullptr),
+    twosided(nullptr),
     numtexunitsinscene(1),
     hasclipplanes(false),
     subgraphsearchenabled(true)
@@ -1895,7 +1895,7 @@ SoShadowGroupP::setFragmentShader(SoState * state)
   texmap->name = str;
   texmap->value = 0;
 
-  SoShaderParameter1i * texmap1 = NULL;
+  SoShaderParameter1i * texmap1 = nullptr;
 
   if (!this->texunit0) {
     this->texunit0 = new SoShaderParameter1i;
@@ -2300,13 +2300,13 @@ SoShadowLightCache::shadowmap_glcallback(void * COIN_UNUSED_ARG(closure), SoActi
     SoState * state = action->getState();
     SoLazyElement::setLightModel(state, SoLazyElement::BASE_COLOR);
     SoTextureQualityElement::set(state, 0.0f);
-    SoMaterialBindingElement::set(state, NULL, SoMaterialBindingElement::OVERALL);
-    SoNormalElement::set(state, NULL, 0, NULL, false);
+    SoMaterialBindingElement::set(state, nullptr, SoMaterialBindingElement::OVERALL);
+    SoNormalElement::set(state, nullptr, 0, nullptr, false);
 
 
-    SoOverrideElement::setNormalVectorOverride(state, NULL, true);
-    SoOverrideElement::setMaterialBindingOverride(state, NULL, true);
-    SoOverrideElement::setLightModelOverride(state, NULL, true);
+    SoOverrideElement::setNormalVectorOverride(state, nullptr, true);
+    SoOverrideElement::setMaterialBindingOverride(state, nullptr, true);
+    SoOverrideElement::setLightModelOverride(state, nullptr, true);
     SoTextureOverrideElement::setQualityOverride(state, true);
   }
 }
diff --git a/coin4/src/shadows/SoShadowSpotLight.cpp b/coin4/src/shadows/SoShadowSpotLight.cpp
index dff64f8..220c02e 100644
--- a/coin4/src/shadows/SoShadowSpotLight.cpp
+++ b/coin4/src/shadows/SoShadowSpotLight.cpp
@@ -44,7 +44,7 @@
   <b>FILE FORMAT/DEFAULTS:</b>
   \code
     ShadowSpotLight {
-      shadowMapScene NULL
+      shadowMapScene nullptr
       nearDistance -1
       farDistance -1
     }
@@ -108,7 +108,7 @@
 /*!
   \var SoSFNode SoShadowGroup::shadowMapScene
   
-  The shadow map scene graph. If this is NULL (the default), the node
+  The shadow map scene graph. If this is nullptr (the default), the node
   will behave as a normal SoSpotLight node.  
 
 */
@@ -149,7 +149,7 @@ SO_NODE_SOURCE(SoShadowSpotLight);
 SoShadowSpotLight::SoShadowSpotLight(void)
 {
   SO_NODE_INTERNAL_CONSTRUCTOR(SoShadowSpotLight);
-  SO_NODE_ADD_FIELD(shadowMapScene, (NULL));
+  SO_NODE_ADD_FIELD(shadowMapScene, (nullptr));
   SO_NODE_ADD_FIELD(nearDistance, (-1.0f));
   SO_NODE_ADD_FIELD(farDistance, (-1.0f));
 }
diff --git a/coin4/src/shadows/SoShadowStyleElement.cpp b/coin4/src/shadows/SoShadowStyleElement.cpp
index 0623938..1511a08 100644
--- a/coin4/src/shadows/SoShadowStyleElement.cpp
+++ b/coin4/src/shadows/SoShadowStyleElement.cpp
@@ -83,7 +83,7 @@ SoShadowStyleElement::init(SoState * state)
 void
 SoShadowStyleElement::set(SoState * const state, const int style)
 {
-  SoShadowStyleElement::set(state, NULL, style);
+  SoShadowStyleElement::set(state, nullptr, style);
 }
 
 //! FIXME: write doc.
diff --git a/coin4/src/shapenodes/SoAsciiText.cpp b/coin4/src/shapenodes/SoAsciiText.cpp
index abd4ebc..7bf0b55 100644
--- a/coin4/src/shapenodes/SoAsciiText.cpp
+++ b/coin4/src/shapenodes/SoAsciiText.cpp
@@ -277,7 +277,7 @@ SoAsciiText::SoAsciiText(void)
   SO_NODE_SET_SF_ENUM_TYPE(justification, Justification);
 
   PRIVATE(this) = new SoAsciiTextP(this);
-  PRIVATE(this)->cache = NULL;
+  PRIVATE(this)->cache = nullptr;
 }
 
 /*!
@@ -373,7 +373,7 @@ SoAsciiText::GLRender(SoGLRenderAction * action)
     }
 
     SbString str = this->string[i];
-    cc_glyph3d * prevglyph = NULL;
+    cc_glyph3d * prevglyph = nullptr;
     const char * p = str.getString();
     size_t length = cc_string_utf8_validate_length(p);
     //    assert(length);
@@ -433,7 +433,7 @@ SoAsciiText::GLRender(SoGLRenderAction * action)
     }
     if (prevglyph) {
       cc_glyph3d_unref(prevglyph);
-      prevglyph = NULL;
+      prevglyph = nullptr;
     }
 
     ypos -= fontspec->size * this->spacing.getValue();
@@ -516,7 +516,7 @@ void SoAsciiTextP::calculateStringStretch(const int i, const cc_font_specificati
   // Approximate the stretchfactor
   stretchfactor = master->width[i] / this->stringwidths[i];
 
-  cc_glyph3d * prevglyph = NULL;
+  cc_glyph3d * prevglyph = nullptr;
   float originalmaxx = 0.0f;
   float originalmaxxpos = 0.0f;
   float originalxpos = 0.0f;
@@ -572,7 +572,7 @@ void SoAsciiTextP::calculateStringStretch(const int i, const cc_font_specificati
 
   // Unreference the last glyph
   cc_glyph3d_unref(prevglyph);
-  prevglyph = NULL;
+  prevglyph = nullptr;
   
   // Calculate the accurate stretchfactor and the width of the
   // string. This should be close to the specified width unless the
@@ -694,7 +694,7 @@ SoAsciiText::generatePrimitives(SoAction * action)
   vertex.setDetail(&detail);
   vertex.setMaterialIndex(0);
 
-  this->beginShape(action, SoShape::TRIANGLES, NULL);
+  this->beginShape(action, SoShape::TRIANGLES, nullptr);
   vertex.setNormal(SbVec3f(0.0f, 0.0f, 1.0f));
 
   float ypos = 0.0f;
@@ -716,7 +716,7 @@ SoAsciiText::generatePrimitives(SoAction * action)
     }
     
     SbString str = this->string[i];
-    cc_glyph3d * prevglyph = NULL;
+    cc_glyph3d * prevglyph = nullptr;
     const char * p = str.getString();
     size_t length = cc_string_utf8_validate_length(p);
     //    assert(length);
@@ -779,7 +779,7 @@ SoAsciiText::generatePrimitives(SoAction * action)
     ypos -= fontspec->size * this->spacing.getValue();
     if (prevglyph) {
       cc_glyph3d_unref(prevglyph);
-      prevglyph = NULL;
+      prevglyph = nullptr;
     }
   }
   this->endShape();
@@ -850,7 +850,7 @@ SoAsciiTextP::setUpGlyphs(SoState * state, SoAsciiText * textnode)
   float kerningy = 0;
   float advancex = 0;
   float advancey = 0;
-  cc_glyph3d * prevglyph = NULL;
+  cc_glyph3d * prevglyph = nullptr;
 
   for (int i = 0; i < textnode->string.getNum(); i++) {
     float stringwidth = 0.0f;
@@ -891,7 +891,7 @@ SoAsciiTextP::setUpGlyphs(SoState * state, SoAsciiText * textnode)
     if (prevglyph) {
       // Have to remove the appended advance and add the last character to the calculated with
       stringwidth += (cc_glyph3d_getwidth(prevglyph) - advancex) * fontspecptr->size;
-      prevglyph = NULL; // To make sure the next line starts with blank sheets
+      prevglyph = nullptr; // To make sure the next line starts with blank sheets
     }
 
     this->stringwidths.append(stringwidth);
diff --git a/coin4/src/shapenodes/SoFaceSet.cpp b/coin4/src/shapenodes/SoFaceSet.cpp
index bcfe1dc..6ab458d 100644
--- a/coin4/src/shapenodes/SoFaceSet.cpp
+++ b/coin4/src/shapenodes/SoFaceSet.cpp
@@ -169,7 +169,7 @@ SO_NODE_SOURCE(SoFaceSet);
 SoFaceSet::SoFaceSet()
 {
   PRIVATE(this) = new SoFaceSetP;
-  PRIVATE(this)->convexCache = NULL;
+  PRIVATE(this)->convexCache = nullptr;
   PRIVATE(this)->concavestatus = STATUS_UNKNOWN;
   PRIVATE(this)->primitivetype = UNKNOWN_TYPE;
 
@@ -295,8 +295,8 @@ namespace { namespace SoGL { namespace FaceSet {
     // Make sure specified coordinate startindex is valid
     assert(idx >= 0);
 
-    const SbVec3f * coords3d = NULL;
-    const SbVec4f * coords4d = NULL;
+    const SbVec3f * coords3d = nullptr;
+    const SbVec4f * coords4d = nullptr;
     const bool is3d = coords->is3D();
     if (is3d) {
       coords3d = coords->getArrayPtr3();
@@ -526,9 +526,9 @@ SoFaceSet::GLRender(SoGLRenderAction * action)
 
     if (!needNormals) nbind = OVERALL;
 
-    SoNormalCache * nc = NULL;
+    SoNormalCache * nc = nullptr;
 
-    if (needNormals && normals == NULL) {
+    if (needNormals && normals == nullptr) {
       nc = this->generateAndReadLockNormalCache(state);
       normals = nc->getNormals();
     }
@@ -567,7 +567,7 @@ SoFaceSet::GLRender(SoGLRenderAction * action)
         !tb.isFunction()) {
       bool dovbo = this->startVertexArray(action,
                                             coords,
-                                            nbind == PER_VERTEX ? normals : NULL,
+                                            nbind == PER_VERTEX ? normals : nullptr,
                                             doTextures,
                                             (mbind == PER_VERTEX));
       int numprimitives = this->numVertices.getNum();
@@ -764,9 +764,9 @@ SoFaceSet::generatePrimitives(SoAction *action)
   Binding mbind = this->findMaterialBinding(state);
   Binding nbind = this->findNormalBinding(state);
 
-  SoNormalCache * nc = NULL;
+  SoNormalCache * nc = nullptr;
 
-  if (needNormals && normals == NULL) {
+  if (needNormals && normals == nullptr) {
     nc = this->generateAndReadLockNormalCache(state);
     normals = nc->getNormals();
   }
@@ -987,16 +987,16 @@ SoFaceSet::useConvexCache(SoAction * action)
     break;
   }
 
-  SoNormalCache * nc = NULL;
+  SoNormalCache * nc = nullptr;
 
-  if (needNormals && normals == NULL) {
+  if (needNormals && normals == nullptr) {
     nc = this->generateAndReadLockNormalCache(state);
     normals = nc->getNormals();
   }
   else if (!needNormals) {
     nbind = SoConvexDataCache::NONE;
   }
-  if (nbind == SoConvexDataCache::NONE && normals == NULL) {
+  if (nbind == SoConvexDataCache::NONE && normals == nullptr) {
     static SbVec3f dummynormal;
     dummynormal.setValue(0.0f, 0.0f, 1.0f);
     normals = &dummynormal;
@@ -1006,7 +1006,7 @@ SoFaceSet::useConvexCache(SoAction * action)
   if (tb.needCoordinates()) tbind = SoConvexDataCache::PER_VERTEX;
 
   if (!isvalid) {
-    SoCacheElement::set(state, NULL); // close cache
+    SoCacheElement::set(state, nullptr); // close cache
     // create an index table to be able to use convex cache.
     // should be fast compared to the tessellation
     const ptrdiff_t diff = end - ptr;
@@ -1021,7 +1021,7 @@ SoFaceSet::useConvexCache(SoAction * action)
     }
     PRIVATE(this)->convexCache->generate(coords, modelmatrix,
                                 dummyidx.getArrayPtr(), dummyidx.getLength(),
-                                NULL, NULL, NULL,
+                                nullptr, nullptr, nullptr,
                                 mbind,
                                 nbind,
                                 tbind);
diff --git a/coin4/src/shapenodes/SoImage.cpp b/coin4/src/shapenodes/SoImage.cpp
index 13bde34..7bb5705 100644
--- a/coin4/src/shapenodes/SoImage.cpp
+++ b/coin4/src/shapenodes/SoImage.cpp
@@ -251,7 +251,7 @@ SoImage::SoImage(void)
 
   SO_NODE_ADD_FIELD(vertAlignment, (SoImage::BOTTOM));
   SO_NODE_ADD_FIELD(horAlignment, (SoImage::LEFT));
-  SO_NODE_ADD_FIELD(image, (SbVec2s(0,0), 0, NULL));
+  SO_NODE_ADD_FIELD(image, (SbVec2s(0,0), 0, nullptr));
   SO_NODE_ADD_FIELD(filename, (""));
 
   SO_NODE_DEFINE_ENUM_VALUE(VertAlignment, BOTTOM);
@@ -325,7 +325,7 @@ SoImage::GLRender(SoGLRenderAction * action)
   if (size == SbVec2s(0,0)) return;
 
   const unsigned char * dataptr = this->image.getValue(orgsize, nc);
-  if (dataptr == NULL) return; // no image
+  if (dataptr == nullptr) return; // no image
 
   if (!this->shouldGLRender(action)) return;
 
@@ -478,7 +478,7 @@ SoImage::GLRender(SoGLRenderAction * action)
 
   glRasterPos3f(rpx, rpy, -nilpoint[2]);
 
-  if (offvp) { glBitmap(0,0,0,0,offsetx,offsety,NULL); }
+  if (offvp) { glBitmap(0,0,0,0,offsetx,offsety,nullptr); }
 
   glPixelStorei(GL_UNPACK_ROW_LENGTH, orgsize[0]);
   glPixelStorei(GL_UNPACK_SKIP_PIXELS, skipx);
@@ -811,7 +811,7 @@ SoImage::getImage(SbVec2s & size, int & nc)
   if (this->getSize() == SbVec2s(0,0)) {
     size = SbVec2s(0,0);
     nc = 0;
-    return NULL;
+    return nullptr;
   }
 
   if (this->width.getValue() >= 0 || this->height.getValue() >= 0) {
@@ -836,7 +836,7 @@ SoImage::getImage(SbVec2s & size, int & nc)
         this->resizedimagevalid = true;
       }
       else if (GLUWrapper()->available) {
-        this->resizedimage->setValue(newsize, nc, NULL);
+        this->resizedimage->setValue(newsize, nc, nullptr);
         const unsigned char * rezdata = this->resizedimage->getValue(newsize, nc);
         GLenum format;
         switch (nc) {
diff --git a/coin4/src/shapenodes/SoIndexedFaceSet.cpp b/coin4/src/shapenodes/SoIndexedFaceSet.cpp
index 981b468..24053b0 100644
--- a/coin4/src/shapenodes/SoIndexedFaceSet.cpp
+++ b/coin4/src/shapenodes/SoIndexedFaceSet.cpp
@@ -287,8 +287,8 @@ SO_NODE_SOURCE(SoIndexedFaceSet);
 SoIndexedFaceSet::SoIndexedFaceSet()
 {
   PRIVATE(this) = new SoIndexedFaceSetP;
-  PRIVATE(this)->convexCache = NULL;
-  PRIVATE(this)->vaindexer = NULL;
+  PRIVATE(this)->convexCache = nullptr;
+  PRIVATE(this)->vaindexer = nullptr;
   PRIVATE(this)->concavestatus = STATUS_UNKNOWN;
 
   SO_NODE_INTERNAL_CONSTRUCTOR(SoIndexedFaceSet);
@@ -403,7 +403,7 @@ SoIndexedFaceSet::notify(SoNotList * list)
     LOCK_VAINDEXER(this);
     if (PRIVATE(this)->vaindexer) {
       delete PRIVATE(this)->vaindexer;
-      PRIVATE(this)->vaindexer = NULL;
+      PRIVATE(this)->vaindexer = nullptr;
     }
     UNLOCK_VAINDEXER(this);
   }
@@ -482,18 +482,18 @@ SoIndexedFaceSet::GLRender(SoGLRenderAction * action)
   if (doTextures) {
     if (tb.isFunction() && !tb.needIndices()) {
       tbind = NONE;
-      tindices = NULL;
+      tindices = nullptr;
     }
     // FIXME: just call inherited::areTexCoordsIndexed() instead of
     // the if-check? 20020110 mortene.
     else if (SoTextureCoordinateBindingElement::get(state) ==
              SoTextureCoordinateBindingElement::PER_VERTEX) {
       tbind = PER_VERTEX;
-      tindices = NULL;
+      tindices = nullptr;
     }
     else {
       tbind = PER_VERTEX_INDEXED;
-      if (tindices == NULL) tindices = cindices;
+      if (tindices == nullptr) tindices = cindices;
     }
   }
 
@@ -523,23 +523,23 @@ SoIndexedFaceSet::GLRender(SoGLRenderAction * action)
 #endif
 
   const uint32_t contextid = action->getCacheContext();
-  SoGLLazyElement * lelem = NULL;
+  SoGLLazyElement * lelem = nullptr;
   bool dova =
     SoVBO::shouldRenderAsVertexArrays(state, contextid, numindices) &&
     !convexcacheused && !normalCacheUsed &&
-    ((nbind == OVERALL) || ((nbind == PER_VERTEX_INDEXED) && ((nindices == cindices) || (nindices == NULL)))) &&
+    ((nbind == OVERALL) || ((nbind == PER_VERTEX_INDEXED) && ((nindices == cindices) || (nindices == nullptr)))) &&
     ((tbind == NONE && !tb.needCoordinates()) || // no 
-     ((tbind == PER_VERTEX_INDEXED) && ((tindices == cindices) || (tindices == NULL)))) &&
-    ((mbind == NONE) || ((mbind == PER_VERTEX_INDEXED) && ((mindices == cindices) || (mindices == NULL)))) &&
+     ((tbind == PER_VERTEX_INDEXED) && ((tindices == cindices) || (tindices == nullptr)))) &&
+    ((mbind == NONE) || ((mbind == PER_VERTEX_INDEXED) && ((mindices == cindices) || (mindices == nullptr)))) &&
     SoGLDriverDatabase::isSupported(sogl_glue_instance(state), SO_GL_VERTEX_ARRAY);
 
   const SoGLVBOElement * vboelem = SoGLVBOElement::getInstance(state);
-  SoVBO * colorvbo = NULL;
+  SoVBO * colorvbo = nullptr;
 
   bool didrenderasvbo = false;
   if (dova && (mbind != OVERALL)) {
     dova = false;
-    if ((mbind == PER_VERTEX_INDEXED) && ((mindices == cindices) || (mindices == NULL))) {
+    if ((mbind == PER_VERTEX_INDEXED) && ((mindices == cindices) || (mindices == nullptr))) {
       lelem = (SoGLLazyElement*) SoLazyElement::getInstance(state);
       colorvbo = vboelem->getColorVBO();
       if (colorvbo) dova = true;
@@ -555,13 +555,13 @@ SoIndexedFaceSet::GLRender(SoGLRenderAction * action)
   if (dova) {
     bool dovbo = this->startVertexArray(action,
                                           coords,
-                                          (nbind != OVERALL) ? normals : NULL,
+                                          (nbind != OVERALL) ? normals : nullptr,
                                           doTextures,
                                           mbind != OVERALL);
     didrenderasvbo = dovbo;
 
     LOCK_VAINDEXER(this);
-    if (PRIVATE(this)->vaindexer == NULL) {
+    if (PRIVATE(this)->vaindexer == nullptr) {
       SoVertexArrayIndexer * indexer = new SoVertexArrayIndexer;
       int i = 0;
       while (i < numindices) {
@@ -745,25 +745,25 @@ SoIndexedFaceSet::generatePrimitives(SoAction *action)
   if (doTextures) {
     if (tb.isFunction() && !tb.needIndices()) {
       tbind = NONE;
-      tindices = NULL;
+      tindices = nullptr;
     }
     // FIXME: just call inherited::areTexCoordsIndexed() instead of
     // the if-check? 20020110 mortene.
     else if (SoTextureCoordinateBindingElement::get(state) ==
              SoTextureCoordinateBindingElement::PER_VERTEX) {
       tbind = PER_VERTEX;
-      tindices = NULL;
+      tindices = nullptr;
     }
     else {
       tbind = PER_VERTEX_INDEXED;
-      if (tindices == NULL) tindices = cindices;
+      if (tindices == nullptr) tindices = cindices;
     }
   }
 
-  if (nbind == PER_VERTEX_INDEXED && nindices == NULL) {
+  if (nbind == PER_VERTEX_INDEXED && nindices == nullptr) {
     nindices = cindices;
   }
-  if (mbind == PER_VERTEX_INDEXED && mindices == NULL) {
+  if (mbind == PER_VERTEX_INDEXED && mindices == nullptr) {
     mindices = cindices;
   }
 
@@ -938,7 +938,7 @@ SoIndexedFaceSet::getPrimitiveCount(SoGetPrimitiveCountAction *action)
 //
 // internal method which checks if convex cache needs to be
 // used or (re)created. Returns true if convex cache must be
-// used. this->convexCache is then guaranteed to be != NULL.
+// used. this->convexCache is then guaranteed to be != nullptr.
 //
 bool
 SoIndexedFaceSet::useConvexCache(SoAction * action,
@@ -1042,13 +1042,13 @@ SoIndexedFaceSet::useConvexCache(SoAction * action,
   }
   else {
     tbind = PER_VERTEX_INDEXED;
-    if (tindices == NULL) tindices = cindices;
+    if (tindices == nullptr) tindices = cindices;
   }
 
-  if (nbind == PER_VERTEX_INDEXED && nindices == NULL) {
+  if (nbind == PER_VERTEX_INDEXED && nindices == nullptr) {
     nindices = cindices;
   }
-  if (mbind == PER_VERTEX_INDEXED && mindices == NULL) {
+  if (mbind == PER_VERTEX_INDEXED && mindices == nullptr) {
     mindices = cindices;
   }
   PRIVATE(this)->convexCache->generate(coords, modelmatrix,
@@ -1101,7 +1101,7 @@ SoIndexedFaceSet::generateDefaultNormals(SoState * state,
                           coordIndex.getValues(0),
                           coordIndex.getNum(),
                           SoCreaseAngleElement::get(state, this->getNodeType() == SoNode::VRML1),
-                          NULL,
+                          nullptr,
                           -1,
                           ccw);
     break;
diff --git a/coin4/src/shapenodes/SoIndexedLineSet.cpp b/coin4/src/shapenodes/SoIndexedLineSet.cpp
index d0d4c77..7074eab 100644
--- a/coin4/src/shapenodes/SoIndexedLineSet.cpp
+++ b/coin4/src/shapenodes/SoIndexedLineSet.cpp
@@ -110,7 +110,7 @@ public:
 SoIndexedLineSet::SoIndexedLineSet()
 {
   PRIVATE(this) = new SoIndexedLineSetP;
-  PRIVATE(this)->vaindexer = NULL;
+  PRIVATE(this)->vaindexer = nullptr;
 
   SO_NODE_INTERNAL_CONSTRUCTOR(SoIndexedLineSet);
 }
@@ -256,7 +256,7 @@ SoIndexedLineSet::GLRender(SoGLRenderAction * action)
                 nindices, tindices, mindices, numindices,
                 sendNormals, normalCacheUsed);
 
-  if (sendNormals && normals == NULL) {
+  if (sendNormals && normals == nullptr) {
     if (!didpush) {
       state->push();
       didpush = true;
@@ -284,9 +284,9 @@ SoIndexedLineSet::GLRender(SoGLRenderAction * action)
   if (doTextures) {
     if (SoTextureCoordinateBindingElement::get(state) ==
         SoTextureCoordinateBindingElement::PER_VERTEX) {
-      tindices = NULL; // just in case
+      tindices = nullptr; // just in case
     }
-    else if (tindices == NULL) {
+    else if (tindices == nullptr) {
       tindices = cindices;
     }
   }
@@ -302,22 +302,22 @@ SoIndexedLineSet::GLRender(SoGLRenderAction * action)
     SoDrawStyleElement::get(state) == SoDrawStyleElement::POINTS;
 
   const uint32_t contextid = action->getCacheContext();
-  SoGLLazyElement * lelem = NULL;
+  SoGLLazyElement * lelem = nullptr;
 
   bool dova =
     !drawPoints &&
     SoVBO::shouldRenderAsVertexArrays(state, contextid, numindices) &&
-    ((nbind == OVERALL) || ((nbind == PER_VERTEX_INDEXED) && ((nindices == cindices) || (nindices == NULL)))) &&
+    ((nbind == OVERALL) || ((nbind == PER_VERTEX_INDEXED) && ((nindices == cindices) || (nindices == nullptr)))) &&
     (!doTextures || (tindices == cindices)) &&
-    ((mbind == OVERALL) || ((mbind == PER_VERTEX_INDEXED) && ((mindices == cindices) || (mindices == NULL)))) &&
+    ((mbind == OVERALL) || ((mbind == PER_VERTEX_INDEXED) && ((mindices == cindices) || (mindices == nullptr)))) &&
     SoGLDriverDatabase::isSupported(sogl_glue_instance(state), SO_GL_VERTEX_ARRAY);
 
   const SoGLVBOElement * vboelem = SoGLVBOElement::getInstance(state);
-  SoVBO * colorvbo = NULL;
+  SoVBO * colorvbo = nullptr;
 
   if (dova && (mbind != OVERALL)) {
     dova = false;
-    if ((mbind == PER_VERTEX_INDEXED) && ((mindices == cindices) || (mindices == NULL))) {
+    if ((mbind == PER_VERTEX_INDEXED) && ((mindices == cindices) || (mindices == nullptr))) {
       lelem = (SoGLLazyElement*) SoLazyElement::getInstance(state);
       colorvbo = vboelem->getColorVBO();
       if (colorvbo) dova = true;
@@ -334,12 +334,12 @@ SoIndexedLineSet::GLRender(SoGLRenderAction * action)
   if (dova) {
     bool dovbo = this->startVertexArray(action,
                                           coords,
-                                          nbind != OVERALL ? normals : NULL,
+                                          nbind != OVERALL ? normals : nullptr,
                                           doTextures,
                                           mbind != OVERALL);
     didrenderasvbo = dovbo;
     LOCK_VAINDEXER(this);
-    if (PRIVATE(this)->vaindexer == NULL) {
+    if (PRIVATE(this)->vaindexer == nullptr) {
       SoVertexArrayIndexer * indexer = new SoVertexArrayIndexer;
 
       int i = 0;
@@ -412,7 +412,7 @@ bool
 SoIndexedLineSet::generateDefaultNormals(SoState * COIN_UNUSED_ARG(state), SoNormalCache * nc)
 {
   // not possible to generate normals for IndexedLineSet
-  nc->set(0, NULL);
+  nc->set(0, nullptr);
   return true;
 }
 
@@ -486,7 +486,7 @@ SoIndexedLineSet::generatePrimitives(SoAction *action)
                 normindices, texindices, matindices, numindices,
                 sendNormals, normalCacheUsed);
 
-  if (normals == NULL) {
+  if (normals == nullptr) {
     sendNormals = false;
     nbind = OVERALL;
   }
@@ -510,28 +510,28 @@ SoIndexedLineSet::generatePrimitives(SoAction *action)
   if (doTextures) {
     if (SoTextureCoordinateBindingElement::get(state) ==
         SoTextureCoordinateBindingElement::PER_VERTEX) {
-      texindices = NULL; // just in case
+      texindices = nullptr; // just in case
     }
-    else if (texindices == NULL) {
+    else if (texindices == nullptr) {
       texindices = cindices;
     }
   }
 
-  if (mbind == PER_VERTEX_INDEXED && matindices == NULL) {
+  if (mbind == PER_VERTEX_INDEXED && matindices == nullptr) {
     matindices = cindices;
   }
-  if (nbind == PER_VERTEX_INDEXED && normindices == NULL) {
+  if (nbind == PER_VERTEX_INDEXED && normindices == nullptr) {
     normindices = cindices;
   }
   if (mbind == PER_VERTEX || mbind == PER_LINE || mbind == PER_SEGMENT) {
-    matindices = NULL;
+    matindices = nullptr;
   }
   if (nbind == PER_VERTEX || nbind == PER_LINE || nbind == PER_SEGMENT) {
-    normindices = NULL;
+    normindices = nullptr;
   }
 
-  if (nbind == OVERALL) normindices = NULL;
-  if (mbind == OVERALL) matindices = NULL;
+  if (nbind == OVERALL) normindices = nullptr;
+  if (mbind == OVERALL) matindices = nullptr;
 
   int matnr = 0;
   int normnr = 0;
@@ -769,7 +769,7 @@ SoIndexedLineSet::notify(SoNotList * list)
     LOCK_VAINDEXER(this);
     if (PRIVATE(this)->vaindexer) {
       delete PRIVATE(this)->vaindexer;
-      PRIVATE(this)->vaindexer = NULL;
+      PRIVATE(this)->vaindexer = nullptr;
     }
     UNLOCK_VAINDEXER(this);
   }
diff --git a/coin4/src/shapenodes/SoIndexedMarkerSet.cpp b/coin4/src/shapenodes/SoIndexedMarkerSet.cpp
index 57f1e7c..d938e34 100644
--- a/coin4/src/shapenodes/SoIndexedMarkerSet.cpp
+++ b/coin4/src/shapenodes/SoIndexedMarkerSet.cpp
@@ -186,7 +186,7 @@ SoIndexedMarkerSet::GLRender(SoGLRenderAction * action)
 
   mbind = this->findMaterialBinding(state);
   //if we don't have explicit material indices, use coord indices:
-  if (mbind == PER_VERTEX_INDEXED && mindices == NULL) mindices = cindices;
+  if (mbind == PER_VERTEX_INDEXED && mindices == nullptr) mindices = cindices;
 
   const SoGLCoordinateElement * glcoords = dynamic_cast<const SoGLCoordinateElement *>(coords);
   assert(glcoords && "could not cast to SoGLCoordinateElement");
diff --git a/coin4/src/shapenodes/SoIndexedNurbsCurve.cpp b/coin4/src/shapenodes/SoIndexedNurbsCurve.cpp
index 34e0d6e..1423de6 100644
--- a/coin4/src/shapenodes/SoIndexedNurbsCurve.cpp
+++ b/coin4/src/shapenodes/SoIndexedNurbsCurve.cpp
@@ -95,8 +95,8 @@ public:
   SoIndexedNurbsCurveP(SoIndexedNurbsCurve * m)
   {
     this->owner = m;
-    this->nurbsrenderer = NULL;
-    this->offscreenctx = NULL;
+    this->nurbsrenderer = nullptr;
+    this->offscreenctx = nullptr;
   }
 
   ~SoIndexedNurbsCurveP()
@@ -288,7 +288,7 @@ SoIndexedNurbsCurve::generatePrimitives(SoAction * action)
     // offscreen context to be guaranteed to have a valid GL context
     // before making the GLU calls.
 
-    if (PRIVATE(this)->offscreenctx == NULL) {
+    if (PRIVATE(this)->offscreenctx == nullptr) {
       PRIVATE(this)->offscreenctx = cc_glglue_context_create_offscreen(32, 32);
     }
 
@@ -307,7 +307,7 @@ SoIndexedNurbsCurve::createLineSegmentDetail(SoRayPickAction * /* action */,
                                              const SoPrimitiveVertex * /* v2 */,
                                              SoPickedPoint * /* pp */)
 {
-  return NULL;
+  return nullptr;
 }
 
 typedef SoNurbsP<SoIndexedNurbsCurve>::coin_nurbs_cbdata coin_inc_cbdata;
@@ -329,7 +329,7 @@ SoIndexedNurbsCurveP::doNurbs(SoAction * action,
     return;
   }
 
-  if (this->nurbsrenderer == NULL) {
+  if (this->nurbsrenderer == nullptr) {
     this->nurbsrenderer = GLUWrapper()->gluNewNurbsRenderer();
 
     if (GLUWrapper()->versionMatchesAtLeast(1, 3, 0)) {
@@ -354,7 +354,7 @@ SoIndexedNurbsCurveP::doNurbs(SoAction * action,
       cbdata.vertex.setMaterialIndex(0);
       cbdata.vertex.setTextureCoords(SbVec4f(0.0f, 0.0f, 0.0f, 1.0f));
       cbdata.vertex.setPoint(SbVec3f(0.0f, 0.0f, 0.0f));
-      cbdata.vertex.setDetail(NULL);
+      cbdata.vertex.setDetail(nullptr);
     }
   }
 
diff --git a/coin4/src/shapenodes/SoIndexedNurbsSurface.cpp b/coin4/src/shapenodes/SoIndexedNurbsSurface.cpp
index 92544be..29e15ff 100644
--- a/coin4/src/shapenodes/SoIndexedNurbsSurface.cpp
+++ b/coin4/src/shapenodes/SoIndexedNurbsSurface.cpp
@@ -123,8 +123,8 @@ public:
   SoIndexedNurbsSurfaceP(SoIndexedNurbsSurface * m)
   {
     this->owner = m;
-    this->nurbsrenderer = NULL;
-    this->offscreenctx = NULL;
+    this->nurbsrenderer = nullptr;
+    this->offscreenctx = nullptr;
   }
 
   ~SoIndexedNurbsSurfaceP()
@@ -309,7 +309,7 @@ SoIndexedNurbsSurface::generatePrimitives(SoAction * action)
     // offscreen context to be guaranteed to have a valid GL context
     // before making the GLU calls.
 
-    if (PRIVATE(this)->offscreenctx == NULL) {
+    if (PRIVATE(this)->offscreenctx == nullptr) {
       PRIVATE(this)->offscreenctx = cc_glglue_context_create_offscreen(32, 32);
     }
 
@@ -329,7 +329,7 @@ SoIndexedNurbsSurface::createTriangleDetail(SoRayPickAction * /* action */,
                                             const SoPrimitiveVertex * /*v3*/,
                                             SoPickedPoint * /* pp */)
 {
-  return NULL;
+  return nullptr;
 }
 
 typedef SoNurbsP<SoIndexedNurbsSurface>::coin_nurbs_cbdata coin_ins_cbdata;
@@ -352,7 +352,7 @@ SoIndexedNurbsSurfaceP::doNurbs(SoAction * action, const bool glrender)
 
   if (!PUBLIC(this)->coordIndex.getNum()) return;
 
-  if (this->nurbsrenderer == NULL) {
+  if (this->nurbsrenderer == nullptr) {
     this->nurbsrenderer = GLUWrapper()->gluNewNurbsRenderer();
 
     if (GLUWrapper()->versionMatchesAtLeast(1, 3, 0)) {
@@ -377,7 +377,7 @@ SoIndexedNurbsSurfaceP::doNurbs(SoAction * action, const bool glrender)
       cbdata.vertex.setMaterialIndex(0);
       cbdata.vertex.setTextureCoords(SbVec4f(0.0f, 0.0f, 0.0f, 1.0f));
       cbdata.vertex.setPoint(SbVec3f(0.0f, 0.0f, 0.0f));
-      cbdata.vertex.setDetail(NULL);
+      cbdata.vertex.setDetail(nullptr);
     }
   }
 
@@ -418,7 +418,7 @@ SoIndexedNurbsSurfaceP::doNurbs(SoAction * action, const bool glrender)
                             PUBLIC(this)->coordIndex.getNum(),
                             PUBLIC(this)->coordIndex.getValues(0),
                             texindex ? PUBLIC(this)->textureCoordIndex.getNum() : 0,
-                            texindex ? PUBLIC(this)->textureCoordIndex.getValues(0) : NULL);
+                            texindex ? PUBLIC(this)->textureCoordIndex.getValues(0) : nullptr);
 }
 
 
diff --git a/coin4/src/shapenodes/SoIndexedPointSet.cpp b/coin4/src/shapenodes/SoIndexedPointSet.cpp
index 238030f..0965406 100644
--- a/coin4/src/shapenodes/SoIndexedPointSet.cpp
+++ b/coin4/src/shapenodes/SoIndexedPointSet.cpp
@@ -124,7 +124,7 @@ SO_NODE_SOURCE(SoIndexedPointSet);
 SoIndexedPointSet::SoIndexedPointSet()
 {
   SO_NODE_INTERNAL_CONSTRUCTOR(SoIndexedPointSet);
-  this->vaindexer = NULL;
+  this->vaindexer = nullptr;
 }
 
 /*!
@@ -262,7 +262,7 @@ SoIndexedPointSet::GLRender(SoGLRenderAction * action)
     return;
   }
 
-  if (normals == NULL && needNormals) {
+  if (normals == nullptr && needNormals) {
     needNormals = false;
     if (!didpush) {
       state->push();
@@ -276,25 +276,25 @@ SoIndexedPointSet::GLRender(SoGLRenderAction * action)
     nbind = this->findNormalBinding(state);
   }
   //if we don't have explicit normal indices, use coord indices:
-  if (nbind == PER_VERTEX_INDEXED && nindices == NULL) nindices = cindices;
+  if (nbind == PER_VERTEX_INDEXED && nindices == nullptr) nindices = cindices;
 
   mbind = this->findMaterialBinding(state);
   //if we don't have explicit material indices, use coord indices:
-  if (mbind == PER_VERTEX_INDEXED && mindices == NULL) mindices = cindices;
+  if (mbind == PER_VERTEX_INDEXED && mindices == nullptr) mindices = cindices;
 
   tbind = OVERALL;
   if (doTextures) {
     tbind = this->findTextureBinding(state);
     if (tb.isFunction() && !tb.needIndices()) {
       tbind = OVERALL;
-      tindices = NULL;//don't send texture coords
+      tindices = nullptr;//don't send texture coords
     }
     else if (tbind == PER_VERTEX){
-      tindices = NULL;//texture coords are sent per vertex
+      tindices = nullptr;//texture coords are sent per vertex
     }
     else {//tbind == PER_VERTEX_INDEXED
       //if we don't have explicit texture coord indices, use coord indices:
-      if (tindices == NULL) tindices = cindices;
+      if (tindices == nullptr) tindices = cindices;
     }
   }
 
@@ -319,7 +319,7 @@ SoIndexedPointSet::GLRender(SoGLRenderAction * action)
 
   if (dova && (mbind == PER_VERTEX_INDEXED)) {
     const SoGLVBOElement * vboelem = SoGLVBOElement::getInstance(state);
-    if (vboelem->getColorVBO() == NULL) {
+    if (vboelem->getColorVBO() == nullptr) {
       dova = false;
       // we might be able to do VA-rendering, but need to check the
       // diffuse color type first.
@@ -333,12 +333,12 @@ SoIndexedPointSet::GLRender(SoGLRenderAction * action)
   if (dova) {
     bool vbo = this->startVertexArray(action,
                                         glcoords,
-                                        (needNormals && (nbind == PER_VERTEX_INDEXED)) ? normals : NULL,
+                                        (needNormals && (nbind == PER_VERTEX_INDEXED)) ? normals : nullptr,
                                         doTextures,
                                         mbind == PER_VERTEX_INDEXED);
     didrenderasvbo = vbo;
     LOCK_VAINDEXER(this);
-    if (this->vaindexer == NULL) {
+    if (this->vaindexer == nullptr) {
       SoVertexArrayIndexer * indexer = new SoVertexArrayIndexer;
       for (int i = 0; i < numindices; i++) {
         int32_t idx = this->coordIndex[i];
@@ -407,7 +407,7 @@ SoIndexedPointSet::generateDefaultNormals(SoState *, SoNormalCache * nc)
 {
   // Overridden to clear normal cache, as it's not possible to
   // generate a normal for a point.
-  nc->set(0, NULL);
+  nc->set(0, nullptr);
   return true;
 }
 
@@ -481,7 +481,7 @@ SoIndexedPointSet::generatePrimitives(SoAction *action)
     return;
   }
 
-  if (normals == NULL) {
+  if (normals == nullptr) {
     needNormals = false;
   }
 
@@ -490,25 +490,25 @@ SoIndexedPointSet::generatePrimitives(SoAction *action)
     nbind = this->findNormalBinding(state);
   }
   //if we don't have explicit normal indices, use coord indices:
-  if (nbind == PER_VERTEX_INDEXED && nindices == NULL) nindices = cindices;
+  if (nbind == PER_VERTEX_INDEXED && nindices == nullptr) nindices = cindices;
 
   mbind = this->findMaterialBinding(state);
   //if we don't have explicit material indices, use coord indices:
-  if (mbind == PER_VERTEX_INDEXED && mindices == NULL) mindices = cindices;
+  if (mbind == PER_VERTEX_INDEXED && mindices == nullptr) mindices = cindices;
 
   tbind = OVERALL;
   if (doTextures) {
     tbind = this->findTextureBinding(state);
     if (tb.isFunction() && !tb.needIndices()) {
       tbind = OVERALL;
-      tindices = NULL;//don't send texture coords
+      tindices = nullptr;//don't send texture coords
     }
     else if (tbind == PER_VERTEX){
-      tindices = NULL;//texture coords are sent per vertex
+      tindices = nullptr;//texture coords are sent per vertex
     }
     else {//tbind == PER_VERTEX_INDEXED
       //if we don't have explicit texture coord indices, use coord indices:
-      if (tindices == NULL) tindices = cindices;
+      if (tindices == nullptr) tindices = cindices;
     }
   }
 
@@ -569,7 +569,7 @@ SoIndexedPointSet::notify(SoNotList * list)
     LOCK_VAINDEXER(this);
     if (this->vaindexer) {
       delete this->vaindexer;
-      this->vaindexer = NULL;
+      this->vaindexer = nullptr;
     }
     UNLOCK_VAINDEXER(this);
   }
diff --git a/coin4/src/shapenodes/SoIndexedShape.cpp b/coin4/src/shapenodes/SoIndexedShape.cpp
index 4951625..0c7635b 100644
--- a/coin4/src/shapenodes/SoIndexedShape.cpp
+++ b/coin4/src/shapenodes/SoIndexedShape.cpp
@@ -133,11 +133,11 @@ SoIndexedShape::computeBBox(SoAction * action, SbBox3f & box, SbVec3f & center)
   assert(box.isEmpty());
   SoState * state = action->getState();
 
-  const SoCoordinateElement * coordelem = NULL;
+  const SoCoordinateElement * coordelem = nullptr;
   SoNode *vpnode = this->vertexProperty.getValue();
   SoVertexProperty *vp = 
     (vpnode && vpnode->isOfType(SoVertexProperty::getClassTypeId())) ?
-    (SoVertexProperty *)vpnode : NULL;
+    (SoVertexProperty *)vpnode : nullptr;
   bool vpvtx = vp && (vp->vertex.getNum() > 0);
   if (!vpvtx) {
     coordelem = SoCoordinateElement::getInstance(state);
@@ -260,7 +260,7 @@ const int32_t *
 SoIndexedShape::getNormalIndices()
 {
   COIN_OBSOLETED();
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -274,7 +274,7 @@ const int32_t *
 SoIndexedShape::getColorIndices()
 {
   COIN_OBSOLETED();
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -288,7 +288,7 @@ const int32_t *
 SoIndexedShape::getTexCoordIndices()
 {
   COIN_OBSOLETED();
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -316,18 +316,18 @@ SoIndexedShape::getVertexData(SoState * state,
   numcindices = this->coordIndex.getNum();
 
   mindices = this->materialIndex.getValues(0);
-  if (this->materialIndex.getNum() <= 0 || mindices[0] < 0) mindices = NULL;
+  if (this->materialIndex.getNum() <= 0 || mindices[0] < 0) mindices = nullptr;
 
   tindices = this->textureCoordIndex.getValues(0);
-  if (this->textureCoordIndex.getNum() <= 0 || tindices[0] < 0) tindices = NULL;
+  if (this->textureCoordIndex.getNum() <= 0 || tindices[0] < 0) tindices = nullptr;
 
   normalCacheUsed = false;
-  nindices = NULL;
+  nindices = nullptr;
   if (needNormals) {
     nindices = this->normalIndex.getValues(0);
-    if (this->normalIndex.getNum() <= 0 || nindices[0] < 0) nindices = NULL;
+    if (this->normalIndex.getNum() <= 0 || nindices[0] < 0) nindices = nullptr;
 
-    if (normals == NULL) {
+    if (normals == nullptr) {
       SoNormalCache * nc = this->generateAndReadLockNormalCache(state);
       normals = nc->getNormals();
       nindices = nc->getIndices();
@@ -335,7 +335,7 @@ SoIndexedShape::getVertexData(SoState * state,
      
       // if no normals were generated, unlock normal cache before
       // returning
-      if (normals == NULL) {
+      if (normals == nullptr) {
         this->readUnlockNormalCache();
         normalCacheUsed = false;
       }
diff --git a/coin4/src/shapenodes/SoIndexedTriangleStripSet.cpp b/coin4/src/shapenodes/SoIndexedTriangleStripSet.cpp
index aa78875..23e0f77 100644
--- a/coin4/src/shapenodes/SoIndexedTriangleStripSet.cpp
+++ b/coin4/src/shapenodes/SoIndexedTriangleStripSet.cpp
@@ -270,13 +270,13 @@ SoIndexedTriangleStripSet::GLRender(SoGLRenderAction * action)
 
   if (dotextures) {
     if (tb.isFunction() && !tb.needIndices()) {
-      tindices = NULL;
+      tindices = nullptr;
     }
     else if (SoTextureCoordinateBindingElement::get(state) ==
              SoTextureCoordinateBindingElement::PER_VERTEX) {
-      tindices = NULL;
+      tindices = nullptr;
     }
-    else if (tindices == NULL) {
+    else if (tindices == nullptr) {
       tindices = cindices;
     }
   }
@@ -348,7 +348,7 @@ SoIndexedTriangleStripSet::generateDefaultNormals(SoState * state,
   SoNode *vpnode = this->vertexProperty.getValue();
   SoVertexProperty *vp = 
     (vpnode && vpnode->isOfType(SoVertexProperty::getClassTypeId())) ?
-    (SoVertexProperty *)vpnode : NULL;
+    (SoVertexProperty *)vpnode : nullptr;
   bool vpvtx = vp && (vp->vertex.getNum() > 0);
   bool vpnorm = vp && (vp->normal.getNum() > 0);
 
@@ -372,7 +372,7 @@ SoIndexedTriangleStripSet::generateDefaultNormals(SoState * state,
                           this->coordIndex.getValues(0),
                           this->coordIndex.getNum(),
                           SoCreaseAngleElement::get(state),
-                          NULL,
+                          nullptr,
                           -1,
                           ccw,
                           true);
@@ -487,21 +487,21 @@ SoIndexedTriangleStripSet::generatePrimitives(SoAction * action)
 
   if (dotextures) {
     if (tb.isFunction() && !tb.needIndices()) {
-      tindices = NULL;
+      tindices = nullptr;
     }
     else if (SoTextureCoordinateBindingElement::get(state) ==
              SoTextureCoordinateBindingElement::PER_VERTEX) {
-      tindices = NULL;
+      tindices = nullptr;
     }
-    else if (tindices == NULL) {
+    else if (tindices == nullptr) {
       tindices = cindices;
     }
   }
 
-  if (nbind == PER_VERTEX_INDEXED && nindices == NULL) {
+  if (nbind == PER_VERTEX_INDEXED && nindices == nullptr) {
     nindices = cindices;
   }
-  if (mbind == PER_VERTEX_INDEXED && mindices == NULL) {
+  if (mbind == PER_VERTEX_INDEXED && mindices == nullptr) {
     mindices = cindices;
   }
 
diff --git a/coin4/src/shapenodes/SoLineSet.cpp b/coin4/src/shapenodes/SoLineSet.cpp
index 97017e7..761523a 100644
--- a/coin4/src/shapenodes/SoLineSet.cpp
+++ b/coin4/src/shapenodes/SoLineSet.cpp
@@ -234,8 +234,8 @@ namespace { namespace SoGL { namespace LineSet {
                        bool needNormals,
                        bool drawPoints)
   {
-    const SbVec3f * coords3d = NULL;
-    const SbVec4f * coords4d = NULL;
+    const SbVec3f * coords3d = nullptr;
+    const SbVec4f * coords4d = nullptr;
     const bool is3d = coords->is3D();
     if (is3d) {
       coords3d = coords->getArrayPtr3();
@@ -460,7 +460,7 @@ SoLineSet::GLRender(SoGLRenderAction * action)
 
   SoVertexShape::getVertexData(state, tmp, normals,
                                needNormals);
-  if (normals == NULL && needNormals) {
+  if (normals == nullptr && needNormals) {
     needNormals = false;
     if (!didpush) {
       state->push();
@@ -513,7 +513,7 @@ bool
 SoLineSet::generateDefaultNormals(SoState * , SoNormalCache * nc)
 {
   // not possible to generate normals for LineSet
-  nc->set(0, NULL);
+  nc->set(0, nullptr);
   return true;
 }
 
@@ -579,7 +579,7 @@ SoLineSet::generatePrimitives(SoAction *action)
   SoVertexShape::getVertexData(action->getState(), coords, normals,
                                needNormals);
 
-  if (normals == NULL) needNormals = false;
+  if (normals == nullptr) needNormals = false;
 
   SoTextureCoordinateBundle tb(action, false, false);
   doTextures = tb.needCoordinates();
diff --git a/coin4/src/shapenodes/SoNonIndexedShape.cpp b/coin4/src/shapenodes/SoNonIndexedShape.cpp
index 4a80af2..d0937f8 100644
--- a/coin4/src/shapenodes/SoNonIndexedShape.cpp
+++ b/coin4/src/shapenodes/SoNonIndexedShape.cpp
@@ -93,7 +93,7 @@ SoNonIndexedShape::computeCoordBBox(SoAction * action, int numVertices,
   SoNode *vpnode = this->vertexProperty.getValue();
   SoVertexProperty *vp = 
     (vpnode && vpnode->isOfType(SoVertexProperty::getClassTypeId())) ?
-    (SoVertexProperty *)vpnode : NULL;
+    (SoVertexProperty *)vpnode : nullptr;
   bool vpvtx = vp && (vp->vertex.getNum() > 0);
 
   const int numCoords = vpvtx ?
diff --git a/coin4/src/shapenodes/SoNurbsCurve.cpp b/coin4/src/shapenodes/SoNurbsCurve.cpp
index 86fccb6..e78619d 100644
--- a/coin4/src/shapenodes/SoNurbsCurve.cpp
+++ b/coin4/src/shapenodes/SoNurbsCurve.cpp
@@ -137,8 +137,8 @@ public:
   SoNurbsCurveP(SoNurbsCurve * m)
   {
     this->owner = m;
-    this->nurbsrenderer = NULL;
-    this->offscreenctx = NULL;
+    this->nurbsrenderer = nullptr;
+    this->offscreenctx = nullptr;
   }
 
   ~SoNurbsCurveP()
@@ -330,7 +330,7 @@ SoNurbsCurve::generatePrimitives(SoAction * action)
     // offscreen context to be guaranteed to have a valid GL context
     // before making the GLU calls.
 
-    if (PRIVATE(this)->offscreenctx == NULL) {
+    if (PRIVATE(this)->offscreenctx == nullptr) {
       PRIVATE(this)->offscreenctx = cc_glglue_context_create_offscreen(32, 32);
     }
 
@@ -349,7 +349,7 @@ SoNurbsCurve::createLineSegmentDetail(SoRayPickAction * COIN_UNUSED_ARG(action),
                                       const SoPrimitiveVertex * COIN_UNUSED_ARG(v2),
                                       SoPickedPoint * COIN_UNUSED_ARG(pp))
 {
-  return NULL;
+  return nullptr;
 }
 
 typedef SoNurbsP<SoNurbsCurve>::coin_nurbs_cbdata coin_nc_cbdata;
@@ -371,7 +371,7 @@ SoNurbsCurveP::doNurbs(SoAction * action,
     return;
   }
 
-  if (this->nurbsrenderer == NULL) {
+  if (this->nurbsrenderer == nullptr) {
     this->nurbsrenderer = GLUWrapper()->gluNewNurbsRenderer();
 
     if (GLUWrapper()->versionMatchesAtLeast(1, 3, 0)) {
@@ -397,7 +397,7 @@ SoNurbsCurveP::doNurbs(SoAction * action,
       cbdata.vertex.setMaterialIndex(0);
       cbdata.vertex.setTextureCoords(SbVec4f(0.0f, 0.0f, 0.0f, 1.0f));
       cbdata.vertex.setPoint(SbVec3f(0.0f, 0.0f, 0.0f));
-      cbdata.vertex.setDetail(NULL);
+      cbdata.vertex.setDetail(nullptr);
     }
   }
 
diff --git a/coin4/src/shapenodes/SoNurbsP.h b/coin4/src/shapenodes/SoNurbsP.h
index 3f1ea24..154cd95 100644
--- a/coin4/src/shapenodes/SoNurbsP.h
+++ b/coin4/src/shapenodes/SoNurbsP.h
@@ -145,7 +145,7 @@ SoNurbsP<Master>::tessBegin(int type, void * data)
 #endif // debug
     break;
   }
-  cbdata->thisp->beginShape(cbdata->action, shapetype, NULL);
+  cbdata->thisp->beginShape(cbdata->action, shapetype, nullptr);
 }
 
 
diff --git a/coin4/src/shapenodes/SoNurbsSurface.cpp b/coin4/src/shapenodes/SoNurbsSurface.cpp
index 3aea738..0e6de76 100644
--- a/coin4/src/shapenodes/SoNurbsSurface.cpp
+++ b/coin4/src/shapenodes/SoNurbsSurface.cpp
@@ -156,8 +156,8 @@ public:
   SoNurbsSurfaceP(SoNurbsSurface * m)
   {
     this->owner = m;
-    this->nurbsrenderer = NULL;
-    this->offscreenctx = NULL;
+    this->nurbsrenderer = nullptr;
+    this->offscreenctx = nullptr;
   }
 
   ~SoNurbsSurfaceP()
@@ -344,7 +344,7 @@ SoNurbsSurface::generatePrimitives(SoAction * action)
     // offscreen context to be guaranteed to have a valid GL context
     // before making the GLU calls.
 
-    if (PRIVATE(this)->offscreenctx == NULL) {
+    if (PRIVATE(this)->offscreenctx == nullptr) {
       PRIVATE(this)->offscreenctx = cc_glglue_context_create_offscreen(32, 32);
     }
 
@@ -364,7 +364,7 @@ SoNurbsSurface::createTriangleDetail(SoRayPickAction * /* action */,
                                      const SoPrimitiveVertex * /*v3*/,
                                      SoPickedPoint * /* pp */)
 {
-  return NULL;
+  return nullptr;
 }
 
 typedef SoNurbsP<SoNurbsSurface>::coin_nurbs_cbdata coin_ns_cbdata;
@@ -388,7 +388,7 @@ SoNurbsSurfaceP::doNurbs(SoAction * action, const bool glrender)
     return;
   }
 
-  if (this->nurbsrenderer == NULL) {
+  if (this->nurbsrenderer == nullptr) {
     this->nurbsrenderer = GLUWrapper()->gluNewNurbsRenderer();
 
     if (GLUWrapper()->versionMatchesAtLeast(1, 3, 0)) {
@@ -413,7 +413,7 @@ SoNurbsSurfaceP::doNurbs(SoAction * action, const bool glrender)
       cbdata.vertex.setMaterialIndex(0);
       cbdata.vertex.setTextureCoords(SbVec4f(0.0f, 0.0f, 0.0f, 1.0f));
       cbdata.vertex.setPoint(SbVec3f(0.0f, 0.0f, 0.0f));
-      cbdata.vertex.setDetail(NULL);
+      cbdata.vertex.setDetail(nullptr);
     }
   }
 
diff --git a/coin4/src/shapenodes/SoPointSet.cpp b/coin4/src/shapenodes/SoPointSet.cpp
index a6be134..b87efd8 100644
--- a/coin4/src/shapenodes/SoPointSet.cpp
+++ b/coin4/src/shapenodes/SoPointSet.cpp
@@ -212,7 +212,7 @@ SoPointSet::GLRender(SoGLRenderAction * action)
   SoVertexShape::getVertexData(state, tmp, normals,
                                needNormals);
 
-  if (normals == NULL && needNormals) {
+  if (normals == nullptr && needNormals) {
     needNormals = false;
     if (!didpush) {
       state->push();
@@ -247,7 +247,7 @@ SoPointSet::GLRender(SoGLRenderAction * action)
   
   if (dova && (mbind == PER_VERTEX)) {
     const SoGLVBOElement * vboelem = SoGLVBOElement::getInstance(state);
-    if (vboelem->getColorVBO() == NULL) {
+    if (vboelem->getColorVBO() == nullptr) {
       dova = false;
       // we might be able to do VA-rendering, but need to check the
       // diffuse color type first.
@@ -261,7 +261,7 @@ SoPointSet::GLRender(SoGLRenderAction * action)
   if (dova) {
     bool vbo = this->startVertexArray(action,
                                         coords,
-                                        (needNormals && (nbind != OVERALL)) ? normals : NULL,
+                                        (needNormals && (nbind != OVERALL)) ? normals : nullptr,
                                         doTextures,
                                         mbind == PER_VERTEX);
     didrenderasvbo = vbo;
@@ -273,9 +273,9 @@ SoPointSet::GLRender(SoGLRenderAction * action)
   }
   else {
     sogl_render_pointset(coords,
-                         nbind != OVERALL ? normals : NULL,
-                         mbind != OVERALL ? &mb : NULL,
-                         doTextures ? &tb : NULL,
+                         nbind != OVERALL ? normals : nullptr,
+                         mbind != OVERALL ? &mb : nullptr,
+                         doTextures ? &tb : nullptr,
                          numpts, idx);
   }
   if (didpush) 
@@ -293,7 +293,7 @@ SoPointSet::generateDefaultNormals(SoState *, SoNormalCache * nc)
 {
   // Overridden to clear normal cache, as it's not possible to
   // generate a normal for a point.
-  nc->set(0, NULL);
+  nc->set(0, nullptr);
   return true;
 }
 
@@ -323,7 +323,7 @@ SoPointSet::getPrimitiveCount(SoGetPrimitiveCountAction *action)
     SoNode *vpnode = this->vertexProperty.getValue();
     SoVertexProperty *vp = 
       (vpnode && vpnode->isOfType(SoVertexProperty::getClassTypeId())) ?
-      (SoVertexProperty *)vpnode : NULL;
+      (SoVertexProperty *)vpnode : nullptr;
     if (vp && vp->vertex.getNum()) {
       num = vp->vertex.getNum() - this->startIndex.getValue();
     }
@@ -358,7 +358,7 @@ SoPointSet::generatePrimitives(SoAction *action)
   SoVertexShape::getVertexData(action->getState(), coords, normals,
                                needNormals);
 
-  if (normals == NULL) needNormals = false;
+  if (normals == nullptr) needNormals = false;
 
   SoTextureCoordinateBundle tb(action, false, false);
   doTextures = tb.needCoordinates();
diff --git a/coin4/src/shapenodes/SoQuadMesh.cpp b/coin4/src/shapenodes/SoQuadMesh.cpp
index b2b70a9..22110b8 100644
--- a/coin4/src/shapenodes/SoQuadMesh.cpp
+++ b/coin4/src/shapenodes/SoQuadMesh.cpp
@@ -157,6 +157,7 @@
 
 #include <math.h> // ilogb
 #include <float.h> // _logb
+#include <cstdlib> // atoi
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
@@ -364,8 +365,8 @@ namespace { namespace SoGL { namespace QuadMesh {
     assert(coords->getNum() - start >= rowsize * colsize);
 
     const bool is3d = coords->is3D();
-    const SbVec3f * coords3d = is3d ? coords->getArrayPtr3() : NULL;
-    const SbVec4f * coords4d = is3d ? NULL : coords->getArrayPtr4();
+    const SbVec3f * coords3d = is3d ? coords->getArrayPtr3() : nullptr;
+    const SbVec4f * coords4d = is3d ? nullptr : coords->getArrayPtr4();
 
     if (preciseLighting == false) {
 
@@ -463,9 +464,9 @@ namespace { namespace SoGL { namespace QuadMesh {
         }
       }
 
-      const SbVec3f *c1d3 = NULL,*c2d3 = NULL,*c3d3 = NULL,*c4d3 = NULL;
+      const SbVec3f *c1d3 = nullptr,*c2d3 = nullptr,*c3d3 = nullptr,*c4d3 = nullptr;
       SbVec3f ccd3;
-      const SbVec4f *c1d4 = NULL,*c2d4 = NULL,*c3d4 = NULL,*c4d4 = NULL;
+      const SbVec4f *c1d4 = nullptr,*c2d4 = nullptr,*c3d4 = nullptr,*c4d4 = nullptr;
       SbVec4f ccd4;
       SbVec4f sum234d4,sum134d4,sum124d4,sum123d4;
       SbVec4f vec1d4,vec2d4,vec3d4,vec4d4;
@@ -473,7 +474,7 @@ namespace { namespace SoGL { namespace QuadMesh {
       float w1,w2,w3,w4;
       const SbVec3f *n1,*n2,*n3,*n4;
       SbVec3f nc;
-      const SbVec4f *t1,*t2, * t3 = NULL, * t4 = NULL;
+      const SbVec4f *t1,*t2, * t3 = nullptr, * t4 = nullptr;
       SbVec4f tc;
 
       int curridx1 = 0;
@@ -880,9 +881,9 @@ SoQuadMesh::GLRender(SoGLRenderAction * action)
   Binding nbind = findNormalBinding(action->getState());
   if (!needNormals) nbind = OVERALL;
 
-  SoNormalCache * nc = NULL;
+  SoNormalCache * nc = nullptr;
 
-  if (needNormals && normals == NULL) {
+  if (needNormals && normals == nullptr) {
     nc = this->generateAndReadLockNormalCache(state);
     normals = nc->getNormals();
   }
@@ -1079,9 +1080,9 @@ SoQuadMesh::generatePrimitives(SoAction *action)
   Binding mbind = findMaterialBinding(action->getState());
   Binding nbind = findNormalBinding(action->getState());
 
-  SoNormalCache * nc = NULL;
+  SoNormalCache * nc = nullptr;
 
-  if (needNormals && normals == NULL) {
+  if (needNormals && normals == nullptr) {
     nc = this->generateAndReadLockNormalCache(state);
     normals = nc->getNormals();
   }
diff --git a/coin4/src/shapenodes/SoShape.cpp b/coin4/src/shapenodes/SoShape.cpp
index 0ec997d..fe4e1ed 100644
--- a/coin4/src/shapenodes/SoShape.cpp
+++ b/coin4/src/shapenodes/SoShape.cpp
@@ -163,9 +163,9 @@
 class SoShapeP {
 public:
   SoShapeP() {
-    this->bboxcache = NULL;
-    this->pvcache = NULL;
-    this->bumprender = NULL;
+    this->bboxcache = nullptr;
+    this->pvcache = nullptr;
+    this->bumprender = nullptr;
     this->rendercnt = 0;
     this->flags = 0;
   }
@@ -242,7 +242,7 @@ public:
 
 double SoShapeP::bboxcachetimelimit;
 
-SbMutex * SoShapeP::mutex = NULL;
+SbMutex * SoShapeP::mutex = nullptr;
 
 #undef PRIVATE
 #define PRIVATE(p) ((p)->pimpl)
@@ -322,10 +322,10 @@ void
 SoShapeP::cleanup(void)
 {
   delete soshape_staticstorage;
-  soshape_staticstorage = NULL;
+  soshape_staticstorage = nullptr;
 
   delete SoShapeP::mutex;
-  SoShapeP::mutex = NULL;
+  SoShapeP::mutex = nullptr;
 }
 
 // *************************************************************************
@@ -397,7 +397,7 @@ SoShape::GLRender(SoGLRenderAction * action)
   // test for SoVertexShape node and push data onto the state before
   // calling generatePrimitives(). This is needed for SoMaterialBundle
   // to work correctly.
-  SoVertexProperty * vp = NULL;
+  SoVertexProperty * vp = nullptr;
   if (this->isOfType(SoVertexShape::getClassTypeId())) {
     vp = (SoVertexProperty*) ((SoVertexShape*)this)->vertexProperty.getValue();
   }
@@ -661,7 +661,7 @@ SoShape::shouldGLRender(SoGLRenderAction * action)
     if (lights.getLength()) {
       // lock since bumprender and pvcache is shared among all threads
       PRIVATE(this)->lock();
-      if (PRIVATE(this)->bumprender == NULL) {
+      if (PRIVATE(this)->bumprender == nullptr) {
         PRIVATE(this)->bumprender = new soshape_bumprender;
       }
       this->validatePVCache(action);
@@ -878,14 +878,14 @@ SoShape::computeObjectSpaceRay(SoRayPickAction * const action,
   only be called internally, when generatePrimitives() is used for
   picking (SoShape::rayPick() is not overridden).
 
-  This method returns \c NULL in Open Inventor, and subclasses will
+  This method returns \c nullptr in Open Inventor, and subclasses will
   need to override this method to create details for a SoPickedPoint.
 
   This is not necessary with Coin. Of course, if you choose to
   override it, it will work in the same way as Open Inventor.
 
   For this to work, you must supply a face or line detail when
-  generating primitives. If you supply \c NULL for the detail argument in
+  generating primitives. If you supply \c nullptr for the detail argument in
   SoShape::beginShape(), you'll have to override this method.
 */
 SoDetail *
@@ -905,7 +905,7 @@ SoShape::createTriangleDetail(SoRayPickAction * COIN_UNUSED_ARG(action),
   SoDebugError::postInfo("SoShape::createTriangleDetail",
                          "Unable to create triangle detail.");
 #endif // COIN_DEBUG
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -913,14 +913,14 @@ SoShape::createTriangleDetail(SoRayPickAction * COIN_UNUSED_ARG(action),
   be called internally, when generatePrimitives() is used for picking
   (SoShape::rayPick() is not overridden).
 
-  This method returns \c NULL in Open Inventor, and subclasses will
+  This method returns \c nullptr in Open Inventor, and subclasses will
   need to override this method to create details for a SoPickedPoint.
 
   This is not necessary with Coin. Of course, if you choose to
   override it, it will work in the same way as Open Inventor.
 
   For this to work, you must supply a face or line detail when
-  generating primitives. If you supply \c NULL for the detail argument in
+  generating primitives. If you supply \c nullptr for the detail argument in
   SoShape::beginShape(), you'll have to override this method.
 */
 SoDetail *
@@ -939,7 +939,7 @@ SoShape::createLineSegmentDetail(SoRayPickAction * COIN_UNUSED_ARG(action),
   SoDebugError::postInfo("SoShape::createLineSegmentDetail",
                          "Unable to create line segment detail.");
 #endif // COIN_DEBUG
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -947,7 +947,7 @@ SoShape::createLineSegmentDetail(SoRayPickAction * COIN_UNUSED_ARG(action),
   be called internally, when generatePrimitives() is used for picking
   (SoShape::rayPick() is not overridden).
 
-  This method returns \c NULL in Open Inventor, and subclasses will
+  This method returns \c nullptr in Open Inventor, and subclasses will
   need to override this method to create details for a SoPickedPoint.
 
   This is not necessary with Coin. Of course, if you choose to
@@ -962,7 +962,7 @@ SoShape::createPointDetail(SoRayPickAction * /* action */,
                            SoPickedPoint * /* pp */)
 {
   if (v->getDetail()) return v->getDetail()->copy();
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -1372,7 +1372,7 @@ SoShape::GLRenderBoundingBox(SoGLRenderAction * action)
   glPushMatrix();
   glTranslatef(center[0], center[1], center[2]);
   sogl_render_cube(size[0], size[1], size[2], &mb,
-                   SOGL_NEED_NORMALS | SOGL_NEED_TEXCOORDS, NULL);
+                   SOGL_NEED_NORMALS | SOGL_NEED_TEXCOORDS, nullptr);
   glPopMatrix();
 }
 
@@ -1423,7 +1423,7 @@ SoShape::notify(SoNotList * nl)
 
 /*!
   Return the bounding box cache for this shape. It might return
-  NULL if no bounding box cache has been created. If not NULL, the
+  nullptr if no bounding box cache has been created. If not nullptr, the
   caller must check if the cache is valid before using it. This
   can be done using SoCache::isValid().
 
@@ -1457,7 +1457,7 @@ SoShape::getBBox(SoAction * action, SbBox3f & box, SbVec3f & center)
   if (PRIVATE(this)->bboxcache) {
     PRIVATE(this)->lock();
     PRIVATE(this)->bboxcache->unref();
-    PRIVATE(this)->bboxcache = NULL;
+    PRIVATE(this)->bboxcache = nullptr;
     PRIVATE(this)->unlock();
     // don't create bbox caches for shapes that change
     PRIVATE(this)->flags &= ~SoShapeP::SHOULD_BBOX_CACHE;
@@ -1469,7 +1469,7 @@ SoShape::getBBox(SoAction * action, SbBox3f & box, SbVec3f & center)
     // must push state to make cache dependencies work
     state->push();
     storedinvalid = SoCacheElement::setInvalid(false);
-    assert(PRIVATE(this)->bboxcache == NULL);
+    assert(PRIVATE(this)->bboxcache == nullptr);
     PRIVATE(this)->lock();
     PRIVATE(this)->bboxcache = new SoBoundingBoxCache(state);
     PRIVATE(this)->bboxcache->ref();
@@ -1493,7 +1493,7 @@ SoShape::getBBox(SoAction * action, SbBox3f & box, SbVec3f & center)
       // once. SoGLRenderAction and SoRayPickAction might need it.
       state->push();
       storedinvalid = SoCacheElement::setInvalid(false);
-      assert(PRIVATE(this)->bboxcache == NULL);
+      assert(PRIVATE(this)->bboxcache == nullptr);
       PRIVATE(this)->lock();
       PRIVATE(this)->bboxcache = new SoBoundingBoxCache(state);
       PRIVATE(this)->bboxcache->ref();
@@ -1561,13 +1561,13 @@ SoShape::startVertexArray(SoGLRenderAction * action,
       dovbo = false;
     }
   }
-  SoVBO * vertexvbo = dovbo ? vboelem->getVertexVBO() : NULL;
+  SoVBO * vertexvbo = dovbo ? vboelem->getVertexVBO() : nullptr;
   if (!vertexvbo) dovbo = false;
   bool didbind = false;
 
   if (colorpervertex) {
-    const GLvoid * dataptr = NULL;
-    SoVBO * colorvbo = dovbo ? vboelem->getColorVBO() : NULL;
+    const GLvoid * dataptr = nullptr;
+    SoVBO * colorvbo = dovbo ? vboelem->getColorVBO() : nullptr;
     SoGLLazyElement * lelem = (SoGLLazyElement*) SoLazyElement::getInstance(state);
     if (colorvbo) {
       lelem->updateColorVBO(colorvbo);
@@ -1590,8 +1590,8 @@ SoShape::startVertexArray(SoGLRenderAction * action,
     cc_glglue_glEnableClientState(glue, GL_COLOR_ARRAY);
   }
   if (texpervertex) {
-    const SoMultiTextureCoordinateElement * mtelem = NULL;
-    const bool * enabledunits = NULL;
+    const SoMultiTextureCoordinateElement * mtelem = nullptr;
+    const bool * enabledunits = nullptr;
     int lastenabled;
     
     enabledunits = SoMultiTextureEnabledElement::getEnabledUnits(state, lastenabled);
@@ -1625,11 +1625,11 @@ SoShape::startVertexArray(SoGLRenderAction * action,
 	if (SoGLDriverDatabase::isSupported(glue, SO_GL_MULTITEXTURE)) {
 	  cc_glglue_glClientActiveTexture(glue, GL_TEXTURE0 + i);
 	}
-        vbo = dovbo ? vboelem->getTexCoordVBO(i) : NULL;
+        vbo = dovbo ? vboelem->getTexCoordVBO(i) : nullptr;
         if (vbo) {
           vbo->bindBuffer(contextid);
           didbind = true;
-          tptr = NULL;
+          tptr = nullptr;
         }
         else {
           if (didbind) {
@@ -1642,9 +1642,9 @@ SoShape::startVertexArray(SoGLRenderAction * action,
       }
     }
   }
-  if (pervertexnormals != NULL) {
-    SoVBO * vbo = dovbo ? vboelem->getNormalVBO() : NULL;
-    const GLvoid * dataptr = NULL;
+  if (pervertexnormals != nullptr) {
+    SoVBO * vbo = dovbo ? vboelem->getNormalVBO() : nullptr;
+    const GLvoid * dataptr = nullptr;
     if (vbo) {
       vbo->bindBuffer(contextid);
       didbind = true;
@@ -1659,7 +1659,7 @@ SoShape::startVertexArray(SoGLRenderAction * action,
     cc_glglue_glNormalPointer(glue, GL_FLOAT, 0, dataptr);
     cc_glglue_glEnableClientState(glue, GL_NORMAL_ARRAY);
   }
-  const GLvoid * dataptr = NULL;
+  const GLvoid * dataptr = nullptr;
   if (vertexvbo) {
     vertexvbo->bindBuffer(contextid);
   }
@@ -1744,7 +1744,7 @@ void
 SoShape::validatePVCache(SoGLRenderAction * action)
 {
   SoState * state = action->getState();
-  if (PRIVATE(this)->pvcache == NULL ||
+  if (PRIVATE(this)->pvcache == nullptr ||
       !PRIVATE(this)->pvcache->isValid(state)) {
     if (PRIVATE(this)->pvcache) {
       PRIVATE(this)->pvcache->unref();
diff --git a/coin4/src/shapenodes/SoText2.cpp b/coin4/src/shapenodes/SoText2.cpp
index 141fd15..02e8c4c 100644
--- a/coin4/src/shapenodes/SoText2.cpp
+++ b/coin4/src/shapenodes/SoText2.cpp
@@ -271,8 +271,8 @@ SoText2::SoText2(void)
   PRIVATE(this)->spacingsensor = new SoFieldSensor(SoText2P::sensor_cb, PRIVATE(this));
   PRIVATE(this)->spacingsensor->attach(&this->spacing);
   PRIVATE(this)->spacingsensor->setPriority(0);
-  PRIVATE(this)->cache = NULL;
-  PRIVATE(this)->pixel_buffer = NULL;
+  PRIVATE(this)->cache = nullptr;
+  PRIVATE(this)->pixel_buffer = nullptr;
   PRIVATE(this)->pixel_buffer_size = 0;
 }
 
@@ -352,8 +352,8 @@ SoText2::GLRender(SoGLRenderAction * action)
     int offvp;
     int thispos[2];
     int thissize[2];
-    const unsigned char * buffer = NULL;
-    cc_glyph2d * prevglyph = NULL;
+    const unsigned char * buffer = nullptr;
+    cc_glyph2d * prevglyph = nullptr;
     
     const int nrlines = this->string.getNum();
 
@@ -428,7 +428,7 @@ SoText2::GLRender(SoGLRenderAction * action)
 
         glRasterPos3f(rpx, rpy, -nilpoint[2]);
 
-        if (offvp) { glBitmap(0,0,0,0,offsetx,offsety,NULL); }
+        if (offvp) { glBitmap(0,0,0,0,offsetx,offsety,nullptr); }
 
         if (buffer) {
           if (cc_glyph2d_getmono(glyph)) {
@@ -753,7 +753,7 @@ SoText2P::dumpBuffer(unsigned char * buffer, SbVec2s size, SbVec2s pos, bool mon
 {
   // FIXME: pure debug method, remove. preng 2003-03-18.
   if (!buffer) {
-    fprintf(stderr,"bitmap error: buffer pointer NULL.\n");
+    fprintf(stderr,"bitmap error: buffer pointer nullptr.\n");
   } else {
     int rows = size[1];
     int bytes = mono ? size[0] >> 3 : size[0];
@@ -785,7 +785,7 @@ SoText2P::dumpBuffer(unsigned char * buffer, SbVec2s size, SbVec2s pos, bool mon
 bool
 SoText2P::shouldBuildGlyphCache(SoState * state)
 {
-  if (this->cache == NULL) return true;
+  if (this->cache == nullptr) return true;
   return !this->cache->isValid(state);
 }
 
@@ -827,7 +827,7 @@ SoText2P::buildGlyphCache(SoState * state)
     int advancey = 0;
     int bitmapsize[2];
     int bitmappos[2];
-    const cc_glyph2d * prevglyph = NULL;
+    const cc_glyph2d * prevglyph = nullptr;
     const char * p = str.getString();
     unsigned int length = cc_string_utf8_validate_length(p);
 
diff --git a/coin4/src/shapenodes/SoText3.cpp b/coin4/src/shapenodes/SoText3.cpp
index 382c3f5..3dce29f 100644
--- a/coin4/src/shapenodes/SoText3.cpp
+++ b/coin4/src/shapenodes/SoText3.cpp
@@ -298,7 +298,7 @@ SoText3::SoText3(void)
 
   PRIVATE(this) = new SoText3P(this);
   PRIVATE(this)->normalgenerator = new SoNormalGenerator(false, 0xff);
-  PRIVATE(this)->cache = NULL;
+  PRIVATE(this)->cache = nullptr;
 }
 
 SoText3::~SoText3()
@@ -653,7 +653,7 @@ SoText3P::render(SoState * state, const cc_font_specification * fontspec,
     }
 
     SbString str = PUBLIC(this)->string[i];
-    cc_glyph3d * prevglyph = NULL;
+    cc_glyph3d * prevglyph = nullptr;
     const char * p = str.getString();
     size_t length = cc_string_utf8_validate_length(p);
     assert(length);
@@ -949,7 +949,7 @@ SoText3P::render(SoState * state, const cc_font_specification * fontspec,
     }
     if (prevglyph) {
       cc_glyph3d_unref(prevglyph);
-      prevglyph = NULL;
+      prevglyph = nullptr;
     }
     ypos -= fontspec->size * PUBLIC(this)->spacing.getValue();
   }
@@ -1073,7 +1073,7 @@ SoText3P::generate(SoAction * action, const cc_font_specification * fontspec,
     }
 
     SbString str = PUBLIC(this)->string[i];
-    cc_glyph3d * prevglyph = NULL;
+    cc_glyph3d * prevglyph = nullptr;
     const char * p = str.getString();
     size_t length = cc_string_utf8_validate_length(p);
     assert(length);
@@ -1102,7 +1102,7 @@ SoText3P::generate(SoAction * action, const cc_font_specification * fontspec,
 
       if (part != SoText3::SIDES) {  // FRONT & BACK
         const int * ptr = cc_glyph3d_getfaceindices(glyph);
-        PUBLIC(this)->beginShape(action, SoShape::TRIANGLES, NULL);
+        PUBLIC(this)->beginShape(action, SoShape::TRIANGLES, nullptr);
 
         while (*ptr >= 0) {
           SbVec2f v0, v1, v2;
@@ -1150,7 +1150,7 @@ SoText3P::generate(SoAction * action, const cc_font_specification * fontspec,
           const int * ptr = cc_glyph3d_getedgeindices(glyph);
           SbVec2f v0, v1;
           int counter = 0;
-          PUBLIC(this)->beginShape(action, SoShape::QUADS, NULL);
+          PUBLIC(this)->beginShape(action, SoShape::QUADS, nullptr);
 
           while (*ptr >= 0) {
             v1 = coords[*ptr++];
@@ -1356,7 +1356,7 @@ SoText3P::generate(SoAction * action, const cc_font_specification * fontspec,
           const SbVec3f * normals = normalgenerator->getNormals();
           const int size = vertexlist.getLength();
 
-          PUBLIC(this)->beginShape(action, SoShape::TRIANGLES, NULL);
+          PUBLIC(this)->beginShape(action, SoShape::TRIANGLES, nullptr);
           for (int z = 0;z < size;z += 3) {
             vertex.setNormal(normals[z+2].getValue());
             vertex.setPoint(SbVec3f(vertexlist[z+2][0] + xpos,
@@ -1390,7 +1390,7 @@ SoText3P::generate(SoAction * action, const cc_font_specification * fontspec,
     }
     if (prevglyph) {
       cc_glyph3d_unref(prevglyph);
-      prevglyph = NULL;
+      prevglyph = nullptr;
     }
     ypos -= fontspec->size * PUBLIC(this)->spacing.getValue();
   }
@@ -1437,7 +1437,7 @@ SoText3P::setUpGlyphs(SoState * state, SoText3 * textnode)
     float kerningy = 0;
     float advancex = 0;
     float advancey = 0;
-    cc_glyph3d * prevglyph = NULL;
+    cc_glyph3d * prevglyph = nullptr;
 
     const float * maxbbox;
     this->maxglyphbbox.makeEmpty();
@@ -1470,7 +1470,7 @@ SoText3P::setUpGlyphs(SoState * state, SoText3 * textnode)
       prevglyph = glyph;
     }
 
-    if (prevglyph != NULL) {
+    if (prevglyph != nullptr) {
       // Italic font might cause last letter to be outside bbox. Add width if needed.
       if (advancex < cc_glyph3d_getwidth(prevglyph))
         stringwidth += (cc_glyph3d_getwidth(prevglyph) - advancex) * fontspec->size;
diff --git a/coin4/src/shapenodes/SoTriangleStripSet.cpp b/coin4/src/shapenodes/SoTriangleStripSet.cpp
index 0bcaa3b..73186fb 100644
--- a/coin4/src/shapenodes/SoTriangleStripSet.cpp
+++ b/coin4/src/shapenodes/SoTriangleStripSet.cpp
@@ -264,8 +264,8 @@ namespace { namespace SoGL { namespace TriStripSet {
                        const int32_t *end,
                        bool needNormals)
   {
-    const SbVec3f * coords3d = NULL;
-    const SbVec4f * coords4d = NULL;
+    const SbVec3f * coords3d = nullptr;
+    const SbVec4f * coords4d = nullptr;
     const bool is3d = coords->is3D();
     if (is3d) {
       coords3d = coords->getArrayPtr3();
@@ -481,8 +481,8 @@ SoTriangleStripSet::GLRender(SoGLRenderAction * action)
   if (!needNormals) nbind = OVERALL;
 
 
-  SoNormalCache * nc = NULL;
-  if (needNormals && normals == NULL) {
+  SoNormalCache * nc = nullptr;
+  if (needNormals && normals == nullptr) {
     nc = this->generateAndReadLockNormalCache(state);
     normals = nc->getNormals();
   }
@@ -643,9 +643,9 @@ SoTriangleStripSet::generatePrimitives(SoAction *action)
   Binding mbind = this->findMaterialBinding(action->getState());
   Binding nbind = this->findNormalBinding(action->getState());
 
-  SoNormalCache * nc = NULL;
+  SoNormalCache * nc = nullptr;
 
-  if (needNormals && normals == NULL) {
+  if (needNormals && normals == nullptr) {
     nc = this->generateAndReadLockNormalCache(state);
     normals = nc->getNormals();
   }
diff --git a/coin4/src/shapenodes/SoVertexShape.cpp b/coin4/src/shapenodes/SoVertexShape.cpp
index 75a1f49..55afac0 100644
--- a/coin4/src/shapenodes/SoVertexShape.cpp
+++ b/coin4/src/shapenodes/SoVertexShape.cpp
@@ -105,10 +105,10 @@ void
 SoVertexShapeP::cleanup(void)
 {
   delete SoVertexShapeP::normalcachemutex;
-  SoVertexShapeP::normalcachemutex = NULL;
+  SoVertexShapeP::normalcachemutex = nullptr;
 }
 
-SbRWMutex * SoVertexShapeP::normalcachemutex = NULL;
+SbRWMutex * SoVertexShapeP::normalcachemutex = nullptr;
 
 #define PRIVATE(obj) ((obj)->pimpl)
 
@@ -138,11 +138,11 @@ SoVertexShape::initClass(void)
 SoVertexShape::SoVertexShape(void)
 {
   PRIVATE(this) = new SoVertexShapeP;
-  PRIVATE(this)->normalcache = NULL;
+  PRIVATE(this)->normalcache = nullptr;
 
   SO_NODE_INTERNAL_CONSTRUCTOR(SoVertexShape);
 
-  SO_NODE_ADD_FIELD(vertexProperty, (NULL));
+  SO_NODE_ADD_FIELD(vertexProperty, (nullptr));
 }
 
 /*!
@@ -236,7 +236,7 @@ SoVertexShape::setNormalCache(SoState * const state,
 }
 
 /*!
-  Returns the current normal cache, or NULL if there is none.
+  Returns the current normal cache, or nullptr if there is none.
 */
 SoNormalCache *
 SoVertexShape::getNormalCache(void) const
@@ -281,7 +281,7 @@ SoVertexShape::generateAndReadLockNormalCache(SoState * const state)
   //
   if (!generateDefaultNormals(state, PRIVATE(this)->normalcache)) {
     // FIXME: implement SoNormalBundle
-    if (generateDefaultNormals(state, (SoNormalBundle *)NULL)) {
+    if (generateDefaultNormals(state, (SoNormalBundle *)nullptr)) {
       // FIXME: set generator in normal cache
     }
   }
@@ -306,7 +306,7 @@ SoVertexShape::getVertexData(SoState * state,
   coords = SoCoordinateElement::getInstance(state);
   assert(coords);
 
-  normals = NULL;
+  normals = nullptr;
   if (neednormals) {
     normals = SoNormalElement::getInstance(state)->getArrayPtr();
   }
diff --git a/coin4/src/shapenodes/soshape_bigtexture.cpp b/coin4/src/shapenodes/soshape_bigtexture.cpp
index 0607622..96376f4 100644
--- a/coin4/src/shapenodes/soshape_bigtexture.cpp
+++ b/coin4/src/shapenodes/soshape_bigtexture.cpp
@@ -47,9 +47,9 @@
 
 soshape_bigtexture::soshape_bigtexture(void)
 {
-  this->clipper = NULL;
-  this->pvlist = NULL;
-  this->regions = NULL;
+  this->clipper = nullptr;
+  this->pvlist = nullptr;
+  this->regions = nullptr;
   this->numallocregions = 0;
 }
 
@@ -92,7 +92,7 @@ soshape_bigtexture::beginShape(SoGLBigImage * imageptr,
   }
   this->numregions = num;
 
-  if (this->clipper == NULL) {
+  if (this->clipper == nullptr) {
     this->clipper = new SbClip(clipcb, this);
     this->pvlist = new SbList <SoPrimitiveVertex*>;
     this->regions = new bt_region[num];
diff --git a/coin4/src/shapenodes/soshape_bumprender.cpp b/coin4/src/shapenodes/soshape_bumprender.cpp
index 864e97c..50119c0 100644
--- a/coin4/src/shapenodes/soshape_bumprender.cpp
+++ b/coin4/src/shapenodes/soshape_bumprender.cpp
@@ -430,7 +430,7 @@ soshape_bumprender::renderBumpSpecular(SoState * state,
 
   state->push();
   SoMultiTextureEnabledElement::disableAll(state);
-  SoGLMultiTextureEnabledElement::set(state, NULL, 0, true); // enable GL_TEXTURE_2D
+  SoGLMultiTextureEnabledElement::set(state, nullptr, 0, true); // enable GL_TEXTURE_2D
   
   SoGLImage * bumpimage = SoBumpMapElement::get(state);
   assert(bumpimage);
@@ -602,7 +602,7 @@ soshape_bumprender::renderBump(SoState * state,
     this->calcTSBCoords(cache, light);
   }
   SoMultiTextureEnabledElement::disableAll(state);
-  SoMultiTextureEnabledElement::set(state, NULL, 0, true);
+  SoMultiTextureEnabledElement::set(state, nullptr, 0, true);
 
   SoGLImage * bumpimage = SoBumpMapElement::get(state);
   assert(bumpimage);
diff --git a/coin4/src/shapenodes/soshape_primdata.cpp b/coin4/src/shapenodes/soshape_primdata.cpp
index af8d450..bb0fbe3 100644
--- a/coin4/src/shapenodes/soshape_primdata.cpp
+++ b/coin4/src/shapenodes/soshape_primdata.cpp
@@ -42,19 +42,19 @@
 soshape_primdata::soshape_primdata(void)
 {
   this->counter = 0;
-  this->action = NULL;
-  this->shape = NULL;
+  this->action = nullptr;
+  this->shape = nullptr;
   this->faceCounter = 0;
   this->arraySize = 4;
   this->vertsArray = new SoPrimitiveVertex[this->arraySize];
   this->pointDetails = new SoPointDetail[this->arraySize];
-  this->faceDetail = NULL;
-  this->lineDetail = NULL;
+  this->faceDetail = nullptr;
+  this->lineDetail = nullptr;
   this->matPerFace = false;
   this->normPerFace = false;
 
-  this->tess = NULL;
-  this->glutess = NULL;
+  this->tess = nullptr;
+  this->glutess = nullptr;
 
   if (SbGLUTessellator::preferred()) {
     this->glutess = new SbGLUTessellator(soshape_primdata::tess_callback, this);
@@ -382,7 +382,7 @@ soshape_primdata::createPickDetail(void)
   case SoShape::POINTS:
     {
       assert(0 && "should not get here");
-      return NULL;
+      return nullptr;
     }
   case SoShape::LINES:
   case SoShape::LINE_STRIP:
@@ -394,7 +394,7 @@ soshape_primdata::createPickDetail(void)
     }
   default:
     assert(0 && "unknown shape type");
-    return NULL;
+    return nullptr;
   }
 }
 
diff --git a/coin4/src/shapenodes/soshape_trianglesort.cpp b/coin4/src/shapenodes/soshape_trianglesort.cpp
index 734cc41..7b7e8b2 100644
--- a/coin4/src/shapenodes/soshape_trianglesort.cpp
+++ b/coin4/src/shapenodes/soshape_trianglesort.cpp
@@ -44,8 +44,8 @@
 
 soshape_trianglesort::soshape_trianglesort(void)
 {
-  this->pvlist = NULL;
-  this->trianglelist = NULL;
+  this->pvlist = nullptr;
+  this->trianglelist = nullptr;
 }
 
 soshape_trianglesort::~soshape_trianglesort()
@@ -57,7 +57,7 @@ soshape_trianglesort::~soshape_trianglesort()
 void
 soshape_trianglesort::beginShape(SoState *)
 {
-  if (this->pvlist == NULL) {
+  if (this->pvlist == nullptr) {
     this->pvlist = new SbList <SoPrimitiveVertex>;
     this->trianglelist = new SbList <sorted_triangle>;
   }
diff --git a/coin4/src/soscxml/ScXMLCoinEvaluator.cpp b/coin4/src/soscxml/ScXMLCoinEvaluator.cpp
index 8f29369..658afed 100644
--- a/coin4/src/soscxml/ScXMLCoinEvaluator.cpp
+++ b/coin4/src/soscxml/ScXMLCoinEvaluator.cpp
@@ -145,7 +145,7 @@ ScXMLCoinEvaluator::setAtLocation(const char * location, ScXMLDataObj * obj)
       PRIVATE(this)->temporaries.erase(it); // erase it
     }
 
-    ScXMLConstantDataObj * cobj = NULL;
+    ScXMLConstantDataObj * cobj = nullptr;
     if (obj->getTypeId().isDerivedFrom(ScXMLConstantDataObj::getClassTypeId())) {
       cobj = static_cast<ScXMLConstantDataObj *>(obj);
     } else {
@@ -183,7 +183,7 @@ ScXMLCoinEvaluator::setAtLocation(const char * location, ScXMLDataObj * obj)
       // no such datamodel variable
       return false;
     }
-    ScXMLConstantDataObj * cobj = NULL;
+    ScXMLConstantDataObj * cobj = nullptr;
     if (obj->getTypeId().isDerivedFrom(ScXMLConstantDataObj::getClassTypeId())) {
       cobj = static_cast<ScXMLConstantDataObj *>(obj);
     } else {
@@ -221,7 +221,7 @@ ScXMLCoinEvaluator::setAtLocation(const char * location, ScXMLDataObj * obj)
   //   location is scene graph?
   //   location is globalfield?
 
-  SoFieldContainer * fieldcontainer = NULL;
+  SoFieldContainer * fieldcontainer = nullptr;
   SbName fieldname(SbName::empty());
 
   if (strncmp(location, "coin:camera.", 12) == 0) {
@@ -283,11 +283,11 @@ ScXMLCoinEvaluator::locate(const char * location) const
     std::map<const char *, ScXMLDataObj *>::const_iterator it =
       PRIVATE(this)->temporaries.find(varname.getString());
     if (it == PRIVATE(this)->temporaries.end()) {
-      return NULL;
+      return nullptr;
     }
     return it->second;
   }
-  else if (strpbrk(location, ":.") == NULL) {
+  else if (strpbrk(location, ":.") == nullptr) {
     // maybe implicit location path
     SbName varname(location);
     std::map<const char *, ScXMLDataObj *>::const_iterator it =
@@ -305,37 +305,37 @@ ScXMLCoinEvaluator::locate(const char * location) const
     if (!dataelt) {
       // no such datamodel variable
       //printf("error: could not find data named '%s'\n", varname.getString());
-      return NULL;
+      return nullptr;
     }
     const char * expr = dataelt->getExprAttribute();
     ScXMLDataObj * obj = this->evaluate(expr);
     if (!obj) {
       // could not evaluate
       //printf("error: could not evaluate data named '%s'\n", varname.getString());
-      return NULL;
+      return nullptr;
     }
 
-    ScXMLConstantDataObj * cobj = NULL;
+    ScXMLConstantDataObj * cobj = nullptr;
     if (obj->getTypeId().isDerivedFrom(ScXMLConstantDataObj::getClassTypeId())) {
       cobj = static_cast<ScXMLConstantDataObj *>(obj);
     } else {
       if (!obj->getTypeId().isDerivedFrom(ScXMLExprDataObj::getClassTypeId())) {
         // illegal obj
         //printf("error: neither constant not expression ('%s')\n", varname.getString());
-        return NULL;
+        return nullptr;
       }
       ScXMLExprDataObj * expr = static_cast<ScXMLExprDataObj *>(obj);
       ScXMLDataObj * res = expr->evaluate(sm);
       if (!res) {
         // unable to evaluate
         //printf("error: evaluate for ('%s') failed\n", varname.getString());
-        return NULL;
+        return nullptr;
       }
       assert(res);
       if (!res->getTypeId().isDerivedFrom(ScXMLConstantDataObj::getClassTypeId())) {
         // did not evaluate
         //printf("error: evaluate for ('%s') and still not constant\n", varname.getString());
-        return NULL;
+        return nullptr;
       }
       cobj = static_cast<ScXMLConstantDataObj *>(res);
     }
@@ -354,21 +354,21 @@ ScXMLCoinEvaluator::locate(const char * location) const
     const char * assoc = event->getAssociation(assocname);
     if (!assoc) {
       // invalid event hook?
-      return NULL;
+      return nullptr;
     }
     ScXMLDataObj * dataobj = this->evaluate(assoc);
     if (!dataobj) {
-      return NULL;
+      return nullptr;
     }
     if (dataobj->getTypeId().isDerivedFrom(ScXMLExprDataObj::getClassTypeId())) {
       ScXMLExprDataObj * expr = static_cast<ScXMLExprDataObj *>(dataobj);
       dataobj = expr->evaluate(sm);
       if (!dataobj) {
-        return NULL;
+        return nullptr;
       }
     }
     if (!dataobj->getTypeId().isDerivedFrom(ScXMLConstantDataObj::getClassTypeId())) {
-      return NULL;
+      return nullptr;
     }
     return dataobj;
   }
@@ -379,7 +379,7 @@ ScXMLCoinEvaluator::locate(const char * location) const
   }
   if (strncmp(location, "coin:global.", 12) == 0) {
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -598,20 +598,20 @@ ScXMLCoinLengthFuncExprDataObj::createFor(ScXMLDataObj * obj)
     default:
       break;
     }
-    return NULL;
+    return nullptr;
   }
   else if (obj->isOfType(ScXMLExprDataObj::getClassTypeId())) {
     return new ScXMLCoinLengthFuncExprDataObj(obj);
   }
   else {
-    return NULL;
+    return nullptr;
   }
-  return NULL;
+  return nullptr;
 }
 
 
 ScXMLCoinLengthFuncExprDataObj::ScXMLCoinLengthFuncExprDataObj(void)
-: expr(NULL)
+: expr(nullptr)
 {
 }
 
@@ -624,7 +624,7 @@ ScXMLCoinLengthFuncExprDataObj::~ScXMLCoinLengthFuncExprDataObj(void)
 {
   if (this->expr) {
     delete this->expr;
-    this->expr = NULL;
+    this->expr = nullptr;
   }
 }
 
@@ -633,7 +633,7 @@ ScXMLCoinLengthFuncExprDataObj::setExpr(ScXMLDataObj * obj)
 {
   if (this->expr) {
     delete this->expr;
-    this->expr = NULL;
+    this->expr = nullptr;
   }
   this->expr = obj;
 }
@@ -642,7 +642,7 @@ bool
 ScXMLCoinLengthFuncExprDataObj::evaluateNow(ScXMLStateMachine * sm, ScXMLDataObj * & pointer) const
 {
   assert(this->expr);
-  ScXMLSbDataObj * evaled = NULL;
+  ScXMLSbDataObj * evaled = nullptr;
   if (this->expr->isOfType(ScXMLExprDataObj::getClassTypeId())) {
     ScXMLExprDataObj * rhsexpr = static_cast<ScXMLExprDataObj *>(this->expr);
     ScXMLDataObj * rhsevaled = rhsexpr->evaluate(sm);
@@ -732,11 +732,11 @@ template <class EXPECTED_TYPE>
 bool
 TestReturnValue(const std::string & evaluationString, typename DataObjDemangler< EXPECTED_TYPE >::RET_VAL retVal, boost::scoped_ptr<ScXMLEvaluator> & evaluator)
 {
-  ScXMLDataObj * res = NULL;
+  ScXMLDataObj * res = nullptr;
 
 
   res = evaluator->evaluate(evaluationString.c_str());
-  COIN_REQUIRE_MESSAGE(res != NULL, std::string("Evaluation returned nothing for expression: ") + evaluationString);
+  COIN_REQUIRE_MESSAGE(res != nullptr, std::string("Evaluation returned nothing for expression: ") + evaluationString);
   //FIXME: Should really remember to delete res before returning from this point on,
   //but don't bother about a memory leak when there are bigger fish to
   //fry. 20090613 BFG
diff --git a/coin4/src/soscxml/SoScXMLEvent.cpp b/coin4/src/soscxml/SoScXMLEvent.cpp
index 2729f2d..39670e4 100644
--- a/coin4/src/soscxml/SoScXMLEvent.cpp
+++ b/coin4/src/soscxml/SoScXMLEvent.cpp
@@ -124,14 +124,14 @@ SoScXMLEvent::cleanClass(void)
 }
 
 SoScXMLEvent::SoScXMLEvent(void)
-: soeventptr(NULL)
+: soeventptr(nullptr)
 {
 }
 
 SoScXMLEvent::~SoScXMLEvent(void)
 {
   delete this->soeventptr;
-  this->soeventptr = NULL;
+  this->soeventptr = nullptr;
 }
 
 /*!
@@ -148,7 +148,7 @@ SoScXMLEvent::setSoEvent(const SoEvent * soevent)
 {
   if (this->soeventptr) {
     delete this->soeventptr;
-    this->soeventptr = NULL;
+    this->soeventptr = nullptr;
   }
   if (soevent) {
     SoEvent * newevent =
@@ -159,7 +159,7 @@ SoScXMLEvent::setSoEvent(const SoEvent * soevent)
 }
 
 /*!
-  Returns the pointer to the stored SoEvent or NULL if no event has
+  Returns the pointer to the stored SoEvent or nullptr if no event has
   been stored yet.
 
   \sa setSoEvent
@@ -182,7 +182,7 @@ SoScXMLEvent::getSoEvent(void) const
 void
 SoScXMLEvent::setUpIdentifier(void)
 {
-  if (this->soeventptr == NULL) {
+  if (this->soeventptr == nullptr) {
     this->setEventName("");
     return;
   }
@@ -250,7 +250,7 @@ SoScXMLEvent::copyContents(const ScXMLEvent * rhs)
   inherited::copyContents(rhs);
   if (this->soeventptr) {
     delete this->soeventptr;
-    this->soeventptr = NULL;
+    this->soeventptr = nullptr;
   }
   const SoScXMLEvent * sorhs = static_cast<const SoScXMLEvent *>(rhs);
   if (sorhs->soeventptr) {
diff --git a/coin4/src/soscxml/SoScXMLStateMachine.cpp b/coin4/src/soscxml/SoScXMLStateMachine.cpp
index 4c10842..ea2e6d5 100644
--- a/coin4/src/soscxml/SoScXMLStateMachine.cpp
+++ b/coin4/src/soscxml/SoScXMLStateMachine.cpp
@@ -56,7 +56,7 @@
 class SoScXMLStateMachine::PImpl {
 public:
   PImpl(void)
-    : scenegraphroot(NULL), activecamera(NULL), viewport(100, 100)
+    : scenegraphroot(nullptr), activecamera(nullptr), viewport(100, 100)
   { }
   ~PImpl(void) { }
 
@@ -157,7 +157,7 @@ bool
 SoScXMLStateMachine::processSoEvent(const SoEvent * event)
 {
   // FIXME: Not sure if this check should be here and not somewhere else,
-  // but removing this again makes us crash on NULL scenegraphs. kintel 20080729.
+  // but removing this again makes us crash on nullptr scenegraphs. kintel 20080729.
   if (PRIVATE(this)->scenegraphroot.get()) {
     boost::scoped_ptr<SoScXMLEvent> wrapperevent;
     wrapperevent.reset(new SoScXMLEvent);
@@ -323,7 +323,7 @@ SoScXMLStateMachine::getVariable(const char * key) const
       if (!camera) {
         SoDebugError::post("SoScXMLStateMachine::getVariable",
                            "queried for camera, but no camera is set.");
-        return NULL;
+        return nullptr;
       }
       const char * detail = subkey + 7;
       if (strcmp(detail, "getTypeId()") == 0) {
diff --git a/coin4/src/soscxml/eval-coin-tab.cpp b/coin4/src/soscxml/eval-coin-tab.cpp
index 0196c5b..22865c6 100644
--- a/coin4/src/soscxml/eval-coin-tab.cpp
+++ b/coin4/src/soscxml/eval-coin-tab.cpp
@@ -170,7 +170,7 @@
 #include <Inventor/scxml/ScXMLMinimumEvaluator.h>
 
 namespace {
-static ScXMLDataObj * root = NULL;
+static ScXMLDataObj * root = nullptr;
 }
 
 
@@ -1928,6 +1928,6 @@ scxml_coin_get_root_obj(void)
 void
 scxml_coin_clear_root_obj(void)
 {
-  root = NULL;
+  root = nullptr;
 }
 
diff --git a/coin4/src/soscxml/eval-coin-tab.y b/coin4/src/soscxml/eval-coin-tab.y
index 393d94f..037ec1b 100644
--- a/coin4/src/soscxml/eval-coin-tab.y
+++ b/coin4/src/soscxml/eval-coin-tab.y
@@ -39,7 +39,7 @@
 #include <Inventor/scxml/ScXMLMinimumEvaluator.h>
 
 namespace {
-static ScXMLDataObj * root = NULL;
+static ScXMLDataObj * root = nullptr;
 }
 
 %}
@@ -214,5 +214,5 @@ scxml_coin_get_root_obj(void)
 void
 scxml_coin_clear_root_obj(void)
 {
-  root = NULL;
+  root = nullptr;
 }
diff --git a/coin4/src/soscxml/eval-coin.cpp b/coin4/src/soscxml/eval-coin.cpp
index a0edfc8..adaef42 100644
--- a/coin4/src/soscxml/eval-coin.cpp
+++ b/coin4/src/soscxml/eval-coin.cpp
@@ -277,14 +277,14 @@ static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
  * future we want to put the buffer states in a more general
  * "scanner state".
  *
- * Returns the top of the stack, or NULL.
+ * Returns the top of the stack, or nullptr.
  */
 #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
-                          : NULL)
+                          : nullptr)
 
 /* Same as previous macro, but useful when we know that the buffer stack is not
- * NULL or when we need an lvalue. For internal use only.
+ * nullptr or when we need an lvalue. For internal use only.
  */
 #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
 
@@ -1674,7 +1674,7 @@ static void scxml_coin__load_buffer_state  (void)
  */
 void scxml_coin_push_buffer_state (YY_BUFFER_STATE new_buffer )
 {
-    	if (new_buffer == NULL)
+    	if (new_buffer == nullptr)
 		return;
 
 	scxml_coin_ensure_buffer_stack();
@@ -1708,7 +1708,7 @@ void scxml_coin_pop_buffer_state (void)
 		return;
 
 	scxml_coin__delete_buffer(YY_CURRENT_BUFFER );
-	YY_CURRENT_BUFFER_LVALUE = NULL;
+	YY_CURRENT_BUFFER_LVALUE = nullptr;
 	if ((yy_buffer_stack_top) > 0)
 		--(yy_buffer_stack_top);
 
@@ -1992,13 +1992,13 @@ int scxml_coin_lex_destroy  (void)
     /* Pop the buffer stack, destroying each element. */
 	while(YY_CURRENT_BUFFER){
 		scxml_coin__delete_buffer(YY_CURRENT_BUFFER  );
-		YY_CURRENT_BUFFER_LVALUE = NULL;
+		YY_CURRENT_BUFFER_LVALUE = nullptr;
 		scxml_coin_pop_buffer_state();
 	}
 
 	/* Destroy the stack itself. */
 	scxml_coin_free((yy_buffer_stack) );
-	(yy_buffer_stack) = NULL;
+	(yy_buffer_stack) = nullptr;
 
     /* Reset the globals. This is important in a non-reentrant scanner so the next time
      * scxml_coin_lex() is called, initialization will occur. */
diff --git a/coin4/src/threads/barrier.cpp b/coin4/src/threads/barrier.cpp
index 77f0c4d..17ed205 100644
--- a/coin4/src/threads/barrier.cpp
+++ b/coin4/src/threads/barrier.cpp
@@ -55,7 +55,7 @@ cc_barrier_construct(unsigned int count)
 void
 cc_barrier_destruct(cc_barrier * barrier)
 {
-  assert(barrier != NULL);
+  assert(barrier != nullptr);
          
   cc_condvar_wake_all(barrier->condvar);
   cc_condvar_destruct(barrier->condvar);
@@ -69,7 +69,7 @@ cc_barrier_destruct(cc_barrier * barrier)
 int
 cc_barrier_enter(cc_barrier * barrier)
 {
-  assert(barrier != NULL);
+  assert(barrier != nullptr);
   cc_mutex_lock(barrier->mutex);
   barrier->counter++;
   if (barrier->counter == barrier->numthreads) {
diff --git a/coin4/src/threads/condvar.cpp b/coin4/src/threads/condvar.cpp
index 4ae3974..26a0230 100644
--- a/coin4/src/threads/condvar.cpp
+++ b/coin4/src/threads/condvar.cpp
@@ -67,7 +67,7 @@ void
 cc_condvar_struct_clean(cc_condvar * condvar_struct)
 {
   int ok;
-  assert(condvar_struct != NULL);
+  assert(condvar_struct != nullptr);
   ok = internal_condvar_struct_clean(condvar_struct);
   assert(ok == CC_OK);
 }
@@ -82,7 +82,7 @@ cc_condvar_construct(void)
 {
   cc_condvar * condvar;
   condvar = (cc_condvar *) malloc(sizeof(cc_condvar));
-  assert(condvar != NULL);
+  assert(condvar != nullptr);
   cc_condvar_struct_init(condvar);
   return condvar;
 }
@@ -93,7 +93,7 @@ cc_condvar_construct(void)
 void
 cc_condvar_destruct(cc_condvar * condvar)
 {
-  assert((condvar != NULL));
+  assert((condvar != nullptr));
   cc_condvar_struct_clean(condvar);
   free(condvar);
 }
@@ -105,7 +105,7 @@ int
 cc_condvar_wait(cc_condvar * condvar, cc_mutex * mutex)
 {
   int ok;
-  assert(condvar != NULL);
+  assert(condvar != nullptr);
   ok = internal_condvar_wait(condvar, mutex);
   assert(ok == CC_OK);
   return ok;
@@ -120,7 +120,7 @@ cc_condvar_timed_wait(cc_condvar * condvar,
                       cc_time period)
 {
   int ret;
-  assert(condvar != NULL);
+  assert(condvar != nullptr);
   ret = internal_condvar_timed_wait(condvar, mutex, period);
   assert(ret == CC_OK || ret == CC_TIMEOUT);
   return ret;
@@ -133,7 +133,7 @@ void
 cc_condvar_wake_one(cc_condvar * condvar)
 {
   int ok;
-  assert(condvar != NULL);
+  assert(condvar != nullptr);
   ok = internal_condvar_wake_one(condvar);
   assert(ok == CC_OK);
 }
@@ -144,7 +144,7 @@ void
 cc_condvar_wake_all(cc_condvar * condvar)
 {
   int ok;
-  assert(condvar != NULL);
+  assert(condvar != nullptr);
 
   ok = internal_condvar_wake_all(condvar);
   assert(ok == CC_OK);
diff --git a/coin4/src/threads/condvar_pthread.icc b/coin4/src/threads/condvar_pthread.icc
index 02d3b27..016f870 100644
--- a/coin4/src/threads/condvar_pthread.icc
+++ b/coin4/src/threads/condvar_pthread.icc
@@ -32,7 +32,7 @@
 static int
 internal_condvar_struct_init(cc_condvar * condvar_struct)
 {
-  int status = pthread_cond_init(&(condvar_struct->pthread.condid), NULL);
+  int status = pthread_cond_init(&(condvar_struct->pthread.condid), nullptr);
   if (status != 0) {
     if (COIN_DEBUG)
       cc_debugerror_post("internal_condvar_struct_init",
diff --git a/coin4/src/threads/condvar_win32.icc b/coin4/src/threads/condvar_win32.icc
index a8fd528..beff85f 100644
--- a/coin4/src/threads/condvar_win32.icc
+++ b/coin4/src/threads/condvar_win32.icc
@@ -38,22 +38,22 @@ internal_condvar_struct_init(cc_condvar * condvar_struct)
 {
   /* auto-reset, initially is non-signaled */
   condvar_struct->w32thread.eventhandle[EVENT_SIGNAL] =
-    CreateEvent(NULL, false, false, NULL);
-  if (condvar_struct->w32thread.eventhandle[EVENT_SIGNAL] == NULL) {
+    CreateEvent(nullptr, false, false, nullptr);
+  if (condvar_struct->w32thread.eventhandle[EVENT_SIGNAL] == nullptr) {
     if (COIN_DEBUG) {
       cc_win32_print_error("internal_condvar_struct_init",
-                           "CreateEvent(NULL,false,false,NULL)",
+                           "CreateEvent(nullptr,false,false,nullptr)",
                            GetLastError());
     }
     return CC_ERROR;
   }
   /* auto-reset, initially is non-signaled */
   condvar_struct->w32thread.eventhandle[EVENT_BROADCAST] =
-    CreateEvent(NULL, true, false, NULL);
-  if (condvar_struct->w32thread.eventhandle[EVENT_BROADCAST] == NULL) {
+    CreateEvent(nullptr, true, false, nullptr);
+  if (condvar_struct->w32thread.eventhandle[EVENT_BROADCAST] == nullptr) {
     if (COIN_DEBUG) {
       cc_win32_print_error("internal_condvar_struct_init",
-                           "CreateEvent(NULL,true,false,NULL)",
+                           "CreateEvent(nullptr,true,false,nullptr)",
                            GetLastError());
     }
     return CC_ERROR;
diff --git a/coin4/src/threads/fifo.cpp b/coin4/src/threads/fifo.cpp
index 0e24248..432385e 100644
--- a/coin4/src/threads/fifo.cpp
+++ b/coin4/src/threads/fifo.cpp
@@ -53,11 +53,11 @@ static cc_fifo_item * i_unlink_head(cc_fifo * fifo);
 void
 cc_fifo_struct_init(cc_fifo * fifo)
 {
-  assert(fifo != NULL);
+  assert(fifo != nullptr);
   cc_mutex_struct_init(&fifo->access);
-  fifo->head = NULL;
-  fifo->tail = NULL;
-  fifo->free = NULL;
+  fifo->head = nullptr;
+  fifo->tail = nullptr;
+  fifo->free = nullptr;
   fifo->elements = 0;
   cc_condvar_struct_init(&fifo->sleep);
 }
@@ -66,18 +66,18 @@ void
 cc_fifo_struct_clean(cc_fifo * fifo)
 {
   cc_fifo_item * item, * next;
-  assert(fifo != NULL);
+  assert(fifo != nullptr);
   cc_mutex_struct_clean(&fifo->access);
   /* free fifo list */
   item = fifo->head;
-  while ( item != NULL ) {
+  while ( item != nullptr ) {
     next = item->next;
     cc_fifo_item_delete(item);
     item = next;
   }
   /* free free list */
   item = fifo->free;
-  while ( item != NULL ) {
+  while ( item != nullptr ) {
     next = item->next;
     cc_fifo_item_delete(item);
     item = next;
@@ -109,7 +109,7 @@ void
 cc_fifo_assign(cc_fifo * fifo, void * ptr, uint32_t type)
 {
   cc_fifo_item * item;
-  assert(fifo != NULL);
+  assert(fifo != nullptr);
   cc_mutex_lock(&fifo->access);
   item = i_get_free_item(fifo);
   item->item = ptr;
@@ -123,7 +123,7 @@ void
 cc_fifo_retrieve(cc_fifo * fifo, void ** ptr, uint32_t * type)
 {
   cc_fifo_item * item;
-  assert(fifo != NULL && ptr != NULL);
+  assert(fifo != nullptr && ptr != nullptr);
   cc_mutex_lock(&fifo->access);
   while ( true ) {
     if ( fifo->elements == 0 ) {
@@ -131,7 +131,7 @@ cc_fifo_retrieve(cc_fifo * fifo, void ** ptr, uint32_t * type)
     } else {
       item = i_unlink_head(fifo);
       *ptr = item->item;
-      if ( type != NULL ) *type = item->type;
+      if ( type != nullptr ) *type = item->type;
       item->next = fifo->free;
       fifo->free = item;
       cc_mutex_unlock(&fifo->access);
@@ -145,7 +145,7 @@ bool
 cc_fifo_try_retrieve(cc_fifo * fifo, void ** ptr, uint32_t * type)
 {
   cc_fifo_item * item;
-  assert(fifo != NULL && ptr != NULL);
+  assert(fifo != nullptr && ptr != nullptr);
   /* FIXME: consider cc_mutex_try_lock()? to escape even a failed lock */
   if ( ! cc_mutex_try_lock(&fifo->access) ) {
     return false;
@@ -156,7 +156,7 @@ cc_fifo_try_retrieve(cc_fifo * fifo, void ** ptr, uint32_t * type)
   }
   item = i_unlink_head(fifo);
   *ptr = item->item;
-  if ( type != NULL ) *type = item->type;
+  if ( type != nullptr ) *type = item->type;
   cc_fifo_item_delete(item);
   cc_mutex_unlock(&fifo->access);
   cc_condvar_wake_one(&fifo->sleep);
@@ -168,7 +168,7 @@ cc_fifo_try_retrieve(cc_fifo * fifo, void ** ptr, uint32_t * type)
 unsigned int
 cc_fifo_size(cc_fifo * fifo)
 {
-  assert(fifo != NULL);
+  assert(fifo != nullptr);
   return fifo->elements;
 }
 
@@ -179,9 +179,9 @@ cc_fifo_item_new(void) /* static */
 {
   cc_fifo_item * item;
   item = (cc_fifo_item*) malloc(sizeof(cc_fifo_item));
-  assert(item != NULL);
-  item->next = NULL;
-  item->item = NULL;
+  assert(item != nullptr);
+  item->next = nullptr;
+  item->item = nullptr;
   item->type = 0;
   return item;
 }
@@ -189,7 +189,7 @@ cc_fifo_item_new(void) /* static */
 void
 cc_fifo_item_delete(cc_fifo_item * item) /* static */
 {
-  assert(item != NULL);
+  assert(item != nullptr);
   free(item);
 }
 
@@ -198,21 +198,21 @@ cc_fifo_item_delete(cc_fifo_item * item) /* static */
 void
 cc_fifo_lock(cc_fifo * fifo)
 {
-  assert(fifo != NULL);
+  assert(fifo != nullptr);
   cc_mutex_lock(&fifo->access);
 }
 
 bool
 cc_fifo_try_lock(cc_fifo * fifo)
 {
-  assert(fifo != NULL);
+  assert(fifo != nullptr);
   return cc_mutex_try_lock(&fifo->access);
 }
 
 void
 cc_fifo_unlock(cc_fifo * fifo)
 {
-  assert(fifo != NULL);
+  assert(fifo != nullptr);
   cc_mutex_unlock(&fifo->access);
 }
 
@@ -221,10 +221,10 @@ cc_fifo_unlock(cc_fifo * fifo)
 bool
 cc_fifo_peek(cc_fifo * fifo, void ** item, uint32_t * type)
 {
-  assert(fifo != NULL);
-  if ( fifo->head == NULL ) return false;
+  assert(fifo != nullptr);
+  if ( fifo->head == nullptr ) return false;
   *item = fifo->head->item;
-  if ( type != NULL ) *type = fifo->head->type;
+  if ( type != nullptr ) *type = fifo->head->type;
   return true;
 }
 
@@ -232,9 +232,9 @@ bool
 cc_fifo_contains(cc_fifo * fifo, void * itemptr)
 {
   cc_fifo_item * item;
-  assert(fifo != NULL);
+  assert(fifo != nullptr);
   item = fifo->head;
-  while ( item != NULL ) {
+  while ( item != nullptr ) {
     if ( item->item == itemptr ) return true;
     item = item->next;
   }
@@ -245,16 +245,16 @@ bool
 cc_fifo_reclaim(cc_fifo * fifo, void * itemptr)
 {
   cc_fifo_item * item, * prev;
-  assert(fifo != NULL);
+  assert(fifo != nullptr);
   item = fifo->head;
-  prev = NULL;
-  while ( item != NULL ) {
+  prev = nullptr;
+  while ( item != nullptr ) {
     if ( item->item == itemptr ) {
-      if ( prev == NULL ) fifo->head = item->next;
+      if ( prev == nullptr ) fifo->head = item->next;
       else prev->next = item->next;
       if ( fifo->tail == item ) fifo->tail = prev;
       /* and reset/store the container */
-      item->item = NULL;
+      item->item = nullptr;
       item->type = 0;
       item->next = fifo->free;
       fifo->free = item;
@@ -276,10 +276,10 @@ cc_fifo_item *
 i_get_free_item(cc_fifo * fifo) /* static */
 {
   cc_fifo_item * item;
-  if ( fifo->free != NULL ) {
+  if ( fifo->free != nullptr ) {
     item = fifo->free;
     fifo->free = item->next;
-    item->next = NULL;
+    item->next = nullptr;
   } else {
     item = cc_fifo_item_new();
   }
@@ -294,7 +294,7 @@ i_get_free_item(cc_fifo * fifo) /* static */
 void
 i_append(cc_fifo * fifo, cc_fifo_item * item) /* static */
 {
-  if ( fifo->tail == NULL ) {
+  if ( fifo->tail == nullptr ) {
     fifo->head = item;
     fifo->tail = item;
   } else {
@@ -315,8 +315,8 @@ i_unlink_head(cc_fifo * fifo) /* static */
   cc_fifo_item * item;
   item = fifo->head;
   fifo->head = item->next;
-  if ( fifo->head == NULL )
-    fifo->tail = NULL;
+  if ( fifo->head == nullptr )
+    fifo->tail = nullptr;
   fifo->elements -= 1;
   return item;
 }
diff --git a/coin4/src/threads/mutex.cpp b/coin4/src/threads/mutex.cpp
index 8bfa585..628bc8a 100644
--- a/coin4/src/threads/mutex.cpp
+++ b/coin4/src/threads/mutex.cpp
@@ -53,7 +53,7 @@
 /* we test if Win32 TryEnterCriticalSection exists, and use Win32
    critical section if it does, and Win32 mutex if it doesn't */
 typedef BOOL (WINAPI * cc_mutex_TryEnterCriticalSection_func)(LPCRITICAL_SECTION);
-static cc_mutex_TryEnterCriticalSection_func cc_mutex_TryEnterCriticalSection = NULL; 
+static cc_mutex_TryEnterCriticalSection_func cc_mutex_TryEnterCriticalSection = nullptr; 
 #include "mutex_win32mutex.icc" 
 #include "mutex_win32cs.icc" 
 #endif /* USE_W32THREAD */
@@ -121,7 +121,7 @@ cc_mutex_construct(void)
 {
   cc_mutex * mutex;
   mutex = (cc_mutex *) malloc(sizeof(cc_mutex));
-  assert(mutex != NULL);
+  assert(mutex != nullptr);
   cc_mutex_struct_init(mutex);
 
   { /* debugging */
@@ -149,7 +149,7 @@ cc_mutex_destruct(cc_mutex * mutex)
     }
   }
 
-  assert(mutex != NULL);
+  assert(mutex != nullptr);
   cc_mutex_struct_clean(mutex);
   free(mutex);
 }
@@ -165,7 +165,7 @@ cc_mutex_lock(cc_mutex * mutex)
   bool timeit;
   cc_time start = 0.0;
 
-  assert(mutex != NULL);
+  assert(mutex != nullptr);
 
   timeit = (maxmutexlocktime != DBL_MAX) || (reportmutexlocktiming != DBL_MAX);
   if (timeit) { start = cc_time_gettimeofday(); }
@@ -203,7 +203,7 @@ int
 cc_mutex_try_lock(cc_mutex * mutex)
 {
   int ok;
-  assert(mutex != NULL);
+  assert(mutex != nullptr);
 #ifdef USE_W32THREAD
   if (cc_mutex_TryEnterCriticalSection)
     ok = win32_cs_try_lock(mutex);
@@ -223,7 +223,7 @@ void
 cc_mutex_unlock(cc_mutex * mutex)
 {
   int ok;
-  assert(mutex != NULL);
+  assert(mutex != nullptr);
 #ifdef USE_W32THREAD
   if (cc_mutex_TryEnterCriticalSection)
     ok = win32_cs_unlock(mutex);
@@ -236,13 +236,13 @@ cc_mutex_unlock(cc_mutex * mutex)
   assert(ok == CC_OK);
 }
 
-static cc_mutex * cc_global_mutex = NULL;
+static cc_mutex * cc_global_mutex = nullptr;
 
 static void
 cc_mutex_cleanup(void)
 {
   cc_mutex_destruct(cc_global_mutex);
-  cc_global_mutex = NULL;
+  cc_global_mutex = nullptr;
 }
 
 void
@@ -265,7 +265,7 @@ cc_mutex_init(void)
   
 #endif /* USE_W32THREAD */
 
-  if (cc_global_mutex == NULL) {
+  if (cc_global_mutex == nullptr) {
     cc_global_mutex = cc_mutex_construct();
     /* atexit priority makes this callback trigger after other cleanup
        functions. */
@@ -289,7 +289,7 @@ cc_mutex_global_lock(void)
      called (called from SoDB::init()). This is safe, since the
      application should not be multithreaded before SoDB::init() is
      called */
-  if (cc_global_mutex == NULL) cc_mutex_init();
+  if (cc_global_mutex == nullptr) cc_mutex_init();
   
   (void) cc_mutex_lock(cc_global_mutex);
 }
diff --git a/coin4/src/threads/mutex_pthread.icc b/coin4/src/threads/mutex_pthread.icc
index 5a1a63d..5146386 100644
--- a/coin4/src/threads/mutex_pthread.icc
+++ b/coin4/src/threads/mutex_pthread.icc
@@ -26,7 +26,7 @@
 static int
 internal_mutex_struct_init(cc_mutex * mutex_struct)
 {
-  int status = pthread_mutex_init(&mutex_struct->pthread.mutexid, NULL);
+  int status = pthread_mutex_init(&mutex_struct->pthread.mutexid, nullptr);
   if (status != 0) {
     if (COIN_DEBUG)
       cc_debugerror_post("internal_mutex_struct_init",
diff --git a/coin4/src/threads/mutex_win32mutex.icc b/coin4/src/threads/mutex_win32mutex.icc
index 70261f5..91c16d2 100644
--- a/coin4/src/threads/mutex_win32mutex.icc
+++ b/coin4/src/threads/mutex_win32mutex.icc
@@ -32,8 +32,8 @@
 static int
 win32_mutex_struct_init(cc_mutex * mutex_struct)
 {
-  mutex_struct->w32thread.mutexhandle = CreateMutex(NULL, false, NULL);
-  if (mutex_struct->w32thread.mutexhandle == NULL) {
+  mutex_struct->w32thread.mutexhandle = CreateMutex(nullptr, false, nullptr);
+  if (mutex_struct->w32thread.mutexhandle == nullptr) {
     if (COIN_DEBUG) {
       cc_win32_print_error("win32_mutex_struct_init",
                            "CreateMutex()", GetLastError());
diff --git a/coin4/src/threads/recmutex.cpp b/coin4/src/threads/recmutex.cpp
index 31e0658..004819d 100644
--- a/coin4/src/threads/recmutex.cpp
+++ b/coin4/src/threads/recmutex.cpp
@@ -78,7 +78,7 @@ cc_recmutex_construct(void)
 {
   cc_recmutex * recmutex;
   recmutex = (cc_recmutex *) malloc(sizeof(cc_recmutex));
-  assert(recmutex != NULL);
+  assert(recmutex != nullptr);
   cc_recmutex_struct_init(recmutex);
 
   { /* debugging */
@@ -111,7 +111,7 @@ cc_recmutex_destruct(cc_recmutex * recmutex)
     }
   }
 
-  assert(recmutex != NULL);
+  assert(recmutex != nullptr);
   cc_recmutex_struct_clean(recmutex);
   free(recmutex);
 }
@@ -124,7 +124,7 @@ static int recmutex_lock_internal(cc_recmutex * recmutex, int wait)
   int level = -1; /* return -1 for recmutex_try_lock() if we couldn't get the mutex */
   unsigned long id = cc_thread_id();
   
-  assert(recmutex != NULL);
+  assert(recmutex != nullptr);
   cc_mutex_lock(&recmutex->mutex);
   if (recmutex->level == 0) {
     recmutex->level++;
@@ -181,7 +181,7 @@ int
 cc_recmutex_unlock(cc_recmutex * recmutex)
 {
   int level;
-  assert(recmutex != NULL);
+  assert(recmutex != nullptr);
   assert(recmutex->threadid == cc_thread_id());
   assert(recmutex->level > 0);
   cc_mutex_lock(&recmutex->mutex);
diff --git a/coin4/src/threads/rwmutex.cpp b/coin4/src/threads/rwmutex.cpp
index afb79e8..f4b9bd7 100644
--- a/coin4/src/threads/rwmutex.cpp
+++ b/coin4/src/threads/rwmutex.cpp
@@ -81,7 +81,7 @@ cc_rwmutex_construct(void)
 {
   cc_rwmutex * rwmutex;
   rwmutex = (cc_rwmutex *) malloc(sizeof(cc_rwmutex));
-  assert(rwmutex != NULL);
+  assert(rwmutex != nullptr);
   cc_rwmutex_struct_init(rwmutex);
 
   { /* debugging */
@@ -106,7 +106,7 @@ cc_rwmutex_construct_etc(enum cc_precedence policy)
   cc_rwmutex * rwmutex;
   assert((policy == CC_READ_PRECEDENCE) || (policy == CC_WRITE_PRECEDENCE));
   rwmutex = cc_rwmutex_construct();
-  assert(rwmutex != NULL);
+  assert(rwmutex != nullptr);
   rwmutex->policy = policy;
   return rwmutex;
 }
@@ -128,7 +128,7 @@ cc_rwmutex_destruct(cc_rwmutex * rwmutex)
     }
   }
 
-  assert(rwmutex != NULL);
+  assert(rwmutex != nullptr);
   cc_rwmutex_struct_clean(rwmutex);
   free(rwmutex);
 }
@@ -214,7 +214,7 @@ cc_rwmutex_write_unlock(cc_rwmutex * rwmutex)
 int
 cc_rwmutex_read_lock(cc_rwmutex * rwmutex)
 {
-  assert(rwmutex != NULL);
+  assert(rwmutex != nullptr);
   (void) cc_mutex_lock(&rwmutex->mutex);
   if (rwmutex->writers == 0) {
     rwmutex->readers++;
@@ -242,7 +242,7 @@ cc_rwmutex_read_lock(cc_rwmutex * rwmutex)
 int
 cc_rwmutex_read_try_lock(cc_rwmutex * rwmutex)
 {
-  assert(rwmutex != NULL);
+  assert(rwmutex != nullptr);
 
   (void) cc_mutex_lock(&rwmutex->mutex);
   if (rwmutex->writers == 0 &&
diff --git a/coin4/src/threads/sched.cpp b/coin4/src/threads/sched.cpp
index 77ab171..a6a445d 100644
--- a/coin4/src/threads/sched.cpp
+++ b/coin4/src/threads/sched.cpp
@@ -46,7 +46,7 @@
 
    20051202 mortene. */
 
-cc_sched * cc_sched_construct(int numthreads) { assert(false); return NULL; }
+cc_sched * cc_sched_construct(int numthreads) { assert(false); return nullptr; }
 void cc_sched_destruct(cc_sched * sched) { assert(false); }
 void cc_sched_set_num_threads(cc_sched * sched, int num) { assert(false); }
 int cc_sched_get_num_threads(cc_sched * sched) { assert(false); return 0; }
@@ -255,7 +255,7 @@ bool
 cc_sched_unschedule(cc_sched * sched, uint32_t schedid)
 {
   bool didremove = false;
-  void * item = NULL;
+  void * item = nullptr;
   cc_mutex_lock(sched->mutex);
 
   if (cc_dict_get(sched->schedid_dict, schedid, &item)) {
diff --git a/coin4/src/threads/storage.cpp b/coin4/src/threads/storage.cpp
index e9e033c..ac99345 100644
--- a/coin4/src/threads/storage.cpp
+++ b/coin4/src/threads/storage.cpp
@@ -96,7 +96,7 @@ cc_storage_hash_destruct_cb(uintptr_t COIN_UNUSED_ARG(key), void * val, void * c
 cc_storage *
 cc_storage_construct(unsigned int size)
 {
-  return cc_storage_init(size, NULL, NULL);
+  return cc_storage_init(size, nullptr, nullptr);
 }
 
 cc_storage *
@@ -112,7 +112,7 @@ cc_storage_construct_etc(unsigned int size,
 void
 cc_storage_destruct(cc_storage * storage)
 {
-  assert(storage != NULL);
+  assert(storage != nullptr);
 
   cc_dict_apply(storage->dict, cc_storage_hash_destruct_cb, storage);
   cc_dict_destruct(storage->dict);
diff --git a/coin4/src/threads/sync.cpp b/coin4/src/threads/sync.cpp
index ff6ed86..3508d4d 100644
--- a/coin4/src/threads/sync.cpp
+++ b/coin4/src/threads/sync.cpp
@@ -39,7 +39,7 @@
 extern "C" {
 #endif /* __cplusplus */
 
-static cc_dict * sync_hash_table = NULL;
+static cc_dict * sync_hash_table = nullptr;
 
 static void
 sync_hash_cb(uintptr_t COIN_UNUSED_ARG(key), void * val, void * COIN_UNUSED_ARG(closure))
@@ -50,9 +50,9 @@ sync_hash_cb(uintptr_t COIN_UNUSED_ARG(key), void * val, void * COIN_UNUSED_ARG(
 static void
 sync_cleanup(void)
 {
-  cc_dict_apply(sync_hash_table, sync_hash_cb, NULL);
+  cc_dict_apply(sync_hash_table, sync_hash_cb, nullptr);
   cc_dict_destruct(sync_hash_table);
-  sync_hash_table = NULL;
+  sync_hash_table = nullptr;
 }
 
 /*
@@ -61,7 +61,7 @@ sync_cleanup(void)
 void
 cc_sync_init(void)
 {
-  if (sync_hash_table == NULL) {
+  if (sync_hash_table == nullptr) {
     /* the priority is set so to make this callback trigger late,
        after normal cleanup function which might still use a cc_sync
        instance */
@@ -83,7 +83,7 @@ cc_sync_begin(void * id)
   void * mutex;
 
   cc_mutex_global_lock();
-  if (sync_hash_table == NULL) {
+  if (sync_hash_table == nullptr) {
     cc_sync_init();
   }
   if (!cc_dict_get(sync_hash_table, (uintptr_t)id, &mutex)) {
@@ -119,7 +119,7 @@ cc_sync_free(void * id)
   void * mutex;
 
   cc_mutex_global_lock();
-  if (sync_hash_table == NULL) {
+  if (sync_hash_table == nullptr) {
     cc_sync_init();
   }
   if (cc_dict_get(sync_hash_table, (uintptr_t)id, &mutex)) {
diff --git a/coin4/src/threads/thread.cpp b/coin4/src/threads/thread.cpp
index ca74f69..a1eb599 100644
--- a/coin4/src/threads/thread.cpp
+++ b/coin4/src/threads/thread.cpp
@@ -73,7 +73,7 @@ cc_thread_construct(cc_thread_f * func, void * closure)
   int ok;
 
   thread = (cc_thread*) malloc(sizeof(cc_thread));
-  assert(thread != NULL);
+  assert(thread != nullptr);
   thread->func = func;
   thread->closure = closure;
 
@@ -81,7 +81,7 @@ cc_thread_construct(cc_thread_f * func, void * closure)
   if (ok) return thread;
   assert(0 && "unable to create thread");
   free(thread);
-  return NULL;
+  return nullptr;
 }
 
 /* ********************************************************************** */
@@ -93,7 +93,7 @@ void
 cc_thread_destruct(cc_thread * thread)
 {
   int ok;
-  assert(thread != NULL);
+  assert(thread != nullptr);
   ok = internal_clean(thread);
   assert(ok == CC_OK);
   free(thread);
@@ -109,7 +109,7 @@ cc_thread_join(cc_thread * thread,
                void ** retvalptr)
 {
   int ok;
-  assert(thread != NULL);
+  assert(thread != nullptr);
 
   ok = internal_join(thread, retvalptr);
   assert(ok == CC_OK);
@@ -308,7 +308,7 @@ cc_thread_init(void)
 /*!
   \fn static SbThread * SbThread::create(void *(*func)(void *), void * closure)
 
-  This function creates a new thread, or returns NULL on failure.
+  This function creates a new thread, or returns nullptr on failure.
 */
 
 /*!
diff --git a/coin4/src/threads/thread_win32.icc b/coin4/src/threads/thread_win32.icc
index 1bed19c..1b9102e 100644
--- a/coin4/src/threads/thread_win32.icc
+++ b/coin4/src/threads/thread_win32.icc
@@ -37,7 +37,7 @@ internal_init(cc_thread * thread)
 {
   DWORD threadid_unused;
 
-  thread->w32thread.threadhandle = CreateThread(NULL, 0,
+  thread->w32thread.threadhandle = CreateThread(nullptr, 0,
     cc_w32thread_thread_proc, (LPVOID) thread, 0, &threadid_unused);
 
   /* threadid_unused - see PlatformSDK doc. for CreateThread */
@@ -50,7 +50,7 @@ internal_init(cc_thread * thread)
    * ExitThread. Failure to do so results in small memory leaks when
    * ExitThread is called. " */
 
-  if (thread->w32thread.threadhandle == NULL) {
+  if (thread->w32thread.threadhandle == nullptr) {
     if (COIN_DEBUG) {
       cc_win32_print_error("internal_init", "CreateThread()", GetLastError());
     }
@@ -104,7 +104,7 @@ internal_join(cc_thread * thread,
    * will result in memory leaks - or bigger problems - see Platform
    * SDK doc. */
   CloseHandle(thread->w32thread.threadhandle);
-  thread->w32thread.threadhandle = NULL;
+  thread->w32thread.threadhandle = nullptr;
 
   return bstatus ? CC_OK : CC_ERROR;
 }
diff --git a/coin4/src/threads/threadsutilp.h b/coin4/src/threads/threadsutilp.h
index 812b293..4fb6811 100644
--- a/coin4/src/threads/threadsutilp.h
+++ b/coin4/src/threads/threadsutilp.h
@@ -42,7 +42,7 @@
 #define CC_MUTEX_CONSTRUCT(_mymutex_) \
   do { \
     cc_mutex_global_lock(); \
-    if (_mymutex_ == NULL) { \
+    if (_mymutex_ == nullptr) { \
       _mymutex_ = static_cast<void*>(cc_mutex_construct()); \
     } \
     cc_mutex_global_unlock(); \
@@ -50,7 +50,7 @@
 
 #define CC_MUTEX_DESTRUCT(_mymutex_) \
   cc_mutex_destruct(static_cast<cc_mutex*>(_mymutex_));     \
-  _mymutex_ = NULL
+  _mymutex_ = nullptr
 
 #define CC_MUTEX_LOCK(_mymutex_) \
   cc_mutex_lock(static_cast<cc_mutex *>(_mymutex_))
diff --git a/coin4/src/threads/worker.cpp b/coin4/src/threads/worker.cpp
index 592d4f3..4889506 100644
--- a/coin4/src/threads/worker.cpp
+++ b/coin4/src/threads/worker.cpp
@@ -67,7 +67,7 @@ worker_thread_loop(cc_worker * worker)
     }
   }
 
-  worker->workfunc = NULL;
+  worker->workfunc = nullptr;
   /* remember to unlock mutex after we break out of the loop */
   cc_mutex_unlock(worker->mutex);
 }
@@ -80,7 +80,7 @@ worker_thread_entry(void * data)
 {
   cc_worker * worker = (cc_worker*) data;
   worker_thread_loop(worker);
-  return NULL;
+  return nullptr;
 }
 
 /*
@@ -122,9 +122,9 @@ worker_stop_thread(cc_worker * worker)
     cc_condvar_wake_one(worker->cond);
     cc_mutex_unlock(worker->mutex);
     /* wait for thread to finish */
-    cc_thread_join(worker->thread, NULL);
+    cc_thread_join(worker->thread, nullptr);
     cc_thread_destruct(worker->thread);
-    worker->thread = NULL;
+    worker->thread = nullptr;
     worker->shutdown = false; /* reset signal */
   }
 }
@@ -140,13 +140,13 @@ cc_worker_construct(void)
   worker->cond = cc_condvar_construct();
   worker->begincond = cc_condvar_construct();
   worker->beginmutex = cc_mutex_construct();
-  worker->thread = NULL; /* delay creating thread */
+  worker->thread = nullptr; /* delay creating thread */
   worker->threadisrunning = false;
   worker->shutdown = false;
-  worker->workfunc = NULL;
-  worker->workclosure = NULL;
-  worker->idlecb = NULL;
-  worker->idleclosure = NULL;
+  worker->workfunc = nullptr;
+  worker->workclosure = nullptr;
+  worker->idlecb = nullptr;
+  worker->idleclosure = nullptr;
   return worker;
 }
 
@@ -159,7 +159,7 @@ cc_worker_destruct(cc_worker * worker)
   if (worker->threadisrunning) {
     worker_stop_thread(worker);
   }
-  assert(worker->thread == NULL);
+  assert(worker->thread == nullptr);
   cc_mutex_destruct(worker->mutex);
   cc_condvar_destruct(worker->cond);
   cc_condvar_destruct(worker->begincond);
diff --git a/coin4/src/tidbits.cpp b/coin4/src/tidbits.cpp
index 6c26286..784d99a 100644
--- a/coin4/src/tidbits.cpp
+++ b/coin4/src/tidbits.cpp
@@ -150,7 +150,7 @@ extern "C" {
 #ifdef COIN_THREADSAFE
 #include <Inventor/C/threads/mutex.h>
 #include "threads/mutexp.h"
-static cc_mutex * atexit_list_monitor = NULL;
+static cc_mutex * atexit_list_monitor = nullptr;
 #endif /* COIN_THREADSAFE */
 
 
@@ -346,7 +346,7 @@ coin_vsnprintf(char * dst, unsigned int n, const char * fmtstr, va_list args)
 static FILE *
 nullfileptr(void)
 {
-  static FILE * nullfp = NULL;
+  static FILE * nullfp = nullptr;
 
   if (!nullfp) {
     struct stat sbuf;
@@ -357,7 +357,7 @@ nullfileptr(void)
       nullfd = open(unixdevnull, O_WRONLY);
 
     if (nullfd == -1) {
-      const char * tmpname = tmpnam(NULL);
+      const char * tmpname = tmpnam(nullptr);
 
       if (tmpname) {
         nullfd = open(tmpname, O_CREAT|O_WRONLY);
@@ -446,8 +446,8 @@ coin_snprintf(char * dst, unsigned int n, const char * fmtstr, ...)
 */
 
 #ifdef HAVE_GETENVIRONMENTVARIABLE
-static struct envvar_data * envlist_head = NULL;
-static struct envvar_data * envlist_tail = NULL;
+static struct envvar_data * envlist_head = nullptr;
+static struct envvar_data * envlist_tail = nullptr;
 
 struct envvar_data {
   char * name;
@@ -459,22 +459,22 @@ static void
 envlist_cleanup(void)
 {
   struct envvar_data * ptr = envlist_head;
-  while (ptr != NULL) {
+  while (ptr != nullptr) {
     struct envvar_data * tmp = ptr;
     free(ptr->name);
     free(ptr->val);
     ptr = ptr->next;
     free(tmp);
   }
-  envlist_head = NULL;
-  envlist_tail = NULL;
+  envlist_head = nullptr;
+  envlist_tail = nullptr;
 }
 
 static void
 envlist_append(struct envvar_data * item)
 {
-  item->next = NULL;
-  if (envlist_head == NULL) {
+  item->next = nullptr;
+  if (envlist_head == nullptr) {
     envlist_head = item;
     envlist_tail = item;
     coin_atexit_func("envlist_cleanup", envlist_cleanup, CC_ATEXIT_ENVIRONMENT);
@@ -531,17 +531,17 @@ coin_getenv(const char * envname)
      having to copy it around. 20060314 mortene. */
 #ifdef HAVE_GETENVIRONMENTVARIABLE
   int neededsize;
-  neededsize = GetEnvironmentVariable(envname, NULL, 0);
+  neededsize = GetEnvironmentVariable(envname, nullptr, 0);
   /* neededsize includes the \0-terminating character */
   if (neededsize >= 1) {
     int resultsize;
     struct envvar_data * envptr;
     char * valbuf = (char *) malloc(neededsize);
-    if (valbuf == NULL) {
+    if (valbuf == nullptr) {
       /* Augh. Could we handle this any better? */
       /* If we already bookkeep a buffer for this variable, we /could/ try
          to reuse it (much work for a non-100% solution).  20030205 larsa */
-      return NULL;
+      return nullptr;
     }
     resultsize = GetEnvironmentVariable(envname, valbuf, neededsize);
     if (resultsize != (neededsize - 1)) {
@@ -550,7 +550,7 @@ coin_getenv(const char * envname)
          and envval being changed in the background, or maybe just asserting?
          20030205 larsa */
       free(valbuf);
-      return NULL;
+      return nullptr;
     }
 
     /*
@@ -565,12 +565,12 @@ coin_getenv(const char * envname)
 
     /* Try to find bookkeeped envvar buffer among those registered earlier. */
     envptr = envlist_head;
-    while ((envptr != NULL) && (strcmp(envptr->name, envname) != 0))
+    while ((envptr != nullptr) && (strcmp(envptr->name, envname) != 0))
       envptr = envptr->next;
 
     /* We can avoid this if-else by always freeing the envvar_data for the
        variable upfront, but it's a tad less efficient. */
-    if (envptr != NULL) {
+    if (envptr != nullptr) {
       /* We are already bookkeeping a buffer for this variable.
        * => free previous value buffer and bookkeep the new one instead */
       free(envptr->val);
@@ -579,28 +579,28 @@ coin_getenv(const char * envname)
     else {
       /* We aren't bookkeeping a buffer for this one yet. */
       envptr = (struct envvar_data *) malloc(sizeof(struct envvar_data));
-      if (envptr == NULL) {
+      if (envptr == nullptr) {
         /* Augh. Could we handle this any better? */
         /* We can alternatively ignore the bookkeeping and leak the buffer
            - 20030205 larsa */
         free(valbuf);
-        return NULL;
+        return nullptr;
       }
       envptr->name = strdup(envname);
-      if (envptr->name == NULL) {
+      if (envptr->name == nullptr) {
         /* Augh. Could we handle this any better? */
         /* We can alternatively ignore the bookkeeping and leak the buffer
            - 20030205 larsa */
         free(envptr);
         free(valbuf);
-        return NULL;
+        return nullptr;
       }
       envptr->val = valbuf;
       envlist_append(envptr);
     }
     return envptr->val;
   }
-  return NULL;
+  return nullptr;
 #else /* !HAVE_GETENVIRONMENTVARIABLE */
   return getenv(envname);
 #endif /* !HAVE_GETENVIRONMENTVARIABLE */
@@ -618,8 +618,8 @@ coin_setenv(const char * name, const char * value, int overwrite)
 */
   struct envvar_data * envptr, * prevptr;
   envptr = envlist_head;
-  prevptr = NULL;
-  while ((envptr != NULL) && (strcmp(envptr->name, name) != 0)) {
+  prevptr = nullptr;
+  while ((envptr != nullptr) && (strcmp(envptr->name, name) != 0)) {
     prevptr = envptr;
     envptr = envptr->next;
   }
@@ -641,7 +641,7 @@ coin_setenv(const char * name, const char * value, int overwrite)
   sign (=), or foreign lowercase characters in the variable name.
   */
 
-  if (overwrite || (GetEnvironmentVariable(name, NULL, 0) == 0))
+  if (overwrite || (GetEnvironmentVariable(name, nullptr, 0) == 0))
     return SetEnvironmentVariable(name, value) ? true : false;
   else
     return true;
@@ -662,8 +662,8 @@ coin_unsetenv(const char * name)
 */
   struct envvar_data * envptr, * prevptr;
   envptr = envlist_head;
-  prevptr = NULL;
-  while ((envptr != NULL) && (strcmp(envptr->name, name) != 0)) {
+  prevptr = nullptr;
+  while ((envptr != nullptr) && (strcmp(envptr->name, name) != 0)) {
     prevptr = envptr;
     envptr = envptr->next;
   }
@@ -677,7 +677,7 @@ coin_unsetenv(const char * name)
     free(envptr->val);
     free(envptr);
   }
-  SetEnvironmentVariable(name, NULL);
+  SetEnvironmentVariable(name, nullptr);
 #else /* !HAVE_GETENVIRONMENTVARIABLE */
   unsetenv(name);
 #endif /* !HAVE_GETENVIRONMENTVARIABLE */
@@ -1076,7 +1076,7 @@ void free_std_fds(void);
 
 typedef void(*atexit_func_type)(void);
 
-static cc_list * atexit_list = NULL;
+static cc_list * atexit_list = nullptr;
 static bool isexiting = false;
 
 typedef struct {
@@ -1122,7 +1122,7 @@ coin_atexit_cleanup(void)
   /* delete mutex here to make sure this is done before the threading subsystem is shut down */
 #ifdef COIN_THREADSAFE
   cc_mutex_destruct(atexit_list_monitor);
-  atexit_list_monitor = NULL;
+  atexit_list_monitor = nullptr;
 #endif /* COIN_THREADSAFE */
 
   debugstr = coin_getenv("COIN_DEBUG_CLEANUP");
@@ -1149,7 +1149,7 @@ coin_atexit_cleanup(void)
   free_std_fds();
 
   cc_list_destruct(atexit_list);
-  atexit_list = NULL;
+  atexit_list = nullptr;
   isexiting = false;
 
   if (debug) {
@@ -1199,7 +1199,7 @@ coin_atexit_func(const char * name, coin_atexit_f * f, coin_atexit_priorities pr
 
   assert(!isexiting && "tried to attach an atexit function while exiting");
 
-  if (atexit_list == NULL) {
+  if (atexit_list == nullptr) {
     atexit_list = cc_list_construct();
     /* The atexit() registration was disabled, since it has proved
        dangerous to let the C library trigger the callbacks.
@@ -1306,9 +1306,9 @@ coin_is_exiting(void)
   then open a new one?  20030217 larsa
 */
 
-static FILE * coin_stdin = NULL;
-static FILE * coin_stdout = NULL;
-static FILE * coin_stderr = NULL;
+static FILE * coin_stdin = nullptr;
+static FILE * coin_stdout = nullptr;
+static FILE * coin_stderr = nullptr;
 static int coin_dup_stdin = -1;
 static int coin_dup_stdout = -1;
 static int coin_dup_stderr = -1;
@@ -1320,7 +1320,7 @@ free_std_fds(void)
   if (coin_stdin) {
     assert(coin_dup_stdin != -1);
     fclose(coin_stdin);
-    coin_stdin = NULL;
+    coin_stdin = nullptr;
     dup2(coin_dup_stdin, STDIN_FILENO);
     close(coin_dup_stdin);
     coin_dup_stdin = -1;
@@ -1328,7 +1328,7 @@ free_std_fds(void)
   if (coin_stdout) {
     assert(coin_dup_stdout != -1);
     fclose(coin_stdout);
-    coin_stdout = NULL;
+    coin_stdout = nullptr;
     dup2(coin_dup_stdout, STDOUT_FILENO);
     close(coin_dup_stdout);
     coin_dup_stdout = -1;
@@ -1336,7 +1336,7 @@ free_std_fds(void)
   if (coin_stderr) {
     assert(coin_dup_stderr != -1);
     fclose(coin_stderr);
-    coin_stderr = NULL;
+    coin_stderr = nullptr;
     dup2(coin_dup_stderr, STDERR_FILENO);
     close(coin_dup_stderr);
     coin_dup_stderr = -1;
@@ -1380,7 +1380,7 @@ coin_locale_set_portable(cc_string * storeold)
 {
   const char * loc;
 
-  const char * deflocale = setlocale(LC_NUMERIC, NULL);
+  const char * deflocale = setlocale(LC_NUMERIC, nullptr);
   if (strcmp(deflocale, "C") == 0) { return false; }
 
   /* Must copy deflocale string, as it will be changed on the next
@@ -1389,7 +1389,7 @@ coin_locale_set_portable(cc_string * storeold)
   cc_string_set_text(storeold, deflocale);
 
   loc = setlocale(LC_NUMERIC, "C");
-  assert(loc != NULL && "could not set locale to supposed portable C locale");
+  assert(loc != nullptr && "could not set locale to supposed portable C locale");
   return true;
 }
 
@@ -1397,7 +1397,7 @@ void
 coin_locale_reset(cc_string * storedold)
 {
   const char * l = setlocale(LC_NUMERIC, cc_string_get_text(storedold));
-  assert(l != NULL && "could not reset locale");
+  assert(l != nullptr && "could not reset locale");
   cc_string_clean(storedold);
 }
 
@@ -1514,7 +1514,7 @@ coin_parse_versionstring(const char * versionstr,
   *major = 0;
   if (minor) *minor = 0;
   if (patch) *patch = 0;
-  if (versionstr == NULL) return false;
+  if (versionstr == nullptr) return false;
 
   (void)strncpy(buffer, versionstr, 255);
   buffer[255] = '\0'; /* strncpy() will not null-terminate if strlen > 255 */
@@ -1524,7 +1524,7 @@ coin_parse_versionstring(const char * versionstr,
     char * start = buffer;
     *dotptr = '\0';
     *major = atoi(start);
-    if (minor == NULL) return true;
+    if (minor == nullptr) return true;
     start = ++dotptr;
 
     dotptr = strchr(start, '.');
@@ -1535,7 +1535,7 @@ coin_parse_versionstring(const char * versionstr,
       int terminate = *dotptr == ' ';
       *dotptr = '\0';
       *minor = atoi(start);
-      if (patch == NULL) return true;
+      if (patch == nullptr) return true;
       if (!terminate) {
         start = ++dotptr;
         dotptr = strchr(start, ' ');
@@ -1565,7 +1565,7 @@ getcwd_wrapper(char * buf, size_t size)
   return getcwd(buf, size);
 #else /* HAVE_GETCWD */
   /* FIXME: abort compilation? pederb, 2003-08-18 */
-  return NULL;
+  return nullptr;
 #endif /* ! HAVE_GETCWD */
 }
 
@@ -1588,20 +1588,20 @@ getcwd_wrapper(char * buf, size_t size)
 bool
 coin_getcwd(cc_string * str)
 {
-  char buf[256], * dynbuf = NULL;
+  char buf[256], * dynbuf = nullptr;
   size_t bufsize = sizeof(buf);
   char * cwd = getcwd_wrapper(buf, bufsize);
 
-  while ((cwd == NULL) && (errno == ERANGE)) {
+  while ((cwd == nullptr) && (errno == ERANGE)) {
     bufsize *= 2;
-    if (dynbuf != NULL) { free(dynbuf); }
+    if (dynbuf != nullptr) { free(dynbuf); }
     dynbuf = (char *)malloc(bufsize);
     cwd = getcwd_wrapper(dynbuf, bufsize);
   }
-  if (cwd == NULL) { cc_string_set_text(str, strerror(errno)); }
+  if (cwd == nullptr) { cc_string_set_text(str, strerror(errno)); }
   else { cc_string_set_text(str, cwd); }
 
-  if (dynbuf != NULL) { free(dynbuf); }
+  if (dynbuf != nullptr) { free(dynbuf); }
   return cwd ? true : false;
 }
 
diff --git a/coin4/src/tidbitsp.h b/coin4/src/tidbitsp.h
index b3b5a12..d4242b7 100644
--- a/coin4/src/tidbitsp.h
+++ b/coin4/src/tidbitsp.h
@@ -216,7 +216,7 @@ void coin_flush_ascii85(FILE * fp,
 
 /*
   Parse version string of type <major>.<minor>.<patch>. <minor> or
-  <patch> might not be in the string. It's possible to supply NULL for
+  <patch> might not be in the string. It's possible to supply nullptr for
   minor and/or patch if you're not interested in minor and/or patch.
 */
 bool coin_parse_versionstring(const char * versionstr,
diff --git a/coin4/src/upgraders/SoUpgrader.cpp b/coin4/src/upgraders/SoUpgrader.cpp
index 0ed8544..e075572 100644
--- a/coin4/src/upgraders/SoUpgrader.cpp
+++ b/coin4/src/upgraders/SoUpgrader.cpp
@@ -35,7 +35,7 @@
 
 #include "upgraders/SoUpgrader.h"
 
-#include <stddef.h> // for NULL
+#include <stddef.h> // for nullptr
 #include <assert.h>
 
 #include <Inventor/SbName.h>
@@ -58,14 +58,14 @@
 //
 // FIXME: replace this with a real set datatype abstraction. 20050524 mortene.
 typedef SbHash<const char *, void *> NameSet;
-static NameSet * soupgrader_namedict = NULL;
+static NameSet * soupgrader_namedict = nullptr;
 static bool soupgrader_isinitialized = false;
 
 static void
 soupgrader_cleanup(void)
 {
   delete soupgrader_namedict;
-  soupgrader_namedict = NULL;
+  soupgrader_namedict = nullptr;
   soupgrader_isinitialized = false;
 }
 
@@ -78,7 +78,7 @@ soupgrader_add_to_namedict(const SbString & name)
   // Note: the SbString->SbName wrapping is necessary, or the const
   // char* will _not_ be valid upon the SbString going out of scope
   // (while SbName makes permanent const char* references).
-  soupgrader_namedict->put(SbName(name.getString()).getString(), NULL);
+  soupgrader_namedict->put(SbName(name.getString()).getString(), nullptr);
 
   // Create lookup both with and without the "So" prefix. This is
   // necessary for the hash lookup in soupgrader_exists() to match
@@ -95,7 +95,7 @@ soupgrader_add_to_namedict(const SbString & name)
 
   // Note: the SbString->SbName wrapping is necessary, see above
   // comment.
-  soupgrader_namedict->put(SbName(tmp.getString()).getString(), NULL);
+  soupgrader_namedict->put(SbName(tmp.getString()).getString(), nullptr);
 }
 
 static bool
@@ -130,7 +130,7 @@ soupgrader_init_classes(void)
 /*!
   Try creating a node of name \a name with Inventor version \a ivversion.
 
-  Returns NULL if no such node exists.
+  Returns nullptr if no such node exists.
 */
 SoBase *
 SoUpgrader::tryCreateNode(const SbName & name, const float ivversion)
@@ -154,7 +154,7 @@ SoUpgrader::tryCreateNode(const SbName & name, const float ivversion)
       }
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -181,7 +181,7 @@ SoUpgrader::createUpgrade(const SoBase * base)
                        "No upgrade functionality available for %s",
                        type.getName().getString());
   }
-  return NULL;
+  return nullptr;
 }
 
 #undef SOUPGRADER_ADD_TYPE
diff --git a/coin4/src/vrml97/Anchor.cpp b/coin4/src/vrml97/Anchor.cpp
index f04c6d0..6c2f7cc 100644
--- a/coin4/src/vrml97/Anchor.cpp
+++ b/coin4/src/vrml97/Anchor.cpp
@@ -197,8 +197,8 @@ void
 SoVRMLAnchor::initClass(void) // static
 {
   SO_NODE_INTERNAL_INIT_CLASS(SoVRMLAnchor, SO_VRML97_NODE_TYPE);
-  SoVRMLAnchor::fetchurlcb = NULL;
-  SoVRMLAnchor::userdata = NULL;
+  SoVRMLAnchor::fetchurlcb = nullptr;
+  SoVRMLAnchor::userdata = nullptr;
 }
 
 
diff --git a/coin4/src/vrml97/Appearance.cpp b/coin4/src/vrml97/Appearance.cpp
index 3b96348..3bd2c13 100644
--- a/coin4/src/vrml97/Appearance.cpp
+++ b/coin4/src/vrml97/Appearance.cpp
@@ -37,17 +37,17 @@
   \verbatim
 
   Appearance {
-    exposedField SFNode material          NULL
-    exposedField SFNode texture           NULL
-    exposedField SFNode textureTransform  NULL
+    exposedField SFNode material          nullptr
+    exposedField SFNode texture           nullptr
+    exposedField SFNode textureTransform  nullptr
   }
   \endverbatim
 
   The Appearance node specifies the visual properties of geometry. The
-  value for each of the fields in this node may be NULL. However, if
-  the field is non-NULL, it shall contain one node of the appropriate
+  value for each of the fields in this node may be nullptr. However, if
+  the field is non-nullptr, it shall contain one node of the appropriate
   type.  The material field, if specified, shall contain a VRMLMaterial
-  node. If the material field is NULL or unspecified, lighting is off
+  node. If the material field is nullptr or unspecified, lighting is off
   (all lights are ignored during rendering of the object that
   references this Appearance) and the unlit object colour is (1, 1,
   1). Details of the VRML lighting model are in 4.14, Lighting model
@@ -55,27 +55,27 @@
 
   The texture field, if specified, shall contain one of the various
   types of texture nodes (VRMLImageTexture, VRMLMovieTexture, or
-  VRMLPixelTexture).  If the texture node is NULL or the texture field
+  VRMLPixelTexture).  If the texture node is nullptr or the texture field
   is unspecified, the object that references this Appearance is not
   textured.  The textureTransform field, if specified, shall contain a
-  VRMLTextureTransform node. If the textureTransform is NULL or
+  VRMLTextureTransform node. If the textureTransform is nullptr or
   unspecified, the textureTransform field has no effect.
 
 */
 
 /*!
   \var SoSFNode SoVRMLAppearance::material
-  Can contain an SoVRMLMaterial node. Is NULL by default.
+  Can contain an SoVRMLMaterial node. Is nullptr by default.
 */
 
 /*!
   \var SoSFNode SoVRMLAppearance::texture
-  Can contain a texture node. Is NULL by default.
+  Can contain a texture node. Is nullptr by default.
 */
 
 /*!
   \var SoSFNode SoVRMLAppearance::textureTransform
-  Can contain an SoVRMLTextureTransform node. Is NULL by default.
+  Can contain an SoVRMLTextureTransform node. Is nullptr by default.
 */
 
 #include <Inventor/VRMLnodes/SoVRMLAppearance.h>
@@ -139,16 +139,16 @@ SoVRMLAppearance::initClass(void)
 SoVRMLAppearance::SoVRMLAppearance(void)
 {
   PRIVATE(this) = new SoVRMLAppearanceP;
-  // supply a NULL-pointer as parent, since notifications will be
+  // supply a nullptr-pointer as parent, since notifications will be
   // handled by the fields that actually contain the node(s)
-  PRIVATE(this)->childlist = new SoChildList(NULL);
+  PRIVATE(this)->childlist = new SoChildList(nullptr);
   PRIVATE(this)->childlistvalid = false;
 
   SO_VRMLNODE_INTERNAL_CONSTRUCTOR(SoVRMLAppearance);
 
-  SO_VRMLNODE_ADD_EXPOSED_FIELD(material, (NULL));
-  SO_VRMLNODE_ADD_EXPOSED_FIELD(texture, (NULL));
-  SO_VRMLNODE_ADD_EXPOSED_FIELD(textureTransform, (NULL));
+  SO_VRMLNODE_ADD_EXPOSED_FIELD(material, (nullptr));
+  SO_VRMLNODE_ADD_EXPOSED_FIELD(texture, (nullptr));
+  SO_VRMLNODE_ADD_EXPOSED_FIELD(textureTransform, (nullptr));
 }
 
 /*!
diff --git a/coin4/src/vrml97/AudioClip.cpp b/coin4/src/vrml97/AudioClip.cpp
index f08a817..ce0c427 100644
--- a/coin4/src/vrml97/AudioClip.cpp
+++ b/coin4/src/vrml97/AudioClip.cpp
@@ -292,7 +292,7 @@ public:
   int totalNumberOfFramesToPlay;
 };
 
-SoVRMLAudioClipP::StaticData * SoVRMLAudioClipP::staticdata = NULL;
+SoVRMLAudioClipP::StaticData * SoVRMLAudioClipP::staticdata = nullptr;
 
 static void
 cleanup_audioclip(void)
@@ -377,7 +377,7 @@ SoVRMLAudioClip::SoVRMLAudioClip(void)
   PRIVATE(this)->loop = false;
   PRIVATE(this)->soundHasFinishedPlaying = false;
 
-  PRIVATE(this)->stream = NULL;
+  PRIVATE(this)->stream = nullptr;
 
   PRIVATE(this)->channels = 0;
   PRIVATE(this)->bitspersample = 0;
@@ -471,8 +471,8 @@ SoVRMLAudioClip::getSampleRate()
 }
 
 /*! Sets callbacks for opening, reading, seeking, telling and closing
- an audio source. Specifying NULL for a function is OK, except for the
- read function. If a function set to NULL is later called, a default
+ an audio source. Specifying nullptr for a function is OK, except for the
+ read function. If a function set to nullptr is later called, a default
  implementation doing nothing is called in it's place. */
 
 void
@@ -493,8 +493,8 @@ SoVRMLAudioClip::setCallbacks(open_func *opencb, read_func *readcb,
 void * 
 SoVRMLAudioClip::open(const SbStringList &urlref)
 {
-  if (PRIVATE(this)->open == NULL)
-    return NULL;
+  if (PRIVATE(this)->open == nullptr)
+    return nullptr;
 
 #ifdef HAVE_THREADS
   SbThreadAutoLock autoLock(&PRIVATE(this)->syncmutex);
@@ -508,7 +508,7 @@ SoVRMLAudioClip::open(const SbStringList &urlref)
 int
 SoVRMLAudioClip::seek(void *datasource, long offset, int whence)
 {
-  if (PRIVATE(this)->seek == NULL)
+  if (PRIVATE(this)->seek == nullptr)
     return -1;
 
 #ifdef HAVE_THREADS
@@ -525,7 +525,7 @@ SoVRMLAudioClip::seek(void *datasource, long offset, int whence)
 long
 SoVRMLAudioClip::tell(void *datasource)
 {
-  if (PRIVATE(this)->tell == NULL)
+  if (PRIVATE(this)->tell == nullptr)
     return -1L;
 
 #ifdef HAVE_THREADS
@@ -541,7 +541,7 @@ SoVRMLAudioClip::tell(void *datasource)
 int
 SoVRMLAudioClip::close(void *datasource)
 {
-  if (PRIVATE(this)->close == NULL)
+  if (PRIVATE(this)->close == nullptr)
     return EOF;
 
 #ifdef HAVE_THREADS
@@ -555,7 +555,7 @@ SoVRMLAudioClip::close(void *datasource)
      \a datasource into \a buffer. Buffer must be allocated by the
      caller, and must be able to hold all the audio data (size = \a
      numframes * \a channels * sizeof(int16_t)). The function must
-     always fill the buffer completely unless \a buffer == NULL. 
+     always fill the buffer completely unless \a buffer == nullptr. 
 
      When an error occurs, or when end-of-file has been reached, 
      this function returns 0. Otherwise, the function should return
@@ -563,7 +563,7 @@ SoVRMLAudioClip::close(void *datasource)
 
      When the caller receives a return value of 0, it will queue the
      returned buffer for playing. When this buffer is finished playing,
-     the caller will call read() one final time, with \a buffer == NULL. 
+     the caller will call read() one final time, with \a buffer == nullptr. 
      The read() function can then set the isActive field to false, 
      free any resources allocated, etc.
 */
@@ -572,7 +572,7 @@ size_t
 SoVRMLAudioClip::read(void *datasource, void *buffer,
                       int numframes, int &channels)
 {
-  assert (PRIVATE(this)->read != NULL);
+  assert (PRIVATE(this)->read != nullptr);
 
 #ifdef HAVE_THREADS
   SbThreadAutoLock autoLock(&PRIVATE(this)->syncmutex);
@@ -728,7 +728,7 @@ void *
 SoVRMLAudioClipP::internal_open(const SbStringList & COIN_UNUSED_ARG(url), 
                                 SoVRMLAudioClip * COIN_UNUSED_ARG(clip))
 {
-  return NULL;
+  return nullptr;
 }
 
 size_t
@@ -756,7 +756,7 @@ SoVRMLAudioClipP::internal_read(void * COIN_UNUSED_ARG(datasource), void *buffer
     return 0;
   }
 
-  if (buffer == NULL) {
+  if (buffer == nullptr) {
     /* Note: The SoVRMLSound node has signalled that it has received
        an eof previously sent by this SoVRMLAudioClip, and it has
        played all buffers including the last one it received. This is
@@ -805,7 +805,7 @@ SoVRMLAudioClipP::internal_read(void * COIN_UNUSED_ARG(datasource), void *buffer
        only try the next if the current file fails.
        2003-01-16 thammer. */
 
-    if (this->stream==NULL) {
+    if (this->stream==nullptr) {
       if (this->currentPlaylistIndex >= this->playlist.getLength()) {
         if (this->loop)
           this->currentPlaylistIndex = 0;
@@ -847,7 +847,7 @@ SoVRMLAudioClipP::internal_read(void * COIN_UNUSED_ARG(datasource), void *buffer
       }
     }
 
-    assert(this->stream!=NULL);
+    assert(this->stream!=nullptr);
     assert(bitspersample == sizeof(int16_t) * 8);
 
     channelsdelivered = this->channels;
@@ -858,7 +858,7 @@ SoVRMLAudioClipP::internal_read(void * COIN_UNUSED_ARG(datasource), void *buffer
     simage_wrapper()->s_stream_get_buffer(this->stream,
                                           ((int16_t *)buffer) + 
                                           framepos*channelsdelivered,
-                                          &numread, NULL);
+                                          &numread, nullptr);
 
     channelsref = this->channels;
 
@@ -914,7 +914,7 @@ SoVRMLAudioClipP::loadUrl()
 
   for (int i=0; i<PUBLIC(this)->url.getNum(); i++) {
     const char * str = PUBLIC(this)->url[i].getString();
-    if ( (str == NULL) || (strlen(str)==0) )
+    if ( (str == nullptr) || (strlen(str)==0) )
       continue; // ignore empty url
 
     SbString filename =
@@ -947,7 +947,7 @@ void
 SoVRMLAudioClipP::urlSensorCBWrapper(void * data, SoSensor *)
 {
   SoVRMLAudioClipP * thisp = (SoVRMLAudioClipP*) data;
-  thisp->urlSensorCB(NULL);
+  thisp->urlSensorCB(nullptr);
 }
 
 //
@@ -966,7 +966,7 @@ void
 SoVRMLAudioClipP::loopSensorCBWrapper(void * data, SoSensor *)
 {
   SoVRMLAudioClipP * thisp = (SoVRMLAudioClipP*) data;
-  thisp->loopSensorCB(NULL);
+  thisp->loopSensorCB(nullptr);
 }
 
 //
@@ -988,7 +988,7 @@ void
 SoVRMLAudioClipP::startTimeSensorCBWrapper(void * data, SoSensor *)
 {
   SoVRMLAudioClipP * thisp = (SoVRMLAudioClipP*) data;
-  thisp->startTimeSensorCB(NULL);
+  thisp->startTimeSensorCB(nullptr);
 }
 
 //
@@ -1013,7 +1013,7 @@ void
 SoVRMLAudioClipP::stopTimeSensorCBWrapper(void * data, SoSensor *)
 {
   SoVRMLAudioClipP * thisp = (SoVRMLAudioClipP*) data;
-  thisp->stopTimeSensorCB(NULL);
+  thisp->stopTimeSensorCB(nullptr);
 }
 
 //
@@ -1041,7 +1041,7 @@ void
 SoVRMLAudioClipP::timerCBWrapper(void * data, SoSensor *)
 {
   SoVRMLAudioClipP * thisp = (SoVRMLAudioClipP*) data;
-  thisp->timerCB(NULL);
+  thisp->timerCB(nullptr);
 }
 
 //
@@ -1116,8 +1116,8 @@ SoVRMLAudioClipP::openFile(const char *filename)
   // FIXME: this is attempted again and again when the file can not be
   // opened. Once should be sufficient, and subsequent attempts should
   // be short-cutted somewhere before this in the call-chain. 20050627 mortene.
-  this->stream = simage_wrapper()->s_stream_open(filename, NULL);
-  if (this->stream == NULL) {
+  this->stream = simage_wrapper()->s_stream_open(filename, nullptr);
+  if (this->stream == nullptr) {
     // FIXME: sound should stop playing.  20021101 thammer
     SoDebugError::postWarning("SoVRMLAudioClipP::openFile",
                               "Couldn't open file '%s'.\n"
@@ -1142,11 +1142,11 @@ SoVRMLAudioClipP::openFile(const char *filename)
   this->channels = 0;
   this->bitspersample = 16;
   int samplerate = 0;
-  if (params != NULL) {
+  if (params != nullptr) {
     simage_wrapper()->s_params_get(params,
-                 "channels", S_INTEGER_PARAM_TYPE, &this->channels, NULL);
+                 "channels", S_INTEGER_PARAM_TYPE, &this->channels, nullptr);
     simage_wrapper()->s_params_get(params,
-                 "samplerate", S_INTEGER_PARAM_TYPE, &samplerate, NULL);
+                 "samplerate", S_INTEGER_PARAM_TYPE, &samplerate, nullptr);
   }
 
 #if COIN_DEBUG && DEBUG_AUDIO
@@ -1160,14 +1160,14 @@ SoVRMLAudioClipP::openFile(const char *filename)
 void
 SoVRMLAudioClipP::closeFile()
 {
-  if (this->stream != NULL) {
+  if (this->stream != nullptr) {
     if (!this->simageVersionOK("SoVRMLAudioClipP::closeFile")) {
       return;
     } else {
       simage_wrapper()->s_stream_close(this->stream);
       simage_wrapper()->s_stream_destroy(this->stream);
     }
-    this->stream = NULL;
+    this->stream = nullptr;
   }
 }
 
diff --git a/coin4/src/vrml97/Background.cpp b/coin4/src/vrml97/Background.cpp
index 3635bfa..92c415a 100644
--- a/coin4/src/vrml97/Background.cpp
+++ b/coin4/src/vrml97/Background.cpp
@@ -455,8 +455,8 @@ SoVRMLBackground::SoVRMLBackground(void)
   PRIVATE(this)->topurlsensor->setPriority(5);
 
   PRIVATE(this)->geometrybuilt = false;  
-  PRIVATE(this)->camera = NULL;
-  PRIVATE(this)->rootnode = NULL;
+  PRIVATE(this)->camera = nullptr;
+  PRIVATE(this)->rootnode = nullptr;
 }
 
 /*!
@@ -787,12 +787,12 @@ SoVRMLBackgroundP::buildGeometry(void)
   this->rootnode->addChild(scale);
   this->rootnode->addChild(cubedata);
   
-  this->frontface = NULL;
-  this->backface = NULL;
-  this->leftface = NULL;
-  this->rightface = NULL;
-  this->topface = NULL;
-  this->bottomface = NULL;
+  this->frontface = nullptr;
+  this->backface = nullptr;
+  this->leftface = nullptr;
+  this->rightface = nullptr;
+  this->topface = nullptr;
+  this->bottomface = nullptr;
 
   if (PUBLIC(this)->backUrl.getNum() != 0) {     
     const int32_t vindices[] = {4, 5, 6, 7, -1};
@@ -922,13 +922,13 @@ SoVRMLBackgroundP::modifyCubeFace(SoMFString & urls, SoSeparator * sep, const in
   SoVRMLImageTexture * tex;
 
   if (urls.getNum() == 0) {
-    if (sep != NULL) {
+    if (sep != nullptr) {
       sep->unref();
-      sep = NULL;
+      sep = nullptr;
     }
     return;
   }
-  else if (sep == NULL) { 
+  else if (sep == nullptr) { 
     sep = new SoSeparator;
     sep->ref();
 
@@ -1003,7 +1003,7 @@ background_geometrychangeCB(void * data, SoSensor * COIN_UNUSED_ARG(sensor))
   if (pimpl->rootnode) {
     pimpl->rootnode->removeAllChildren();
     pimpl->rootnode->unref();
-    pimpl->rootnode = NULL;
+    pimpl->rootnode = nullptr;
   }
   pimpl->buildGeometry();
 }
diff --git a/coin4/src/vrml97/Collision.cpp b/coin4/src/vrml97/Collision.cpp
index fdfff34..1c1d122 100644
--- a/coin4/src/vrml97/Collision.cpp
+++ b/coin4/src/vrml97/Collision.cpp
@@ -42,7 +42,7 @@
     exposedField SFBool   collide         true
     field        SFVec3f  bboxCenter      0 0 0      # (-,)
     field        SFVec3f  bboxSize        -1 -1 -1   # (0,) or -1,-1,-1
-    field        SFNode   proxy           NULL
+    field        SFNode   proxy           nullptr
     eventOut     SFTime   collideTime
   }
   \endverbatim
@@ -104,9 +104,9 @@
   that is used as a substitute for the Collision node's children
   during collision detection. The proxy is used strictly for collision
   detection; it is not drawn.  If the value of the collide field is
-  true and the proxy field is non-NULL, the proxy field defines the
+  true and the proxy field is non-nullptr, the proxy field defines the
   scene on which collision detection is performed. If the proxy value
-  is NULL, collision detection is performed against the children of
+  is nullptr, collision detection is performed against the children of
   the Collision node.  If proxy is specified, any descendent children
   of the Collision node are ignored during collision detection. If
   children is empty, collide is true, and proxy is specified,
@@ -182,7 +182,7 @@ SoVRMLCollision::commonConstructor(void)
   SO_VRMLNODE_INTERNAL_CONSTRUCTOR(SoVRMLCollision);
 
   SO_VRMLNODE_ADD_EXPOSED_FIELD(collide, (true));
-  SO_VRMLNODE_ADD_FIELD(proxy, (NULL));
+  SO_VRMLNODE_ADD_FIELD(proxy, (nullptr));
 
   SO_VRMLNODE_ADD_EVENT_OUT(collideTime);
 }
diff --git a/coin4/src/vrml97/Color.cpp b/coin4/src/vrml97/Color.cpp
index 5adf1dc..d1c4baa 100644
--- a/coin4/src/vrml97/Color.cpp
+++ b/coin4/src/vrml97/Color.cpp
@@ -83,7 +83,7 @@ class SoVRMLColorP {
 #ifdef COIN_THREADSAFE
     colorpacker_storage(sizeof(void*), alloc_colorpacker, free_colorpacker),
 #endif // COIN_THREADSAFE
-    vbo(NULL) 
+    vbo(nullptr) 
   { }
 
   ~SoVRMLColorP() { delete this->vbo; }
@@ -169,12 +169,12 @@ SoVRMLColor::doAction(SoAction * action)
       SoBase::staticDataLock();
       if (SoGLVBOElement::shouldCreateVBO(state, num)) {
         setvbo = true;
-        if (PRIVATE(this)->vbo == NULL) {
+        if (PRIVATE(this)->vbo == nullptr) {
           PRIVATE(this)->vbo = new SoVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW);
         }
       }
       else if (PRIVATE(this)->vbo) {
-        PRIVATE(this)->vbo->setBufferData(NULL, 0, 0);
+        PRIVATE(this)->vbo->setBufferData(nullptr, 0, 0);
       }
       // don't fill in any data in the VBO. Data will be filled in
       // using the ColorPacker right before the VBO is used
diff --git a/coin4/src/vrml97/Coordinate.cpp b/coin4/src/vrml97/Coordinate.cpp
index 41a28d3..c912a4e 100644
--- a/coin4/src/vrml97/Coordinate.cpp
+++ b/coin4/src/vrml97/Coordinate.cpp
@@ -68,7 +68,7 @@ SO_NODE_SOURCE(SoVRMLCoordinate);
 
 class SoVRMLCoordinateP {
  public:
-  SoVRMLCoordinateP() : vbo(NULL) { }
+  SoVRMLCoordinateP() : vbo(nullptr) { }
   ~SoVRMLCoordinateP() { delete this->vbo; }
   SoVBO * vbo;
 };
@@ -120,7 +120,7 @@ SoVRMLCoordinate::GLRender(SoGLRenderAction * action)
   if (SoGLVBOElement::shouldCreateVBO(state, num)) {
     bool dirty = false;
     setvbo = true;
-    if (PRIVATE(this)->vbo == NULL) {
+    if (PRIVATE(this)->vbo == nullptr) {
       PRIVATE(this)->vbo = new SoVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW); 
       dirty =  true;
     }
@@ -135,7 +135,7 @@ SoVRMLCoordinate::GLRender(SoGLRenderAction * action)
   }
   else if (PRIVATE(this)->vbo && PRIVATE(this)->vbo->getBufferDataId()) {
     // clear buffers to deallocate VBO memory
-    PRIVATE(this)->vbo->setBufferData(NULL, 0, 0);
+    PRIVATE(this)->vbo->setBufferData(nullptr, 0, 0);
   }
   SoBase::staticDataUnlock();
   if (setvbo) {
diff --git a/coin4/src/vrml97/ElevationGrid.cpp b/coin4/src/vrml97/ElevationGrid.cpp
index b7f20e3..4f24bd3 100644
--- a/coin4/src/vrml97/ElevationGrid.cpp
+++ b/coin4/src/vrml97/ElevationGrid.cpp
@@ -37,9 +37,9 @@
   \verbatim
   ElevationGrid {
     eventIn      MFFloat  set_height
-    exposedField SFNode   color             NULL
-    exposedField SFNode   normal            NULL
-    exposedField SFNode   texCoord          NULL
+    exposedField SFNode   color             nullptr
+    exposedField SFNode   normal            nullptr
+    exposedField SFNode   texCoord          nullptr
     field        MFFloat  height            []      # (-inf,inf)
     field        SFBool   ccw               true
     field        SFBool   colorPerVertex    true
@@ -91,14 +91,14 @@
 
   The color field specifies per-vertex or per-quadrilateral colours
   for the ElevationGrid node depending on the value of colorPerVertex.
-  If the color field is NULL, the ElevationGrid node is rendered with
+  If the color field is nullptr, the ElevationGrid node is rendered with
   the overall attributes of the Shape node enclosing the ElevationGrid
   node (see 4.14, Lighting model).  
   
   The colorPerVertex field
   determines whether colours specified in the color field are applied
   to each vertex or each quadrilateral of the ElevationGrid node. If
-  colorPerVertex is false and the color field is not NULL, the color
+  colorPerVertex is false and the color field is not nullptr, the color
   field shall specify a Color node containing at least
   (xDimension-1)(zDimension-1) colours; one for each quadrilateral,
   ordered as follows: 
@@ -113,7 +113,7 @@
   \endverbatim
   
   If
-  colorPerVertex is true and the color field is not NULL, the color
+  colorPerVertex is true and the color field is not nullptr, the color
   field shall specify a Color node containing at least xDimension 
   zDimension colours, one for each vertex, ordered as follows:
 
@@ -126,7 +126,7 @@
   \endverbatim
 
   The normal field specifies per-vertex or per-quadrilateral normals
-  for the ElevationGrid node. If the normal field is NULL, the browser
+  for the ElevationGrid node. If the normal field is nullptr, the browser
   shall automatically generate normals, using the creaseAngle field to
   determine if and how normals are smoothed across the surface (see
   4.6.3.5, Crease angle field). 
@@ -134,7 +134,7 @@
   The normalPerVertex field determines whether normals are applied to
   each vertex or each quadrilateral of the ElevationGrid node
   depending on the value of normalPerVertex. If normalPerVertex is
-  false and the normal node is not NULL, the normal field shall
+  false and the normal node is not nullptr, the normal field shall
   specify a Normal node containing at least
   (xDimension-1)(zDimension-1) normals; one for each quadrilateral,
   ordered as follows: 
@@ -148,7 +148,7 @@
     height[(i+1)+(j+1)xDimension] and height[i+(j+1)xDimension] 
   \endverbatim
 
-  If normalPerVertex is true and the normal field is not NULL, the
+  If normalPerVertex is true and the normal field is not nullptr, the
   normal field shall specify a Normal node containing at least
   xDimension  zDimension normals; one for each vertex, ordered as
   follows:
@@ -162,11 +162,11 @@
   \endverbatim
 
   The texCoord field specifies per-vertex texture coordinates for the
-  ElevationGrid node. If texCoord is NULL, default texture coordinates
+  ElevationGrid node. If texCoord is nullptr, default texture coordinates
   are applied to the geometry. The default texture coordinates range
   from (0,0) at the first vertex to (1,1) at the last vertex. The S
   texture coordinate is aligned with the positive X-axis, and the T
-  texture coordinate with positive Z-axis. If texCoord is not NULL, it
+  texture coordinate with positive Z-axis. If texCoord is not nullptr, it
   shall specify a TextureCoordinate node containing at least
   (xDimension)(zDimension) texture coordinates; one for each vertex,
   ordered as follows:
@@ -349,9 +349,9 @@ SoVRMLElevationGrid::SoVRMLElevationGrid(void)
   SO_VRMLNODE_ADD_FIELD(zSpacing, (1.0f));
   SO_VRMLNODE_ADD_FIELD(xSpacing, (1.0f));
   SO_VRMLNODE_ADD_EMPTY_MFIELD(height);
-  SO_VRMLNODE_ADD_EXPOSED_FIELD(texCoord, (NULL));
-  SO_VRMLNODE_ADD_EXPOSED_FIELD(normal, (NULL));
-  SO_VRMLNODE_ADD_EXPOSED_FIELD(color, (NULL));
+  SO_VRMLNODE_ADD_EXPOSED_FIELD(texCoord, (nullptr));
+  SO_VRMLNODE_ADD_EXPOSED_FIELD(normal, (nullptr));
+  SO_VRMLNODE_ADD_EXPOSED_FIELD(color, (nullptr));
   SO_VRMLNODE_ADD_FIELD(colorPerVertex, (true));
   SO_VRMLNODE_ADD_FIELD(normalPerVertex, (true));
 }
@@ -401,7 +401,7 @@ SoVRMLElevationGrid::GLRender(SoGLRenderAction * action)
 
   if (!donorm) nbind = OVERALL;
 
-  const SbVec2f * tcoords = NULL;
+  const SbVec2f * tcoords = nullptr;
   SoVRMLTextureCoordinate * tnode = (SoVRMLTextureCoordinate*)
     this->texCoord.getValue();
 
@@ -410,11 +410,11 @@ SoVRMLElevationGrid::GLRender(SoGLRenderAction * action)
   mb.sendFirst();
 
   bool normalcache = false;
-  const SbVec3f * normals = NULL;
+  const SbVec3f * normals = nullptr;
   if (nbind != OVERALL) {
     SoVRMLNormal * nnode = (SoVRMLNormal*) this->normal.getValue();
     if (nnode) normals = nnode->vector.getValues(0);
-    if (normals == NULL) {
+    if (normals == nullptr) {
       normals = this->updateNormalCache(nbind);
       normalcache = true;
     }
@@ -685,18 +685,18 @@ SoVRMLElevationGrid::generatePrimitives(SoAction * action)
 
   if (!donorm) nbind = OVERALL;
 
-  const SbVec2f * tcoords = NULL;
+  const SbVec2f * tcoords = nullptr;
   SoVRMLTextureCoordinate * tnode = (SoVRMLTextureCoordinate*)
     this->texCoord.getValue();
 
   if (tnode) tcoords = tnode->point.getValues(0);
 
   bool normalcache = false;
-  const SbVec3f * normals = NULL;
+  const SbVec3f * normals = nullptr;
   if (nbind != OVERALL) {
     SoVRMLNormal * nnode = (SoVRMLNormal*) this->normal.getValue();
     if (nnode) normals = nnode->vector.getValues(0);
-    if (normals == NULL) {
+    if (normals == nullptr) {
       // updateNormalCache will readLock the normal cache. We unlock
       // at the end of this function.
       normals = this->updateNormalCache(nbind);
@@ -906,7 +906,7 @@ SoVRMLElevationGrid::updateNormalCache(Binding & nbind)
 
     const int xdim = this->xDimension.getValue();
     const int zdim = this->zDimension.getValue();
-    if (xdim < 2 || zdim < 2) return NULL;
+    if (xdim < 2 || zdim < 2) return nullptr;
 
     const float * h = this->height.getValues(0);
 
diff --git a/coin4/src/vrml97/Extrusion.cpp b/coin4/src/vrml97/Extrusion.cpp
index 7ba1580..577a479 100644
--- a/coin4/src/vrml97/Extrusion.cpp
+++ b/coin4/src/vrml97/Extrusion.cpp
@@ -413,7 +413,7 @@ public:
      idx(32),
      gen(true),
      dirty(true),
-     vbocache(NULL)
+     vbocache(nullptr)
 #ifdef COIN_THREADSAFE
      , rwmutex(SbRWMutex::READ_PRECEDENCE)
 #endif // COIN_THREADSAFE
@@ -539,7 +539,7 @@ SoVRMLExtrusion::GLRender(SoGLRenderAction * action)
        SoMultiTextureCoordinateElement::FUNCTION) &&
       (SoMultiTextureCoordinateElement::getType(state) !=
        SoMultiTextureCoordinateElement::TEXGEN)) {
-    SoGLMultiTextureCoordinateElement::setTexGen(state, this, NULL);
+    SoGLMultiTextureCoordinateElement::setTexGen(state, this, nullptr);
     SoMultiTextureCoordinateElement::set2(state, this, PRIVATE(this)->tcoord.getLength(),
                                           PRIVATE(this)->tcoord.getArrayPtr());
   }
@@ -566,13 +566,13 @@ SoVRMLExtrusion::GLRender(SoGLRenderAction * action)
 
     if (doTextures) {
       PRIVATE(this)->vbocache->getTexCoordVBO(0)->bindBuffer(contextid);
-      cc_glglue_glTexCoordPointer(glue, 2, GL_FLOAT, 0, NULL);
+      cc_glglue_glTexCoordPointer(glue, 2, GL_FLOAT, 0, nullptr);
       cc_glglue_glEnableClientState(glue, GL_TEXTURE_COORD_ARRAY);
 
       for (i = 1; i <= lastenabled; i++) {
         if (enabled[i]) {
           cc_glglue_glClientActiveTexture(glue, GL_TEXTURE0 + i);
-          cc_glglue_glTexCoordPointer(glue, 2, GL_FLOAT, 0, NULL);
+          cc_glglue_glTexCoordPointer(glue, 2, GL_FLOAT, 0, nullptr);
           cc_glglue_glEnableClientState(glue, GL_TEXTURE_COORD_ARRAY);
         }
       }
@@ -580,11 +580,11 @@ SoVRMLExtrusion::GLRender(SoGLRenderAction * action)
     }
 
     PRIVATE(this)->vbocache->getNormalVBO()->bindBuffer(contextid);
-    cc_glglue_glNormalPointer(glue, GL_FLOAT, 0, NULL);
+    cc_glglue_glNormalPointer(glue, GL_FLOAT, 0, nullptr);
     cc_glglue_glEnableClientState(glue, GL_NORMAL_ARRAY);
 
     PRIVATE(this)->vbocache->getCoordVBO()->bindBuffer(contextid);
-    cc_glglue_glVertexPointer(glue, 3, GL_FLOAT, 0, NULL);
+    cc_glglue_glVertexPointer(glue, 3, GL_FLOAT, 0, nullptr);
     cc_glglue_glEnableClientState(glue, GL_VERTEX_ARRAY);
 
     SoGLVertexAttributeElement::getInstance(state)->enableVBO(action);
@@ -646,9 +646,9 @@ SoVRMLExtrusion::GLRender(SoGLRenderAction * action)
                         PRIVATE(this)->idx.getArrayPtr(),
                         PRIVATE(this)->idx.getLength(),
                         normals,
-                        NULL,
+                        nullptr,
                         &mb,
-                        NULL,
+                        nullptr,
                         &tb,
                         PRIVATE(this)->idx.getArrayPtr(),
                         &vab,
@@ -798,7 +798,7 @@ SoVRMLExtrusion::updateCache(void)
 void
 SoVRMLExtrusionP::updateVBO(SoAction * action)
 {
-  if (this->vbocache == NULL || !this->vbocache->isValid(action->getState())) {
+  if (this->vbocache == nullptr || !this->vbocache->isValid(action->getState())) {
     this->readUnlock();
     SoTextureCoordinateBundle tb(action, false, false);
     bool istexfunc = tb.isFunction();
@@ -923,7 +923,7 @@ SoVRMLExtrusion::createTriangleDetail(SoRayPickAction * COIN_UNUSED_ARG(action),
                                       SoPickedPoint * COIN_UNUSED_ARG(pp))
 {
   // no triangle detail for Extrusion
-  return NULL;
+  return nullptr;
 }
 
 static SbVec3f
diff --git a/coin4/src/vrml97/Geometry.cpp b/coin4/src/vrml97/Geometry.cpp
index 807def9..ec26fce 100644
--- a/coin4/src/vrml97/Geometry.cpp
+++ b/coin4/src/vrml97/Geometry.cpp
@@ -85,9 +85,9 @@ SoVRMLGeometry::initClass(void)
 SoVRMLGeometry::SoVRMLGeometry(void)
 {
   PRIVATE(this) = new SoVRMLGeometryP;
-  // supply a NULL-pointer as parent, since notifications will be 
+  // supply a nullptr-pointer as parent, since notifications will be 
   // handled by the fields that actually contain the node(s)
-  PRIVATE(this)->childlist = new SoChildList(NULL);
+  PRIVATE(this)->childlist = new SoChildList(nullptr);
   PRIVATE(this)->childlistvalid = false;
   SO_VRMLNODE_INTERNAL_CONSTRUCTOR(SoVRMLGeometry);
 }
@@ -147,7 +147,7 @@ void
 SoVRMLGeometry::search(SoSearchAction * action)
 {
   SoNode::search(action);
-  if (action->isFound() || this->getChildren() == NULL) return;
+  if (action->isFound() || this->getChildren() == nullptr) return;
 
   int numindices;
   const int * indices;
diff --git a/coin4/src/vrml97/Group.cpp b/coin4/src/vrml97/Group.cpp
index b498380..4b61b51 100644
--- a/coin4/src/vrml97/Group.cpp
+++ b/coin4/src/vrml97/Group.cpp
@@ -135,7 +135,7 @@ static void
 sovrmlgroup_storage_construct(void * data)
 {
   sovrmlgroup_storage * ptr = (sovrmlgroup_storage*) data;
-  ptr->glcachelist = NULL;
+  ptr->glcachelist = nullptr;
 }
 
 static void 
@@ -181,7 +181,7 @@ public:
   SoGLCacheList * getGLCacheList(const bool createifnull);
 
   void invalidateGLCaches(void) {
-    glcachestorage->applyToAll(invalidate_gl_cache, NULL);
+    glcachestorage->applyToAll(invalidate_gl_cache, nullptr);
   }
 
 #ifdef COIN_THREADSAFE
@@ -199,7 +199,7 @@ SoVRMLGroupP::getGLCacheList(const bool createifnull)
 {
   sovrmlgroup_storage * ptr = 
     (sovrmlgroup_storage*) this->glcachestorage->get();
-  if (createifnull && ptr->glcachelist == NULL) {
+  if (createifnull && ptr->glcachelist == nullptr) {
     ptr->glcachelist = new SoGLCacheList(SoVRMLGroup::getNumRenderCaches());
   }
   return ptr->glcachelist;
@@ -245,7 +245,7 @@ void
 SoVRMLGroup::commonConstructor(void)
 {
   PRIVATE(this) = new SoVRMLGroupP;
-  PRIVATE(this)->bboxcache = NULL;
+  PRIVATE(this)->bboxcache = nullptr;
   PRIVATE(this)->bboxcache_usecount = 0;
   PRIVATE(this)->bboxcache_destroycount = 0;
 
@@ -275,7 +275,7 @@ SoVRMLGroup::commonConstructor(void)
     maxcaches = -2; // so we don't request the envvar later if it is not set
     const char * maxcachesstr = coin_getenv("IV_SEPARATOR_MAX_CACHES");
     if (maxcachesstr) {
-      maxcaches = strtol(maxcachesstr, NULL, 10);
+      maxcaches = strtol(maxcachesstr, nullptr, 10);
       if ((maxcaches == LONG_MIN) || (maxcaches == LONG_MAX) || (maxcaches < 0)) {
         SoDebugError::post("SoVRMLGroup::commonConstructor",
                            "Environment variable IV_SEPARATOR_MAX_CACHES "
@@ -554,7 +554,7 @@ SoVRMLGroup::GLRenderBelowPath(SoGLRenderAction * action)
   SoState * state = action->getState();
   state->push();
   bool didcull = false;
-  SoGLCacheList * createcache = NULL;
+  SoGLCacheList * createcache = nullptr;
   if ((this->renderCaching.getValue() != OFF) && 
       (SoVRMLGroup::getNumRenderCaches() > 0)) {
     if (!state->isCacheOpen()) {
diff --git a/coin4/src/vrml97/ImageTexture.cpp b/coin4/src/vrml97/ImageTexture.cpp
index 83ebd4a..9923e16 100644
--- a/coin4/src/vrml97/ImageTexture.cpp
+++ b/coin4/src/vrml97/ImageTexture.cpp
@@ -212,8 +212,8 @@
 // *************************************************************************
 
 static int imagedata_maxage = 0;
-static VRMLPrequalifyFileCallback * imagetexture_prequalify_cb = NULL;
-static void * imagetexture_prequalify_closure = NULL;
+static VRMLPrequalifyFileCallback * imagetexture_prequalify_cb = nullptr;
+static void * imagetexture_prequalify_closure = nullptr;
 static bool imagetexture_delay_fetch = true;
 
 // *************************************************************************
@@ -274,25 +274,25 @@ public:
 
 #ifdef COIN_THREADSAFE
     delete glimagemutex;
-    glimagemutex = NULL;
+    glimagemutex = nullptr;
 #endif // COIN_THREADSAFE
 
     if (scheduler) {
       cc_sched_destruct(scheduler);
-      scheduler = NULL;
+      scheduler = nullptr;
     }
 
     imagetexture_delay_fetch = true;
-    imagetexture_prequalify_cb = NULL;
-    imagetexture_prequalify_closure = NULL;
+    imagetexture_prequalify_cb = nullptr;
+    imagetexture_prequalify_closure = nullptr;
   }
 };
 
 #ifdef COIN_THREADSAFE
-SbMutex * SoVRMLImageTextureP::glimagemutex = NULL;
+SbMutex * SoVRMLImageTextureP::glimagemutex = nullptr;
 #endif // COIN_THREADSAFE
 
-cc_sched * SoVRMLImageTextureP::scheduler = NULL;
+cc_sched * SoVRMLImageTextureP::scheduler = nullptr;
 bool SoVRMLImageTextureP::is_exiting = false;
 
 // *************************************************************************
@@ -343,7 +343,7 @@ SoVRMLImageTexture::SoVRMLImageTexture(void)
   SO_VRMLNODE_INTERNAL_CONSTRUCTOR(SoVRMLImageTexture);
   SO_VRMLNODE_ADD_EMPTY_EXPOSED_MFIELD(url);
 
-  PRIVATE(this)->glimage = NULL;
+  PRIVATE(this)->glimage = nullptr;
   PRIVATE(this)->glimagevalid = false;
   PRIVATE(this)->readstatus = 1;
   PRIVATE(this)->allowprequalifycb = true;
@@ -373,7 +373,7 @@ SoVRMLImageTexture::~SoVRMLImageTexture()
     cc_sched_wait_all(SoVRMLImageTextureP::scheduler);
   }
 
-  if (PRIVATE(this)->glimage) PRIVATE(this)->glimage->unref(NULL);
+  if (PRIVATE(this)->glimage) PRIVATE(this)->glimage->unref(nullptr);
   PRIVATE(this)->clearSearchDirs();
   delete PRIVATE(this)->urlsensor;
   delete PRIVATE(this);
@@ -635,7 +635,7 @@ static void
 imagetexture_glimage_delete(void * closure, SoSensor * s)
 {
   SoGLImage * img = (SoGLImage*) closure;
-  img->unref(NULL);
+  img->unref(nullptr);
   delete s;
 }
 
@@ -654,7 +654,7 @@ SoVRMLImageTexture::glimage_callback(void * closure)
       // SoGLImage. Use a sensor to delete it the next time the
       // delayqueue sensors are processed.
       if (PRIVATE(thisp)->glimage) {
-        PRIVATE(thisp)->glimage->setEndFrameCallback(NULL, NULL);
+        PRIVATE(thisp)->glimage->setEndFrameCallback(nullptr, nullptr);
         // allocate new sensor. It will be deleted in the sensor
         // callback. We do this here since this node might be outside
         // the view frustum, and GLRender() may not be called anytime
@@ -662,11 +662,11 @@ SoVRMLImageTexture::glimage_callback(void * closure)
         SoOneShotSensor * s = new SoOneShotSensor(imagetexture_glimage_delete, PRIVATE(thisp)->glimage);
         s->schedule();
         // clear the GLImage in this node. The sensor has a pointer to it and will delete it
-        PRIVATE(thisp)->glimage = NULL;
+        PRIVATE(thisp)->glimage = nullptr;
         PRIVATE(thisp)->glimagevalid = false;
       }
       PRIVATE(thisp)->unlock_glimage();
-      PRIVATE(thisp)->image.setValue(SbVec2s(0,0), 0, NULL);
+      PRIVATE(thisp)->image.setValue(SbVec2s(0,0), 0, nullptr);
       (void) thisp->loadUrl();
       return;
     }
@@ -778,7 +778,7 @@ SoVRMLImageTexture::urlSensorCB(void * data, SoSensor *)
         cc_sched_wait_all(SoVRMLImageTextureP::scheduler);
       }
 
-      thisp->pimpl->image.setValue(SbVec2s(0,0), 0, NULL);
+      thisp->pimpl->image.setValue(SbVec2s(0,0), 0, nullptr);
     }
   }
 }
@@ -794,7 +794,7 @@ SoVRMLImageTexture::readImage(const SbString & filename)
                                         this);
   }
   else {
-    retval = default_prequalify_cb(filename, NULL, this); 
+    retval = default_prequalify_cb(filename, nullptr, this); 
   }
   PRIVATE(this)->lock_glimage();
   PRIVATE(this)->glimagevalid = false;
diff --git a/coin4/src/vrml97/IndexedFaceSet.cpp b/coin4/src/vrml97/IndexedFaceSet.cpp
index 2446fbc..9d995ea 100644
--- a/coin4/src/vrml97/IndexedFaceSet.cpp
+++ b/coin4/src/vrml97/IndexedFaceSet.cpp
@@ -40,10 +40,10 @@
     eventIn       MFInt32 set_coordIndex
     eventIn       MFInt32 set_normalIndex
     eventIn       MFInt32 set_texCoordIndex
-    exposedField  SFNode  color             NULL
-    exposedField  SFNode  coord             NULL
-    exposedField  SFNode  normal            NULL
-    exposedField  SFNode  texCoord          NULL
+    exposedField  SFNode  color             nullptr
+    exposedField  SFNode  coord             nullptr
+    exposedField  SFNode  normal            nullptr
+    exposedField  SFNode  texCoord          nullptr
     field         SFBool  ccw               true
     field         MFInt32 colorIndex        []        # [-1,)
     field         SFBool  colorPerVertex    true
@@ -86,7 +86,7 @@
   between color field, normal field, textures, materials, and
   geometries are provided in 4.14, Lighting model.
 
-  If the color field is not NULL, it shall contain a Color node whose
+  If the color field is not nullptr, it shall contain a Color node whose
   colours are applied to the vertices or faces of the IndexedFaceSet
   as follows:
 
@@ -121,22 +121,22 @@
       in the coordIndex field is N, then there shall be N+1 colours in
       the Color node.
 
-  If the color field is NULL, the geometry shall be rendered normally
+  If the color field is nullptr, the geometry shall be rendered normally
   using the Material and texture defined in the Appearance node (see
   4.14, Lighting model, for details
   http://www.web3d.org/x3d/specifications/vrml/ISO-IEC-14772-VRML97/part1/concepts.html#4.6.5).
 
-  If the normal field is not NULL, it shall contain a Normal node
+  If the normal field is not nullptr, it shall contain a Normal node
   whose normals are applied to the vertices or faces of the
   IndexedFaceSet in a manner exactly equivalent to that described
   above for applying colours to vertices/faces (where normalPerVertex
   corresponds to colorPerVertex and normalIndex corresponds to
-  colorIndex). If the normal field is NULL, the browser shall
+  colorIndex). If the normal field is nullptr, the browser shall
   automatically generate normals, using creaseAngle to determine if
   and how normals are smoothed across shared vertices (see 4.6.3.5,
   Crease angle field).
 
-  If the texCoord field is not NULL, it shall contain a
+  If the texCoord field is not nullptr, it shall contain a
   TextureCoordinate node. The texture coordinates in that node are
   applied to the vertices of the IndexedFaceSet as follows: If the
   texCoordIndex field is not empty, then it is used to choose texture
@@ -153,7 +153,7 @@
   used to choose texture coordinates from the TextureCoordinate
   node. If the greatest index in the coordIndex field is N, then there
   shall be N+1 texture coordinates in the TextureCoordinate node.  If
-  the texCoord field is NULL, a default texture coordinate mapping is
+  the texCoord field is nullptr, a default texture coordinate mapping is
   calculated using the local coordinate system bounding box of the
   shape.  The longest dimension of the bounding box defines the S
   coordinates, and the next longest defines the T coordinates. If two
@@ -299,9 +299,9 @@ SoVRMLIndexedFaceSet::initClass(void) // static
 SoVRMLIndexedFaceSet::SoVRMLIndexedFaceSet(void)
 {
   PRIVATE(this) = new SoVRMLIndexedFaceSetP;
-  PRIVATE(this)->convexCache = NULL;
+  PRIVATE(this)->convexCache = nullptr;
   PRIVATE(this)->concavestatus = STATUS_UNKNOWN;
-  PRIVATE(this)->vaindexer = NULL;
+  PRIVATE(this)->vaindexer = nullptr;
 
   SO_VRMLNODE_INTERNAL_CONSTRUCTOR(SoVRMLIndexedFaceSet);
 
@@ -430,7 +430,7 @@ SoVRMLIndexedFaceSet::findNormalBinding(SoState * state) const
 void
 SoVRMLIndexedFaceSet::GLRender(SoGLRenderAction * action)
 {
-  if (this->coordIndex.getNum() < 3 || this->coord.getValue() == NULL) return;
+  if (this->coordIndex.getNum() < 3 || this->coord.getValue() == nullptr) return;
   SoState * state = action->getState();
 
   state->push();
@@ -468,8 +468,8 @@ SoVRMLIndexedFaceSet::GLRender(SoGLRenderAction * action)
 
   if (!sendNormals) {
     nbind = OVERALL;
-    normals = NULL;
-    nindices = NULL;
+    normals = nullptr;
+    nindices = nullptr;
   }
   else if (nbind == OVERALL) {
     if (normals) glNormal3fv(normals[0].getValue());
@@ -495,11 +495,11 @@ SoVRMLIndexedFaceSet::GLRender(SoGLRenderAction * action)
   if (doTextures) {
     if (tb.isFunction() && !tb.needIndices()) {
       tbind = NONE;
-      tindices = NULL;
+      tindices = nullptr;
     }
     else {
       tbind = PER_VERTEX_INDEXED;
-      if (tindices == NULL) tindices = cindices;
+      if (tindices == nullptr) tindices = cindices;
     }
   }
   bool convexcacheused = false;
@@ -522,24 +522,24 @@ SoVRMLIndexedFaceSet::GLRender(SoGLRenderAction * action)
 
   mb.sendFirst(); // make sure we have the correct material
 
-  SoGLLazyElement * lelem = NULL;
+  SoGLLazyElement * lelem = nullptr;
   const uint32_t contextid = action->getCacheContext();
 
   bool dova = 
     SoVBO::shouldRenderAsVertexArrays(state, contextid, numindices) &&
     !convexcacheused && !normalCacheUsed &&
-    ((nbind == OVERALL) || ((nbind == PER_VERTEX_INDEXED) && ((nindices == cindices) || (nindices == NULL)))) &&
+    ((nbind == OVERALL) || ((nbind == PER_VERTEX_INDEXED) && ((nindices == cindices) || (nindices == nullptr)))) &&
     ((tbind == NONE && !tb.needCoordinates()) || 
-     ((tbind == PER_VERTEX_INDEXED) && ((tindices == cindices) || (tindices == NULL)))) &&
-    ((mbind == NONE) || ((mbind == PER_VERTEX_INDEXED) && ((mindices == cindices) || (mindices == NULL)))) &&
+     ((tbind == PER_VERTEX_INDEXED) && ((tindices == cindices) || (tindices == nullptr)))) &&
+    ((mbind == NONE) || ((mbind == PER_VERTEX_INDEXED) && ((mindices == cindices) || (mindices == nullptr)))) &&
     SoGLDriverDatabase::isSupported(sogl_glue_instance(state), SO_GL_VERTEX_ARRAY);
 
   const SoGLVBOElement * vboelem = SoGLVBOElement::getInstance(state);
-  SoVBO * colorvbo = NULL;
+  SoVBO * colorvbo = nullptr;
 
   if (dova && (mbind != OVERALL)) {
     dova = false;
-    if ((mbind == PER_VERTEX_INDEXED) && ((mindices == cindices) || (mindices == NULL))) {
+    if ((mbind == PER_VERTEX_INDEXED) && ((mindices == cindices) || (mindices == nullptr))) {
       lelem = (SoGLLazyElement*) SoLazyElement::getInstance(state);
       colorvbo = vboelem->getColorVBO();
       if (colorvbo) dova = true;
@@ -556,12 +556,12 @@ SoVRMLIndexedFaceSet::GLRender(SoGLRenderAction * action)
   if (dova) {
     bool dovbo = this->startVertexArray(action,
                                           coords,
-                                          (nbind != OVERALL) ? normals : NULL,
+                                          (nbind != OVERALL) ? normals : nullptr,
                                           doTextures,
                                           mbind != OVERALL);
     didrenderasvbo = dovbo;
     LOCK_VAINDEXER(this);
-    if (PRIVATE(this)->vaindexer == NULL) {
+    if (PRIVATE(this)->vaindexer == nullptr) {
       SoVertexArrayIndexer * indexer = new SoVertexArrayIndexer;
       int i = 0;
       while (i < numindices) {
@@ -755,8 +755,8 @@ SoVRMLIndexedFaceSet::generatePrimitives(SoAction * action)
 
   if (!sendNormals) {
     nbind = OVERALL;
-    normals = NULL;
-    nindices = NULL;
+    normals = nullptr;
+    nindices = nullptr;
   }
   else if (normalCacheUsed && nbind == PER_VERTEX) {
     nbind = PER_VERTEX_INDEXED;
@@ -781,11 +781,11 @@ SoVRMLIndexedFaceSet::generatePrimitives(SoAction * action)
   if (doTextures) {
     if (tb.isFunction() && !tb.needIndices()) {
       tbind = NONE;
-      tindices = NULL;
+      tindices = nullptr;
     }
     else {
       tbind = PER_VERTEX_INDEXED;
-      if (tindices == NULL) tindices = cindices;
+      if (tindices == nullptr) tindices = cindices;
     }
   }
   
@@ -921,7 +921,7 @@ SoVRMLIndexedFaceSet::generateDefaultNormals(SoState * state,
                                              SoNormalCache * nc)
 {
   SoVRMLCoordinate * node = (SoVRMLCoordinate*) this->coord.getValue();
-  if (node == NULL) return true; // ok, empty ifs
+  if (node == nullptr) return true; // ok, empty ifs
 
   const SbVec3f * coords = node->point.getValues(0);
 
@@ -935,7 +935,7 @@ SoVRMLIndexedFaceSet::generateDefaultNormals(SoState * state,
                           coordIndex.getValues(0),
                           coordIndex.getNum(),
                           this->creaseAngle.getValue(),
-                          NULL, // face normals
+                          nullptr, // face normals
                           0,    // num face normals
                           this->ccw.getValue());
     break;
@@ -964,7 +964,7 @@ SoVRMLIndexedFaceSet::notify(SoNotList * list)
     LOCK_VAINDEXER(this);
     if (PRIVATE(this)->vaindexer) {
       delete PRIVATE(this)->vaindexer;
-      PRIVATE(this)->vaindexer = NULL;
+      PRIVATE(this)->vaindexer = nullptr;
     }
     UNLOCK_VAINDEXER(this);
   }
@@ -974,7 +974,7 @@ SoVRMLIndexedFaceSet::notify(SoNotList * list)
 //
 // internal method which checks if convex cache needs to be
 // used or (re)created. Returns true if convex cache must be
-// used. PRIVATE(this)->convexCache is then guaranteed to be != NULL.
+// used. PRIVATE(this)->convexCache is then guaranteed to be != nullptr.
 //
 bool
 SoVRMLIndexedFaceSet::useConvexCache(SoAction * action, 
@@ -1006,7 +1006,7 @@ SoVRMLIndexedFaceSet::useConvexCache(SoAction * action,
   if (PRIVATE(this)->convexCache && PRIVATE(this)->convexCache->isValid(state)) {
     // check if convex cache has normal indices. The convex cache
     // might be generated without normals.
-    if (normals == NULL || PRIVATE(this)->convexCache->getNormalIndices()) {
+    if (normals == nullptr || PRIVATE(this)->convexCache->getNormalIndices()) {
       return true;
     }
   }
@@ -1062,12 +1062,12 @@ SoVRMLIndexedFaceSet::useConvexCache(SoAction * action,
   }
 
   Binding tbind = PER_VERTEX_INDEXED;
-  if (tindices == NULL) tindices = cindices;
+  if (tindices == nullptr) tindices = cindices;
 
-  if (nbind == PER_VERTEX_INDEXED && nindices == NULL) {
+  if (nbind == PER_VERTEX_INDEXED && nindices == nullptr) {
     nindices = cindices;
   }
-  if (mbind == PER_VERTEX_INDEXED && mindices == NULL) {
+  if (mbind == PER_VERTEX_INDEXED && mindices == nullptr) {
     mindices = cindices;
   }
   PRIVATE(this)->convexCache->generate(coords, modelmatrix,
diff --git a/coin4/src/vrml97/IndexedLine.cpp b/coin4/src/vrml97/IndexedLine.cpp
index 1f45fe7..a08cad4 100644
--- a/coin4/src/vrml97/IndexedLine.cpp
+++ b/coin4/src/vrml97/IndexedLine.cpp
@@ -73,7 +73,7 @@ SoVRMLIndexedLine::computeBBox(SoAction * COIN_UNUSED_ARG(action),
                                SbVec3f & center)
 {
   SoVRMLCoordinate * node = (SoVRMLCoordinate*) this->coord.getValue();
-  if (node == NULL) return;
+  if (node == nullptr) return;
 
   int numCoords = node->point.getNum();
   const SbVec3f * coords = node->point.getValues(0);
@@ -109,7 +109,7 @@ SoVRMLIndexedLine::getColorIndices(void) // protected
 {
   // FIXME: why is there just a dummy implementation of this method?
   // Please document special cases like this.  20030603 mortene.
-  return NULL;
+  return nullptr;
 }
 
 void
diff --git a/coin4/src/vrml97/IndexedLineSet.cpp b/coin4/src/vrml97/IndexedLineSet.cpp
index 82c6c3b..05fb332 100644
--- a/coin4/src/vrml97/IndexedLineSet.cpp
+++ b/coin4/src/vrml97/IndexedLineSet.cpp
@@ -38,8 +38,8 @@
   IndexedLineSet {
     eventIn       MFInt32 set_colorIndex
     eventIn       MFInt32 set_coordIndex
-    exposedField  SFNode  color             NULL
-    exposedField  SFNode  coord             NULL
+    exposedField  SFNode  color             nullptr
+    exposedField  SFNode  coord             nullptr
     field         MFInt32 colorIndex        []     # [-1, inf)
     field         SFBool  colorPerVertex    true
     field         MFInt32 coordIndex        []     # [-1, inf)
@@ -60,7 +60,7 @@
   contains a Coordinate node.  Lines are not lit, are not
   texture-mapped, and do not participate in collision detection. The
   width of lines is implementation dependent and each line segment is
-  solid (i.e., not dashed).  If the color field is not NULL, it shall
+  solid (i.e., not dashed).  If the color field is not nullptr, it shall
   contain a Color node.  The colours are applied to the line(s) as
   follows: 
   
@@ -94,7 +94,7 @@
       the coordIndex field is N, there shall be N+1 colours in the Color
       node.  
 
-  If the color field is NULL and there is a Material defined for the
+  If the color field is nullptr and there is a Material defined for the
   Appearance affecting this IndexedLineSet, the emissiveColor of the
   Material shall be used to draw the lines. Details on lighting
   equations as they affect IndexedLineSet nodes are described in 4.14,
@@ -146,7 +146,7 @@
 
 class SoVRMLIndexedLineSetP {
  public:
-  SoVRMLIndexedLineSetP() : vaindexer(NULL) { }
+  SoVRMLIndexedLineSetP() : vaindexer(nullptr) { }
   ~SoVRMLIndexedLineSetP() { delete this->vaindexer; }
 
   enum Binding {
@@ -271,7 +271,7 @@ SoVRMLIndexedLineSet::GLRender(SoGLRenderAction * action)
   coords = SoCoordinateElement::getInstance(state);
   cindices = this->coordIndex.getValues(0);
   numindices = this->coordIndex.getNum();
-  mindices = this->colorIndex.getNum() ? this->colorIndex.getValues(0) : NULL;
+  mindices = this->colorIndex.getNum() ? this->colorIndex.getValues(0) : nullptr;
 
   SoVRMLIndexedLineSetP::Binding mbind =
     SoVRMLIndexedLineSetP::findMaterialBinding(this, state);
@@ -286,7 +286,7 @@ SoVRMLIndexedLineSet::GLRender(SoGLRenderAction * action)
   // place it here so that it will stay in stack scope
   uint32_t packedcolor;
 
-  if (this->color.getValue() == NULL) {
+  if (this->color.getValue() == nullptr) {
     // FIXME: the vrml97 spec states that the emissiveColor should be
     // used when no color node is found, but this doesn't work for
     // some Hydro models, since diffuseColor is used to set the color
@@ -309,7 +309,7 @@ SoVRMLIndexedLineSet::GLRender(SoGLRenderAction * action)
   SoMaterialBundle mb(action);
   mb.sendFirst(); // make sure we have the correct material
  
-  SoGLLazyElement * lelem = NULL;
+  SoGLLazyElement * lelem = nullptr;
   const uint32_t contextid = action->getCacheContext();
 
   bool dova = 
@@ -318,12 +318,12 @@ SoVRMLIndexedLineSet::GLRender(SoGLRenderAction * action)
     SoGLDriverDatabase::isSupported(sogl_glue_instance(state), SO_GL_VERTEX_ARRAY);
   
   const SoGLVBOElement * vboelem = SoGLVBOElement::getInstance(state);
-  SoVBO * colorvbo = NULL;
+  SoVBO * colorvbo = nullptr;
   
   if (dova && (mbind != SoVRMLIndexedLineSetP::OVERALL)) {
     dova = false;
     if ((mbind == SoVRMLIndexedLineSetP::PER_VERTEX_INDEXED) && 
-        ((mindices == cindices) || (mindices == NULL))) {
+        ((mindices == cindices) || (mindices == nullptr))) {
       lelem = (SoGLLazyElement*) SoLazyElement::getInstance(state);
       colorvbo = vboelem->getColorVBO();
       if (colorvbo) dova = true;
@@ -345,7 +345,7 @@ SoVRMLIndexedLineSet::GLRender(SoGLRenderAction * action)
                                           mbind != SoVRMLIndexedLineSetP::OVERALL);
     didrenderasvbo = dovbo;
     LOCK_VAINDEXER(this);
-    if (PRIVATE(this)->vaindexer == NULL) {
+    if (PRIVATE(this)->vaindexer == nullptr) {
       SoVertexArrayIndexer * indexer = new SoVertexArrayIndexer;
       
       int i = 0;
@@ -388,11 +388,11 @@ SoVRMLIndexedLineSet::GLRender(SoGLRenderAction * action)
     sogl_render_lineset((SoGLCoordinateElement*)coords,
                         cindices,
                         numindices,
-                        NULL,
-                        NULL,
+                        nullptr,
+                        nullptr,
                         &mb,
                         mindices,
-                        NULL, 0,
+                        nullptr, 0,
                         0,
                         (int)mbind,
                         0,
@@ -458,7 +458,7 @@ SoVRMLIndexedLineSet::generatePrimitives(SoAction * action)
   coords = SoCoordinateElement::getInstance(state);
   cindices = this->coordIndex.getValues(0);
   numindices = this->coordIndex.getNum();
-  matindices = this->colorIndex.getNum() ? this->colorIndex.getValues(0) : NULL;
+  matindices = this->colorIndex.getNum() ? this->colorIndex.getValues(0) : nullptr;
 
   SoVRMLIndexedLineSetP::Binding mbind =
     SoVRMLIndexedLineSetP::findMaterialBinding(this, state);
@@ -468,7 +468,7 @@ SoVRMLIndexedLineSet::generatePrimitives(SoAction * action)
   }
 
   if (mbind == SoVRMLIndexedLineSetP::PER_LINE || mbind == SoVRMLIndexedLineSetP::OVERALL) {
-    matindices = NULL;
+    matindices = nullptr;
   }
 
   int matnr = 0;
@@ -536,7 +536,7 @@ SoVRMLIndexedLineSet::notify(SoNotList * list)
     LOCK_VAINDEXER(this);
     if (PRIVATE(this)->vaindexer) {
       delete PRIVATE(this)->vaindexer;
-      PRIVATE(this)->vaindexer = NULL;
+      PRIVATE(this)->vaindexer = nullptr;
     }
     UNLOCK_VAINDEXER(this);
   }
diff --git a/coin4/src/vrml97/IndexedShape.cpp b/coin4/src/vrml97/IndexedShape.cpp
index 9110727..8db7c81 100644
--- a/coin4/src/vrml97/IndexedShape.cpp
+++ b/coin4/src/vrml97/IndexedShape.cpp
@@ -114,26 +114,26 @@ SoVRMLIndexedShape::getVertexData(SoState * state,
   numcindices = this->coordIndex.getNum();
 
   mindices = this->colorIndex.getValues(0);
-  if (this->colorIndex.getNum() <= 0 || mindices[0] < 0) mindices = NULL;
+  if (this->colorIndex.getNum() <= 0 || mindices[0] < 0) mindices = nullptr;
 
   tindices = this->texCoordIndex.getValues(0);
-  if (this->texCoordIndex.getNum() <= 0 || tindices[0] < 0) tindices = NULL;
+  if (this->texCoordIndex.getNum() <= 0 || tindices[0] < 0) tindices = nullptr;
 
   normalcacheused = false;
-  nindices = NULL;
+  nindices = nullptr;
 
   if (neednormals) {
     nindices = this->normalIndex.getValues(0);
-    if (this->normalIndex.getNum() <= 0 || nindices[0] < 0) nindices = NULL;
+    if (this->normalIndex.getNum() <= 0 || nindices[0] < 0) nindices = nullptr;
     
-    if (normals == NULL) {
+    if (normals == nullptr) {
       SoNormalCache * nc = this->generateAndReadLockNormalCache(state);
       normals = nc->getNormals();
       nindices = nc->getIndices();
       normalcacheused = true;
       // if no normals were generated, unlock normal cache before
       // returning
-      if (normals == NULL) {
+      if (normals == nullptr) {
         this->readUnlockNormalCache();
         normalcacheused = false;
       }
@@ -160,7 +160,7 @@ SoVRMLIndexedShape::computeBBox(SoAction * COIN_UNUSED_ARG(action), SbBox3f & bo
                                 SbVec3f & center)
 {
   SoVRMLCoordinate * node = (SoVRMLCoordinate*) this->coord.getValue();
-  if (node == NULL) return;
+  if (node == nullptr) return;
 
   int numCoords = node->point.getNum();
   const SbVec3f * coords = node->point.getValues(0);
diff --git a/coin4/src/vrml97/Inline.cpp b/coin4/src/vrml97/Inline.cpp
index 0082463..e7752ae 100644
--- a/coin4/src/vrml97/Inline.cpp
+++ b/coin4/src/vrml97/Inline.cpp
@@ -150,19 +150,19 @@ public:
 
 static SoVRMLInline::BboxVisibility
 sovrmlinline_bboxvisibility = SoVRMLInline::UNTIL_LOADED;
-static SoVRMLInlineFetchURLCB * sovrmlinline_fetchurlcb = NULL;
+static SoVRMLInlineFetchURLCB * sovrmlinline_fetchurlcb = nullptr;
 static void * sovrmlinline_fetchurlcbclosure;
 
-static SbColor * sovrmlinline_bboxcolor = NULL;
+static SbColor * sovrmlinline_bboxcolor = nullptr;
 static bool sovrmlinline_readassofile = true;
 
 static void
 sovrmlinline_cleanup(void)
 {
   delete sovrmlinline_bboxcolor;
-  sovrmlinline_bboxcolor = NULL;
+  sovrmlinline_bboxcolor = nullptr;
   sovrmlinline_bboxvisibility = SoVRMLInline::UNTIL_LOADED;
-  sovrmlinline_fetchurlcb = NULL;  
+  sovrmlinline_fetchurlcb = nullptr;  
   sovrmlinline_readassofile = true;
 }
 
@@ -235,7 +235,7 @@ SoVRMLInline::getFullURLName(void)
 SoGroup *
 SoVRMLInline::copyChildren(void) const
 {
-  if (PRIVATE(this)->children->getLength() == 0) return NULL;
+  if (PRIVATE(this)->children->getLength() == 0) return nullptr;
   assert(PRIVATE(this)->children->getLength() == 1);
   SoNode * rootcopy = (*(PRIVATE(this)->children))[0]->copy();
   assert(rootcopy->isOfType(SoGroup::getClassTypeId()));
@@ -278,7 +278,7 @@ SoVRMLInline::isURLDataRequested(void) const
 bool
 SoVRMLInline::isURLDataHere(void) const
 {
-  return this->getChildData() != NULL;
+  return this->getChildData() != nullptr;
 }
 
 /*!
@@ -312,7 +312,7 @@ SoVRMLInline::getChildData(void) const
   if (PRIVATE(this)->children->getLength()) {
     return (*PRIVATE(this)->children)[0];
   }
-  return NULL;
+  return nullptr;
 }
 
 /*!
@@ -410,7 +410,7 @@ SoVRMLInline::GLRender(SoGLRenderAction * action)
   SoNode * child = this->getChildData();
   if ((size[0] >= 0.0f && size[1] >= 0.0f && size[1] >= 0.0f) &&
       ((vis == ALWAYS) || 
-       (vis == UNTIL_LOADED && child == NULL))) {
+       (vis == UNTIL_LOADED && child == nullptr))) {
     SoState * state = action->getState();
     state->push();
 
diff --git a/coin4/src/vrml97/JS_VRMLClasses.cpp b/coin4/src/vrml97/JS_VRMLClasses.cpp
index ea7d3d8..4cbd84d 100644
--- a/coin4/src/vrml97/JS_VRMLClasses.cpp
+++ b/coin4/src/vrml97/JS_VRMLClasses.cpp
@@ -102,9 +102,9 @@ struct CoinVrmlJs_SensorInfo {
   SbList <JSObject *> objects;
 };
 #if defined(_WIN64)
-SbHash <unsigned long long, void *> * CoinVrmlJs_sensorinfohash = NULL;
+SbHash <unsigned long long, void *> * CoinVrmlJs_sensorinfohash = nullptr;
 #else
-SbHash <unsigned long, void *> * CoinVrmlJs_sensorinfohash = NULL;
+SbHash <unsigned long, void *> * CoinVrmlJs_sensorinfohash = nullptr;
 #endif
 
 const char * CoinVrmlJs_SFColorAliases[] = {"r", "g", "b"};
@@ -114,11 +114,11 @@ double CoinVrmlJs_SFdefaultValuesDouble[] = {0.0, 0.0, 0.0, 0.0};
 float CoinVrmlJs_SFRotationDefaultValues[] = {0.0, 1.0, 0.0, 0.0};
 
 // Macros for instance checking
-#define JSVAL_IS_SFVEC2F(cx, jsval) (JSVAL_IS_OBJECT(jsval) && spidermonkey()->JS_InstanceOf(cx, JSVAL_TO_OBJECT(jsval), &CoinVrmlJs::SFVec2f.cls, NULL))
-#define JSVAL_IS_SFVEC3F(cx, jsval) (JSVAL_IS_OBJECT(jsval) && spidermonkey()->JS_InstanceOf(cx, JSVAL_TO_OBJECT(jsval), &CoinVrmlJs::SFVec3f.cls, NULL))
-#define JSVAL_IS_SFVEC3D(cx, jsval) (JSVAL_IS_OBJECT(jsval) && spidermonkey()->JS_InstanceOf(cx, JSVAL_TO_OBJECT(jsval), &CoinVrmlJs::SFVec3d.cls, NULL))
-#define JSVAL_IS_SFCOLOR(cx, jsval) (JSVAL_IS_OBJECT(jsval) && spidermonkey()->JS_InstanceOf(cx, JSVAL_TO_OBJECT(jsval), &CoinVrmlJs::SFColor.cls, NULL))
-#define JSVAL_IS_SFROTATION(cx, jsval) (JSVAL_IS_OBJECT(jsval) && spidermonkey()->JS_InstanceOf(cx, JSVAL_TO_OBJECT(jsval), &CoinVrmlJs::SFRotation.cls, NULL))
+#define JSVAL_IS_SFVEC2F(cx, jsval) (JSVAL_IS_OBJECT(jsval) && spidermonkey()->JS_InstanceOf(cx, JSVAL_TO_OBJECT(jsval), &CoinVrmlJs::SFVec2f.cls, nullptr))
+#define JSVAL_IS_SFVEC3F(cx, jsval) (JSVAL_IS_OBJECT(jsval) && spidermonkey()->JS_InstanceOf(cx, JSVAL_TO_OBJECT(jsval), &CoinVrmlJs::SFVec3f.cls, nullptr))
+#define JSVAL_IS_SFVEC3D(cx, jsval) (JSVAL_IS_OBJECT(jsval) && spidermonkey()->JS_InstanceOf(cx, JSVAL_TO_OBJECT(jsval), &CoinVrmlJs::SFVec3d.cls, nullptr))
+#define JSVAL_IS_SFCOLOR(cx, jsval) (JSVAL_IS_OBJECT(jsval) && spidermonkey()->JS_InstanceOf(cx, JSVAL_TO_OBJECT(jsval), &CoinVrmlJs::SFColor.cls, nullptr))
+#define JSVAL_IS_SFROTATION(cx, jsval) (JSVAL_IS_OBJECT(jsval) && spidermonkey()->JS_InstanceOf(cx, JSVAL_TO_OBJECT(jsval), &CoinVrmlJs::SFRotation.cls, nullptr))
 
 // Handlers
 #define SFColorHandler CoinVrmlJsSFHandler<SbColor, 3, CoinVrmlJs_SFColorAliases, float, CoinVrmlJs_SFdefaultValues>
@@ -140,7 +140,7 @@ float CoinVrmlJs_SFRotationDefaultValues[] = {0.0, 1.0, 0.0, 0.0};
 
 static JSFunctionSpec MFFunctions[] = {
 //  {"toString", MF_toString, 0, 0, 0},
-  {NULL, NULL, 0, 0, 0}
+  {nullptr, nullptr, 0, 0, 0}
 };
 
 static JSBool SFRotationConstructor(JSContext * cx, JSObject * obj,
@@ -154,8 +154,8 @@ static JSObject * SFVec2fFactory(JSContext * cx, const SbVec2f & self);
 static JSObject * SFVec3fFactory(JSContext * cx, const SbVec3f & self);
 static JSObject * SFVec3dFactory(JSContext * cx, const SbVec3d & self);
 
-static SbList <JSObject *> * garbagecollectedobjects = NULL;
-static SbList <SoNodeSensor *> * nodesensorstobedeleted = NULL;
+static SbList <JSObject *> * garbagecollectedobjects = nullptr;
+static SbList <SoNodeSensor *> * nodesensorstobedeleted = nullptr;
 
 // getIndex returns -1 if id is not an alias or in range 0-max
 static JSBool getIndex(JSContext * cx, jsval id, const char * aliases[], int max)
@@ -220,7 +220,7 @@ struct CoinVrmlJsSFHandler {
     }
 
     Base * data = (Base *)spidermonkey()->JS_GetPrivate(cx, obj);
-    assert(data != NULL);
+    assert(data != nullptr);
     basetype var = (*data)[index];
     bool ok = spidermonkey()->JS_NewDoubleValue(cx, (double)var, rval);
     assert(ok && "JS_NewDoubleValue failed");
@@ -235,7 +235,7 @@ struct CoinVrmlJsSFHandler {
     }
 
     Base * data = (Base *)spidermonkey()->JS_GetPrivate(cx, obj);
-    assert(data != NULL);
+    assert(data != nullptr);
 
     // FIXME: number may be NaN, PositiveInfinity and NegativeInfinity.
     // Should be checked for every time we run JS_ValueToNumber.
@@ -277,7 +277,7 @@ struct CoinVrmlJsSFHandler {
     Base * data = (Base *)spidermonkey()->JS_GetPrivate(cx, obj);
     // FIXME: We cannot assume this since the class object itself is an
     // instance of this JSClass. kintel 20050804.
-    //    assert(data != NULL);
+    //    assert(data != nullptr);
     delete data;
   }
 };
@@ -287,7 +287,7 @@ struct CoinVrmlJsMFHandler {
   static JSBool constructor(JSContext * cx, JSObject * obj, uintN argc, jsval * argv, jsval * COIN_UNUSED_ARG(rval))
   {
     jsval * val = new jsval;
-    JSObject * array = spidermonkey()->JS_NewArrayObject(cx, 0, NULL);
+    JSObject * array = spidermonkey()->JS_NewArrayObject(cx, 0, nullptr);
     *val = OBJECT_TO_JSVAL(array);
     bool ok = spidermonkey()->JS_AddRoot(cx, val);
     assert(ok && "JS_AddRoot failed");
@@ -313,7 +313,7 @@ struct CoinVrmlJsMFHandler {
   static void destructor(JSContext * cx, JSObject * obj)
   {
     jsval * val = (jsval *)spidermonkey()->JS_GetPrivate(cx, obj);
-    if (val != NULL) {
+    if (val != nullptr) {
       bool ok = spidermonkey()->JS_RemoveRoot(cx, val);
       assert(ok && "JS_RemoveRoot failed");
       delete val;
@@ -322,9 +322,9 @@ struct CoinVrmlJsMFHandler {
 
   static JSObject * init(JSContext * cx, JSObject * obj)
   {
-    return spidermonkey()->JS_InitClass(cx, obj, NULL, &desc->cls,
+    return spidermonkey()->JS_InitClass(cx, obj, nullptr, &desc->cls,
                                         constructor, 0,
-                                        NULL, MFFunctions, NULL, NULL);
+                                        nullptr, MFFunctions, nullptr, nullptr);
   }
 
   static void resize(JSContext * cx, JSObject * array, uint32_t newLength)
@@ -352,42 +352,42 @@ struct CoinVrmlJsMFHandler {
           val = STRING_TO_JSVAL(str);
         }
         else if (type == SoMFNode::getClassTypeId()) {
-          // All elements not explicitly initialized are set to NULL
+          // All elements not explicitly initialized are set to nullptr
           val = JSVAL_VOID;
         }
         else if (type == SoMFColor::getClassTypeId()) {
           JSObject * newObj =
-            spidermonkey()->JS_NewObject(cx, &CoinVrmlJs::SFColor.cls, NULL, NULL);
-          assert(newObj != NULL);
-          SFColorHandler::constructor(cx, newObj, 0, NULL, &val);
+            spidermonkey()->JS_NewObject(cx, &CoinVrmlJs::SFColor.cls, nullptr, nullptr);
+          assert(newObj != nullptr);
+          SFColorHandler::constructor(cx, newObj, 0, nullptr, &val);
           val = OBJECT_TO_JSVAL(newObj);
         }
         else if (type == SoMFRotation::getClassTypeId()) {
           JSObject * newObj =
-            spidermonkey()->JS_NewObject(cx, &CoinVrmlJs::SFRotation.cls, NULL, NULL);
-          assert(newObj != NULL);
-          SFRotationConstructor(cx, newObj, 0, NULL, &val);
+            spidermonkey()->JS_NewObject(cx, &CoinVrmlJs::SFRotation.cls, nullptr, nullptr);
+          assert(newObj != nullptr);
+          SFRotationConstructor(cx, newObj, 0, nullptr, &val);
           val = OBJECT_TO_JSVAL(newObj);
         }
         else if (type == SoMFVec2f::getClassTypeId()) {
           JSObject * newObj =
-            spidermonkey()->JS_NewObject(cx, &CoinVrmlJs::SFVec2f.cls, NULL, NULL);
-          assert(newObj != NULL);
-          SFVec2fHandler::constructor(cx, newObj, 0, NULL, &val);
+            spidermonkey()->JS_NewObject(cx, &CoinVrmlJs::SFVec2f.cls, nullptr, nullptr);
+          assert(newObj != nullptr);
+          SFVec2fHandler::constructor(cx, newObj, 0, nullptr, &val);
           val = OBJECT_TO_JSVAL(newObj);
         }
         else if (type == SoMFVec3f::getClassTypeId()) {
           JSObject * newObj =
-            spidermonkey()->JS_NewObject(cx, &CoinVrmlJs::SFVec3f.cls, NULL, NULL);
-          assert(newObj != NULL);
-          SFVec3fHandler::constructor(cx, newObj, 0, NULL, &val);
+            spidermonkey()->JS_NewObject(cx, &CoinVrmlJs::SFVec3f.cls, nullptr, nullptr);
+          assert(newObj != nullptr);
+          SFVec3fHandler::constructor(cx, newObj, 0, nullptr, &val);
           val = OBJECT_TO_JSVAL(newObj);
         }
         else if (type == SoMFVec3d::getClassTypeId()) {
           JSObject * newObj =
-            spidermonkey()->JS_NewObject(cx, &CoinVrmlJs::SFVec3d.cls, NULL, NULL);
-          assert(newObj != NULL);
-          SFVec3dHandler::constructor(cx, newObj, 0, NULL, &val);
+            spidermonkey()->JS_NewObject(cx, &CoinVrmlJs::SFVec3d.cls, nullptr, nullptr);
+          assert(newObj != nullptr);
+          SFVec3dHandler::constructor(cx, newObj, 0, nullptr, &val);
           val = OBJECT_TO_JSVAL(newObj);
         }
         else {
@@ -405,14 +405,14 @@ struct CoinVrmlJsMFHandler {
     jsval * array = (jsval *)spidermonkey()->JS_GetPrivate(cx, obj);
 
     if (JSVAL_IS_INT(id)) {
-      assert(array != NULL);
+      assert(array != nullptr);
       int index = JSVAL_TO_INT(id);
       return spidermonkey()->JS_GetElement(cx, JSVAL_TO_OBJECT(*array), index, rval);
     }
     else if (JSVAL_IS_STRING(id)) {
       const char * str = spidermonkey()->JS_GetStringBytes(JSVAL_TO_STRING(id));
       if (SbName("length") == str) {
-        assert(array != NULL);
+        assert(array != nullptr);
         uint32_t length;
         bool ok = spidermonkey()->JS_GetArrayLength(cx, JSVAL_TO_OBJECT(*array), &length);
         assert(ok && "JS_GetArrayLength failed");
@@ -476,10 +476,10 @@ struct CoinVrmlJsMFHandler {
   static bool jsval2field(JSContext * cx, const jsval v, SoField * f)
   {
     if (JSVAL_IS_OBJECT(v) &&
-        spidermonkey()->JS_InstanceOf(cx, JSVAL_TO_OBJECT(v), &desc->cls, NULL)) {
+        spidermonkey()->JS_InstanceOf(cx, JSVAL_TO_OBJECT(v), &desc->cls, nullptr)) {
       JSObject * obj = JSVAL_TO_OBJECT(v);
       jsval * array = (jsval *)spidermonkey()->JS_GetPrivate(cx, obj);
-      assert(array != NULL);
+      assert(array != nullptr);
 
       jsval element;
       uint32_t i;
@@ -504,7 +504,7 @@ struct CoinVrmlJsMFHandler {
 
   static void field2jsval(JSContext * cx, const SoField * f, jsval * v)
   {
-    JSObject * obj = spidermonkey()->JS_NewObject(cx, &desc->cls, NULL, NULL);
+    JSObject * obj = spidermonkey()->JS_NewObject(cx, &desc->cls, nullptr, nullptr);
     spidermonkey()->JS_DefineFunctions(cx, obj, desc->functions);
 
     int num = ((SoMField *)f)->getNum();
@@ -1140,7 +1140,7 @@ static JSFunctionSpec SFNodeFunctions[] = {
   {"ref", SFNode_ref, 0, 0, 0},
   {"unref", SFNode_unref, 0, 0, 0},
   {"toString", SFNode_toString, 0, 0, 0},
-  {NULL, NULL, 0, 0, 0}
+  {nullptr, nullptr, 0, 0, 0}
 };
 
 static JSFunctionSpec SFVec2fFunctions[] = {
@@ -1151,7 +1151,7 @@ static JSFunctionSpec SFVec2fFunctions[] = {
   {"multiply", SFVec2f_multiply, 1, 0, 0},
   {"normalize", SFVec2f_normalize, 0, 0, 0},
   {"subtract", SFVec2f_subtract, 1, 0, 0},
-  {NULL, NULL, 0, 0, 0}
+  {nullptr, nullptr, 0, 0, 0}
 };
 
 static JSFunctionSpec SFVec3fFunctions[] = {
@@ -1163,7 +1163,7 @@ static JSFunctionSpec SFVec3fFunctions[] = {
   {"normalize", SFVec3f_normalize, 0, 0, 0},
   {"negate", SFVec3f_negate, 0, 0, 0},
   {"subtract", SFVec3f_subtract, 1, 0, 0},
-  {NULL, NULL, 0, 0, 0}
+  {nullptr, nullptr, 0, 0, 0}
 };
 
 static JSFunctionSpec SFVec3dFunctions[] = {
@@ -1175,13 +1175,13 @@ static JSFunctionSpec SFVec3dFunctions[] = {
   {"normalize", SFVec3d_normalize, 0, 0, 0},
   {"negate", SFVec3d_negate, 0, 0, 0},
   {"subtract", SFVec3d_subtract, 1, 0, 0},
-  {NULL, NULL, 0, 0, 0}
+  {nullptr, nullptr, 0, 0, 0}
 };
 
 static JSFunctionSpec SFColorFunctions[] = {
   {"setHSV", SFColor_setHSV, 3, 0, 0},
   {"getHSV", SFColor_getHSV, 0, 0, 0},
-  {NULL, NULL, 0, 0, 0}
+  {nullptr, nullptr, 0, 0, 0}
 };
 
 static JSFunctionSpec SFRotationFunctions[] = {
@@ -1191,7 +1191,7 @@ static JSFunctionSpec SFRotationFunctions[] = {
   {"multVec", SFRotation_multVec, 1, 0, 0},
   {"setAxis", SFRotation_setAxis, 1, 0, 0},
   {"slerp", SFRotation_slerp, 2, 0, 0},
-  {NULL, NULL, 0, 0, 0}
+  {nullptr, nullptr, 0, 0, 0}
 };
 
 // *************************************************************************
@@ -1200,7 +1200,7 @@ static JSFunctionSpec SFRotationFunctions[] = {
 static JSObject * SFColorFactory(JSContext * cx, const SbColor & self)
 {
   JSObject * obj =
-    spidermonkey()->JS_NewObject(cx, &CoinVrmlJs::SFColor.cls, NULL, NULL);
+    spidermonkey()->JS_NewObject(cx, &CoinVrmlJs::SFColor.cls, nullptr, nullptr);
   spidermonkey()->JS_DefineFunctions(cx, obj, SFColorFunctions);
 
   SbColor * color = new SbColor(self);
@@ -1212,7 +1212,7 @@ static JSObject * SFColorFactory(JSContext * cx, const SbColor & self)
 static JSObject * SFRotationFactory(JSContext * cx, const SbRotation & self)
 {
   JSObject * obj =
-    spidermonkey()->JS_NewObject(cx, &CoinVrmlJs::SFRotation.cls, NULL, NULL);
+    spidermonkey()->JS_NewObject(cx, &CoinVrmlJs::SFRotation.cls, nullptr, nullptr);
   spidermonkey()->JS_DefineFunctions(cx, obj, SFRotationFunctions);
 
   SbVec3f axis;
@@ -1227,7 +1227,7 @@ static JSObject * SFRotationFactory(JSContext * cx, const SbRotation & self)
 static JSObject * SFVec2fFactory(JSContext * cx, const SbVec2f & self)
 {
   JSObject * obj =
-    spidermonkey()->JS_NewObject(cx, &CoinVrmlJs::SFVec2f.cls, NULL, NULL);
+    spidermonkey()->JS_NewObject(cx, &CoinVrmlJs::SFVec2f.cls, nullptr, nullptr);
   spidermonkey()->JS_DefineFunctions(cx, obj, SFVec2fFunctions);
 
   SbVec2f * data = new SbVec2f(self);
@@ -1238,7 +1238,7 @@ static JSObject * SFVec2fFactory(JSContext * cx, const SbVec2f & self)
 static JSObject * SFVec3fFactory(JSContext * cx, const SbVec3f & self)
 {
   JSObject * obj =
-    spidermonkey()->JS_NewObject(cx, &CoinVrmlJs::SFVec3f.cls, NULL, NULL);
+    spidermonkey()->JS_NewObject(cx, &CoinVrmlJs::SFVec3f.cls, nullptr, nullptr);
   spidermonkey()->JS_DefineFunctions(cx, obj, SFVec3fFunctions);
 
   SbVec3f * data = new SbVec3f(self);
@@ -1250,7 +1250,7 @@ static JSObject * SFVec3fFactory(JSContext * cx, const SbVec3f & self)
 static JSObject * SFVec3dFactory(JSContext * cx, const SbVec3d & self)
 {
   JSObject * obj =
-    spidermonkey()->JS_NewObject(cx, &CoinVrmlJs::SFVec3d.cls, NULL, NULL);
+    spidermonkey()->JS_NewObject(cx, &CoinVrmlJs::SFVec3d.cls, nullptr, nullptr);
   spidermonkey()->JS_DefineFunctions(cx, obj, SFVec3dFunctions);
 
   SbVec3d * data = new SbVec3d(self);
@@ -1261,37 +1261,37 @@ static JSObject * SFVec3dFactory(JSContext * cx, const SbVec3d & self)
 
 static JSObject * SFVec2f_init(JSContext * cx, JSObject * obj)
 {
-  return spidermonkey()->JS_InitClass(cx, obj, NULL, &CoinVrmlJs::SFVec2f.cls,
+  return spidermonkey()->JS_InitClass(cx, obj, nullptr, &CoinVrmlJs::SFVec2f.cls,
                                       SFVec2fHandler::constructor, 0,
-                                      NULL, SFVec2fFunctions, NULL, NULL);
+                                      nullptr, SFVec2fFunctions, nullptr, nullptr);
 }
 
 static JSObject * SFVec3f_init(JSContext * cx, JSObject * obj)
 {
-  return spidermonkey()->JS_InitClass(cx, obj, NULL, &CoinVrmlJs::SFVec3f.cls,
+  return spidermonkey()->JS_InitClass(cx, obj, nullptr, &CoinVrmlJs::SFVec3f.cls,
                                       SFVec3fHandler::constructor, 0,
-                                      NULL, SFVec3fFunctions, NULL, NULL);
+                                      nullptr, SFVec3fFunctions, nullptr, nullptr);
 }
 
 static JSObject * SFVec3d_init(JSContext * cx, JSObject * obj)
 {
-  return spidermonkey()->JS_InitClass(cx, obj, NULL, &CoinVrmlJs::SFVec3d.cls,
+  return spidermonkey()->JS_InitClass(cx, obj, nullptr, &CoinVrmlJs::SFVec3d.cls,
                                       SFVec3dHandler::constructor, 0,
-                                      NULL, SFVec3dFunctions, NULL, NULL);
+                                      nullptr, SFVec3dFunctions, nullptr, nullptr);
 }
 
 static JSObject * SFColor_init(JSContext * cx, JSObject * obj)
 {
-  return spidermonkey()->JS_InitClass(cx, obj, NULL, &CoinVrmlJs::SFColor.cls,
+  return spidermonkey()->JS_InitClass(cx, obj, nullptr, &CoinVrmlJs::SFColor.cls,
                                       SFColorHandler::constructor, 0,
-                                      NULL, SFColorFunctions, NULL, NULL);
+                                      nullptr, SFColorFunctions, nullptr, nullptr);
 }
 
 static JSObject * SFRotation_init(JSContext * cx, JSObject * obj)
 {
-  return spidermonkey()->JS_InitClass(cx, obj, NULL, &CoinVrmlJs::SFRotation.cls,
+  return spidermonkey()->JS_InitClass(cx, obj, nullptr, &CoinVrmlJs::SFRotation.cls,
                                       SFRotationConstructor, 0,
-                                      NULL, SFRotationFunctions, NULL, NULL);
+                                      nullptr, SFRotationFunctions, nullptr, nullptr);
 }
 
 // *************************************************************************
@@ -1307,7 +1307,7 @@ static JSBool SFNode_get(JSContext * cx, JSObject * obj, jsval id, jsval * rval)
 
   SoNode * container = (SoNode *)spidermonkey()->JS_GetPrivate(cx, obj);
 
-  if (container == NULL) {
+  if (container == nullptr) {
     // this will only happen when JS_NewObject calls "constructor"
     // or the node is "undefined"
 
@@ -1330,12 +1330,12 @@ static JSBool SFNode_get(JSContext * cx, JSObject * obj, jsval id, jsval * rval)
     static const char post[] = "_changed";
     static const size_t postLen = sizeof(post) - 1;
 
-    if (out == NULL && len > (int)postLen &&
+    if (out == nullptr && len > (int)postLen &&
         str.getSubString(len - postLen) == post) {
       out = container->getField(SbName(str.getSubString(0, len - postLen - 1)));
     }
 
-    if (out != NULL) {
+    if (out != nullptr) {
       SoJavaScriptEngine::getEngine(cx)->field2jsval(out, rval);
       return JS_TRUE;
     }
@@ -1367,7 +1367,7 @@ static JSBool SFNode_set(JSContext * cx, JSObject * obj, jsval id, jsval * rval)
 {
   SoNode * container = (SoNode *)spidermonkey()->JS_GetPrivate(cx, obj);
 
-  if (container == NULL) {
+  if (container == nullptr) {
     spidermonkey()->JS_ReportError(cx, "node is undefined");
     return JS_FALSE;
   }
@@ -1381,12 +1381,12 @@ static JSBool SFNode_set(JSContext * cx, JSObject * obj, jsval id, jsval * rval)
     static const char pre[] = "set_";
     static const size_t preLen = sizeof(pre) - 1;
 
-    if (in == NULL && len > (int)preLen &&
+    if (in == nullptr && len > (int)preLen &&
         str.getSubString(0, preLen - 1) == pre) {
       in = container->getField(SbName(str.getSubString(preLen)));
     }
 
-    if (in != NULL) {
+    if (in != nullptr) {
       SoJavaScriptEngine::getEngine(cx)->jsval2field(*rval, in);
       if (SoJavaScriptEngine::debug()) {
         SoDebugError::postInfo("SFNode_set", "setting field %s", str.getString());
@@ -1410,7 +1410,7 @@ static void SFNodeDestructor(JSContext * cx, JSObject * obj)
   SoNode * container = (SoNode *)spidermonkey()->JS_GetPrivate(cx, obj);
   // FIXME: We cannot assume this since the class object itself is an
   // instance of this JSClass. kintel 20050804.
-  //  assert(container != NULL);
+  //  assert(container != nullptr);
   if (SoJavaScriptEngine::getEngine(cx)->getAutoNodeUnrefState())
     if (container) container->unref();
 }
@@ -1466,7 +1466,7 @@ static JSObject * SFNodeFactory(JSContext * cx, SoNode * container)
   // Delete all SoNodeSensors which no longer has a node attached.
   cleanupObsoleteNodeSensors();
 
-  JSObject * obj = spidermonkey()->JS_NewObject(cx, &CoinVrmlJs::SFNode.cls, NULL, NULL);
+  JSObject * obj = spidermonkey()->JS_NewObject(cx, &CoinVrmlJs::SFNode.cls, nullptr, nullptr);
 
   if(garbagecollectedobjects->find(obj) != -1) // Pointer has been used before. Remove from list.
     garbagecollectedobjects->removeItem(obj);
@@ -1506,7 +1506,7 @@ static JSBool SFNodeConstructor(JSContext * cx, JSObject * obj,
     SoInput input;
     const char * array[2];
     array[0] = str;
-    array[1] = NULL;
+    array[1] = nullptr;
     input.setStringArray(array);
 
     SoGroup * group;
@@ -1516,7 +1516,7 @@ static JSBool SFNodeConstructor(JSContext * cx, JSObject * obj,
     else
       group = SoDB::readAll(&input);
 
-    if (group == NULL) {
+    if (group == nullptr) {
       spidermonkey()->JS_ReportError(cx, "input is not legal VRML string");
       return JS_FALSE;
     }
@@ -1545,9 +1545,9 @@ static JSBool SFNodeConstructor(JSContext * cx, JSObject * obj,
 
 static JSObject * SFNode_init(JSContext * cx, JSObject * obj)
 {
-  return spidermonkey()->JS_InitClass(cx, obj, NULL, &CoinVrmlJs::SFNode.cls,
+  return spidermonkey()->JS_InitClass(cx, obj, nullptr, &CoinVrmlJs::SFNode.cls,
                                       SFNodeConstructor, 0,
-                                      NULL, NULL, NULL, NULL);
+                                      nullptr, nullptr, nullptr, nullptr);
 }
 
 
@@ -1575,7 +1575,7 @@ static bool SFColor_jsval2field(JSContext * cx, const jsval v, SoField * f)
 {
   if (JSVAL_IS_SFCOLOR(cx, v)) {
     SbColor * color = (SbColor *)spidermonkey()->JS_GetPrivate(cx, JSVAL_TO_OBJECT(v));
-    assert(color != NULL);
+    assert(color != nullptr);
     ((SoSFColor *)f)->setValue(*color);
     return true;
   }
@@ -1615,11 +1615,11 @@ static bool SFEnum_jsval2field(JSContext * cx, const jsval v, SoField * f)
 static bool SFNode_jsval2field(JSContext * cx, const jsval v, SoField * f)
 {
   if (JSVAL_IS_NULL(v)) {
-    ((SoSFNode *)f)->setValue(NULL);
+    ((SoSFNode *)f)->setValue(nullptr);
     return true;
   }
   if (JSVAL_IS_OBJECT(v) &&
-      spidermonkey()->JS_InstanceOf(cx, JSVAL_TO_OBJECT(v), &CoinVrmlJs::SFNode.cls, NULL)) {
+      spidermonkey()->JS_InstanceOf(cx, JSVAL_TO_OBJECT(v), &CoinVrmlJs::SFNode.cls, nullptr)) {
     SoNode * node = (SoNode *)spidermonkey()->JS_GetPrivate(cx, JSVAL_TO_OBJECT(v));
     ((SoSFNode *)f)->setValue(node);
     return true;
@@ -1631,7 +1631,7 @@ static bool SFRotation_jsval2field(JSContext * cx, const jsval v, SoField * f)
 {
   if (JSVAL_IS_SFROTATION(cx, v)) {
     SbVec4f * rot = (SbVec4f *)spidermonkey()->JS_GetPrivate(cx, JSVAL_TO_OBJECT(v));
-    assert(rot != NULL);
+    assert(rot != nullptr);
     SbVec3f axis((*rot)[0], (*rot)[1], (*rot)[2]);
     ((SoSFRotation *)f)->setValue(SbRotation(axis, (*rot)[3]));
     return true;
@@ -1664,7 +1664,7 @@ static bool SFVec2f_jsval2field(JSContext * cx, const jsval v, SoField * f)
 {
   if (JSVAL_IS_SFVEC2F(cx, v)) {
     SbVec2f * vec = (SbVec2f *)spidermonkey()->JS_GetPrivate(cx, JSVAL_TO_OBJECT(v));
-    assert(vec != NULL);
+    assert(vec != nullptr);
     ((SoSFVec2f *)f)->setValue(*vec);
     return true;
   }
@@ -1675,7 +1675,7 @@ static bool SFVec3f_jsval2field(JSContext * cx, const jsval v, SoField * f)
 {
   if (JSVAL_IS_SFVEC3F(cx, v)) {
     SbVec3f * vec = (SbVec3f *)spidermonkey()->JS_GetPrivate(cx, JSVAL_TO_OBJECT(v));
-    assert(vec != NULL);
+    assert(vec != nullptr);
     ((SoSFVec3f *)f)->setValue(*vec);
     return true;
   }
@@ -1686,7 +1686,7 @@ static bool SFVec3d_jsval2field(JSContext * cx, const jsval v, SoField * f)
 {
   if (JSVAL_IS_SFVEC3D(cx, v)) {
     SbVec3d * vec = (SbVec3d *)spidermonkey()->JS_GetPrivate(cx, JSVAL_TO_OBJECT(v));
-    assert(vec != NULL);
+    assert(vec != nullptr);
     ((SoSFVec3d *)f)->setValue(*vec);
     return true;
   }
@@ -1730,7 +1730,7 @@ static void SFEnum_field2jsval(JSContext * COIN_UNUSED_ARG(cx), const SoField *
 static void SFNode_field2jsval(JSContext * cx, const SoField * f, jsval * v)
 {
   SoNode * node = ((SoSFNode *)f)->getValue();
-  if (node == NULL)
+  if (node == nullptr)
     *v = JSVAL_NULL;
   else {
     JSObject * obj = SFNodeFactory(cx, node);
@@ -1784,177 +1784,177 @@ static void SFVec3d_field2jsval(JSContext * cx, const SoField * f, jsval *v)
 
 CoinVrmlJs::ClassDescriptor CoinVrmlJs::SFColor = {
   {
-    "SFColor", JSCLASS_HAS_PRIVATE, NULL, NULL,
+    "SFColor", JSCLASS_HAS_PRIVATE, nullptr, nullptr,
     SFColorHandler::get, SFColorHandler::set,
-    NULL, NULL, NULL,
+    nullptr, nullptr, nullptr,
     SFColorHandler::destructor,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0
+    nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, 0
   },
   SFColorFunctions
 };
 
 CoinVrmlJs::ClassDescriptor CoinVrmlJs::SFNode = {
   {
-    "SFNode", JSCLASS_HAS_PRIVATE, NULL, NULL,
+    "SFNode", JSCLASS_HAS_PRIVATE, nullptr, nullptr,
     SFNode_get, SFNode_set,
-    NULL, NULL, NULL,
+    nullptr, nullptr, nullptr,
     SFNodeDestructor,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0
+    nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, 0
   },
-  NULL
+  nullptr
 };
 
 
 CoinVrmlJs::ClassDescriptor CoinVrmlJs::SFRotation = {
   {
-    "SFRotation", JSCLASS_HAS_PRIVATE, NULL, NULL,
+    "SFRotation", JSCLASS_HAS_PRIVATE, nullptr, nullptr,
     SFRotationHandler::get, SFRotationHandler::set,
-    NULL, NULL, NULL,
+    nullptr, nullptr, nullptr,
     SFRotationHandler::destructor,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0
+    nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, 0
   },
   SFRotationFunctions
 };
 
 CoinVrmlJs::ClassDescriptor CoinVrmlJs::SFVec2f = {
   {
-    "SFVec2f", JSCLASS_HAS_PRIVATE, NULL, NULL,
+    "SFVec2f", JSCLASS_HAS_PRIVATE, nullptr, nullptr,
     SFVec2fHandler::get, SFVec2fHandler::set,
-    NULL, NULL, NULL,
+    nullptr, nullptr, nullptr,
     SFVec2fHandler::destructor,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0
+    nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, 0
   },
   SFVec2fFunctions
 };
 
 CoinVrmlJs::ClassDescriptor CoinVrmlJs::SFVec3f = {
   {
-    "SFVec3f", JSCLASS_HAS_PRIVATE, NULL, NULL,
+    "SFVec3f", JSCLASS_HAS_PRIVATE, nullptr, nullptr,
     SFVec3fHandler::get, SFVec3fHandler::set,
-    NULL, NULL, NULL,
+    nullptr, nullptr, nullptr,
     SFVec3fHandler::destructor,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0
+    nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, 0
   },
   SFVec3fFunctions
 };
 
 CoinVrmlJs::ClassDescriptor CoinVrmlJs::SFVec3d = {
   {
-    "SFVec3d", JSCLASS_HAS_PRIVATE, NULL, NULL,
+    "SFVec3d", JSCLASS_HAS_PRIVATE, nullptr, nullptr,
     SFVec3dHandler::get, SFVec3dHandler::set,
-    NULL, NULL, NULL,
+    nullptr, nullptr, nullptr,
     SFVec3dHandler::destructor,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0
+    nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, 0
   },
   SFVec3dFunctions
 };
 
 CoinVrmlJs::ClassDescriptor CoinVrmlJs::MFColor = {
   {
-    "MFColor", JSCLASS_HAS_PRIVATE, NULL, NULL,
+    "MFColor", JSCLASS_HAS_PRIVATE, nullptr, nullptr,
     MFColorHandler::get, MFColorHandler::set,
-    NULL, NULL, NULL,
+    nullptr, nullptr, nullptr,
     MFColorHandler::destructor,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0
+    nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, 0
   },
   MFFunctions,
 };
 
 CoinVrmlJs::ClassDescriptor CoinVrmlJs::MFFloat = {
   {
-    "MFFloat", JSCLASS_HAS_PRIVATE, NULL, NULL,
+    "MFFloat", JSCLASS_HAS_PRIVATE, nullptr, nullptr,
     MFFloatHandler::get, MFFloatHandler::set,
-    NULL, NULL, NULL,
+    nullptr, nullptr, nullptr,
     MFFloatHandler::destructor,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0
+    nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, 0
   },
   MFFunctions,
 };
 
 CoinVrmlJs::ClassDescriptor CoinVrmlJs::MFInt32 = {
   {
-    "MFInt32", JSCLASS_HAS_PRIVATE, NULL, NULL,
+    "MFInt32", JSCLASS_HAS_PRIVATE, nullptr, nullptr,
     MFInt32Handler::get, MFInt32Handler::set,
-    NULL, NULL, NULL,
+    nullptr, nullptr, nullptr,
     MFInt32Handler::destructor,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0
+    nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, 0
   },
   MFFunctions,
 };
 
 CoinVrmlJs::ClassDescriptor CoinVrmlJs::MFNode = {
   {
-    "MFNode", JSCLASS_HAS_PRIVATE, NULL, NULL,
+    "MFNode", JSCLASS_HAS_PRIVATE, nullptr, nullptr,
     MFNodeHandler::get, MFNodeHandler::set,
-    NULL, NULL, NULL,
+    nullptr, nullptr, nullptr,
     MFNodeHandler::destructor,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0
+    nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, 0
   },
   MFFunctions,
 };
 
 CoinVrmlJs::ClassDescriptor CoinVrmlJs::MFRotation = {
   {
-    "MFRotation", JSCLASS_HAS_PRIVATE, NULL, NULL,
+    "MFRotation", JSCLASS_HAS_PRIVATE, nullptr, nullptr,
     MFRotationHandler::get, MFRotationHandler::set,
-    NULL, NULL, NULL,
+    nullptr, nullptr, nullptr,
     MFRotationHandler::destructor,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0
+    nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, 0
   },
   MFFunctions,
 };
 
 CoinVrmlJs::ClassDescriptor CoinVrmlJs::MFString = {
   {
-    "MFString", JSCLASS_HAS_PRIVATE, NULL, NULL,
+    "MFString", JSCLASS_HAS_PRIVATE, nullptr, nullptr,
     MFStringHandler::get, MFStringHandler::set,
-    NULL, NULL, NULL,
+    nullptr, nullptr, nullptr,
     MFStringHandler::destructor,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0
+    nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, 0
   },
   MFFunctions,
 };
 
 CoinVrmlJs::ClassDescriptor CoinVrmlJs::MFTime = {
   {
-    "MFTime", JSCLASS_HAS_PRIVATE, NULL, NULL,
+    "MFTime", JSCLASS_HAS_PRIVATE, nullptr, nullptr,
     MFTimeHandler::get, MFTimeHandler::set,
-    NULL, NULL, NULL,
+    nullptr, nullptr, nullptr,
     MFTimeHandler::destructor,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0
+    nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, 0
   },
   MFFunctions,
 };
 
 CoinVrmlJs::ClassDescriptor CoinVrmlJs::MFVec2f = {
   {
-    "MFVec2f", JSCLASS_HAS_PRIVATE, NULL, NULL,
+    "MFVec2f", JSCLASS_HAS_PRIVATE, nullptr, nullptr,
     MFVec2fHandler::get, MFVec2fHandler::set,
-    NULL, NULL, NULL,
+    nullptr, nullptr, nullptr,
     MFVec2fHandler::destructor,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0
+    nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, 0
   },
   MFFunctions,
 };
 
 CoinVrmlJs::ClassDescriptor CoinVrmlJs::MFVec3f = {
   {
-    "MFVec3f", JSCLASS_HAS_PRIVATE, NULL, NULL,
+    "MFVec3f", JSCLASS_HAS_PRIVATE, nullptr, nullptr,
     MFVec3fHandler::get, MFVec3fHandler::set,
-    NULL, NULL, NULL,
+    nullptr, nullptr, nullptr,
     MFVec3fHandler::destructor,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0
+    nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, 0
   },
   MFFunctions,
 };
 
 CoinVrmlJs::ClassDescriptor CoinVrmlJs::MFVec3d = {
   {
-    "MFVec3d", JSCLASS_HAS_PRIVATE, NULL, NULL,
+    "MFVec3d", JSCLASS_HAS_PRIVATE, nullptr, nullptr,
     MFVec3dHandler::get, MFVec3dHandler::set,
-    NULL, NULL, NULL,
+    nullptr, nullptr, nullptr,
     MFVec3dHandler::destructor,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0
+    nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, 0
   },
   MFFunctions,
 };
@@ -1978,8 +1978,8 @@ js_vrmlclasses_cleanup(void)
   delete garbagecollectedobjects;
   delete nodesensorstobedeleted;
 
-  garbagecollectedobjects = NULL;
-  nodesensorstobedeleted = NULL;
+  garbagecollectedobjects = nullptr;
+  nodesensorstobedeleted = nullptr;
 }
 
 // *************************************************************************
@@ -1989,7 +1989,7 @@ void
 JS_addVRMLclasses(SoJavaScriptEngine * engine)
 {
   // init static data
-  if (garbagecollectedobjects == NULL) {
+  if (garbagecollectedobjects == nullptr) {
     garbagecollectedobjects = new SbList <JSObject *>;
     nodesensorstobedeleted = new SbList <SoNodeSensor *>;
     coin_atexit((coin_atexit_f *)js_vrmlclasses_cleanup, CC_ATEXIT_NORMAL);
@@ -2010,7 +2010,7 @@ JS_addVRMLclasses(SoJavaScriptEngine * engine)
 
   // Bool
   engine->addHandler(
-    SoSFBool::getClassTypeId(), NULL,
+    SoSFBool::getClassTypeId(), nullptr,
     SFBool_field2jsval, SFBool_jsval2field);
 
   // Color
@@ -2025,7 +2025,7 @@ JS_addVRMLclasses(SoJavaScriptEngine * engine)
 
   // Float
   engine->addHandler(
-    SoSFFloat::getClassTypeId(), NULL,
+    SoSFFloat::getClassTypeId(), nullptr,
     SFFloat_field2jsval, SFFloat_jsval2field);
   engine->addHandler(
     SoMFFloat::getClassTypeId(),
@@ -2035,7 +2035,7 @@ JS_addVRMLclasses(SoJavaScriptEngine * engine)
 
   // Int32
   engine->addHandler(
-    SoSFInt32::getClassTypeId(), NULL,
+    SoSFInt32::getClassTypeId(), nullptr,
     SFInt32_field2jsval, SFInt32_jsval2field);
   engine->addHandler(
     SoMFInt32::getClassTypeId(),
@@ -2045,7 +2045,7 @@ JS_addVRMLclasses(SoJavaScriptEngine * engine)
 
   // Enum
   engine->addHandler(
-    SoSFEnum::getClassTypeId(), NULL,
+    SoSFEnum::getClassTypeId(), nullptr,
     SFEnum_field2jsval, SFEnum_jsval2field);
 
   // Node
@@ -2070,7 +2070,7 @@ JS_addVRMLclasses(SoJavaScriptEngine * engine)
 
   // String
   engine->addHandler(
-    SoSFString::getClassTypeId(), NULL,
+    SoSFString::getClassTypeId(), nullptr,
     SFString_field2jsval, SFString_jsval2field);
   engine->addHandler(
     SoMFString::getClassTypeId(),
@@ -2080,7 +2080,7 @@ JS_addVRMLclasses(SoJavaScriptEngine * engine)
 
   // Time
   engine->addHandler(
-    SoSFTime::getClassTypeId(), NULL,
+    SoSFTime::getClassTypeId(), nullptr,
     SFTime_field2jsval, SFTime_jsval2field);
   engine->addHandler(
     SoMFTime::getClassTypeId(),
diff --git a/coin4/src/vrml97/LOD.cpp b/coin4/src/vrml97/LOD.cpp
index 909b22d..0cb9ba1 100644
--- a/coin4/src/vrml97/LOD.cpp
+++ b/coin4/src/vrml97/LOD.cpp
@@ -198,10 +198,10 @@ SoVRMLLOD::commonConstructor(void)
   // HACK WARNING: All children of this node are stored in the level
   // field. Avoid double notifications (because of notification
   // through SoChildList) be reallocating the SoChildList with a
-  // NULL-parent here. SoGroup will have allocated an SoChildList in
+  // nullptr-parent here. SoGroup will have allocated an SoChildList in
   // its constructor when we get here.
   delete this->SoGroup::children;
-  this->SoGroup::children = new SoChildList(NULL);
+  this->SoGroup::children = new SoChildList(nullptr);
 }
 
 // *************************************************************************
diff --git a/coin4/src/vrml97/Normal.cpp b/coin4/src/vrml97/Normal.cpp
index 4ca9b03..d42518f 100644
--- a/coin4/src/vrml97/Normal.cpp
+++ b/coin4/src/vrml97/Normal.cpp
@@ -66,7 +66,7 @@ SO_NODE_SOURCE(SoVRMLNormal);
 
 class SoVRMLNormalP {
  public:
-  SoVRMLNormalP() : vbo(NULL) { }
+  SoVRMLNormalP() : vbo(nullptr) { }
   ~SoVRMLNormalP() { delete this->vbo; }
   
   SoVBO * vbo;
@@ -126,7 +126,7 @@ SoVRMLNormal::GLRender(SoGLRenderAction * action)
   if (SoGLVBOElement::shouldCreateVBO(state, num)) {
     setvbo = true;
     bool dirty = false;
-    if (PRIVATE(this)->vbo == NULL) {
+    if (PRIVATE(this)->vbo == nullptr) {
       PRIVATE(this)->vbo = new SoVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW); 
       dirty =  true;
     }
@@ -141,7 +141,7 @@ SoVRMLNormal::GLRender(SoGLRenderAction * action)
   }
   else if (PRIVATE(this)->vbo && PRIVATE(this)->vbo->getBufferDataId()) {
     // clear buffers to deallocate VBO memory
-    PRIVATE(this)->vbo->setBufferData(NULL, 0, 0);
+    PRIVATE(this)->vbo->setBufferData(nullptr, 0, 0);
   }
   SoBase::staticDataUnlock();
   if (setvbo) {
diff --git a/coin4/src/vrml97/Parent.cpp b/coin4/src/vrml97/Parent.cpp
index 1601b42..b6ffbc6 100644
--- a/coin4/src/vrml97/Parent.cpp
+++ b/coin4/src/vrml97/Parent.cpp
@@ -84,7 +84,7 @@ public:
 #endif // !COIN_THREADSAFE
 
   static SoInfo * getNullNode(void) {
-    if (SoVRMLParentP::nullnode == NULL) {
+    if (SoVRMLParentP::nullnode == nullptr) {
       SoVRMLParentP::nullnode = new SoInfo;
       SoVRMLParentP::nullnode->ref();
       SoVRMLParentP::nullnode->setName("SoVRMLParent::nullnode");
@@ -92,9 +92,9 @@ public:
     return SoVRMLParentP::nullnode;
   }
   static void freeNullNode(void) {
-    if (SoVRMLParentP::nullnode != NULL) {
+    if (SoVRMLParentP::nullnode != nullptr) {
       SoVRMLParentP::nullnode->unref();
-      SoVRMLParentP::nullnode = NULL;
+      SoVRMLParentP::nullnode = nullptr;
     }
   }
 
@@ -102,7 +102,7 @@ private:
   static SoInfo * nullnode;
 };
 
-SoInfo * SoVRMLParentP::nullnode = NULL;
+SoInfo * SoVRMLParentP::nullnode = nullptr;
 
 static void
 vrmlparent_cleanup(void)
@@ -121,7 +121,7 @@ void
 SoVRMLParent::initClass(void)
 {
   SO_NODE_INTERNAL_INIT_ABSTRACT_CLASS(SoVRMLParent, SO_VRML97_NODE_TYPE);
-  // used when the 'children' field contains NULL-nodes
+  // used when the 'children' field contains nullptr-nodes
   coin_atexit((coin_atexit_f*) vrmlparent_cleanup, CC_ATEXIT_NORMAL);
 }
 
@@ -164,10 +164,10 @@ SoVRMLParent::commonConstructor(void)
   // HACK WARNING: All children of this node are stored in the
   // children field. Avoid double notifications (because of
   // notification through SoChildList) be reallocating the SoChildList
-  // with a NULL-parent here. SoGroup will have allocated an
+  // with a nullptr-parent here. SoGroup will have allocated an
   // SoChildList in its constructor when we get here.
   delete this->SoGroup::children;
-  this->SoGroup::children = new SoChildList(NULL);
+  this->SoGroup::children = new SoChildList(nullptr);
 }
 
 /*!
@@ -401,10 +401,10 @@ SoVRMLParent::updateChildList(const SoNode * const * nodes,
   if (numChildren && (numnodes == numChildren)) {
     const SoNode ** clarr = (const SoNode**) cl.getArrayPtr();
     for (i = 0; i < numnodes; i++) {
-      // if the MFNode contains NULL values, we insert a dummy node
+      // if the MFNode contains nullptr values, we insert a dummy node
       // (of type SoInfo). This is to simplify the traversal code, and
       // to make it easier to check if the SoChildList is up-to-date
-      if (clarr[i] == NULL) {
+      if (clarr[i] == nullptr) {
         if (nodes[i] != SoVRMLParentP::getNullNode()) break;
       }
       else {
diff --git a/coin4/src/vrml97/PixelTexture.cpp b/coin4/src/vrml97/PixelTexture.cpp
index 23b27e8..d888111 100644
--- a/coin4/src/vrml97/PixelTexture.cpp
+++ b/coin4/src/vrml97/PixelTexture.cpp
@@ -153,9 +153,9 @@ SoVRMLPixelTexture::SoVRMLPixelTexture(void)
 
   SO_VRMLNODE_INTERNAL_CONSTRUCTOR(SoVRMLPixelTexture);
 
-  SO_VRMLNODE_ADD_EXPOSED_FIELD(image, (SbVec2s(0,0), 0, NULL));
+  SO_VRMLNODE_ADD_EXPOSED_FIELD(image, (SbVec2s(0,0), 0, nullptr));
 
-  PRIVATE(this)->glimage = NULL;
+  PRIVATE(this)->glimage = nullptr;
   PRIVATE(this)->glimagevalid = false;
   PRIVATE(this)->readstatus = 1;
 }
@@ -165,7 +165,7 @@ SoVRMLPixelTexture::SoVRMLPixelTexture(void)
 */
 SoVRMLPixelTexture::~SoVRMLPixelTexture()
 {
-  if (PRIVATE(this)->glimage) PRIVATE(this)->glimage->unref(NULL);
+  if (PRIVATE(this)->glimage) PRIVATE(this)->glimage->unref(nullptr);
   delete PRIVATE(this);
 }
 
@@ -241,13 +241,13 @@ SoVRMLPixelTexture::GLRender(SoGLRenderAction * action)
     bool needbig = (scalepolicy == SoTextureScalePolicyElement::FRACTURE);
 
     if (needbig &&
-        (PRIVATE(this)->glimage == NULL ||
+        (PRIVATE(this)->glimage == nullptr ||
          PRIVATE(this)->glimage->getTypeId() != SoGLBigImage::getClassTypeId())) {
       if (PRIVATE(this)->glimage) PRIVATE(this)->glimage->unref(state);
       PRIVATE(this)->glimage = new SoGLBigImage();
     }
     else if (!needbig &&
-             (PRIVATE(this)->glimage == NULL ||
+             (PRIVATE(this)->glimage == nullptr ||
               PRIVATE(this)->glimage->getTypeId() != SoGLImage::getClassTypeId())) {
       if (PRIVATE(this)->glimage) PRIVATE(this)->glimage->unref(state);
       PRIVATE(this)->glimage = new SoGLImage();
@@ -274,7 +274,7 @@ SoVRMLPixelTexture::GLRender(SoGLRenderAction * action)
   PRIVATE(this)->unlock_glimage();
 
   SoGLMultiTextureImageElement::set(state, this, unit,
-                                    PRIVATE(this)->glimagevalid ? PRIVATE(this)->glimage : NULL,
+                                    PRIVATE(this)->glimagevalid ? PRIVATE(this)->glimage : nullptr,
                                     SoMultiTextureImageElement::MODULATE,
                                     SbColor(1.0f, 1.0f, 1.0f));
 
diff --git a/coin4/src/vrml97/PointSet.cpp b/coin4/src/vrml97/PointSet.cpp
index 92b79c5..9bca37e 100644
--- a/coin4/src/vrml97/PointSet.cpp
+++ b/coin4/src/vrml97/PointSet.cpp
@@ -36,8 +36,8 @@
 
   \verbatim
   PointSet {
-    exposedField  SFNode  color      NULL
-    exposedField  SFNode  coord      NULL
+    exposedField  SFNode  color      nullptr
+    exposedField  SFNode  coord      nullptr
   }
   \endverbatim
   
@@ -46,16 +46,16 @@
   field specifies a SoVRMLCoordinate node (or instance of a Coordinate
   node). The results are undefined if the coord field specifies any
   other type of node. PointSet uses the coordinates in order. If the
-  coord field is NULL, the point set is considered empty.  PointSet
+  coord field is nullptr, the point set is considered empty.  PointSet
   nodes are not lit, not texture-mapped, nor do they participate in
   collision detection. The size of each point is implementation-
-  dependent.  If the color field is not NULL, it shall specify a
+  dependent.  If the color field is not nullptr, it shall specify a
   SoVRMLColor node that contains at least the number of points
   contained in the coord node. The results are undefined if the color
   field specifies any other type of node. Colours shall be applied to
   each point in order. The results are undefined if the number of
   values in the Color node is less than the number of values specified
-  in the Coordinate node.  If the color field is NULL and there is a
+  in the Coordinate node.  If the color field is nullptr and there is a
   SoVRMLMaterial node defined for the SoVRMLAppearance node affecting
   this PointSet node, the emissiveColor of the Material node shall be
   used to draw the points. More details on lighting equations can be
@@ -110,7 +110,7 @@ is_material_per_vertex(SoVRMLPointSet * ps, SoState * state)
         SoMaterialBindingElement::OVERALL) return true;
     return false;
   }
-  return ps->color.getValue() != NULL;
+  return ps->color.getValue() != nullptr;
 }
 
 SO_NODE_SOURCE(SoVRMLPointSet);
@@ -177,7 +177,7 @@ SoVRMLPointSet::GLRender(SoGLRenderAction * action)
   
   if (dova && matpervertex) {
     const SoGLVBOElement * vboelem = SoGLVBOElement::getInstance(state);
-    if (vboelem->getColorVBO() == NULL) {
+    if (vboelem->getColorVBO() == nullptr) {
       dova = false;
       // we might be able to do VA-rendering, but need to check the
       // diffuse color type first.
@@ -191,7 +191,7 @@ SoVRMLPointSet::GLRender(SoGLRenderAction * action)
   if (dova) {
     bool vbo = this->startVertexArray(action,
                                         coords,
-                                        NULL,
+                                        nullptr,
                                         false,
                                         matpervertex);
     didrenderasvbo = vbo;
@@ -203,9 +203,9 @@ SoVRMLPointSet::GLRender(SoGLRenderAction * action)
   }
   else {
     sogl_render_pointset((SoGLCoordinateElement*) coords,
-                         NULL,
-                         matpervertex ? &mb : NULL,
-                         NULL,
+                         nullptr,
+                         matpervertex ? &mb : nullptr,
+                         nullptr,
                          numpts, 0);
   }
 
diff --git a/coin4/src/vrml97/Script.cpp b/coin4/src/vrml97/Script.cpp
index 2565f0e..f5f5641 100644
--- a/coin4/src/vrml97/Script.cpp
+++ b/coin4/src/vrml97/Script.cpp
@@ -167,8 +167,8 @@
 
 // *************************************************************************
 
-static SoVRMLScriptEvaluateCB * sovrmlscript_eval_cb = NULL;
-static void * sovrmlscript_eval_closure = NULL;
+static SoVRMLScriptEvaluateCB * sovrmlscript_eval_cb = nullptr;
+static void * sovrmlscript_eval_closure = nullptr;
 
 class SoVRMLScriptP {
 public:
@@ -179,7 +179,7 @@ public:
     this->isreading = false;
     this->isevaluating = false;
 #ifdef COIN_HAVE_JAVASCRIPT
-    this->engine = NULL;
+    this->engine = nullptr;
 #endif // !COIN_HAVE_JAVASCRIPT
   }
 
@@ -189,7 +189,7 @@ public:
 
 #ifdef COIN_HAVE_JAVASCRIPT
     // FIXME: this needs to be done in a nicer way. 20050720 erikgors.
-    if (this->engine != NULL)
+    if (this->engine != nullptr)
       this->shutdown();
 #endif // !COIN_HAVE_JAVASCRIPT
   }
@@ -235,7 +235,7 @@ SoVRMLScriptP::cleanup(void)
 #ifdef COIN_HAVE_JAVASCRIPT
   // FIXME: need to make sure this is added to atexit only after
   // the engine has started. 20050720 erikgors.
-  if (SoJavaScriptEngine::getRuntime() == NULL)
+  if (SoJavaScriptEngine::getRuntime() == nullptr)
     return;
 
   if (SoVRMLScriptP::useSpiderMonkey()) {
@@ -247,8 +247,8 @@ SoVRMLScriptP::cleanup(void)
 
   // reset static var
   SoVRMLScriptP::spidermonkey_init_failed = false;
-  sovrmlscript_eval_cb = NULL;
-  sovrmlscript_eval_closure = NULL;
+  sovrmlscript_eval_cb = nullptr;
+  sovrmlscript_eval_closure = nullptr;
 }
 
 // *************************************************************************
@@ -286,7 +286,7 @@ SoVRMLScriptP::useSpiderMonkey(void)
 {
   if (!SoVRMLScriptP::allowSpiderMonkey()) { return false; }
   if (!spidermonkey()->available) { return false; }
-  if (SoJavaScriptEngine::getRuntime() == NULL) { return false; }
+  if (SoJavaScriptEngine::getRuntime() == nullptr) { return false; }
   return true;
 }
 
@@ -311,7 +311,7 @@ SoVRMLScript::initClass(void) // static
 // *************************************************************************
 
 SoVRMLScript::SoVRMLScript(void)
-  : fielddata(NULL)
+  : fielddata(nullptr)
 {
   coin_atexit((coin_atexit_f *)SoVRMLScriptP::cleanup, CC_ATEXIT_NORMAL);
 
@@ -321,7 +321,7 @@ SoVRMLScript::SoVRMLScript(void)
       // FIXME: next line is a hack-ish way of checking whether init()
       // has already been done on the SoJavaScriptEngine class.
       // 20060207 mortene.
-      (SoJavaScriptEngine::getRuntime() == NULL)) {
+      (SoJavaScriptEngine::getRuntime() == nullptr)) {
     bool ok = SoJavaScriptEngine::init();
     if (!ok) { SoVRMLScriptP::spidermonkey_init_failed = true; }
   }
@@ -689,7 +689,7 @@ SoVRMLScript::readInstance(SoInput * in, unsigned short COIN_UNUSED_ARG(flags))
         ok = in->read(name, true);
       }
     }
-    else if ((builtinfield = this->getField(name)) != NULL) {
+    else if ((builtinfield = this->getField(name)) != nullptr) {
       err = !builtinfield->read(in, name);
       if (!err) {
         name = "";
@@ -735,7 +735,7 @@ SoVRMLScript::initFieldData(void)
 void
 SoVRMLScriptP::initialize(void)
 {
-  if (this->engine != NULL) {
+  if (this->engine != nullptr) {
     if (SoVRMLScriptP::debug()) {
       SoDebugError::postInfo("SoVRMLScriptP::initialize",
                              "restarting script engine");
@@ -765,14 +765,14 @@ SoVRMLScriptP::initialize(void)
         }
         continue;
       }
-      assert(this->engine == NULL);
+      assert(this->engine == nullptr);
       this->engine = new SoJavaScriptEngine;
       script = s.getSubString(jsPrefixlen);
       break;
     }
   }
 
-  if (this->engine == NULL) {
+  if (this->engine == nullptr) {
     static int first = 1;
     if (first) {
       SoDebugError::postWarning("SoVRMLScript::initialize",
@@ -824,14 +824,14 @@ SoVRMLScriptP::initialize(void)
       SoDebugError::postInfo("SoVRMLScriptP::initialize",
                              "executing script function \"%s\"", initialize.getString());
     }
-    this->engine->executeFunction(initialize, 0, NULL);
+    this->engine->executeFunction(initialize, 0, nullptr);
   }
 }
 
 void
 SoVRMLScriptP::shutdown(void)
 {
-  assert(this->engine != NULL);
+  assert(this->engine != nullptr);
 
   SbName shutdown("shutdown");
   if (this->engine->hasScriptField(shutdown)) {
@@ -839,11 +839,11 @@ SoVRMLScriptP::shutdown(void)
       SoDebugError::postInfo("SoVRMLScriptP::initialize",
                              "executing script function \"%s\"", shutdown.getString());
     }
-    this->engine->executeFunction(shutdown, 0, NULL);
+    this->engine->executeFunction(shutdown, 0, nullptr);
   }
 
   delete this->engine;
-  this->engine = NULL;
+  this->engine = nullptr;
 }
 
 #endif // !COIN_HAVE_JAVASCRIPT
@@ -866,7 +866,7 @@ SoVRMLScriptP::evaluate(void)
     sovrmlscript_eval_cb(sovrmlscript_eval_closure, PUBLIC(this));
   }
 #ifdef COIN_HAVE_JAVASCRIPT
-  else if (this->engine != NULL) {
+  else if (this->engine != nullptr) {
     this->executeFunctions();
   }
 #endif // !COIN_HAVE_JAVASCRIPT
@@ -927,7 +927,7 @@ SoVRMLScriptP::executeFunctions(void)
 #ifdef COIN_HAVE_JAVASCRIPT
   static SbName eventsProcessed("eventsProcessed");
   if (this->engine->hasScriptField(eventsProcessed)) {
-    this->engine->executeFunction(eventsProcessed, 0, NULL);
+    this->engine->executeFunction(eventsProcessed, 0, nullptr);
   }
 #endif // !COIN_HAVE_JAVASCRIPT
 
diff --git a/coin4/src/vrml97/Shape.cpp b/coin4/src/vrml97/Shape.cpp
index 16ab8b3..3577240 100644
--- a/coin4/src/vrml97/Shape.cpp
+++ b/coin4/src/vrml97/Shape.cpp
@@ -36,8 +36,8 @@
 
   \verbatim
   Shape {
-    exposedField SFNode appearance NULL
-    exposedField SFNode geometry   NULL
+    exposedField SFNode appearance nullptr
+    exposedField SFNode geometry   nullptr
   }
   \endverbatim
 
@@ -55,7 +55,7 @@
   (<http://www.web3d.org/x3d/specifications/vrml/ISO-IEC-14772-VRML97/part1/concepts.html#4.14>),
   contains details of the VRML lighting model and the interaction
   between Appearance nodes and geometry nodes.  If the geometry field
-  is NULL, the object is not drawn.
+  is nullptr, the object is not drawn.
 
 */
 
@@ -81,12 +81,12 @@
 
 /*!
   \var SoSFNode SoVRMLShape::appearance
-  Can store an SoVRMLAppearance node, or NULL.
+  Can store an SoVRMLAppearance node, or nullptr.
 */
 
 /*!
   \var SoSFNode SoVRMLShape::geometry
-  Can store any SoVRMLGeometry subclass, or NULL.
+  Can store any SoVRMLGeometry subclass, or nullptr.
 */
 
 /*!
@@ -183,8 +183,8 @@ SoVRMLShape::SoVRMLShape(void)
 
   SO_VRMLNODE_INTERNAL_CONSTRUCTOR(SoVRMLShape);
 
-  SO_VRMLNODE_ADD_EXPOSED_FIELD(appearance, (NULL));
-  SO_VRMLNODE_ADD_EXPOSED_FIELD(geometry, (NULL));
+  SO_VRMLNODE_ADD_EXPOSED_FIELD(appearance, (nullptr));
+  SO_VRMLNODE_ADD_EXPOSED_FIELD(geometry, (nullptr));
 
   SO_NODE_ADD_FIELD(renderCaching, (AUTO));
   SO_NODE_ADD_FIELD(boundingBoxCaching, (AUTO));
@@ -196,11 +196,11 @@ SoVRMLShape::SoVRMLShape(void)
   SO_NODE_SET_SF_ENUM_TYPE(renderCaching, CacheEnabled);
   SO_NODE_SET_SF_ENUM_TYPE(boundingBoxCaching, CacheEnabled);
 
-  // supply a NULL-pointer as parent, since notifications will be 
+  // supply a nullptr-pointer as parent, since notifications will be 
   // handled by the fields that actually contain the node(s)
-  PRIVATE(this)->childlist = new SoChildList(NULL);
+  PRIVATE(this)->childlist = new SoChildList(nullptr);
   PRIVATE(this)->childlistvalid = false;
-  PRIVATE(this)->cachelist = NULL;
+  PRIVATE(this)->cachelist = nullptr;
 }
 
 SoVRMLShape::~SoVRMLShape()
@@ -234,8 +234,8 @@ SoVRMLShape::doAction(SoAction * action)
   SoState * state = action->getState();
 
   if (state->isElementEnabled(SoLazyElement::getClassStackIndex())) {
-    if ((this->appearance.getValue() == NULL) ||
-        (((SoVRMLAppearance*)this->appearance.getValue())->material.getValue() == NULL)) {
+    if ((this->appearance.getValue() == nullptr) ||
+        (((SoVRMLAppearance*)this->appearance.getValue())->material.getValue() == nullptr)) {
       SoLazyElement::setLightModel(state, SoLazyElement::BASE_COLOR);
     }
   }
@@ -264,8 +264,8 @@ SoVRMLShape::GLRender(SoGLRenderAction * action)
   SoState * state = action->getState();
   state->push();
 
-  if ((this->appearance.getValue() == NULL) ||
-      (((SoVRMLAppearance*)this->appearance.getValue())->material.getValue() == NULL)) {
+  if ((this->appearance.getValue() == nullptr) ||
+      (((SoVRMLAppearance*)this->appearance.getValue())->material.getValue() == nullptr)) {
     SoLazyElement::setLightModel(state, SoLazyElement::BASE_COLOR);
   }
 
diff --git a/coin4/src/vrml97/Sound.cpp b/coin4/src/vrml97/Sound.cpp
index 4929d6d..06fe593 100644
--- a/coin4/src/vrml97/Sound.cpp
+++ b/coin4/src/vrml97/Sound.cpp
@@ -45,7 +45,7 @@
     exposedField SFFloat  minBack       1       # [0,inf)
     exposedField SFFloat  minFront      1       # [0,inf)
     exposedField SFFloat  priority      0       # [0,1]
-    exposedField SFNode   source        NULL
+    exposedField SFNode   source        nullptr
     field        SFBool   spatialize    true
   }
   \endverbatim
@@ -365,7 +365,7 @@ SoVRMLSound::SoVRMLSound(void)
 
   SO_VRMLNODE_INTERNAL_CONSTRUCTOR(SoVRMLSound);
 
-  SO_VRMLNODE_ADD_EXPOSED_FIELD(source, (NULL));
+  SO_VRMLNODE_ADD_EXPOSED_FIELD(source, (nullptr));
   SO_VRMLNODE_ADD_EXPOSED_FIELD(intensity, (1.0f));
   SO_VRMLNODE_ADD_EXPOSED_FIELD(priority, (0.0f));
   SO_VRMLNODE_ADD_EXPOSED_FIELD(location, (0.0f, 0.0f, 0.0f));
@@ -383,12 +383,12 @@ SoVRMLSound::SoVRMLSound(void)
   // because spatialize defaults to true
   // and OpenAL only spatializes mono buffers
 
-  PRIVATE(this)->currentAudioClip = NULL;
+  PRIVATE(this)->currentAudioClip = nullptr;
   PRIVATE(this)->playing = false;
   PRIVATE(this)->endoffile = false;
   PRIVATE(this)->waitingForAudioClipToFinish = false;
 
-  PRIVATE(this)->timersensor = NULL;
+  PRIVATE(this)->timersensor = nullptr;
 #ifdef HAVE_THREADS
   /* FIXME: Let the user override use of timer callback with an
      environment variable. 2003-01-16 thammer.  */
@@ -406,11 +406,11 @@ SoVRMLSound::SoVRMLSound(void)
   PRIVATE(this)->sourcesensor->attach(&this->source);
 
 #ifdef HAVE_THREADS
-  PRIVATE(this)->workerThread = NULL;
+  PRIVATE(this)->workerThread = nullptr;
 #endif
   PRIVATE(this)->exitthread = false;
   PRIVATE(this)->errorInThread = false;
-  PRIVATE(this)->audioBuffer = NULL;
+  PRIVATE(this)->audioBuffer = nullptr;
   PRIVATE(this)->bufferLength = 0;
 
   this->setBufferingProperties(SoVRMLSoundP::defaultBufferLength,
@@ -419,7 +419,7 @@ SoVRMLSound::SoVRMLSound(void)
 
   PRIVATE(this)->sourceId = 0;
 
-  PRIVATE(this)->cliphandle = NULL;
+  PRIVATE(this)->cliphandle = nullptr;
 
   static bool warningprintedonce = false;
 
@@ -517,11 +517,11 @@ SoVRMLSound::~SoVRMLSound(void)
 
   PRIVATE(this)->stopPlaying();
 
-  if (PRIVATE(this)->currentAudioClip != NULL)
+  if (PRIVATE(this)->currentAudioClip != nullptr)
     PRIVATE(this)->currentAudioClip->unref();
-  PRIVATE(this)->currentAudioClip = NULL;
+  PRIVATE(this)->currentAudioClip = nullptr;
 
-  if (PRIVATE(this)->audioBuffer != NULL)
+  if (PRIVATE(this)->audioBuffer != nullptr)
     delete[] PRIVATE(this)->audioBuffer;
 
 #ifdef HAVE_SOUND
@@ -683,7 +683,7 @@ void SoVRMLSound::audioRender(SoAudioRenderAction *action)
   if (!SoAudioDevice::instance()->haveSound())
     return;
 
-  if (PRIVATE(this)->currentAudioClip == NULL)
+  if (PRIVATE(this)->currentAudioClip == nullptr)
     return;
 
   SoSFBool * isActiveField = (SoSFBool *)PRIVATE(this)->currentAudioClip->getField("isActive");
@@ -1121,7 +1121,7 @@ SoVRMLSoundP::threadCallback()
     this->exitthreadmutex.unlock();
 #endif
   }
-  return NULL;
+  return nullptr;
 }
 
 void
@@ -1151,7 +1151,7 @@ bool SoVRMLSoundP::stopPlaying()
     if (this->timersensor->isScheduled())
       this->timersensor->unschedule();
     delete this->timersensor;
-    this->timersensor = NULL;
+    this->timersensor = nullptr;
   }
 
   /* FIXME: joining with workerThread will normally cause a lag of
@@ -1159,15 +1159,15 @@ bool SoVRMLSoundP::stopPlaying()
 
   // stop thread
 #ifdef HAVE_THREADS
-  if (this->workerThread!=NULL) {
+  if (this->workerThread!=nullptr) {
     this->exitthreadmutex.lock();
     this->exitthread = true;
     this->exitthreadcondvar.wakeAll();
     this->exitthreadmutex.unlock();
-    void *retval = NULL;
+    void *retval = nullptr;
     cc_thread_join(this->workerThread, &retval);
     cc_thread_destruct(this->workerThread);
-    this->workerThread = NULL;
+    this->workerThread = nullptr;
   }
 #endif // HAVE_THREADS
 
@@ -1238,7 +1238,7 @@ bool SoVRMLSoundP::stopPlaying()
      unqueues only processed buffers).
 
      So, we try explisitly setting the AL_BUFFER source attribute to
-     NULL, which is legal according to the OpenAL documentation (and
+     nullptr, which is legal according to the OpenAL documentation (and
      also redundant, wrt alSourceUnqueueBuffers according to the same
      documentation).
 
@@ -1308,7 +1308,7 @@ bool SoVRMLSoundP::startPlaying()
   this->playing = true;
   this->endoffile = false;
   this->waitingForAudioClipToFinish = false;
-  this->cliphandle = NULL;
+  this->cliphandle = nullptr;
 
   // Start timer or thread
   if (this->useTimerCallback) {
@@ -1317,7 +1317,7 @@ bool SoVRMLSoundP::startPlaying()
       if (this->timersensor->isScheduled())
         this->timersensor->unschedule();
       delete this->timersensor;
-      this->timersensor = NULL;
+      this->timersensor = nullptr;
     }
     this->errorInThread = false;
     // start new timer
@@ -1328,7 +1328,7 @@ bool SoVRMLSoundP::startPlaying()
   else {
     // stop existing thread, start new thread
 #ifdef HAVE_THREADS
-    if (this->workerThread!=NULL) {
+    if (this->workerThread!=nullptr) {
       /* FIXME: Verify that this will actually happen sometimes. Also
          verify that it is indeed necessary to stop and start the
          thread. 2003-01-20 thammer. */
@@ -1336,10 +1336,10 @@ bool SoVRMLSoundP::startPlaying()
       this->exitthread = true;
       this->exitthreadcondvar.wakeAll();
       this->exitthreadmutex.unlock();
-      void *retval = NULL;
+      void *retval = nullptr;
       cc_thread_join(this->workerThread, &retval);
       cc_thread_destruct(this->workerThread);
-      this->workerThread = NULL;
+      this->workerThread = nullptr;
     }
 
     this->workerThreadSleepTime = this->sleepTime;
@@ -1362,7 +1362,7 @@ void SoVRMLSoundP::fillBuffers()
   SbThreadAutoLock autoLock(&this->syncmutex);
 #endif
 
-  assert(this->currentAudioClip != NULL);
+  assert(this->currentAudioClip != nullptr);
   assert(this->hasValidAlSource());
 
   if (this->waitingForAudioClipToFinish) {
@@ -1396,7 +1396,7 @@ void SoVRMLSoundP::fillBuffers()
   // 20021021 thammer, kept for debugging purposes
   if (queued<=0) {
     // no buffers were queued, so there's nothing to do. This should
-    // only happen after audioclip::fillBuffer() returns NULL to
+    // only happen after audioclip::fillBuffer() returns nullptr to
     // indicate an EOF, and sound::fillBuffers() does not queue new
     // buffers after that
     #if COIN_DEBUG && DEBUG_AUDIO // debug
@@ -1420,7 +1420,7 @@ void SoVRMLSoundP::fillBuffers()
       // inform currentAudioClip() that the last buffer has been played,
       // so it can decide if it would like to stop playing
       int numchannels;
-      ret = this->currentAudioClip->read(this->cliphandle, NULL, 0, 
+      ret = this->currentAudioClip->read(this->cliphandle, nullptr, 0, 
                                          numchannels);
       assert (ret == 0); // or else the AudioClip isn't performing as it should
     }
@@ -1622,7 +1622,7 @@ void
 SoVRMLSoundP::sourceSensorCBWrapper(void * data, SoSensor *)
 {
   SoVRMLSoundP * thisp = (SoVRMLSoundP*) data;
-  thisp->sourceSensorCB(NULL);
+  thisp->sourceSensorCB(nullptr);
 }
 
 //
@@ -1644,7 +1644,7 @@ SoVRMLSoundP::sourceSensorCB(SoSensor *)
   if (!node->isOfType(SoVRMLAudioClip::getClassTypeId())) {
     SoDebugError::postWarning("SoVRMLSoundP::sourceSensorCB",
                               "Unknown source node type");
-    if (this->currentAudioClip != NULL) {
+    if (this->currentAudioClip != nullptr) {
       this->currentAudioClip->unref();
 #ifdef HAVE_THREADS
       this->syncmutex.unlock();
@@ -1654,15 +1654,15 @@ SoVRMLSoundP::sourceSensorCB(SoSensor *)
       this->syncmutex.lock();
 #endif
     }
-    this->currentAudioClip = NULL;
+    this->currentAudioClip = nullptr;
     return;
   }
 
   SoVRMLAudioClip *audioClip = (SoVRMLAudioClip *)node;
   if (audioClip != this->currentAudioClip) {
-    if (this->currentAudioClip != NULL) {
+    if (this->currentAudioClip != nullptr) {
       this->currentAudioClip->unref();
-      this->currentAudioClip = NULL;
+      this->currentAudioClip = nullptr;
 #ifdef HAVE_THREADS
       this->syncmutex.unlock();
 #endif
@@ -1671,12 +1671,12 @@ SoVRMLSoundP::sourceSensorCB(SoSensor *)
       this->syncmutex.lock();
 #endif
     }
-    if (audioClip!=NULL)
+    if (audioClip!=nullptr)
       audioClip->ref();
     this->currentAudioClip = audioClip;
   }
 
-  if (this->currentAudioClip == NULL)
+  if (this->currentAudioClip == nullptr)
     return;
 
   SoSFBool * isActiveField =
diff --git a/coin4/src/vrml97/Switch.cpp b/coin4/src/vrml97/Switch.cpp
index 75e88a8..d2254c1 100644
--- a/coin4/src/vrml97/Switch.cpp
+++ b/coin4/src/vrml97/Switch.cpp
@@ -164,10 +164,10 @@ SoVRMLSwitch::commonConstructor(void)
   // HACK WARNING: All children of this node are stored in the choice
   // field. Avoid double notifications (because of notification
   // through SoChildList) be reallocating the SoChildList with a
-  // NULL-parent here. SoGroup will have allocated an SoChildList in
+  // nullptr-parent here. SoGroup will have allocated an SoChildList in
   // its constructor when we get here.
   delete this->SoGroup::children;
-  this->SoGroup::children = new SoChildList(NULL);
+  this->SoGroup::children = new SoChildList(nullptr);
 }
 
 /*!
diff --git a/coin4/src/vrml97/Text.cpp b/coin4/src/vrml97/Text.cpp
index 42db824..c39a9ec 100644
--- a/coin4/src/vrml97/Text.cpp
+++ b/coin4/src/vrml97/Text.cpp
@@ -43,7 +43,7 @@
   \verbatim
   Text { 
     exposedField  MFString string    []
-    exposedField  SFNode   fontStyle NULL
+    exposedField  SFNode   fontStyle nullptr
     exposedField  MFFloat  length    []      # [0,)
     exposedField  SFFloat  maxExtent 0.0     # [0,)
   }
@@ -219,7 +219,7 @@ SoVRMLText::SoVRMLText(void)
 
   SO_VRMLNODE_ADD_EMPTY_EXPOSED_MFIELD(string);
 
-  SO_VRMLNODE_ADD_EXPOSED_FIELD(fontStyle, (NULL));
+  SO_VRMLNODE_ADD_EXPOSED_FIELD(fontStyle, (nullptr));
   SO_VRMLNODE_ADD_EXPOSED_FIELD(maxExtent, (0.0f));
   SO_VRMLNODE_ADD_EMPTY_EXPOSED_MFIELD(length);
 
@@ -238,7 +238,7 @@ SoVRMLText::SoVRMLText(void)
   PRIVATE(this)->fontstylesensor->attach(&fontStyle);
   PRIVATE(this)->fontstylesensor->setPriority(0);
   
-  PRIVATE(this)->cache = NULL;
+  PRIVATE(this)->cache = nullptr;
 }
 
 float
@@ -413,7 +413,7 @@ SoVRMLText::GLRender(SoGLRenderAction * action)
 
     }
      
-    cc_glyph3d * prevglyph = NULL;
+    cc_glyph3d * prevglyph = nullptr;
 
     SbString str = this->string[i];
     const char * p = str.getString();
@@ -496,7 +496,7 @@ SoVRMLText::GLRender(SoGLRenderAction * action)
 
     if (prevglyph) {
       cc_glyph3d_unref(prevglyph);
-      prevglyph = NULL;
+      prevglyph = nullptr;
     }
   }
   glEnd();
@@ -573,7 +573,7 @@ SoVRMLText::notify(SoNotList * list)
 SoChildList *
 SoVRMLText::getChildren(void) const
 {
-  return NULL;
+  return nullptr;
 }
 
 
@@ -776,7 +776,7 @@ SoVRMLText::generatePrimitives(SoAction * action)
   vertex.setDetail(&detail);
   vertex.setMaterialIndex(0);
 
-  this->beginShape(action, SoShape::TRIANGLES, NULL);
+  this->beginShape(action, SoShape::TRIANGLES, nullptr);
   vertex.setNormal(SbVec3f(0.0f, 0.0f, 1.0f));
 
   float ypos = 0.0f;
@@ -880,7 +880,7 @@ SoVRMLText::generatePrimitives(SoAction * action)
     }
     
     SbString str = this->string[i];
-    cc_glyph3d * prevglyph = NULL;
+    cc_glyph3d * prevglyph = nullptr;
     const char * p = str.getString();
     size_t len = cc_string_utf8_validate_length(p);
     assert(len);
@@ -963,7 +963,7 @@ SoVRMLText::generatePrimitives(SoAction * action)
     }
     if (prevglyph) {
       cc_glyph3d_unref(prevglyph);
-      prevglyph = NULL;
+      prevglyph = nullptr;
     }
   }
 
@@ -1094,7 +1094,7 @@ SoVRMLTextP::setUpGlyphs(SoState * state, SoVRMLText * textnode)
     float kerningy = 0;
     float advancex = 0;
     float advancey = 0;
-    cc_glyph3d * prevglyph = NULL;
+    cc_glyph3d * prevglyph = nullptr;
     this->maxglyphbbox.makeEmpty();
 
     for (unsigned int strcharidx = 0; strcharidx < len; strcharidx++) {
@@ -1120,7 +1120,7 @@ SoVRMLTextP::setUpGlyphs(SoState * state, SoVRMLText * textnode)
           
     }
 
-    if (prevglyph != NULL) {
+    if (prevglyph != nullptr) {
       // Italic font might cause last letter to be outside bbox. Add width if needed.
       if (advancex < cc_glyph3d_getwidth(prevglyph)) 
         stringwidth += (cc_glyph3d_getwidth(prevglyph) - advancex);
diff --git a/coin4/src/vrml97/TextureCoordinate.cpp b/coin4/src/vrml97/TextureCoordinate.cpp
index caddd35..e74531c 100644
--- a/coin4/src/vrml97/TextureCoordinate.cpp
+++ b/coin4/src/vrml97/TextureCoordinate.cpp
@@ -92,7 +92,7 @@
 
 class SoVRMLTextureCoordinateP {
  public:
-  SoVRMLTextureCoordinateP() : vbo(NULL) { }
+  SoVRMLTextureCoordinateP() : vbo(nullptr) { }
   ~SoVRMLTextureCoordinateP() { delete this->vbo; }
   SoVBO * vbo;
 };
@@ -149,7 +149,7 @@ SoVRMLTextureCoordinate::GLRender(SoGLRenderAction * action)
 {
   SoState * state = action->getState();
   SoGLMultiTextureCoordinateElement::setTexGen(state,
-                                               this, 0, NULL);
+                                               this, 0, nullptr);
   SoVRMLTextureCoordinate::doAction((SoAction*)action);
 
   SoBase::staticDataLock();
@@ -158,7 +158,7 @@ SoVRMLTextureCoordinate::GLRender(SoGLRenderAction * action)
   if (SoGLVBOElement::shouldCreateVBO(state, num)) {
     setvbo = true;
     bool dirty = false;
-    if (PRIVATE(this)->vbo == NULL) {
+    if (PRIVATE(this)->vbo == nullptr) {
       PRIVATE(this)->vbo = new SoVBO(GL_ARRAY_BUFFER, GL_STATIC_DRAW); 
       dirty =  true;
     }
@@ -173,7 +173,7 @@ SoVRMLTextureCoordinate::GLRender(SoGLRenderAction * action)
   }
   else if (PRIVATE(this)->vbo && PRIVATE(this)->vbo->getBufferDataId()) {
     // clear buffers to deallocate VBO memory
-    PRIVATE(this)->vbo->setBufferData(NULL, 0, 0);
+    PRIVATE(this)->vbo->setBufferData(nullptr, 0, 0);
   }
   SoBase::staticDataUnlock();
   if (setvbo) {
diff --git a/coin4/src/vrml97/TimeSensor.cpp b/coin4/src/vrml97/TimeSensor.cpp
index f491378..cad685d 100644
--- a/coin4/src/vrml97/TimeSensor.cpp
+++ b/coin4/src/vrml97/TimeSensor.cpp
@@ -318,7 +318,7 @@ SoVRMLTimeSensor::write(SoWriteAction * action)
   // corrected, remember to pass on the updates.
 
   // Disconnect from realTime field.
-  SoField * connectfield = NULL;
+  SoField * connectfield = nullptr;
   bool connectfromrealTime =
     this->timeIn.getConnectedField(connectfield) &&
     connectfield == SoDB::getGlobalField("realTime");
diff --git a/coin4/src/vrml97/TouchSensor.cpp b/coin4/src/vrml97/TouchSensor.cpp
index 6784fef..45e2400 100644
--- a/coin4/src/vrml97/TouchSensor.cpp
+++ b/coin4/src/vrml97/TouchSensor.cpp
@@ -301,7 +301,7 @@ SoVRMLTouchSensor::handleEvent(SoHandleEventAction * action)
   if (mousemove || buttondown || buttonup) {
     bool isover = false;
     const SoPickedPoint * pp = action->getPickedPoint();
-    SoNode * parentnode = NULL;
+    SoNode * parentnode = nullptr;
     if (pp) {
       const SoFullPath * currpath = (const SoFullPath*) action->getCurPath();
       SoFullPath * parentpath = (SoFullPath*) currpath->copy(0, currpath->getLength()-1);
diff --git a/coin4/src/vrml97/VertexLine.cpp b/coin4/src/vrml97/VertexLine.cpp
index 882f8ea..a457b68 100644
--- a/coin4/src/vrml97/VertexLine.cpp
+++ b/coin4/src/vrml97/VertexLine.cpp
@@ -75,8 +75,8 @@ SoVRMLVertexLine::SoVRMLVertexLine(void)
 {
   SO_VRMLNODE_INTERNAL_CONSTRUCTOR(SoVRMLVertexLine);
 
-  SO_VRMLNODE_ADD_EXPOSED_FIELD(coord, (NULL));
-  SO_VRMLNODE_ADD_EXPOSED_FIELD(color, (NULL));
+  SO_VRMLNODE_ADD_EXPOSED_FIELD(coord, (nullptr));
+  SO_VRMLNODE_ADD_EXPOSED_FIELD(color, (nullptr));
   SO_VRMLNODE_ADD_FIELD(colorPerVertex, (true));
 }
 
@@ -145,7 +145,7 @@ SoVRMLVertexLine::notify(SoNotList * list)
 bool
 SoVRMLVertexLine::shouldGLRender(SoGLRenderAction * action)
 {
-  if (this->coord.getValue() == NULL) return false;
+  if (this->coord.getValue() == nullptr) return false;
   return inherited::shouldGLRender(action);
 }
 
diff --git a/coin4/src/vrml97/VertexPoint.cpp b/coin4/src/vrml97/VertexPoint.cpp
index e3a72f3..0d7c77d 100644
--- a/coin4/src/vrml97/VertexPoint.cpp
+++ b/coin4/src/vrml97/VertexPoint.cpp
@@ -69,8 +69,8 @@ SoVRMLVertexPoint::SoVRMLVertexPoint(void)
 {
   SO_VRMLNODE_INTERNAL_CONSTRUCTOR(SoVRMLVertexPoint);
 
-  SO_VRMLNODE_ADD_EXPOSED_FIELD(coord, (NULL));
-  SO_VRMLNODE_ADD_EXPOSED_FIELD(color, (NULL));
+  SO_VRMLNODE_ADD_EXPOSED_FIELD(coord, (nullptr));
+  SO_VRMLNODE_ADD_EXPOSED_FIELD(color, (nullptr));
 }
 
 /*!
@@ -140,7 +140,7 @@ SoVRMLVertexPoint::computeBBox(SoAction * COIN_UNUSED_ARG(action), SbBox3f & box
                                SbVec3f & center)
 {
   SoVRMLCoordinate * node = (SoVRMLCoordinate*) this->coord.getValue();
-  if (node == NULL) return;
+  if (node == nullptr) return;
 
   int num = node->point.getNum();
   const SbVec3f * coords = node->point.getValues(0);
@@ -168,7 +168,7 @@ SoVRMLVertexPoint::getPrimitiveCount(SoGetPrimitiveCountAction * action)
 bool
 SoVRMLVertexPoint::shouldGLRender(SoGLRenderAction * action)
 {
-  if (this->coord.getValue() == NULL) return false;
+  if (this->coord.getValue() == nullptr) return false;
   return inherited::shouldGLRender(action);
 }
 
diff --git a/coin4/src/vrml97/VertexShape.cpp b/coin4/src/vrml97/VertexShape.cpp
index fdb43f9..955b6c7 100644
--- a/coin4/src/vrml97/VertexShape.cpp
+++ b/coin4/src/vrml97/VertexShape.cpp
@@ -118,14 +118,14 @@ SoVRMLVertexShape::initClass(void)
 SoVRMLVertexShape::SoVRMLVertexShape(void)
 {
   PRIVATE(this) = new SoVRMLVertexShapeP;
-  PRIVATE(this)->normalcache = NULL;
+  PRIVATE(this)->normalcache = nullptr;
 
   SO_VRMLNODE_INTERNAL_CONSTRUCTOR(SoVRMLVertexShape);
 
-  SO_VRMLNODE_ADD_EXPOSED_FIELD(coord, (NULL));
-  SO_VRMLNODE_ADD_EXPOSED_FIELD(texCoord, (NULL));
-  SO_VRMLNODE_ADD_EXPOSED_FIELD(normal, (NULL));
-  SO_VRMLNODE_ADD_FIELD(color, (NULL));
+  SO_VRMLNODE_ADD_EXPOSED_FIELD(coord, (nullptr));
+  SO_VRMLNODE_ADD_EXPOSED_FIELD(texCoord, (nullptr));
+  SO_VRMLNODE_ADD_EXPOSED_FIELD(normal, (nullptr));
+  SO_VRMLNODE_ADD_FIELD(color, (nullptr));
   SO_VRMLNODE_ADD_FIELD(colorPerVertex, (true));
   SO_VRMLNODE_ADD_FIELD(normalPerVertex, (true));
 }
@@ -309,7 +309,7 @@ SoVRMLVertexShape::generateAndReadLockNormalCache(SoState * const state)
   //
   if (!generateDefaultNormals(state, PRIVATE(this)->normalcache)) {
     // FIXME: implement SoNormalBundle
-    if (generateDefaultNormals(state, (SoNormalBundle *)NULL)) {
+    if (generateDefaultNormals(state, (SoNormalBundle *)nullptr)) {
       // FIXME: set generator in normal cache
     }
   }
@@ -340,10 +340,10 @@ SoVRMLVertexShape::getVertexData(SoState * state,
   coords = SoCoordinateElement::getInstance(state);
   assert(coords);
 
-  normals = NULL;
+  normals = nullptr;
   if (neednormals) {
     SoVRMLNormal * node = (SoVRMLNormal*) this->normal.getValue();
-    normals = (node && node->vector.getNum()) ? node->vector.getValues(0) : NULL;
+    normals = (node && node->vector.getNum()) ? node->vector.getValues(0) : nullptr;
   }
 }
 
diff --git a/coin4/src/xml/attribute.cpp b/coin4/src/xml/attribute.cpp
index de906aa..17be597 100644
--- a/coin4/src/xml/attribute.cpp
+++ b/coin4/src/xml/attribute.cpp
@@ -54,14 +54,14 @@ cc_xml_attr_new(void)
 {
   cc_xml_attr * attr = new cc_xml_attr;
   assert(attr);
-  attr->name = NULL;
-  attr->value = NULL;
+  attr->name = nullptr;
+  attr->value = nullptr;
   return attr;
 }
 
 /*!
   Creates a new cc_xml_attr object, with the given name and value information.
-  The \a value argument can be NULL.
+  The \a value argument can be nullptr.
 */
 
 cc_xml_attr *
@@ -101,7 +101,7 @@ cc_xml_attr_delete_x(cc_xml_attr * attr)
 
 /*!
   Sets the name-part of the attribute.  Old name-information will be freed.
-  The \a name argument can be NULL to clear the setting.
+  The \a name argument can be nullptr to clear the setting.
 */
 
 void
@@ -109,13 +109,13 @@ cc_xml_attr_set_name_x(cc_xml_attr * attr, const char * name)
 {
   if (attr->name) {
     delete [] attr->name;
-    attr->name = NULL;
+    attr->name = nullptr;
   }
   if (name) attr->name = cc_xml_strdup(name);
 }
 
 /*!
-  Returns the name-part of the attribute if one is set, and NULL otherwise.
+  Returns the name-part of the attribute if one is set, and nullptr otherwise.
 */
 
 const char *
@@ -126,7 +126,7 @@ cc_xml_attr_get_name(const cc_xml_attr * attr)
 
 /*!
   Sets the value-part of the attribute.  Old information will be freed.
-  The \a value argument can be NULL to clear the information.
+  The \a value argument can be nullptr to clear the information.
 */
 
 void
@@ -134,13 +134,13 @@ cc_xml_attr_set_value_x(cc_xml_attr * attr, const char * value)
 {
   if (attr->value) {
     delete [] attr->value;
-    attr->value = NULL;
+    attr->value = nullptr;
   }
   if (value) attr->value = cc_xml_strdup(value);
 }
 
 /*!
-  Returns the value part of the attribute if one is set, or NULL otherwise.
+  Returns the value part of the attribute if one is set, or nullptr otherwise.
 */
 
 const char *
diff --git a/coin4/src/xml/document.cpp b/coin4/src/xml/document.cpp
index c535f51..d622580 100644
--- a/coin4/src/xml/document.cpp
+++ b/coin4/src/xml/document.cpp
@@ -134,13 +134,13 @@ cc_xml_doc_expat_element_start_handler_cb(void * userdata, const XML_Char * elem
   XML_Parser parser = static_cast<XML_Parser>(userdata);
   cc_xml_doc * doc = static_cast<cc_xml_doc *>(XML_GetUserData(parser));
 
-  cc_xml_elt * elt = cc_xml_elt_new_from_data(elementtype, NULL);
+  cc_xml_elt * elt = cc_xml_elt_new_from_data(elementtype, nullptr);
   assert(elt);
 
   // FIXME: check if attribute values are automatically dequoted or not...
   // (dequote if not)
   if (attributes) {
-    for (int c = 0; attributes[c] != NULL; c += 2) {
+    for (int c = 0; attributes[c] != nullptr; c += 2) {
       cc_xml_attr * attr = cc_xml_attr_new_from_data(attributes[c], attributes[c+1]);
       cc_xml_elt_set_attribute_x(elt, attr);
     }
@@ -151,7 +151,7 @@ cc_xml_doc_expat_element_start_handler_cb(void * userdata, const XML_Char * elem
     cc_xml_elt_add_child_x(parent, elt);
   }
 
-  if ((doc->parsestack.getLength() == 0) && (doc->root == NULL)) {
+  if ((doc->parsestack.getLength() == 0) && (doc->root == nullptr)) {
     cc_xml_doc_set_root_x(doc, elt);
   }
 
@@ -190,7 +190,7 @@ cc_xml_doc_expat_element_end_handler_cb(void * userdata, const XML_Char * elemen
           cc_xml_elt_delete_x(topelt);
         } else {
           if (topelt == doc->root) {
-            cc_xml_doc_set_root_x(doc, NULL);
+            cc_xml_doc_set_root_x(doc, nullptr);
             cc_xml_elt_delete_x(topelt);
           } else {
             assert(!"invalid case - investigate");
@@ -270,7 +270,7 @@ cc_xml_doc_expat_character_data_handler_cb(void * userdata, const XML_Char * cda
           cc_xml_elt * parent = doc->parsestack[doc->parsestack.getLength()-1];
           cc_xml_elt_remove_child_x(parent, elt);
           cc_xml_elt_delete_x(elt);
-          elt = NULL;
+          elt = nullptr;
         }
       }
       break;
@@ -298,7 +298,7 @@ void
 cc_xml_doc_create_parser_x(cc_xml_doc * doc)
 {
   assert(doc && !doc->parser);
-  doc->parser = XML_ParserCreate(NULL);
+  doc->parser = XML_ParserCreate(nullptr);
   assert(doc->parser);
   XML_UseParserAsHandlerArg(doc->parser);
   XML_SetUserData(doc->parser, doc);
@@ -315,7 +315,7 @@ cc_xml_doc_delete_parser_x(cc_xml_doc * doc)
 {
   assert(doc && doc->parser);
   XML_ParserFree(doc->parser);
-  doc->parser = NULL;
+  doc->parser = nullptr;
 }
 
 } // anonymous namespace
@@ -336,14 +336,14 @@ cc_xml_doc_new(void)
 {
   cc_xml_doc * doc = new cc_xml_doc;
   assert(doc);
-  doc->parser = NULL;
-  doc->xmlversion = NULL;
-  doc->xmlencoding = NULL;
-  doc->filtercb = NULL;
-  doc->filtercbdata = NULL;
-  doc->filename = NULL;
-  doc->root = NULL;
-  doc->current = NULL;
+  doc->parser = nullptr;
+  doc->xmlversion = nullptr;
+  doc->xmlencoding = nullptr;
+  doc->filtercb = nullptr;
+  doc->filtercbdata = nullptr;
+  doc->filename = nullptr;
+  doc->root = nullptr;
+  doc->current = nullptr;
   return doc;
 }
 
@@ -420,7 +420,7 @@ cc_xml_read_file(const char * path) // parser.h convenience function
   assert(doc);
   if (!cc_xml_doc_read_file_x(doc, path)) {
     cc_xml_doc_delete_x(doc);
-    return NULL;
+    return nullptr;
   }
   return doc;
 }
@@ -437,7 +437,7 @@ cc_xml_doc_read_file_x(cc_xml_doc * doc, const char * path)
   assert(doc);
   if (doc->root) {
     cc_xml_elt_delete_x(doc->root);
-    doc->root = NULL;
+    doc->root = nullptr;
   }
 
   if (!doc->parser) {
@@ -481,7 +481,7 @@ cc_xml_read_buffer(const char * buffer) // parser.h convenience function
   size_t buflen = strlen(buffer);
   if (!cc_xml_doc_read_buffer_x(doc, buffer, buflen)) {
     cc_xml_doc_delete_x(doc);
-    return NULL;
+    return nullptr;
   }
   cc_xml_doc_set_filename_x(doc, "<memory buffer>");
   return doc;
@@ -510,7 +510,7 @@ cc_xml_doc_parse_buffer_partial_init_x(cc_xml_doc * doc) // maybe expose and req
 #ifdef DEV_DEBUG
   fprintf(stdout, "cc_xml_doc_parse_buffer_partial_init_x()\n");
 #endif // DEV_DEBUG
-  assert(doc->parser == NULL);
+  assert(doc->parser == nullptr);
   cc_xml_doc_create_parser_x(doc);
 }
 }
@@ -567,13 +567,13 @@ cc_xml_doc_set_filename_x(cc_xml_doc * doc, const char * path)
   assert(doc);
   if (doc->filename) {
     delete [] doc->filename;
-    doc->filename = NULL;
+    doc->filename = nullptr;
   }
   doc->filename = cc_xml_strdup(path);
 }
 
 /*!
-  Returns the filename attribute.  If nothing has been set, NULL is returned.
+  Returns the filename attribute.  If nothing has been set, nullptr is returned.
   If document was read from memory, "<memory buffer>" was returned.
 */
 
@@ -638,9 +638,9 @@ cc_xml_doc_strip_whitespace_x(cc_xml_doc * doc)
   return;
 #if 0 // FIXME
   cc_xml_path * path = cc_xml_path_new();
-  cc_xml_path_set_x(path, CC_XML_CDATA_TYPE, NULL);
+  cc_xml_path_set_x(path, CC_XML_CDATA_TYPE, nullptr);
   cc_xml_elt * elt = cc_xml_doc_find_element(doc, path);
-  while ( elt != NULL ) {
+  while ( elt != nullptr ) {
     cc_xml_elt * next = cc_xml_doc_find_next_element(doc, elt, path);
     if ( sc_whitespace_p(cc_xml_elt_get_data(elt)) )  {
       cc_xml_elt_remove_child_x(cc_xml_elt_get_parent(elt), elt);
@@ -747,7 +747,7 @@ cc_xml_doc_write_to_file(const cc_xml_doc * doc, const char * path)
   size_t bufsize = 0;
   boost::scoped_array<char> buffer;
   {
-    char * bufptr = NULL;
+    char * bufptr = nullptr;
     if (!cc_xml_doc_write_to_buffer(doc, bufptr, bufsize)) {
       return false;
     }
@@ -757,12 +757,12 @@ cc_xml_doc_write_to_file(const cc_xml_doc * doc, const char * path)
 
   const size_t bytes = strlen(buffer.get());
   assert(bufsize == bytes);
-  FILE * fp = NULL;
+  FILE * fp = nullptr;
   if (strcmp(path, "-") == 0)
     fp = stdout;
   else
     fp = fopen(path, "wb");
-  assert(fp != NULL);
+  assert(fp != nullptr);
   fwrite(buffer.get(), 1, bufsize, fp);
   if (strcmp(path, "-") != 0)
     fclose(fp);
@@ -774,7 +774,7 @@ cc_xml_doc_write_to_file(const cc_xml_doc * doc, const char * path)
 
 /*!
   Compare document DOM against other document DOM, and return path to first
-  difference.  Returns NULL if documents are equal.  To be used mostly for
+  difference.  Returns nullptr if documents are equal.  To be used mostly for
   testing the XML I/O code.
 */
 
@@ -785,7 +785,7 @@ cc_xml_doc_diff(const cc_xml_doc * COIN_UNUSED_ARG(doc), const cc_xml_doc * COIN
   COIN_STUB();
 #endif // DEV_DEBUG
   // FIXME: implement
-  return NULL;
+  return nullptr;
 }
 
 // In documentp.h
@@ -886,12 +886,12 @@ BOOST_AUTO_TEST_CASE(bufread)
 "  <b>hei</b>\n"
 "</test>\n";
   cc_xml_doc * doc1 = cc_xml_read_buffer(buffer);
-  BOOST_CHECK_MESSAGE(doc1 != NULL, "cc_xml_doc_read_buffer() failed");
+  BOOST_CHECK_MESSAGE(doc1 != nullptr, "cc_xml_doc_read_buffer() failed");
 
   boost::scoped_array<char> buffer2;
   size_t bytecount = 0;
   {
-    char * bufptr = NULL;
+    char * bufptr = nullptr;
     cc_xml_doc_write_to_buffer(doc1, bufptr, bytecount);
     buffer2.reset(bufptr);
   }
@@ -899,7 +899,7 @@ BOOST_AUTO_TEST_CASE(bufread)
   cc_xml_doc * doc2 = cc_xml_read_buffer(buffer2.get());
 
   cc_xml_path * diffpath = cc_xml_doc_diff(doc1, doc2);
-  BOOST_CHECK_MESSAGE(diffpath == NULL, "document read->write->read DOM differences");
+  BOOST_CHECK_MESSAGE(diffpath == nullptr, "document read->write->read DOM differences");
 
   cc_xml_doc_delete_x(doc1);
   cc_xml_doc_delete_x(doc2);
diff --git a/coin4/src/xml/element.cpp b/coin4/src/xml/element.cpp
index 6515309..db39ace 100644
--- a/coin4/src/xml/element.cpp
+++ b/coin4/src/xml/element.cpp
@@ -64,16 +64,16 @@ cc_xml_elt_new(void)
 {
   cc_xml_elt * elt = new cc_xml_elt;
   assert(elt);
-  elt->type = NULL;
-  elt->data = NULL;
-  elt->cdata = NULL;
-  elt->parent = NULL;
+  elt->type = nullptr;
+  elt->data = nullptr;
+  elt->cdata = nullptr;
+  elt->parent = nullptr;
   return elt;
 }
 
 /*!
   Creates a new element with the given type and attributes.
-  The \a attrs argument can be NULL.
+  The \a attrs argument can be nullptr.
 */
 
 cc_xml_elt *
@@ -143,7 +143,7 @@ cc_xml_elt_delete_x(cc_xml_elt * elt)
 
 /*!
   Sets the element type identifier.  The old value will be freed, if any.
-  The \a type argument can be NULL to just clear the old value.
+  The \a type argument can be nullptr to just clear the old value.
 */
 
 void
@@ -152,13 +152,13 @@ cc_xml_elt_set_type_x(cc_xml_elt * elt, const char * type)
   assert(elt);
   if (elt->type) {
     delete [] elt->type;
-    elt->type = NULL;
+    elt->type = nullptr;
   }
   if (type) elt->type = cc_xml_strdup(type);
 }
 
 /*!
-  Returns the element type identifier if one is set, and NULL otherwise.
+  Returns the element type identifier if one is set, and nullptr otherwise.
 */
 
 const char *
@@ -191,12 +191,12 @@ cc_xml_elt_set_cdata_x(cc_xml_elt * elt, const char * cdata)
   }
   if ( elt->cdata ) {
     delete [] elt->cdata;
-    elt->cdata = NULL;
+    elt->cdata = nullptr;
   }
   if ( cdata ) elt->cdata = cc_xml_strdup(cdata);
   if ( elt->data ) {
     delete [] elt->data;
-    elt->data = NULL;
+    elt->data = nullptr;
   }
   // Update data to whitespace-stripped cdata
   if( cdata) {
@@ -268,7 +268,7 @@ cc_xml_elt_set_attribute_x(cc_xml_elt * elt, cc_xml_attr * attr)
 void
 cc_xml_elt_set_attributes_x(cc_xml_elt * elt, cc_xml_attr ** attrs)
 {
-  for (int c = 0; attrs[c] != NULL; ++c) {
+  for (int c = 0; attrs[c] != nullptr; ++c) {
     cc_xml_elt_set_attribute_x(elt, attrs[c]);
   }
 }
@@ -282,7 +282,7 @@ cc_xml_elt_get_attribute(const cc_xml_elt * elt, const char * attrname)
     if (strcmp(attrname, cc_xml_attr_get_name(elt->attributes[c])) == 0)
       return elt->attributes[c];
   }
-  return NULL;
+  return nullptr;
 }
 
 int
@@ -389,9 +389,9 @@ cc_xml_elt_get_path(const cc_xml_elt * elt)
 {
   assert(elt);
   cc_xml_path * path = cc_xml_path_new();
-  while ( elt != NULL ) {
+  while ( elt != nullptr ) {
     const cc_xml_elt * parent = cc_xml_elt_get_parent(elt);
-    if ( parent != NULL ) {
+    if ( parent != nullptr ) {
       int idx = cc_xml_elt_get_child_type_index(parent, elt);
       cc_xml_path_prepend_x(path, elt->type, idx);
     }
@@ -404,7 +404,7 @@ cc_xml_elt *
 cc_xml_elt_get_child_of_type(const cc_xml_elt * elt, const char * type, int idx)
 {
   assert(elt);
-  if ( !elt->children.getLength() ) return NULL;
+  if ( !elt->children.getLength() ) return nullptr;
   int i;
   for ( i = 0; i < elt->children.getLength(); i++ ) {
     if ( strcmp(elt->children[i]->type, type) == 0 ) {
@@ -412,7 +412,7 @@ cc_xml_elt_get_child_of_type(const cc_xml_elt * elt, const char * type, int idx)
       idx -= 1;
     }
   }
-  return NULL;
+  return nullptr;
 }
 
 cc_xml_elt *
@@ -428,7 +428,7 @@ cc_xml_elt_get_child_of_type_x(cc_xml_elt * elt, const char * type, int idx)
       }
     }
   }
-  cc_xml_elt * child = NULL;
+  cc_xml_elt * child = nullptr;
   while ( idx >= 0 ) {
     child = cc_xml_elt_new();
     cc_xml_elt_set_type_x(child, type);
@@ -452,7 +452,7 @@ cc_xml_elt_add_child_x(cc_xml_elt * elt, cc_xml_elt * child)
 {
   assert(elt);
   assert(child);
-  if (child->parent != NULL) {
+  if (child->parent != nullptr) {
     // FIXME: ERROR - element already a child of another element
     return;
   }
@@ -476,7 +476,7 @@ cc_xml_elt_remove_child_x(cc_xml_elt * elt, cc_xml_elt * child)
   for (int i = 0; i < numchildren; ++i) {
     if (elt->children[i] == child) {
       elt->children.remove(i);
-      child->parent = NULL;
+      child->parent = nullptr;
       return;
     }
   }
@@ -488,7 +488,7 @@ cc_xml_elt_insert_child_x(cc_xml_elt * elt, cc_xml_elt * child, int idx)
 {
   assert(elt);
   assert(child);
-  if (child->parent != NULL) {
+  if (child->parent != nullptr) {
     // FIXME: error, child already a child of another element
     return;
   }
@@ -524,8 +524,8 @@ cc_xml_elt_get_boolean(const cc_xml_elt * elt, int * value)
     }
   }
   const char * data = cc_xml_elt_get_data(elt);
-  assert(value != NULL);
-  if ( data == NULL ) return false;
+  assert(value != nullptr);
+  if ( data == nullptr ) return false;
   if ( cc_xml_strieq(data, "true") ||
        cc_xml_strieq(data, "on") ||
        cc_xml_strieq(data, "t") ) {
@@ -554,8 +554,8 @@ cc_xml_elt_get_integer(const cc_xml_elt * elt, int * value)
     }
   }
   const char * data = cc_xml_elt_get_data(elt);
-  assert(value != NULL);
-  if ( data == NULL ) return false;
+  assert(value != nullptr);
+  if ( data == nullptr ) return false;
   if ( sscanf(data, "%d", value) == 1 ) return true;
   return false;
 }
@@ -573,8 +573,8 @@ cc_xml_elt_get_uint64(const cc_xml_elt * elt, uint64_t * value)
     }
   }
   const char * data = cc_xml_elt_get_data(elt);
-  assert(value != NULL);
-  if ( data == NULL ) return false;
+  assert(value != nullptr);
+  if ( data == nullptr ) return false;
   if ( sscanf(data, "%lld", value) == 1 ) return true; // FIXME: unsigned
   return false;
 }
@@ -592,8 +592,8 @@ cc_xml_elt_get_int64(const cc_xml_elt * elt, int64_t * value)
     }
   }
   const char * data = cc_xml_elt_get_data(elt);
-  assert(value != NULL);
-  if ( data == NULL ) return false;
+  assert(value != nullptr);
+  if ( data == nullptr ) return false;
   if ( sscanf(data, "%lld", value) == 1 ) return true;
   return false;
 }
@@ -611,8 +611,8 @@ cc_xml_elt_get_uint32(const cc_xml_elt * elt, uint32_t * value)
     }
   }
   const char * data = cc_xml_elt_get_data(elt);
-  assert(value != NULL);
-  if ( data == NULL ) return false;
+  assert(value != nullptr);
+  if ( data == nullptr ) return false;
   if ( sscanf(data, "%u", value) == 1 ) return true; // FIXME: unsigned
   return false;
 }
@@ -630,8 +630,8 @@ cc_xml_elt_get_int32(const cc_xml_elt * elt, int32_t * value)
     }
   }
   const char * data = cc_xml_elt_get_data(elt);
-  assert(value != NULL);
-  if ( data == NULL ) return false;
+  assert(value != nullptr);
+  if ( data == nullptr ) return false;
   if ( sscanf(data, "%u", value) == 1 ) return true;
   return false;
 }
@@ -649,8 +649,8 @@ cc_xml_elt_get_float(const cc_xml_elt * elt, float * value)
     }
   }
   const char * data = cc_xml_elt_get_data(elt);
-  assert(value != NULL);
-  if ( data == NULL ) return false;
+  assert(value != nullptr);
+  if ( data == nullptr ) return false;
   if ( sscanf(data, "%g", value) == 1 ) return true;
   return false;
 }
@@ -668,8 +668,8 @@ cc_xml_elt_get_double(const cc_xml_elt * elt, double * value)
     }
   }
   const char * data = cc_xml_elt_get_data(elt);
-  assert(value != NULL);
-  if ( data == NULL ) return false;
+  assert(value != nullptr);
+  if ( data == nullptr ) return false;
   if ( sscanf(data, "%lg", value) == 1 ) return true;
   return false;
 }
@@ -876,12 +876,12 @@ cc_xml_elt_dump_to_file(const cc_xml_elt * elt, int indent, FILE * fp)
   // todo
   // - support notation for empty elements and shortcuts
   // - document-wide settings?  how to propagate...
-  assert( elt && elt->type != NULL );
+  assert( elt && elt->type != nullptr );
   int i;
   if ( cc_xml_elt_get_num_children(elt) == 1 &&
        strcmp(COIN_XML_CDATA_TYPE, elt->children[0]->type) == 0 ) {
     for ( i = 0; i < indent; i++ ) fprintf(fp, " ");
-    if ( elt->children[0]->data != NULL )
+    if ( elt->children[0]->data != nullptr )
       fprintf(fp, "<%s>%s</%s>\n", elt->type, elt->children[0]->data, elt->type);
     else
       fprintf(fp, "<%s/>\n", elt->type);
@@ -895,7 +895,7 @@ cc_xml_elt_dump_to_file(const cc_xml_elt * elt, int indent, FILE * fp)
     }
     for ( i = 0; i < indent; i++ ) fprintf(fp, " ");
     fprintf(fp, "</%s>\n", elt->type);
-  } else if ( elt->data != NULL ) {
+  } else if ( elt->data != nullptr ) {
     for ( i = 0; i < indent; i++ ) fprintf(fp, " ");
     fprintf(fp, "%s\n", elt->data);
   }
@@ -929,13 +929,13 @@ cc_xml_elt_get_traversal_next(const cc_xml_elt * root, cc_xml_elt * here)
   // if we're here then 'here' has no children (except possibly cdata).
   do {
     cc_xml_elt * parent = cc_xml_elt_get_parent(here);
-    if (parent == NULL) return NULL; // here is the root
+    if (parent == nullptr) return nullptr; // here is the root
     int idx = cc_xml_elt_get_child_index(parent, here);
     // if 'here' was the last child then set here as parent..
     if (idx == (cc_xml_elt_get_num_children(parent) - 1)) {
       here = parent;
       // if we're back to root, simply quit..
-      if (here == root) return NULL;
+      if (here == root) return nullptr;
     } else {
       // there is more children than 'here' left, find someone thats not "cdata".
       do {
@@ -949,7 +949,7 @@ cc_xml_elt_get_traversal_next(const cc_xml_elt * root, cc_xml_elt * here)
     }
   } while (true);
 
-  return NULL;
+  return nullptr;
 } // cc_xml_elt_get_traversal_next()
 
 // *************************************************************************
@@ -959,7 +959,7 @@ cc_xml_elt_find(const cc_xml_elt * root, const cc_xml_path * path)
 {
   assert(root && path);
   cc_xml_elt * elt = const_cast<cc_xml_elt *>(root);
-  while ( (elt != NULL) && (!cc_xml_path_match_p(path, elt)) ) {
+  while ( (elt != nullptr) && (!cc_xml_path_match_p(path, elt)) ) {
     elt = cc_xml_elt_get_traversal_next(root, elt);
   }
   return elt;
@@ -972,7 +972,7 @@ cc_xml_elt_find_next(const cc_xml_elt * root, cc_xml_elt * from, cc_xml_path * p
   cc_xml_elt * elt = from;
   do {
     elt = cc_xml_elt_get_traversal_next(root, elt);
-  } while ( (elt != NULL) && (!cc_xml_path_match_p(path, elt)) );
+  } while ( (elt != nullptr) && (!cc_xml_path_match_p(path, elt)) );
   return elt;
 } // cc_xml_elt_find_next()
 
diff --git a/coin4/src/xml/entity.cpp b/coin4/src/xml/entity.cpp
index 72d3235..75a8193 100644
--- a/coin4/src/xml/entity.cpp
+++ b/coin4/src/xml/entity.cpp
@@ -43,8 +43,8 @@ cc_xml_ent *
 cc_xml_ent_new(void)
 {
   cc_xml_ent * ent = new cc_xml_ent;
-  ent->name = NULL;
-  ent->value = NULL;
+  ent->name = nullptr;
+  ent->value = nullptr;
   return ent;
 }
 
