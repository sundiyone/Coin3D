.TH "SoInteractionKit" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SoInteractionKit \- The \fBSoInteractionKit\fP class is a base class for draggers\&.
.PP
This nodekit class makes it possible to set surrogate paths for parts\&. Instead of creating new geometry for the dragger, it is possible to specify an existing path in your scene to be used for interaction\&. All picks on this path will be handled by the dragger\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Inventor/nodekits/SoInteractionKit\&.h>\fP
.PP
Inherits \fBSoBaseKit\fP\&.
.PP
Inherited by \fBSoDragger\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBCacheEnabled\fP { \fBOFF\fP, \fBON\fP, \fBAUTO\fP }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fBSoType\fP \fBgetTypeId\fP (void) const"
.br
.RI "Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. "
.ti -1c
.RI "virtual const \fBSoNodekitCatalog\fP * \fBgetNodekitCatalog\fP (void) const"
.br
.ti -1c
.RI "\fBSoInteractionKit\fP (void)"
.br
.ti -1c
.RI "virtual SbBool \fBsetPartAsPath\fP (const \fBSbName\fP &partname, \fBSoPath\fP *path)"
.br
.ti -1c
.RI "virtual SbBool \fBsetPartAsDefault\fP (const \fBSbName\fP &partname, \fBSoNode\fP *node, SbBool onlyifdefault=TRUE)"
.br
.ti -1c
.RI "virtual SbBool \fBsetPartAsDefault\fP (const \fBSbName\fP &partname, const \fBSbName\fP &nodename, SbBool onlyifdefault=TRUE)"
.br
.ti -1c
.RI "SbBool \fBisPathSurrogateInMySubgraph\fP (const \fBSoPath\fP *path, \fBSoPath\fP *&pathToOwner, \fBSbName\fP &surrogatename, \fBSoPath\fP *&surrogatepath, SbBool fillargs=TRUE)"
.br
.ti -1c
.RI "SbBool \fBisPathSurrogateInMySubgraph\fP (const \fBSoPath\fP *path)"
.br
.ti -1c
.RI "virtual SbBool \fBsetPart\fP (const \fBSbName\fP &partname, \fBSoNode\fP *from)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBSoType\fP \fBgetClassTypeId\fP (void)"
.br
.ti -1c
.RI "static const \fBSoNodekitCatalog\fP * \fBgetClassNodekitCatalog\fP (void)"
.br
.ti -1c
.RI "static void \fBinitClass\fP (void)"
.br
.ti -1c
.RI "static void \fBsetSwitchValue\fP (\fBSoNode\fP *node, const \fBint\fP newVal)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBSoSFEnum\fP \fBrenderCaching\fP"
.br
.ti -1c
.RI "\fBSoSFEnum\fP \fBboundingBoxCaching\fP"
.br
.ti -1c
.RI "\fBSoSFEnum\fP \fBrenderCulling\fP"
.br
.ti -1c
.RI "\fBSoSFEnum\fP \fBpickCulling\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual const \fBSoFieldData\fP * \fBgetFieldData\fP (void) const"
.br
.ti -1c
.RI "virtual \fB~SoInteractionKit\fP ()"
.br
.ti -1c
.RI "virtual void \fBcopyContents\fP (const \fBSoFieldContainer\fP *fromFC, SbBool copyConnections)"
.br
.ti -1c
.RI "virtual SbBool \fBsetPart\fP (const \fBint\fP partNum, \fBSoNode\fP *node)"
.br
.ti -1c
.RI "virtual SbBool \fBreadInstance\fP (\fBSoInput\fP *in, unsigned short flags)"
.br
.ti -1c
.RI "virtual SbBool \fBsetAnyPartAsDefault\fP (const \fBSbName\fP &partname, \fBSoNode\fP *node, SbBool anypart=TRUE, SbBool onlyifdefault=TRUE)"
.br
.ti -1c
.RI "virtual SbBool \fBsetAnyPartAsDefault\fP (const \fBSbName\fP &partname, const \fBSbName\fP &nodename, SbBool anypart=TRUE, SbBool onlyifdefault=TRUE)"
.br
.ti -1c
.RI "SbBool \fBsetAnySurrogatePath\fP (const \fBSbName\fP &name, \fBSoPath\fP *path, SbBool leafcheck=FALSE, SbBool publiccheck=FALSE)"
.br
.ti -1c
.RI "virtual SbBool \fBsetUpConnections\fP (SbBool onoff, SbBool doitalways=FALSE)"
.br
.ti -1c
.RI "virtual void \fBsetDefaultOnNonWritingFields\fP ()"
.br
.ti -1c
.RI "void \fBconnectSeparatorFields\fP (\fBSoSeparator\fP *dest, SbBool onOff)"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static const \fBSoFieldData\fP ** \fBgetFieldDataPtr\fP (void)"
.br
.ti -1c
.RI "static const \fBSoNodekitCatalog\fP ** \fBgetClassNodekitCatalogPtr\fP (void)"
.br
.ti -1c
.RI "static void \fBreadDefaultParts\fP (const char *fileName, const char defaultBuffer[], \fBint\fP defBufSize)"
.br
.ti -1c
.RI "static void \fBfieldSensorCB\fP (void *, \fBSoSensor\fP *)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBSoSFNode\fP \fBgeomSeparator\fP"
.br
.ti -1c
.RI "\fBSoSFNode\fP \fBtopSeparator\fP"
.br
.ti -1c
.RI "\fBSoFieldSensor\fP * \fBfieldSensor\fP"
.br
.ti -1c
.RI "\fBSoSeparator\fP * \fBoldTopSep\fP"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
The \fBSoInteractionKit\fP class is a base class for draggers\&.
.PP
This nodekit class makes it possible to set surrogate paths for parts\&. Instead of creating new geometry for the dragger, it is possible to specify an existing path in your scene to be used for interaction\&. All picks on this path will be handled by the dragger\&. 

The \fBSoInteractionKit\fP is primarily an internal class used as a superclass for the dragger classes, and it is unlikely that it should be of interest to application programmers, unless you have very special needs in your application\&.
.PP
Node kit structure (new entries versus parent class marked with arrow prefix):
.PP
.PP
.nf
CLASS SoInteractionKit
-->"this"
      "callbackList"
-->   "topSeparator"
-->      "geomSeparator"
.fi
.PP
.PP
(See \fBSoBaseKit::printDiagram()\fP for information about the output formatting\&.)
.PP
Detailed information on catalog parts:
.PP
.PP
.nf
CLASS SoInteractionKit
PVT   "this",  SoInteractionKit  --- 
      "callbackList",  SoNodeKitListPart [ SoCallback, SoEventCallback ] 
PVT   "topSeparator",  SoSeparator  --- 
PVT   "geomSeparator",  SoSeparator  --- 
.fi
.PP
.PP
(See \fBSoBaseKit::printTable()\fP for information about the output formatting\&.) 
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBSoInteractionKit::CacheEnabled\fP"
Enumeration of valid values for the cache control fields \fBSoInteractionKit::renderCaching\fP, \fBSoInteractionKit::boundingBoxCaching\fP, \fBSoInteractionKit::renderCulling\fP and \fBSoInteractionKit::pickCulling\fP\&.
.PP
The same values with the same semantics are present in this enum as for \fBSoSeparator::CacheEnabled\fP, so see that documentation\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SoInteractionKit::SoInteractionKit (void)"
Constructor\&. 
.SS "SoInteractionKit::~SoInteractionKit ()\fC [protected]\fP, \fC [virtual]\fP"
Destructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBSoType\fP SoInteractionKit::getTypeId (void) const\fC [virtual]\fP"

.PP
Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. Usage example:
.PP
.PP
.nf
void foo(SoNode * node)
{
  if (node->getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
.fi
.PP
.PP
For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in \fIall\fP subclasses\&. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance \fBInventor/nodes/SoSubNode\&.h\fP (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), \fBInventor/engines/SoSubEngine\&.h\fP (for engine classes) and so on\&.
.PP
For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups\&. 
.PP
Reimplemented from \fBSoBaseKit\fP\&.
.PP
Reimplemented in \fBSoDragger\fP, \fBSoTrackballDragger\fP, \fBSoTransformerDragger\fP, \fBSoSpotLightDragger\fP, \fBSoRotateSphericalDragger\fP, \fBSoScale2UniformDragger\fP, \fBSoTabPlaneDragger\fP, \fBSoTranslate1Dragger\fP, \fBSoTranslate2Dragger\fP, \fBSoHandleBoxDragger\fP, \fBSoScale2Dragger\fP, \fBSoRotateCylindricalDragger\fP, \fBSoScale1Dragger\fP, \fBSoScaleUniformDragger\fP, \fBSoDirectionalLightDragger\fP, \fBSoJackDragger\fP, \fBSoRotateDiscDragger\fP, \fBSoCenterballDragger\fP, \fBSoTransformBoxDragger\fP, \fBSoPointLightDragger\fP, \fBSoDragPointDragger\fP, and \fBSoTabBoxDragger\fP\&.
.SS "const \fBSoFieldData\fP * SoInteractionKit::getFieldData (void) const\fC [protected]\fP, \fC [virtual]\fP"
Returns a pointer to the class-wide field data storage object for this instance\&. If no fields are present, returns \fCNULL\fP\&. 
.PP
Reimplemented from \fBSoBaseKit\fP\&.
.PP
Reimplemented in \fBSoDragger\fP, \fBSoTrackballDragger\fP, \fBSoTransformerDragger\fP, \fBSoSpotLightDragger\fP, \fBSoRotateSphericalDragger\fP, \fBSoScale2UniformDragger\fP, \fBSoTabPlaneDragger\fP, \fBSoTranslate1Dragger\fP, \fBSoTranslate2Dragger\fP, \fBSoHandleBoxDragger\fP, \fBSoScale2Dragger\fP, \fBSoRotateCylindricalDragger\fP, \fBSoScale1Dragger\fP, \fBSoScaleUniformDragger\fP, \fBSoDirectionalLightDragger\fP, \fBSoJackDragger\fP, \fBSoRotateDiscDragger\fP, \fBSoCenterballDragger\fP, \fBSoTransformBoxDragger\fP, \fBSoPointLightDragger\fP, \fBSoDragPointDragger\fP, and \fBSoTabBoxDragger\fP\&.
.SS "const \fBSoNodekitCatalog\fP * SoInteractionKit::getNodekitCatalog (void) const\fC [virtual]\fP"
Returns the nodekit catalog which defines the layout of this class' kit\&. 
.PP
Reimplemented from \fBSoBaseKit\fP\&.
.PP
Reimplemented in \fBSoDragger\fP, \fBSoTrackballDragger\fP, \fBSoTransformerDragger\fP, \fBSoSpotLightDragger\fP, \fBSoRotateSphericalDragger\fP, \fBSoScale2UniformDragger\fP, \fBSoTabPlaneDragger\fP, \fBSoTranslate1Dragger\fP, \fBSoTranslate2Dragger\fP, \fBSoHandleBoxDragger\fP, \fBSoScale2Dragger\fP, \fBSoRotateCylindricalDragger\fP, \fBSoScale1Dragger\fP, \fBSoScaleUniformDragger\fP, \fBSoDirectionalLightDragger\fP, \fBSoJackDragger\fP, \fBSoRotateDiscDragger\fP, \fBSoCenterballDragger\fP, \fBSoTransformBoxDragger\fP, \fBSoPointLightDragger\fP, \fBSoDragPointDragger\fP, and \fBSoTabBoxDragger\fP\&.
.SS "SbBool SoInteractionKit::setPartAsPath (const \fBSbName\fP & partname, \fBSoPath\fP * path)\fC [virtual]\fP"
Sets a part in the kit as a surrogate path\&. The \fIpartname\fP part is set to \fCNULL\fP, and the surrogate path is remembered\&. Following picks on the surrogate path will be regarded as a pick on \fIpartname\fP\&. 
.SS "SbBool SoInteractionKit::setPartAsDefault (const \fBSbName\fP & partname, \fBSoNode\fP * node, SbBool onlyifdefault = \fCTRUE\fP)\fC [virtual]\fP"
Sets the value of \fIpartname\fP to \fInode\fP, and sets the part's field to default (i\&.e\&. node will not be written on scene graph export)\&.
.PP
If \fIonlyifdefault\fP is \fCTRUE\fP, \fIpartname\fP is only set if it is already in the default state\&.
.PP
The reason for this method is to make it possible for dragger subclasses to avoid having their default parts written out on export\&. 
.SS "SbBool SoInteractionKit::setPartAsDefault (const \fBSbName\fP & partname, const \fBSbName\fP & nodename, SbBool onlyifdefault = \fCTRUE\fP)\fC [virtual]\fP"
Find node in the global dictionary, and set as default\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetPartAsDefault()\fP 
.RE
.PP

.SS "SbBool SoInteractionKit::isPathSurrogateInMySubgraph (const \fBSoPath\fP * path, \fBSoPath\fP *& pathToOwner, \fBSbName\fP & surrogatename, \fBSoPath\fP *& surrogatepath, SbBool fillargs = \fCTRUE\fP)"
Checks if \fIpath\fP is contained within any of the surrogate paths in any interaction kits from this node down\&. Returns information about the owner and the surrogate path if found, and \fIfillargs\fP is \fITRUE\fP\&. The returned path (\fIpathToOwner\fP) is not ref'ed, It's the callers responsibility to ref and unref this path\&. 
.SS "SbBool SoInteractionKit::isPathSurrogateInMySubgraph (const \fBSoPath\fP * path)"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. 
.SS "void SoInteractionKit::setSwitchValue (\fBSoNode\fP * node, const \fBint\fP newVal)\fC [static]\fP"
Convenience method that sets the switch value for a switch node\&. Checks if node != 0, and only sets the switch value if value has changed\&. 
.SS "SbBool SoInteractionKit::setPart (const \fBSbName\fP & partname, \fBSoNode\fP * from)\fC [virtual]\fP"
Sets the catalog part given by \fIpartname\fP to the \fIfrom\fP node pointer\&. 
.PP
Reimplemented from \fBSoBaseKit\fP\&.
.SS "void SoInteractionKit::copyContents (const \fBSoFieldContainer\fP * from, SbBool copyconnections)\fC [protected]\fP, \fC [virtual]\fP"
Makes a deep copy of all data of \fIfrom\fP into this instance, \fIexcept\fP external scenegraph references if \fIcopyconnections\fP is \fCFALSE\fP\&.
.PP
This is the method that should be overridden by extension node / engine / dragger / whatever subclasses which needs to account for internal data that are not handled automatically\&.
.PP
For copying nodes from application code, you should not invoke this function directly, but rather call the \fBSoNode::copy()\fP function:
.PP
.PP
.nf
SoNode * mynewnode = templatenode->copy();
.fi
.PP
.PP
The same also goes for engines\&.
.PP
Make sure that when you override the \fBcopyContents()\fP method in your extension class that you also make it call upwards to it's parent superclass in the inheritance hierarchy, as \fBcopyContents()\fP in for instance \fBSoNode\fP and \fBSoFieldContainer\fP does important work\&. It should go something like this:
.PP
.PP
.nf
void
MyCoinExtensionNode::copyContents(const SoFieldContainer * from,
                                  SbBool copyconnections)
{
  // let parent superclasses do their thing (copy fields, copy
  // instance name, etc etc)
  SoNode::copyContents(from, copyconnections);

  // [\&.\&.then copy internal data\&.\&.]
}
.fi
.PP
 
.PP
Reimplemented from \fBSoBaseKit\fP\&.
.PP
Reimplemented in \fBSoRotateSphericalDragger\fP, and \fBSoRotateCylindricalDragger\fP\&.
.SS "SbBool SoInteractionKit::setPart (const \fBint\fP partnum, \fBSoNode\fP * node)\fC [protected]\fP, \fC [virtual]\fP"
Sets parts, updates nodekit scene graph, and makes sure graph is valid with respect to right siblings and parent\&. This method is virtual to enable subclasses to detect when a part changes value\&.
.PP
This method is not part of the original SGI Open Inventor API, but is an extension specific to Coin\&. 
.PP
Reimplemented from \fBSoBaseKit\fP\&.
.SS "SbBool SoInteractionKit::readInstance (\fBSoInput\fP * in, unsigned short flags)\fC [protected]\fP, \fC [virtual]\fP"
This method is mainly intended for internal use during file import operations\&.
.PP
It reads a definition of an instance from the input stream \fIin\fP\&. The input stream state points to the start of a serialized / persistant representation of an instance of this class type\&.
.PP
\fCTRUE\fP or \fCFALSE\fP is returned, depending on if the instantiation and configuration of the new object of this class type went ok or not\&. The import process should be robust and handle corrupted input streams by returning \fCFALSE\fP\&.
.PP
\fIflags\fP is used internally during binary import when reading user extension nodes, group nodes or engines\&. 
.PP
Reimplemented from \fBSoBaseKit\fP\&.
.SS "void SoInteractionKit::readDefaultParts (const char * fileName, const char defaultBuffer[], \fBint\fP defBufSize)\fC [static]\fP, \fC [protected]\fP"
Reads default parts for a dragger\&.
.PP
This method is called from dragger constructors to set up a dragger's nodekit catalog of interaction and feedback geometry\&.
.PP
\fIfileName\fP is the user-changeable resource file in the Inventor file format, while \fIdefaultBuffer\fP and \fIdefBufSize\fP can point to the statically compiled default parts\&.
.PP
The environment variable \fCSO_DRAGGER_DIR\fP must be set to a valid directory prefix for \fIfileName\fP, or no resource file will be loaded (and \fIdefaultBuffer\fP will be used instead)\&.
.PP
If both a \fIfileName\fP and a \fIdefaultBuffer\fP is provided, the file will be attempted found and loaded first, if that fails, the geometry will be attempted read from the buffer\&. 
.SS "SbBool SoInteractionKit::setAnyPartAsDefault (const \fBSbName\fP & partname, \fBSoNode\fP * node, SbBool anypart = \fCTRUE\fP, SbBool onlyifdefault = \fCTRUE\fP)\fC [protected]\fP, \fC [virtual]\fP"
Protected version of \fBsetPartAsDefault()\fP, to make it possible to set non-leaf and private parts (if \fIanypart\fP is \fCTRUE\fP)\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetPartAsDefault()\fP 
.RE
.PP

.SS "SbBool SoInteractionKit::setAnyPartAsDefault (const \fBSbName\fP & partname, const \fBSbName\fP & nodename, SbBool anypart = \fCTRUE\fP, SbBool onlyifdefault = \fCTRUE\fP)\fC [protected]\fP, \fC [virtual]\fP"
Protected version of \fBsetPartAsDefault()\fP, to make it possible to set non-leaf and private parts (if anypart is \fCTRUE\fP)\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetPartAsDefault()\fP 
.RE
.PP

.SS "SbBool SoInteractionKit::setAnySurrogatePath (const \fBSbName\fP & partname, \fBSoPath\fP * path, SbBool leafcheck = \fCFALSE\fP, SbBool publiccheck = \fCFALSE\fP)\fC [protected]\fP"
Protected version of \fBsetPartAsPath()\fP, to make it possible to set non-leaf and private parts\&.
.PP
('The nice thing about C++ is that only your friends can handle your
private parts\&.')
.PP
\fBSee also:\fP
.RS 4
\fBsetPartAsPath()\fP 
.RE
.PP

.SS "SbBool SoInteractionKit::setUpConnections (SbBool onoff, SbBool doitalways = \fCFALSE\fP)\fC [protected]\fP, \fC [virtual]\fP"
Sets up all internal connections for instances of this class\&.
.PP
(This method will usually not be of interest to the application programmer, unless you want to extend the library with new custom nodekits or dragger classes\&. If so, see the \fBSoBaseKit\fP class documentation\&.) 
.PP
Reimplemented from \fBSoBaseKit\fP\&.
.PP
Reimplemented in \fBSoTransformerDragger\fP, \fBSoHandleBoxDragger\fP, \fBSoDragPointDragger\fP, \fBSoTransformBoxDragger\fP, \fBSoTrackballDragger\fP, \fBSoCenterballDragger\fP, \fBSoTabPlaneDragger\fP, \fBSoTabBoxDragger\fP, \fBSoSpotLightDragger\fP, \fBSoTranslate2Dragger\fP, \fBSoRotateSphericalDragger\fP, \fBSoRotateCylindricalDragger\fP, \fBSoTranslate1Dragger\fP, \fBSoDirectionalLightDragger\fP, \fBSoScale2UniformDragger\fP, \fBSoJackDragger\fP, \fBSoScale2Dragger\fP, \fBSoScale1Dragger\fP, \fBSoScaleUniformDragger\fP, \fBSoRotateDiscDragger\fP, and \fBSoPointLightDragger\fP\&.
.SS "void SoInteractionKit::setDefaultOnNonWritingFields (void)\fC [protected]\fP, \fC [virtual]\fP"
(Be aware that this method is unlikely to be of interest to the application programmer who does not want to extend the library with new custom nodekits or draggers\&. If you indeed \fIare\fP writing extensions, see the information in the \fBSoBaseKit\fP class documentation\&.)
.PP
This is a virtual method, and the code in it should call \fBSoField::setDefault()\fP with argument \fCTRUE\fP on part fields that should not be written upon scenegraph export operations\&.
.PP
This is typically done when:
.PP
.PD 0
.IP "1." 4
field value is \fCNULL\fP and part is \fCNULL\fP by default 
.PP

.IP "2." 4
it is a leaf \fBSoGroup\fP or \fBSoSeparator\fP node with no children 
.PP

.IP "3." 4
it is a leaf listpart with no children and an \fBSoGroup\fP or \fBSoSeparator\fP container 
.PP

.IP "4." 4
it is a non-leaf part and it's of \fBSoGroup\fP type and all fields are at their default values 
.PP

.PP
.PP
Subclasses should usually override this to do additional settings for new member fields\&. From the subclass, do remember to call 'upwards' to your superclass' \fBsetDefaultOnNonWritingFields()\fP method\&. 
.PP
Reimplemented from \fBSoBaseKit\fP\&.
.PP
Reimplemented in \fBSoTransformerDragger\fP, \fBSoDragger\fP, \fBSoHandleBoxDragger\fP, \fBSoDragPointDragger\fP, \fBSoTransformBoxDragger\fP, \fBSoTrackballDragger\fP, \fBSoCenterballDragger\fP, \fBSoTabPlaneDragger\fP, \fBSoTabBoxDragger\fP, \fBSoSpotLightDragger\fP, \fBSoDirectionalLightDragger\fP, \fBSoJackDragger\fP, and \fBSoPointLightDragger\fP\&.
.SS "void SoInteractionKit::fieldSensorCB (void * d, \fBSoSensor\fP * s)\fC [static]\fP, \fC [protected]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "void SoInteractionKit::connectSeparatorFields (\fBSoSeparator\fP * dest, SbBool onOff)\fC [protected]\fP"
Obsoleted in Coin\&. 
.SH "Member Data Documentation"
.PP 
.SS "\fBSoSFEnum\fP SoInteractionKit::renderCaching"
Controls the value of the \fBSoSeparator::renderCaching\fP field in the \fBSoInteractionKit\fP catalog's topSeparator instance\&.
.PP
See documentation of \fBSoSeparator::renderCaching\fP\&. 
.SS "\fBSoSFEnum\fP SoInteractionKit::boundingBoxCaching"
Controls the value of the \fBSoSeparator::boundingBoxCaching\fP field in the \fBSoInteractionKit\fP catalog's topSeparator instance\&.
.PP
See documentation of \fBSoSeparator::boundingBoxCaching\fP\&. 
.SS "\fBSoSFEnum\fP SoInteractionKit::renderCulling"
Controls the value of the \fBSoSeparator::renderCulling\fP field in the \fBSoInteractionKit\fP catalog's topSeparator instance\&.
.PP
See documentation of \fBSoSeparator::renderCulling\fP\&. 
.SS "\fBSoSFEnum\fP SoInteractionKit::pickCulling"
Controls the value of the \fBSoSeparator::pickCulling\fP field in the \fBSoInteractionKit\fP catalog's topSeparator instance\&.
.PP
See documentation of \fBSoSeparator::pickCulling\fP\&. 
.SS "\fBSoFieldSensor\fP * SoInteractionKit::fieldSensor\fC [protected]\fP"
Obsoleted in Coin\&. 
.SS "\fBSoFieldSensor\fP * SoInteractionKit::oldTopSep\fC [protected]\fP"
Obsoleted in Coin\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
