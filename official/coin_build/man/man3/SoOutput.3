.TH "SoOutput" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SoOutput \- The \fBSoOutput\fP class is an abstraction of an output stream\&.
.PP
\fBSoOutput\fP offers the ability to write basic types to a file or a memory buffer in either ASCII or binary format\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Inventor/SoOutput\&.h>\fP
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBStage\fP { \fBCOUNT_REFS\fP, \fBWRITE\fP }"
.br
.ti -1c
.RI "enum \fBAnnotations\fP { \fBADDRESSES\fP = 0x01, \fBREF_COUNTS\fP = 0x02 }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSoOutput\fP (void)"
.br
.ti -1c
.RI "\fBSoOutput\fP (\fBSoOutput\fP *dictOut)"
.br
.ti -1c
.RI "virtual \fB~SoOutput\fP ()"
.br
.ti -1c
.RI "virtual void \fBsetFilePointer\fP (FILE *newFP)"
.br
.ti -1c
.RI "virtual FILE * \fBgetFilePointer\fP (void) const"
.br
.ti -1c
.RI "virtual SbBool \fBopenFile\fP (const char *const fileName)"
.br
.ti -1c
.RI "virtual void \fBcloseFile\fP (void)"
.br
.ti -1c
.RI "SbBool \fBsetCompression\fP (const \fBSbName\fP &compmethod, const float level=0\&.5f)"
.br
.ti -1c
.RI "virtual void \fBsetBuffer\fP (void *bufPointer, size_t initSize, SoOutputReallocCB *reallocFunc, int32_t offset=0)"
.br
.ti -1c
.RI "virtual SbBool \fBgetBuffer\fP (void *&bufPointer, size_t &nBytes) const"
.br
.ti -1c
.RI "virtual size_t \fBgetBufferSize\fP (void) const"
.br
.ti -1c
.RI "virtual void \fBresetBuffer\fP (void)"
.br
.ti -1c
.RI "virtual void \fBsetBinary\fP (const SbBool flag)"
.br
.ti -1c
.RI "virtual SbBool \fBisBinary\fP (void) const"
.br
.ti -1c
.RI "virtual void \fBsetHeaderString\fP (const \fBSbString\fP &str)"
.br
.ti -1c
.RI "virtual void \fBresetHeaderString\fP (void)"
.br
.ti -1c
.RI "virtual void \fBsetFloatPrecision\fP (const \fBint\fP precision)"
.br
.ti -1c
.RI "void \fBsetStage\fP (\fBStage\fP stage)"
.br
.ti -1c
.RI "\fBStage\fP \fBgetStage\fP (void) const"
.br
.ti -1c
.RI "void \fBincrementIndent\fP (const \fBint\fP levels=1)"
.br
.ti -1c
.RI "void \fBdecrementIndent\fP (const \fBint\fP levels=1)"
.br
.ti -1c
.RI "virtual void \fBwrite\fP (const char c)"
.br
.ti -1c
.RI "virtual void \fBwrite\fP (const char *s)"
.br
.ti -1c
.RI "virtual void \fBwrite\fP (const \fBSbString\fP &s)"
.br
.ti -1c
.RI "virtual void \fBwrite\fP (const \fBSbName\fP &n)"
.br
.ti -1c
.RI "virtual void \fBwrite\fP (const \fBint\fP i)"
.br
.ti -1c
.RI "virtual void \fBwrite\fP (const unsigned \fBint\fP i)"
.br
.ti -1c
.RI "virtual void \fBwrite\fP (const short s)"
.br
.ti -1c
.RI "virtual void \fBwrite\fP (const unsigned short s)"
.br
.ti -1c
.RI "virtual void \fBwrite\fP (const float f)"
.br
.ti -1c
.RI "virtual void \fBwrite\fP (const double d)"
.br
.ti -1c
.RI "virtual void \fBwriteBinaryArray\fP (const unsigned char *c, const \fBint\fP length)"
.br
.ti -1c
.RI "virtual void \fBwriteBinaryArray\fP (const int32_t *const l, const \fBint\fP length)"
.br
.ti -1c
.RI "virtual void \fBwriteBinaryArray\fP (const float *const f, const \fBint\fP length)"
.br
.ti -1c
.RI "virtual void \fBwriteBinaryArray\fP (const double *const d, const \fBint\fP length)"
.br
.ti -1c
.RI "virtual void \fBindent\fP (void)"
.br
.ti -1c
.RI "virtual void \fBreset\fP (void)"
.br
.ti -1c
.RI "void \fBsetCompact\fP (SbBool flag)"
.br
.ti -1c
.RI "SbBool \fBisCompact\fP (void) const"
.br
.ti -1c
.RI "void \fBsetAnnotation\fP (uint32_t bits)"
.br
.ti -1c
.RI "uint32_t \fBgetAnnotation\fP (void)"
.br
.ti -1c
.RI "\fBint\fP \fBaddReference\fP (const \fBSoBase\fP *base)"
.br
.ti -1c
.RI "\fBint\fP \fBfindReference\fP (const \fBSoBase\fP *base) const"
.br
.ti -1c
.RI "void \fBsetReference\fP (const \fBSoBase\fP *base, \fBint\fP refid)"
.br
.ti -1c
.RI "void \fBaddDEFNode\fP (\fBSbName\fP name)"
.br
.ti -1c
.RI "SbBool \fBlookupDEFNode\fP (\fBSbName\fP name)"
.br
.ti -1c
.RI "void \fBremoveDEFNode\fP (\fBSbName\fP name)"
.br
.ti -1c
.RI "void \fBpushProto\fP (\fBSoProto\fP *proto)"
.br
.ti -1c
.RI "\fBSoProto\fP * \fBgetCurrentProto\fP (void) const"
.br
.ti -1c
.RI "void \fBpopProto\fP (void)"
.br
.ti -1c
.RI "void \fBaddRoute\fP (\fBSoFieldContainer\fP *from, const \fBSbName\fP &fromfield, \fBSoFieldContainer\fP *to, const \fBSbName\fP &tofield)"
.br
.ti -1c
.RI "void \fBresolveRoutes\fP (void)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static const \fBSbName\fP * \fBgetAvailableCompressionMethods\fP (unsigned \fBint\fP &num)"
.br
.ti -1c
.RI "static \fBSbString\fP \fBgetDefaultASCIIHeader\fP (void)"
.br
.ti -1c
.RI "static \fBSbString\fP \fBgetDefaultBinaryHeader\fP (void)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "SbBool \fBisToBuffer\fP (void) const"
.br
.ti -1c
.RI "size_t \fBbytesInBuf\fP (void) const"
.br
.ti -1c
.RI "SbBool \fBmakeRoomInBuf\fP (size_t nBytes)"
.br
.ti -1c
.RI "void \fBconvertShort\fP (short s, char *to)"
.br
.ti -1c
.RI "void \fBconvertInt32\fP (int32_t l, char *to)"
.br
.ti -1c
.RI "void \fBconvertFloat\fP (float f, char *to)"
.br
.ti -1c
.RI "void \fBconvertDouble\fP (double d, char *to)"
.br
.ti -1c
.RI "void \fBconvertShortArray\fP (short *from, char *to, \fBint\fP len)"
.br
.ti -1c
.RI "void \fBconvertInt32Array\fP (int32_t *from, char *to, \fBint\fP len)"
.br
.ti -1c
.RI "void \fBconvertFloatArray\fP (float *from, char *to, \fBint\fP len)"
.br
.ti -1c
.RI "void \fBconvertDoubleArray\fP (double *from, char *to, \fBint\fP len)"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static \fBSbString\fP \fBpadHeader\fP (const \fBSbString\fP &inString)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "SbBool \fBwroteHeader\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
The \fBSoOutput\fP class is an abstraction of an output stream\&.
.PP
\fBSoOutput\fP offers the ability to write basic types to a file or a memory buffer in either ASCII or binary format\&. 


.PP
\fBSee also:\fP
.RS 4
\fBSoInput\fP, \fBSoWriteAction\fP 
.RE
.PP

.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBSoOutput::Stage\fP"
Enumerates the possible stages of a write operation (writing needs to be done in mutiple passes)\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetStage()\fP, \fBgetStage()\fP 
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fICOUNT_REFS \fP\fP
Not writing, just counting the internal references in the scene graph\&. 
.TP
\fB\fIWRITE \fP\fP
Signifies that actual data export should take place during this pass\&. 
.SS "enum \fBSoOutput::Annotations\fP"
Values from this enum is used for debugging purposes to annotate the output from a write operation\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIADDRESSES \fP\fP
Annotate output with pointer address information\&. 
.TP
\fB\fIREF_COUNTS \fP\fP
Annotate output with reference counts of the objects written\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SoOutput::SoOutput (void)"
The default constructor makes an \fBSoOutput\fP instance which will write to the standard output\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetFilePointer()\fP, \fBopenFile()\fP, \fBsetBuffer()\fP 
.RE
.PP

.SS "SoOutput::SoOutput (\fBSoOutput\fP * dictOut)"
Constructs an \fBSoOutput\fP which has a copy of the set of named references from \fIdictOut\fP\&. 
.SS "SoOutput::~SoOutput (void)\fC [virtual]\fP"
Destructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "void SoOutput::setFilePointer (FILE * newFP)\fC [virtual]\fP"
Set up a new file pointer which we will write to\&.
.PP
Important note: do \fInot\fP use this method when the Coin library has been compiled as an MSWindows DLL, as passing FILE* instances back or forth to DLLs is dangerous and will most likely cause a crash\&. This is an intrinsic limitation for MSWindows DLLs\&.
.PP
\fBSee also:\fP
.RS 4
\fBopenFile()\fP, \fBsetBuffer()\fP, \fBgetFilePointer()\fP 
.RE
.PP

.SS "FILE * SoOutput::getFilePointer (void) const\fC [virtual]\fP"
Returns the current filepointer\&. If we're writing to a memory buffer, \fCNULL\fP is returned\&.
.PP
Important note: do \fInot\fP use this method when the Coin library has been compiled as an MSWindows DLL, as passing FILE* instances back or forth to DLLs is dangerous and will most likely cause a crash\&. This is an intrinsic limitation for MSWindows DLLs\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetFilePointer()\fP 
.RE
.PP

.SS "SbBool SoOutput::openFile (const char *const fileName)\fC [virtual]\fP"
Opens a file for writing\&. If the file can not be opened or is not writeable, \fIFALSE\fP will be returned\&.
.PP
Files opened by this method will automatically be closed if the user supplies another filepointer, another filename for writing, or if the \fBSoOutput\fP instance is deleted\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetFilePointer()\fP, \fBsetBuffer()\fP, \fBcloseFile()\fP 
.RE
.PP

.SS "void SoOutput::closeFile (void)\fC [virtual]\fP"
Closes the currently opened file, but only if the file was passed to \fBSoOutput\fP through the \fBopenFile()\fP method\&.
.PP
\fBSee also:\fP
.RS 4
\fBopenFile()\fP 
.RE
.PP

.SS "SbBool SoOutput::setCompression (const \fBSbName\fP & compmethod, const float level = \fC0\&.5f\fP)"
Sets the compression method and level used when writing the file\&. \fIcompmethod\fP is the compression library/method to use when compressing\&. \fIlevel\fP is the compression level, where 0\&.0 means no compression and 1\&.0 means maximum compression\&.
.PP
Currently \fIBZIP2\fP, \fIGZIP\fP are the only compression methods supported, and you have to compile Coin with zlib and bzip2-support to enable them\&.
.PP
Supply \fIcompmethod\fP = \fINONE\fP or \fIlevel\fP = 0\&.0 if you want to disable compression\&. The compression is disabled by default\&.
.PP
Please note that it's not possible to compress when writing to a memory buffer\&.
.PP
This method will return \fITRUE\fP if the compression method selected is available\&. If it's not available, \fIFALSE\fP will be returned and compression is disabled\&.
.PP
\fBSee also:\fP
.RS 4
\fBgetAvailableCompressionMethods()\fP 
.RE
.PP
\fBSince:\fP
.RS 4
Coin 2\&.1 
.RE
.PP

.SS "const \fBSbName\fP * SoOutput::getAvailableCompressionMethods (unsigned \fBint\fP & num)\fC [static]\fP"
Returns the array of available compression methods\&. The number of elements in the array will be stored in \fInum\fP\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetCompression()\fP 
.RE
.PP
\fBSince:\fP
.RS 4
Coin 2\&.1 
.RE
.PP

.SS "void SoOutput::setBuffer (void * bufPointer, size_t initSize, SoOutputReallocCB * reallocFunc, int32_t offset = \fC0\fP)\fC [virtual]\fP"
Sets up a memory buffer of size \fIinitSize\fP for writing\&. Writing will start at \fIbufPointer\fP + \fIoffset\fP\&.
.PP
If the buffer is filled up, \fIreallocFunc\fP is called to get more memory\&. If \fIreallocFunc\fP returns \fINULL\fP, further writing is disabled\&.
.PP
Important note: remember that the resultant memory buffer after write operations have completed may reside somewhere else in memory than on \fIbufPointer\fP if \fIreallocFunc\fP is set\&. It is a good idea to make it a habit to always use \fBgetBuffer()\fP to retrieve the memory buffer pointer after write operations\&.
.PP
Here's a complete, stand-alone usage example which shows how to write a scene graph to a memory buffer:
.PP
.PP
.nf
#include <Inventor/SoDB\&.h>
#include <Inventor/actions/SoWriteAction\&.h>
#include <Inventor/nodes/SoCone\&.h>
#include <Inventor/nodes/SoSeparator\&.h>

static char * buffer;
static size_t buffer_size = 0;

static void *
buffer_realloc(void * bufptr, size_t size)
{
  buffer = (char *)realloc(bufptr, size);
  buffer_size = size;
  return buffer;
}

static SbString
buffer_writeaction(SoNode * root)
{
  SoOutput out;
  buffer = (char *)malloc(1024);
  buffer_size = 1024;
  out\&.setBuffer(buffer, buffer_size, buffer_realloc);

  SoWriteAction wa(&out);
  wa\&.apply(root);

  SbString s(buffer);
  free(buffer);
  return s;
}

int
main(int argc, char ** argv)
{
  SoDB::init();

  SoSeparator * root = new SoSeparator;
  root->ref();

  root->addChild(new SoCone);

  SbString s = buffer_writeaction(root);
  (void)fprintf(stdout, "%s\n", s\&.getString());

  root->unref();
  return 0;
}
.fi
.PP
.PP
\fBSee also:\fP
.RS 4
\fBgetBuffer()\fP, \fBgetBufferSize()\fP, \fBresetBuffer()\fP 
.RE
.PP

.SS "SbBool SoOutput::getBuffer (void *& bufPointer, size_t & nBytes) const\fC [virtual]\fP"
Returns the current buffer in \fIbufPointer\fP and the current write position of the buffer in \fInBytes\fP\&. If we're writing into a file and not a memory buffer, \fIFALSE\fP is returned and the other return values will be undefined\&.
.PP
\fBSee also:\fP
.RS 4
\fBgetBufferSize()\fP 
.RE
.PP

.SS "size_t SoOutput::getBufferSize (void) const\fC [virtual]\fP"
Returns total size of memory buffer\&.
.PP
\fBSee also:\fP
.RS 4
\fBgetBuffer()\fP 
.RE
.PP

.SS "void SoOutput::resetBuffer (void)\fC [virtual]\fP"
Reset the memory buffer write pointer back to the beginning of the buffer\&. 
.SS "void SoOutput::setBinary (const SbBool flag)\fC [virtual]\fP"
Set whether or not to write the output as a binary stream\&.
.PP
\fBSee also:\fP
.RS 4
\fBisBinary()\fP 
.RE
.PP

.SS "SbBool SoOutput::isBinary (void) const\fC [virtual]\fP"
Returns a flag which indicates whether or not we're writing the output as a binary stream\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetBinary()\fP 
.RE
.PP

.SS "void SoOutput::setHeaderString (const \fBSbString\fP & str)\fC [virtual]\fP"
Set the output file header string\&.
.PP
\fBSee also:\fP
.RS 4
\fBresetHeaderString()\fP, \fBgetDefaultASCIIHeader()\fP, \fBgetDefaultBinaryHeader()\fP 
.RE
.PP

.SS "void SoOutput::resetHeaderString (void)\fC [virtual]\fP"
Reset the header string to the default one\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetHeaderString()\fP, \fBgetDefaultASCIIHeader()\fP, \fBgetDefaultBinaryHeader()\fP 
.RE
.PP

.SS "void SoOutput::setFloatPrecision (const \fBint\fP precision)\fC [virtual]\fP"
Set the precision used when writing floating point numbers to ASCII files\&. \fIprecision\fP should be between 0 and 8\&. The double precision will be set to \fIprecision\fP * 2\&. 
.SS "void SoOutput::setStage (\fBStage\fP stage)"
Sets an indicator on the current stage\&. This is necessary to do as writing has to be done in multiple stages to account for the export of references/connections within the scene graphs\&.
.PP
This method is basically just used from within \fBSoWriteAction\fP, and should usually not be of interest to the application programmer\&. Do not use it unless you \fIreally\fP know what you are doing\&.
.PP
\fBSee also:\fP
.RS 4
\fBgetStage()\fP 
.RE
.PP

.SS "\fBSoOutput::Stage\fP SoOutput::getStage (void) const"
Returns an indicator on the current write stage\&. Writing is done in two passes, one to count and check connections, one to do the actual ascii or binary export of data\&.
.PP
You should not need to use this method, as it is meant for internal purposes in Coin\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetStage()\fP 
.RE
.PP

.SS "void SoOutput::incrementIndent (const \fBint\fP levels = \fC1\fP)"
Increase indentation level in the file\&.
.PP
\fBSee also:\fP
.RS 4
\fBdecrementIndent()\fP, \fBindent()\fP 
.RE
.PP

.SS "void SoOutput::decrementIndent (const \fBint\fP levels = \fC1\fP)"
Decrease indentation level in the file\&.
.PP
\fBSee also:\fP
.RS 4
\fBincrementIndent()\fP, \fBindent()\fP 
.RE
.PP

.SS "void SoOutput::write (const char c)\fC [virtual]\fP"
Write the character in \fIc\fP\&.
.PP
For binary write, the character plus 3 padding zero characters will be written\&. 
.SS "void SoOutput::write (const char * s)\fC [virtual]\fP"
Write the character string pointed to by \fIs\fP\&.
.PP
For binary write, a 4-byte MSB-ordered integer with the string length, plus the string plus padding zero characters to get on a 4-byte boundary (if necessary) will be written\&. 
.SS "void SoOutput::write (const \fBSbString\fP & s)\fC [virtual]\fP"
Write the character string in \fIs\fP\&. The string will be written with apostrophes\&. Cast \fBSbString\fP to char * to write without apostrophes\&.
.PP
If we are supposed to write in binary format, no apostrophes will be added, and writing will be done in the exact same manner as with \fBSoOutput::write(const char * s)\fP\&. 
.SS "void SoOutput::write (const \fBSbName\fP & n)\fC [virtual]\fP"
Write the character string in \fIn\fP\&. The name will be enclosed by apostrophes\&. If you want to write an \fBSbName\fP instance without the apostrophes, cast the argument to a char *\&.
.PP
If we are supposed to write in binary format, no apostrophes will be added, and writing will be done in the exact same manner as with \fBSoOutput::write(const char * s)\fP\&. 
.SS "void SoOutput::write (const \fBint\fP i)\fC [virtual]\fP"
Write \fIi\fP as a character string, or as an architecture independent binary pattern if the \fBsetBinary()\fP flag is activated\&. 
.SS "void SoOutput::write (const unsigned \fBint\fP i)\fC [virtual]\fP"
Write \fIi\fP as a character string, or as an architecture independent binary pattern if the \fBsetBinary()\fP flag is activated\&. 
.SS "void SoOutput::write (const short s)\fC [virtual]\fP"
Write \fIs\fP as a character string, or as an architecture independent binary pattern if the \fBsetBinary()\fP flag is activated\&. 
.SS "void SoOutput::write (const unsigned short s)\fC [virtual]\fP"
Write \fIs\fP as a character string, or as an architecture independent binary pattern if the \fBsetBinary()\fP flag is activated\&. If we're writing in ASCII format, the value will be written in base 16 (hexadecimal)\&. 
.SS "void SoOutput::write (const float f)\fC [virtual]\fP"
Write \fIf\fP as a character string\&. 
.SS "void SoOutput::write (const double d)\fC [virtual]\fP"
Write \fId\fP as a character string\&. 
.SS "void SoOutput::writeBinaryArray (const unsigned char * constc, const \fBint\fP length)\fC [virtual]\fP"
Write the given number of bytes to either a file or a memory buffer in binary format\&. 
.SS "void SoOutput::writeBinaryArray (const int32_t *const l, const \fBint\fP length)\fC [virtual]\fP"
Write an \fIlength\fP array of int32_t values in binary format\&. 
.SS "void SoOutput::writeBinaryArray (const float *const f, const \fBint\fP length)\fC [virtual]\fP"
Write an array of float values in binary format\&. 
.SS "void SoOutput::writeBinaryArray (const double *const d, const \fBint\fP length)\fC [virtual]\fP"
Write an array of double values in binary format\&. 
.SS "void SoOutput::indent (void)\fC [virtual]\fP"
Call this method after writing a newline to a file to indent the next line to the correct position\&.
.PP
\fBSee also:\fP
.RS 4
\fBincrementIndent()\fP, \fBdecrementIndent()\fP 
.RE
.PP

.SS "void SoOutput::reset (void)\fC [virtual]\fP"
Reset all value and make ready for using another filepointer or buffer\&. 
.SS "void SoOutput::setCompact (SbBool flag)"
Set up the output to be more compact than with the default write routines\&. 
.SS "SbBool SoOutput::isCompact (void) const"
Returns whether or not the write routines tries to compact the data when writing it (i\&.e\&. using less whitespace, etc)\&.
.PP
Note that 'compact' in this sense does \fInot\fP mean 'bitwise compression', as it could easily be mistaken for\&. 
.SS "void SoOutput::setAnnotation (uint32_t bits)"
Set up annotation of different aspects of the output data\&. This is not useful for much else than debugging purposes, I s'pose\&. 
.SS "uint32_t SoOutput::getAnnotation (void)"
Returns the current annotation debug bitflag settings\&. 
.SS "\fBSbString\fP SoOutput::getDefaultASCIIHeader (void)\fC [static]\fP"
Return the default header string written to ASCII files\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetHeaderString()\fP, \fBresetHeaderString()\fP, \fBgetDefaultBinaryHeader()\fP 
.RE
.PP

.SS "\fBSbString\fP SoOutput::getDefaultBinaryHeader (void)\fC [static]\fP"
Return the default header string written to binary files\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetHeaderString()\fP, \fBresetHeaderString()\fP, \fBgetDefaultASCIIHeader()\fP 
.RE
.PP

.SS "\fBint\fP SoOutput::addReference (const \fBSoBase\fP * base)"
Makes a unique id for \fIbase\fP and adds a mapping into our dictionary\&. 
.SS "\fBint\fP SoOutput::findReference (const \fBSoBase\fP * base) const"
Returns the unique identifier for \fIbase\fP or -1 if not found\&. 
.SS "void SoOutput::setReference (const \fBSoBase\fP * base, \fBint\fP refid)"
Sets the reference for \fIbase\fP manually\&. 
.SS "void SoOutput::addDEFNode (\fBSbName\fP name)"
Adds \fIname\fP to the set of currently DEF'ed node names so far in the output process\&. 
.SS "SbBool SoOutput::lookupDEFNode (\fBSbName\fP name)"
Checks whether \fIname\fP is already DEF'ed at this point in the output process\&. Returns TRUE if \fIname\fP is DEF'ed\&. 
.SS "void SoOutput::removeDEFNode (\fBSbName\fP name)"
Removes \fIname\fP from the set of DEF'ed node names\&. Used after the last reference to a DEF'ed node if we want to reuse the DEF at a later point in the file\&. 
.SS "void SoOutput::pushProto (\fBSoProto\fP * proto)"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP
.PP
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2\&.1 API\&.
.PP
\fBSince:\fP
.RS 4
Coin 2\&.0 
.RE
.PP

.SS "\fBSoProto\fP * SoOutput::getCurrentProto (void) const"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP
.PP
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2\&.1 API\&.
.PP
\fBSince:\fP
.RS 4
Coin 2\&.0 
.RE
.PP

.SS "void SoOutput::popProto (void)"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP
.PP
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2\&.1 API\&.
.PP
\fBSince:\fP
.RS 4
Coin 2\&.0 
.RE
.PP

.SS "void SoOutput::addRoute (\fBSoFieldContainer\fP * from, const \fBSbName\fP & fromfield, \fBSoFieldContainer\fP * to, const \fBSbName\fP & tofield)"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP
.PP
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2\&.1 API\&.
.PP
\fBSince:\fP
.RS 4
Coin 2\&.0 
.RE
.PP

.SS "void SoOutput::resolveRoutes (void)"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP
.PP
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2\&.1 API\&.
.PP
\fBSince:\fP
.RS 4
Coin 2\&.0 
.RE
.PP

.SS "SbBool SoOutput::isToBuffer (void) const\fC [protected]\fP"
Returns \fITRUE\fP of we're set up to write to a memory buffer\&. 
.SS "size_t SoOutput::bytesInBuf (void) const\fC [protected]\fP"
Returns current write position\&.
.PP
Note that for memory buffer writing, this includes the offset from \fBSoOutput::setBuffer()\fP, if any\&. 
.SS "SbBool SoOutput::makeRoomInBuf (size_t bytes)\fC [protected]\fP"
Check that the current memory buffer has enough space to contain the given number of bytes needed for the next write operation\&.
.PP
Returns \fIFALSE\fP if there's not enough space left, otherwise \fITRUE\fP\&.
.PP
Note that there will automatically be made an attempt at allocating more memory if the realloction callback function argument of \fBsetBuffer()\fP was not \fINULL\fP\&. 
.SS "void SoOutput::convertShort (short s, char * to)\fC [protected]\fP"
Convert the short integer in \fIs\fP to most-significant-byte first format and put the resulting bytes sequentially at \fIto\fP\&.
.PP
\fBSee also:\fP
.RS 4
\fBSoInput::convertShort()\fP 
.RE
.PP

.SS "void SoOutput::convertInt32 (int32_t l, char * to)\fC [protected]\fP"
Convert the 32-bit integer in \fIl\fP to most-significant-byte first format and put the resulting bytes sequentially at \fIto\fP\&.
.PP
\fBSee also:\fP
.RS 4
\fBSoInput::convertInt32()\fP 
.RE
.PP

.SS "void SoOutput::convertFloat (float f, char * to)\fC [protected]\fP"
Convert the single-precision floating point number in \fIf\fP to most-significant-byte first format and put the resulting bytes sequentially at \fIto\fP\&.
.PP
\fBSee also:\fP
.RS 4
\fBSoInput::convertFloat()\fP 
.RE
.PP

.SS "void SoOutput::convertDouble (double d, char * to)\fC [protected]\fP"
Convert the double-precision floating point number in \fId\fP to most-significant-byte first format and put the resulting bytes sequentially at \fIto\fP\&.
.PP
\fBSee also:\fP
.RS 4
\fBSoInput::convertDouble()\fP 
.RE
.PP

.SS "void SoOutput::convertShortArray (short * from, char * to, \fBint\fP len)\fC [protected]\fP"
Convert \fIlen\fP short integer values from the array at \fIfrom\fP into the array at \fIto\fP from native host format to network independent format (i\&.e\&. most significant byte first)\&. 
.SS "void SoOutput::convertInt32Array (int32_t * from, char * to, \fBint\fP len)\fC [protected]\fP"
Convert \fIlen\fP 32-bit integer values from the array at \fIfrom\fP into the array at \fIto\fP from native host format to network independent format (i\&.e\&. most significant byte first)\&. 
.SS "void SoOutput::convertFloatArray (float * from, char * to, \fBint\fP len)\fC [protected]\fP"
Convert \fIlen\fP single-precision floating point values from the array at \fIfrom\fP into the array at \fIto\fP from native host format to network independent format (i\&.e\&. most significant byte first)\&. 
.SS "void SoOutput::convertDoubleArray (double * from, char * to, \fBint\fP len)\fC [protected]\fP"
Convert \fIlen\fP double-precision floating point values from the array at \fIfrom\fP into the array at \fIto\fP from native host format to network independent format (i\&.e\&. most significant byte first)\&. 
.SS "\fBSbString\fP SoOutput::padHeader (const \fBSbString\fP & inString)\fC [static]\fP, \fC [protected]\fP"
Pads the header we're writing so it contains the correct amount of bytes for the alignment of the following binary writes\&. 
.SH "Member Data Documentation"
.PP 
.SS "SbBool SoOutput::wroteHeader\fC [protected]\fP"
Indicates whether or not the file format header has been written out\&. As long as this is \fIFALSE\fP, the header will be written once upon the first invocation of any write method in the class\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
