.TH "SoShapeHints" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SoShapeHints \- The \fBSoShapeHints\fP class is a node containing hints about how to render geometry\&.
.PP
The \fBSoShapeHints\fP node is used to set up clues to the rendering subsystem about how particular aspects of the subsequent geometry in the scene graph should be drawn\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Inventor/nodes/SoShapeHints\&.h>\fP
.PP
Inherits \fBSoNode\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBVertexOrdering\fP { \fBUNKNOWN_ORDERING\fP = SoShapeHintsElement::UNKNOWN_ORDERING, \fBCLOCKWISE\fP = SoShapeHintsElement::CLOCKWISE, \fBCOUNTERCLOCKWISE\fP = SoShapeHintsElement::COUNTERCLOCKWISE }"
.br
.ti -1c
.RI "enum \fBShapeType\fP { \fBUNKNOWN_SHAPE_TYPE\fP = SoShapeHintsElement::UNKNOWN_SHAPE_TYPE, \fBSOLID\fP = SoShapeHintsElement::SOLID }"
.br
.ti -1c
.RI "enum \fBFaceType\fP { \fBUNKNOWN_FACE_TYPE\fP = SoShapeHintsElement::UNKNOWN_FACE_TYPE, \fBCONVEX\fP = SoShapeHintsElement::CONVEX }"
.br
.ti -1c
.RI "enum \fBWindingType\fP { \fBNO_WINDING_TYPE\fP = 0 }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fBSoType\fP \fBgetTypeId\fP (void) const"
.br
.RI "Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. "
.ti -1c
.RI "\fBSoShapeHints\fP (void)"
.br
.ti -1c
.RI "virtual void \fBdoAction\fP (\fBSoAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBGLRender\fP (\fBSoGLRenderAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBcallback\fP (\fBSoCallbackAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBgetBoundingBox\fP (\fBSoGetBoundingBoxAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBpick\fP (\fBSoPickAction\fP *action)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBSoType\fP \fBgetClassTypeId\fP (void)"
.br
.ti -1c
.RI "static void \fBinitClass\fP (void)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBSoSFEnum\fP \fBvertexOrdering\fP"
.br
.ti -1c
.RI "\fBSoSFEnum\fP \fBshapeType\fP"
.br
.ti -1c
.RI "\fBSoSFEnum\fP \fBfaceType\fP"
.br
.ti -1c
.RI "\fBSoSFEnum\fP \fBwindingType\fP"
.br
.ti -1c
.RI "\fBSoSFBool\fP \fBuseVBO\fP"
.br
.ti -1c
.RI "\fBSoSFFloat\fP \fBcreaseAngle\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual const \fBSoFieldData\fP * \fBgetFieldData\fP (void) const"
.br
.ti -1c
.RI "virtual \fB~SoShapeHints\fP ()"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static const \fBSoFieldData\fP ** \fBgetFieldDataPtr\fP (void)"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
The \fBSoShapeHints\fP class is a node containing hints about how to render geometry\&.
.PP
The \fBSoShapeHints\fP node is used to set up clues to the rendering subsystem about how particular aspects of the subsequent geometry in the scene graph should be drawn\&. 

Here is an example on how to display a scene in wireframe mode which only shows the triangles facing towards the camera\&.
.PP
.PP
.nf
#include <Inventor/nodes/SoCone\&.h>
#include <Inventor/nodes/SoDrawStyle\&.h>
#include <Inventor/nodes/SoLightModel\&.h>
#include <Inventor/nodes/SoSeparator\&.h>
#include <Inventor/nodes/SoShapeHints\&.h>
#include <Inventor/Win/SoWin\&.h>
#include <Inventor/Win/viewers/SoWinExaminerViewer\&.h>

int main(int, char * argv[])
{
  HWND window = SoWin::init(argv[0]);

  SoSeparator * root = new SoSeparator;

  // wireframe
  SoDrawStyle * drawStyle = new SoDrawStyle;
  drawStyle->style = SoDrawStyle::LINES;
  root->addChild(drawStyle);

  // back-face culling
  SoShapeHints * shapeHints = new SoShapeHints;
  shapeHints->vertexOrdering = SoShapeHints::COUNTERCLOCKWISE;
  shapeHints->shapeType = SoShapeHints::SOLID;
  root->addChild(shapeHints);

  // keep a solid color
  SoLightModel * lightModel = new SoLightModel;
  lightModel->model = SoLightModel::BASE_COLOR;
  root->addChild(lightModel);

  // a cone
  SoCone * cone = new SoCone;
  root->addChild(cone);

  // set up a window
  SoWinExaminerViewer * viewer = new SoWinExaminerViewer(window);
  SbViewportRegion vpRegion = viewer->getViewportRegion();
  viewer->setSceneGraph(root);
  viewer->show();

  SoWin::mainLoop();
  delete viewer;
  return 0;
}
.fi
.PP
.PP
The default settings of the rendering system is tuned towards programmer convenience\&. For instance, the default is to render both sides of all polygons to make sure we avoid any 'holes' in the geometry if the vertex ordering should happen to differ for different polygons\&.
.PP
If the programmer gives up some of this convenience and uses \fBSoShapeHints\fP nodes to more closely specify information about the scene graph geometry, the clues given by the \fBSoShapeHints\fP node(s) will then be used by the rendering subsystem to avoid certain costly operations\&. Significant gains in rendering speed could be seen as a result\&.
.PP
Be aware that the way backface culling and two-sided lighting is decided by the rendering system is not at all intuitive\&. Here are the common rules of how primitive shapes will render themselves with regard to how the \fBSoShapeHints::vertexOrdering\fP and \fBSoShapeHints::shapeType\fP fields are set:
.PP
.PD 0
.IP "\(bu" 2
vertexOrdering == CLOCKWISE or COUNTERCLOCKWISE, shapeType == SOLID: causes primitives to be backface culled and rendered with one-sided lighting\&.
.PP

.IP "\(bu" 2
vertexOrdering == CLOCKWISE or COUNTERCLOCKWISE, shapeType == UNKNOWN_SHAPE_TYPE: primitives are \fInot\fP backface culled, and they are rendered with two-sided lighting\&.
.PP

.IP "\(bu" 2
vertexOrdering == UNKNOWN_ORDERING, any shapeType: primitives are \fInot\fP backface culled, and they are rendered with one-sided lighting\&. The OpenGL vertex ordering will be set to counter clockwise ordering\&. 
.PP
.PP
The UNKNOWN_ORDERING enum has a special and non-intuitive meaning\&. The ordering is really set to counter clockwise -- in OpenGL and when generating normals\&. However, if you want to render your geometry with one-sided lighting and backface culling disabled, you have to use this enum value, and your polygons need to be in counter clockwise ordering\&.
.PP
\fBFILE FORMAT/DEFAULTS:\fP 
.PP
.nf
ShapeHints {
    vertexOrdering UNKNOWN_ORDERING
    shapeType UNKNOWN_SHAPE_TYPE
    faceType CONVEX
    creaseAngle 0
}

.fi
.PP
 
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBSoShapeHints::VertexOrdering\fP"
Enumeration of available ways to specify ordering of vertices for a polygon\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIUNKNOWN_ORDERING \fP\fP
Ordering not known, render both sides of the polygon\&. 
.TP
\fB\fICLOCKWISE \fP\fP
Vertices are specified in a clockwise order\&. 
.TP
\fB\fICOUNTERCLOCKWISE \fP\fP
Vertices are specified in a counter-clockwise order\&. 
.SS "enum \fBSoShapeHints::ShapeType\fP"
Enumeration of different shape types\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIUNKNOWN_SHAPE_TYPE \fP\fP
Nothing known about the shape, be conservative when rendering\&. 
.TP
\fB\fISOLID \fP\fP
The subsequent shapes in the graph are all known to be completely 'closed', solid 3D shapes\&. Backface culling will be done if vertexOrdering is known\&. 
.SS "enum \fBSoShapeHints::FaceType\fP"
Enumeration of polygon face types\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIUNKNOWN_FACE_TYPE \fP\fP
Signifies: nothing is known about subsequent polygon data, be conservative when rendering\&.
.PP
All polygons in the scene will be analyzed to see if they needs to be tessellated (broken up) into triangles before passed on to the underlying immediate mode rendering system\&.
.PP
The OpenGL rendering system handles most complex polygon types, but not all: it can for instance have problems with many-sided, concave polygons (concave polygons are 'hollow', that is: rounded inwards)\&. Coin's internal tessellator will most often handle the cases that OpenGL fails on\&.
.PP
So if you are seeing weird artifacts in how complex polygons are rendered, try to change the \fBSoShapeHints::faceType\fP field to this value and see if they are then rendered correctly\&.
.PP
Beware that turning on this functionality might have the effect of making the rendering performance worse\&. If it has a noticable effect on your particular scenegraph, we advise that you investigate whether you could change how the polygons are generated for Coin rendering and then avoid using this flag\&. 
.TP
\fB\fICONVEX \fP\fP
Subsequent faces are all convex, so turn off the check for and tessellation of inconvex faces\&.
.PP
Subsequent polygons from faceset-type nodes (like \fBSoFaceSet\fP and \fBSoIndexedFaceSet\fP) will be sent unmodified to OpenGL, thereby assuming that the polygons are in a form handled by OpenGL\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SoShapeHints::SoShapeHints (void)"
Constructor\&. 
.SS "SoShapeHints::~SoShapeHints ()\fC [protected]\fP, \fC [virtual]\fP"
Destructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBSoType\fP SoShapeHints::getTypeId (void) const\fC [virtual]\fP"

.PP
Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. Usage example:
.PP
.PP
.nf
void foo(SoNode * node)
{
  if (node->getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
.fi
.PP
.PP
For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in \fIall\fP subclasses\&. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance \fBInventor/nodes/SoSubNode\&.h\fP (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), \fBInventor/engines/SoSubEngine\&.h\fP (for engine classes) and so on\&.
.PP
For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups\&. 
.PP
Implements \fBSoBase\fP\&.
.SS "const \fBSoFieldData\fP * SoShapeHints::getFieldData (void) const\fC [protected]\fP, \fC [virtual]\fP"
Returns a pointer to the class-wide field data storage object for this instance\&. If no fields are present, returns \fCNULL\fP\&. 
.PP
Reimplemented from \fBSoFieldContainer\fP\&.
.SS "void SoShapeHints::doAction (\fBSoAction\fP * action)\fC [virtual]\fP"
This function performs the typical operation of a node for any action\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoShapeHints::GLRender (\fBSoGLRenderAction\fP * action)\fC [virtual]\fP"
Action method for the \fBSoGLRenderAction\fP\&.
.PP
This is called during rendering traversals\&. Nodes influencing the rendering state in any way or who wants to throw geometry primitives at OpenGL overrides this method\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoShapeHints::callback (\fBSoCallbackAction\fP * action)\fC [virtual]\fP"
Action method for \fBSoCallbackAction\fP\&.
.PP
Simply updates the state according to how the node behaves for the render action, so the application programmer can use the \fBSoCallbackAction\fP for extracting information about the scene graph\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoShapeHints::getBoundingBox (\fBSoGetBoundingBoxAction\fP * action)\fC [virtual]\fP"
Action method for the \fBSoGetBoundingBoxAction\fP\&.
.PP
Calculates bounding box and center coordinates for node and modifies the values of the \fIaction\fP to encompass the bounding box for this node and to shift the center point for the scene more towards the one for this node\&.
.PP
Nodes influencing how geometry nodes calculates their bounding box also overrides this method to change the relevant state variables\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoShapeHints::pick (\fBSoPickAction\fP * action)\fC [virtual]\fP"
Action method for \fBSoPickAction\fP\&.
.PP
Does common processing for \fBSoPickAction\fP \fIaction\fP instances\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBSoSFEnum\fP SoShapeHints::vertexOrdering"
Specifies how vertices are ordered for polygon faces\&.
.PP
Set this field to \fBSoShapeHints::CLOCKWISE\fP or \fBSoShapeHints::COUNTERCLOCKWISE\fP if possible to turn on backface culling and thereby optimize rendering\&.
.PP
Default value is \fBSoShapeHints::UNKNOWN_ORDERING\fP\&. 
.SS "\fBSoSFEnum\fP SoShapeHints::shapeType"
Hint about whether or not shapes are known to be 'closed'\&. Default value is \fBSoShapeHints::UNKNOWN_SHAPE_TYPE\fP\&. 
.SS "\fBSoSFEnum\fP SoShapeHints::faceType"
Hint about whether or not polygon faces are known to be convex\&. Default value is \fBSoShapeHints::CONVEX\fP\&. 
.SS "\fBSoSFFloat\fP SoShapeHints::creaseAngle"
When normals are automatically generated by Coin (i\&.e\&. \fBSoNormal\fP nodes are not used), this is the smallest angle between two faces where we would still calculate normals to do flatshading\&.
.PP
If the angle between the normals of two neighboring faces is less than the value of this field, the faces will be smoothshaded around their common edge\&.
.PP
The angle is specified in radians, and the default value is 0\&.0, meaning no smoothing will be done by default\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
