.TH "SoBase" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SoBase \- The \fBSoBase\fP class is the top-level superclass for a number of class-hierarchies\&.
.PP
\fBSoBase\fP provides the basic interfaces and methods for doing reference counting, type identification and import/export\&. All classes in Coin which uses these mechanisms are descendent from this class\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Inventor/misc/SoBase\&.h>\fP
.PP
Inherited by \fBSoFieldContainer\fP, and \fBSoPath\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBref\fP (void) const"
.br
.ti -1c
.RI "void \fBunref\fP (void) const"
.br
.ti -1c
.RI "void \fBunrefNoDelete\fP (void) const"
.br
.ti -1c
.RI "int32_t \fBgetRefCount\fP (void) const"
.br
.ti -1c
.RI "void \fBtouch\fP (void)"
.br
.ti -1c
.RI "virtual \fBSoType\fP \fBgetTypeId\fP (void) const =0"
.br
.RI "Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. "
.ti -1c
.RI "SbBool \fBisOfType\fP (\fBSoType\fP type) const"
.br
.RI "Returns \fCTRUE\fP if the type of this object is either of the same type or inherited from \fItype\fP\&. "
.ti -1c
.RI "virtual \fBSbName\fP \fBgetName\fP (void) const"
.br
.ti -1c
.RI "virtual void \fBsetName\fP (const \fBSbName\fP &newname)"
.br
.ti -1c
.RI "virtual void \fBstartNotify\fP (void)"
.br
.ti -1c
.RI "virtual void \fBnotify\fP (\fBSoNotList\fP *l)"
.br
.ti -1c
.RI "void \fBaddAuditor\fP (void *const auditor, const \fBSoNotRec::Type\fP type)"
.br
.ti -1c
.RI "void \fBremoveAuditor\fP (void *const auditor, const \fBSoNotRec::Type\fP type)"
.br
.ti -1c
.RI "const \fBSoAuditorList\fP & \fBgetAuditors\fP (void) const"
.br
.ti -1c
.RI "virtual void \fBaddWriteReference\fP (\fBSoOutput\fP *out, SbBool isfromfield=FALSE)"
.br
.ti -1c
.RI "SbBool \fBshouldWrite\fP (void)"
.br
.ti -1c
.RI "void \fBassertAlive\fP (void) const"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static void \fBinitClass\fP (void)"
.br
.RI "Sets up initialization for data common to all instances of this class, like submitting necessary information to the Coin type system\&. "
.ti -1c
.RI "static \fBSoType\fP \fBgetClassTypeId\fP (void)"
.br
.RI "This static method returns the \fBSoType\fP object associated with objects of this class\&. "
.ti -1c
.RI "static void \fBaddName\fP (\fBSoBase\fP *const base, const char *const name)"
.br
.ti -1c
.RI "static void \fBremoveName\fP (\fBSoBase\fP *const base, const char *const name)"
.br
.ti -1c
.RI "static void \fBincrementCurrentWriteCounter\fP (void)"
.br
.ti -1c
.RI "static void \fBdecrementCurrentWriteCounter\fP (void)"
.br
.ti -1c
.RI "static \fBSoBase\fP * \fBgetNamedBase\fP (const \fBSbName\fP &name, \fBSoType\fP type)"
.br
.ti -1c
.RI "static \fBint\fP \fBgetNamedBases\fP (const \fBSbName\fP &name, \fBSoBaseList\fP &baselist, \fBSoType\fP type)"
.br
.ti -1c
.RI "static SbBool \fBread\fP (\fBSoInput\fP *input, \fBSoBase\fP *&base, \fBSoType\fP expectedtype)"
.br
.ti -1c
.RI "static void \fBsetInstancePrefix\fP (const \fBSbString\fP &c)"
.br
.ti -1c
.RI "static void \fBsetTraceRefs\fP (SbBool trace)"
.br
.ti -1c
.RI "static SbBool \fBgetTraceRefs\fP (void)"
.br
.ti -1c
.RI "static SbBool \fBconnectRoute\fP (\fBSoInput\fP *input, const \fBSbName\fP &fromnodename, const \fBSbName\fP &fromfieldname, const \fBSbName\fP &tonodename, const \fBSbName\fP &tofieldname)"
.br
.ti -1c
.RI "static SbBool \fBreadRoute\fP (\fBSoInput\fP *input)"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "enum \fBBaseFlags\fP { \fBIS_ENGINE\fP = 0x01, \fBIS_GROUP\fP = 0x02 }"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBSoBase\fP (void)"
.br
.ti -1c
.RI "virtual \fB~SoBase\fP ()"
.br
.ti -1c
.RI "virtual void \fBdestroy\fP (void)"
.br
.ti -1c
.RI "SbBool \fBhasMultipleWriteRefs\fP (void) const"
.br
.ti -1c
.RI "SbBool \fBwriteHeader\fP (\fBSoOutput\fP *out, SbBool isgroup, SbBool isengine) const"
.br
.ti -1c
.RI "void \fBwriteFooter\fP (\fBSoOutput\fP *out) const"
.br
.ti -1c
.RI "virtual const char * \fBgetFileFormatName\fP (void) const"
.br
.ti -1c
.RI "virtual SbBool \fBreadInstance\fP (\fBSoInput\fP *input, unsigned short flags)=0"
.br
.ti -1c
.RI "virtual \fBSoNotRec\fP \fBcreateNotRec\fP (void)"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static uint32_t \fBgetCurrentWriteCounter\fP (void)"
.br
.ti -1c
.RI "static void \fBstaticDataLock\fP (void)"
.br
.ti -1c
.RI "static void \fBstaticDataUnlock\fP (void)"
.br
.in -1c
.SH "Detailed Description"
.PP 
The \fBSoBase\fP class is the top-level superclass for a number of class-hierarchies\&.
.PP
\fBSoBase\fP provides the basic interfaces and methods for doing reference counting, type identification and import/export\&. All classes in Coin which uses these mechanisms are descendent from this class\&. 

One important issue with SoBase-derived classes is that they should \fInot\fP be statically allocated, neither in static module memory nor on function's stack-frames\&. SoBase-derived classes must \fIalways\fP be allocated dynamically from the memory heap with the \fCnew\fP operator\&.
.PP
This is so because SoBase-derived instances are reference counted, and will self-destruct on the approriate time\&. For this to work, they must be explicitly allocated in heap-memory\&. See the class documentation of \fBSoNode\fP for more information\&. 
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBSoBase::BaseFlags\fP\fC [protected]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SoBase::SoBase (void)\fC [protected]\fP"
Constructor\&. The initial reference count will be set to zero\&. 
.SS "SoBase::~SoBase ()\fC [protected]\fP, \fC [virtual]\fP"
Destructor\&. There should not be any normal circumstance where you need to explicitly delete an object derived from the \fBSoBase\fP class, as the reference counting should take care of deallocating unused objects\&.
.PP
\fBSee also:\fP
.RS 4
\fBunref()\fP, \fBunrefNoDelete()\fP 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "void SoBase::ref (void) const"
Increase the reference count of the object\&. This might be necessary to do explicitly from user code for certain situations (chiefly to avoid premature deletion), but is usually called from other instances within the Coin library when objects are made dependent on each other\&.
.PP
See the class documentation of \fBSoNode\fP for more extensive information about reference counting\&.
.PP
\fBSee also:\fP
.RS 4
\fBunref()\fP, \fBunrefNoDelete()\fP 
.RE
.PP

.SS "void SoBase::unref (void) const"
Decrease the reference count of an object\&. If the reference count reaches zero, the object will delete itself\&. Be careful when explicitly calling this method, beware that you usually need to match user level calls to \fBref()\fP with calls to either \fBunref()\fP or \fBunrefNoDelete()\fP to avoid memory leaks\&.
.PP
\fBSee also:\fP
.RS 4
\fBref()\fP, \fBunrefNoDelete()\fP 
.RE
.PP

.SS "void SoBase::unrefNoDelete (void) const"
Decrease reference count, but do \fInot\fP delete ourself if the count reaches zero\&.
.PP
\fBSee also:\fP
.RS 4
\fBunref()\fP 
.RE
.PP

.SS "int32_t SoBase::getRefCount (void) const"
Returns number of objects referring to this object\&. 
.SS "void SoBase::touch (void)"
Force an update, in the sense that all objects connected to this object as an auditor will have to re-check the values of their inter-dependent data\&.
.PP
This is often used as an effective way of manually triggering a redraw by application programmers\&. 
.SS "\fBSoType\fP SoBase::getTypeId (void) const\fC [pure virtual]\fP"

.PP
Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. Usage example:
.PP
.PP
.nf
void foo(SoNode * node)
{
  if (node->getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
.fi
.PP
.PP
For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in \fIall\fP subclasses\&. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance \fBInventor/nodes/SoSubNode\&.h\fP (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), \fBInventor/engines/SoSubEngine\&.h\fP (for engine classes) and so on\&.
.PP
For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups\&. 
.PP
Implemented in \fBSoShaderStateMatrixParameter\fP, \fBSoShaderParameterMatrixArray\fP, \fBSoShaderParameterMatrix\fP, \fBSoShaderParameterArray4i\fP, \fBSoShaderParameterArray4f\fP, \fBSoShaderParameterArray3i\fP, \fBSoShaderParameterArray3f\fP, \fBSoShaderParameterArray2i\fP, \fBSoShaderParameterArray2f\fP, \fBSoShaderParameterArray1i\fP, \fBSoShaderParameterArray1f\fP, \fBSoShaderParameter4i\fP, \fBSoShaderParameter4f\fP, \fBSoShaderParameter3i\fP, \fBSoShaderParameter3f\fP, \fBSoShaderParameter2i\fP, \fBSoShaderParameter2f\fP, \fBSoShaderParameter1i\fP, \fBSoShaderParameter1f\fP, \fBSoUniformShaderParameter\fP, \fBSoExtSelection\fP, \fBSoShaderParameter\fP, \fBSoBaseKit\fP, \fBSoDragger\fP, \fBSoCamera\fP, \fBSoPath\fP, \fBSoWWWInline\fP, \fBSoProto\fP, \fBSoVRMLInline\fP, \fBSoVertexAttribute\fP, \fBSoEventCallback\fP, \fBSoShape\fP, \fBSoVRMLScript\fP, \fBSoVRMLSwitch\fP, \fBSoTrackballDragger\fP, \fBSoNodeVisualize\fP, \fBSoDirectionalLightManip\fP, \fBSoInteractionKit\fP, \fBSoVertexShape\fP, \fBSoSelection\fP, \fBSoVRMLElevationGrid\fP, \fBSoVRMLFontStyle\fP, \fBSoSpotLightManip\fP, \fBSoShaderProgram\fP, \fBSoTexture2\fP, \fBSoShaderObject\fP, \fBSoWWWAnchor\fP, \fBSoSTLFileKit\fP, \fBSoScrollingGraphKit\fP, \fBSoProfilerTopEngine\fP, \fBSoComposeMatrix\fP, \fBSoProtoInstance\fP, \fBSoTransformManip\fP, \fBSoClipPlaneManip\fP, \fBSoPointLightManip\fP, \fBSoTextureCubeMap\fP, \fBSoTexture3\fP, \fBSoComposeRotation\fP, \fBSoComposeRotationFromTo\fP, \fBSoComposeVec2f\fP, \fBSoComposeVec4f\fP, \fBSoComposeVec3f\fP, \fBSoVRMLAudioClip\fP, \fBSoVRMLImageTexture\fP, \fBSoVRMLVertexShape\fP, \fBSoTransformerDragger\fP, \fBSoSpotLightDragger\fP, \fBSoRotateSphericalDragger\fP, \fBSoText3\fP, \fBSoSceneTexture2\fP, \fBSoSceneTextureCubeMap\fP, \fBSoImage\fP, \fBSoProfilerStats\fP, \fBSoDecomposeVec4f\fP, \fBSoDecomposeVec3f\fP, \fBSoDecomposeMatrix\fP, \fBSoDecomposeVec2f\fP, \fBSoVRMLMovieTexture\fP, \fBSoVRMLAnchor\fP, \fBSoVRMLIndexedFaceSet\fP, \fBSoVRMLViewpoint\fP, \fBSoScale2UniformDragger\fP, \fBSoTabPlaneDragger\fP, \fBSoTranslate1Dragger\fP, \fBSoTranslate2Dragger\fP, \fBSoHandleBoxDragger\fP, \fBSoRotor\fP, \fBSoGeoSeparator\fP, \fBSoGeoCoordinate\fP, \fBSoVertexProperty\fP, \fBSoShuttle\fP, \fBSoPendulum\fP, \fBSoSwitch\fP, \fBSoBumpMap\fP, \fBSoDecomposeRotation\fP, \fBSoVRMLDragSensor\fP, \fBSoVRMLSound\fP, \fBSoScale2Dragger\fP, \fBSoRotateCylindricalDragger\fP, \fBSoScale1Dragger\fP, \fBSoScaleUniformDragger\fP, \fBSoDirectionalLightDragger\fP, \fBSoJackDragger\fP, \fBSoRotateDiscDragger\fP, \fBSoCenterballDragger\fP, \fBSoTransformBoxDragger\fP, \fBSoNodeKitListPart\fP, \fBSoIndexedLineSet\fP, \fBSoIndexedFaceSet\fP, \fBSoFontStyle\fP, \fBSoIndexedTriangleStripSet\fP, \fBSoGeoLocation\fP, \fBSoCacheHint\fP, \fBSoForeignFileKit\fP, \fBSoShadowGroup\fP, \fBSoCalculator\fP, \fBSoComputeBoundingBox\fP, \fBSoVRMLBillboard\fP, \fBSoVRMLIndexedLineSet\fP, \fBSoVRMLNavigationInfo\fP, \fBSoVRMLTimeSensor\fP, \fBSoVRMLFog\fP, \fBSoVRMLBackground\fP, \fBSoVRMLText\fP, \fBSoPointLightDragger\fP, \fBSoDragPointDragger\fP, \fBSoTabBoxDragger\fP, \fBSoIndexedNurbsSurface\fP, \fBSoTextureCoordinatePlane\fP, \fBSoAsciiText\fP, \fBSoTexture3Transform\fP, \fBSoIndexedNurbsCurve\fP, \fBSoMaterial\fP, \fBSoSeparator\fP, \fBSoLocateHighlight\fP, \fBSoRotationXYZ\fP, \fBSoProfile\fP, \fBSoProfilerTopKit\fP, \fBSoProfilerVisualizeKit\fP, \fBSoGate\fP, \fBSoTimeCounter\fP, \fBSoElapsedTime\fP, \fBSoOneShot\fP, \fBSoVRMLGroup\fP, \fBSoVRMLPositionInterpolator\fP, \fBSoVRMLLOD\fP, \fBSoVRMLExtrusion\fP, \fBSoVRMLCollision\fP, \fBSoIndexedPointSet\fP, \fBSoSurroundScale\fP, \fBSoBlinker\fP, \fBSoListener\fP, \fBSoTextureCombine\fP, \fBSoEnvironment\fP, \fBSoGeoOrigin\fP, \fBSoTextureCoordinateReflectionMap\fP, \fBSoDrawStyle\fP, \fBSoNurbsCurve\fP, \fBSoTransform\fP, \fBSoFile\fP, \fBSoLOD\fP, \fBSoNurbsSurface\fP, \fBSoSelectOne\fP, \fBSoVRMLParent\fP, \fBSoVRMLOrientationInterpolator\fP, \fBSoVRMLSphereSensor\fP, \fBSoVRMLTextureTransform\fP, \fBSoVRMLProximitySensor\fP, \fBSoVRMLColorInterpolator\fP, \fBSoVRMLMaterial\fP, \fBSoNormal\fP, \fBSoShapeHints\fP, \fBSoBumpMapTransform\fP, \fBSoArray\fP, \fBSoText2\fP, \fBSoFaceSet\fP, \fBSoTexture2Transform\fP, \fBSoTextureCoordinateNormalMap\fP, \fBSoPolygonOffset\fP, \fBSoIndexedShape\fP, \fBSoDepthBuffer\fP, \fBSoLevelOfDetail\fP, \fBSoIndexedMarkerSet\fP, \fBSoCube\fP, \fBSoAntiSquish\fP, \fBSoShadowSpotLight\fP, \fBSoShadowDirectionalLight\fP, \fBSoBoolOperation\fP, \fBSoCounter\fP, \fBSoVRMLLight\fP, \fBSoVRMLVisibilitySensor\fP, \fBSoVRMLNormal\fP, \fBSoVRMLCoordinate\fP, \fBSoVRMLColor\fP, \fBSoVRMLCoordinateInterpolator\fP, \fBSoVRMLTouchSensor\fP, \fBSoVRMLInterpolator\fP, \fBSoVRMLVertexPoint\fP, \fBSoVRMLShape\fP, \fBSoVRMLPixelTexture\fP, \fBSoVRMLNormalInterpolator\fP, \fBSoVRMLAppearance\fP, \fBSoVRMLTextureCoordinate\fP, \fBSoTextureCoordinate3\fP, \fBSoSpotLight\fP, \fBSoComplexity\fP, \fBSoCylinder\fP, \fBSoCoordinate3\fP, \fBSoBaseColor\fP, \fBSoNurbsProfile\fP, \fBSoCoordinate4\fP, \fBSoLight\fP, \fBSoCone\fP, \fBSoNonIndexedShape\fP, \fBSoGeometryShader\fP, \fBSoPackedColor\fP, \fBSoHeightMapToNormalMap\fP, \fBSoTransformVec3f\fP, \fBSoTriggerAny\fP, \fBSoOnOff\fP, \fBSoConcatenate\fP, \fBSoVRMLPlaneSensor\fP, \fBSoVRMLCylinder\fP, \fBSoVRMLPointLight\fP, \fBSoVRMLTransform\fP, \fBSoVRMLGeometry\fP, \fBSoVRMLCone\fP, \fBSoVRMLSpotLight\fP, \fBSoVRMLScalarInterpolator\fP, \fBSoVRMLCylinderSensor\fP, \fBSoVRMLWorldInfo\fP, \fBSoVRMLVertexLine\fP, \fBSoHandleBoxManip\fP, \fBSoTrackballManip\fP, \fBSoTransformerManip\fP, \fBSoTransformBoxManip\fP, \fBSoTabBoxManip\fP, \fBSoCenterballManip\fP, \fBSoJackManip\fP, \fBSoSeparatorKit\fP, \fBSoClipPlane\fP, \fBSoRotation\fP, \fBSoUnits\fP, \fBSoTextureCoordinateObject\fP, \fBSoFrustumCamera\fP, \fBSoTranslation\fP, \fBSoNormalBinding\fP, \fBSoTextureCoordinateEnvironment\fP, \fBSoPickStyle\fP, \fBSoCallback\fP, \fBSoLightModel\fP, \fBSoTextureUnit\fP, \fBSoPathSwitch\fP, \fBSoGroup\fP, \fBSoPointSet\fP, \fBSoMarkerSet\fP, \fBSoVertexAttributeBinding\fP, \fBSoLineSet\fP, \fBSoTextureCoordinateBinding\fP, \fBSoTransparencyType\fP, \fBSoTextureCoordinate2\fP, \fBSoMatrixTransform\fP, \fBSoMaterialBinding\fP, \fBSoTriangleStripSet\fP, \fBSoSphere\fP, \fBSoDirectionalLight\fP, \fBSoPointLight\fP, \fBSoFont\fP, \fBSoResetTransform\fP, \fBSoTextureScalePolicy\fP, \fBSoQuadMesh\fP, \fBSoAlphaTest\fP, \fBSoScale\fP, \fBSoMultipleCopy\fP, \fBSoShadowStyle\fP, \fBSoShadowCulling\fP, \fBSoFieldConverter\fP, \fBSoInterpolate\fP, \fBSoTexture2Convert\fP, \fBSoVRMLBox\fP, \fBSoVRMLIndexedLine\fP, \fBSoVRMLSphere\fP, \fBSoVRMLPointSet\fP, \fBSoVRMLIndexedShape\fP, \fBSoVRMLTexture\fP, \fBSoVRMLDirectionalLight\fP, \fBSoAppearanceKit\fP, \fBSoSceneKit\fP, \fBSoLightKit\fP, \fBSoCameraKit\fP, \fBSoLinearProfile\fP, \fBSoTextureMatrixTransform\fP, \fBSoBumpMapCoordinate\fP, \fBSoProfileCoordinate3\fP, \fBSoColorIndex\fP, \fBSoTextureCoordinateDefault\fP, \fBSoFragmentShader\fP, \fBSoTransformSeparator\fP, \fBSoLabel\fP, \fBSoAnnotation\fP, \fBSoOrthographicCamera\fP, \fBSoProfileCoordinate2\fP, \fBSoReversePerspectiveCamera\fP, \fBSoPerspectiveCamera\fP, \fBSoInfo\fP, \fBSoVRMLSensor\fP, \fBSoShapeKit\fP, \fBSoWrapperKit\fP, \fBSoTextureCoordinateSphere\fP, \fBSoTextureCoordinateCylinder\fP, \fBSoTransformation\fP, \fBSoTextureCoordinateCube\fP, \fBSoTextureCoordinateFunction\fP, \fBSoInterpolateVec4f\fP, \fBSoInterpolateVec3f\fP, \fBSoInterpolateFloat\fP, \fBSoInterpolateRotation\fP, \fBSoInterpolateVec2f\fP, \fBSoVertexShader\fP, \fBSoTexture\fP, and \fBSoProfilerOverlayKit\fP\&.
.SS "SbBool SoBase::isOfType (\fBSoType\fP type) const"

.PP
Returns \fCTRUE\fP if the type of this object is either of the same type or inherited from \fItype\fP\&. This is used for run-time type checking and 'downward' casting\&.
.PP
Usage example:
.PP
.PP
.nf
void foo(SoNode * node)
{
  if (node->isOfType(SoGroup::getClassTypeId())) {
    SoGroup * group = (SoGroup *)node;  // safe downward cast, knows the type
  }
}
.fi
.PP
 
.SS "\fBSbName\fP SoBase::getName (void) const\fC [virtual]\fP"
Returns name of object\&. If no name has been given to this object, the returned \fBSbName\fP will contain the empty string\&. 
.SS "void SoBase::setName (const \fBSbName\fP & newname)\fC [virtual]\fP"
Set the name of this object\&.
.PP
Some characters are invalid to use as parts of names for \fBSoBase\fP derived objects, as object names needs to be consistent with the syntax of Inventor and VRML files upon file export / import operations (so one must for instance avoid using special token characters)\&.
.PP
Invalid characters will be automatically replaced by underscore characters\&. If the name \fIstarts\fP with an invalid character, the new name will be \fIpreceded\fP by an underscore character\&.
.PP
For the exact definitions of what constitutes legal and illegal characters for \fBSoBase\fP names, see the \fBSbName\fP functions listed below\&.
.PP
\fBSee also:\fP
.RS 4
\fBgetName()\fP, \fBSbName::isBaseNameStartChar()\fP, \fBSbName::isBaseNameChar()\fP 
.RE
.PP

.SS "void SoBase::addName (\fBSoBase\fP *const b, const char *const name)\fC [static]\fP"
Adds a name<->object mapping to the global dictionary\&. 
.SS "void SoBase::removeName (\fBSoBase\fP *const base, const char *const name)\fC [static]\fP"
Removes a name<->object mapping from the global dictionary\&. 
.SS "void SoBase::startNotify (void)\fC [virtual]\fP"
This is the method which starts the notification sequence after changes\&.
.PP
At the end of a notification sequence, all 'immediate' sensors (i\&.e\&. sensors set up with a zero priority) are triggered\&. 
.PP
Reimplemented in \fBSoNode\fP\&.
.SS "void SoBase::notify (\fBSoNotList\fP * l)\fC [virtual]\fP"
Notifies all auditors for this instance when changes are made\&. 
.PP
Reimplemented in \fBSoNode\fP, \fBSoSceneTexture2\fP, \fBSoVRMLSwitch\fP, \fBSoVRMLLOD\fP, \fBSoProfilerStats\fP, \fBSoSceneTextureCubeMap\fP, \fBSoTextureCubeMap\fP, \fBSoText3\fP, \fBSoTexture2\fP, \fBSoImage\fP, \fBSoTexture3\fP, \fBSoVRMLGroup\fP, \fBSoVertexProperty\fP, \fBSoVRMLParent\fP, \fBSoVRMLTransform\fP, \fBSoVRMLVertexShape\fP, \fBSoShadowGroup\fP, \fBSoVRMLElevationGrid\fP, \fBSoAsciiText\fP, \fBSoVRMLShape\fP, \fBSoSeparator\fP, \fBSoVRMLScript\fP, \fBSoFieldContainer\fP, \fBSoBumpMap\fP, \fBSoVRMLProximitySensor\fP, \fBSoVRMLExtrusion\fP, \fBSoSwitch\fP, \fBSoVRMLBillboard\fP, \fBSoVRMLText\fP, \fBSoVertexAttribute\fP, \fBSoMaterial\fP, \fBSoShape\fP, \fBSoLOD\fP, \fBSoVRMLTouchSensor\fP, \fBSoLevelOfDetail\fP, \fBSoVRMLIndexedLine\fP, \fBSoVRMLPixelTexture\fP, \fBSoVRMLAppearance\fP, \fBSoEngine\fP, \fBSoVRMLIndexedLineSet\fP, \fBSoVertexShape\fP, \fBSoIndexedLineSet\fP, \fBSoBlinker\fP, \fBSoPackedColor\fP, \fBSoVRMLVertexPoint\fP, \fBSoVRMLTimeSensor\fP, \fBSoVRMLCollision\fP, \fBSoVRMLGeometry\fP, \fBSoVRMLVertexLine\fP, \fBSoNodeEngine\fP, \fBSoVRMLIndexedShape\fP, and \fBSoIndexedPointSet\fP\&.
.SS "void SoBase::addAuditor (void *const auditor, const \fBSoNotRec::Type\fP type)"
Add an auditor to notify whenever the object changes in any significant way\&.
.PP
\fBSee also:\fP
.RS 4
\fBremoveAuditor()\fP 
.RE
.PP

.SS "void SoBase::removeAuditor (void *const auditor, const \fBSoNotRec::Type\fP type)"
Remove an auditor from the list\&. \fIauditor\fP will then no longer be notified whenever any updates are made to this object\&.
.PP
\fBSee also:\fP
.RS 4
\fBaddAuditor()\fP 
.RE
.PP

.SS "const \fBSoAuditorList\fP & SoBase::getAuditors (void) const"
Returns list of objects auditing this object\&.
.PP
\fBSee also:\fP
.RS 4
\fBaddAuditor()\fP, \fBremoveAuditor()\fP 
.RE
.PP

.SS "void SoBase::addWriteReference (\fBSoOutput\fP * out, SbBool isfromfield = \fCFALSE\fP)\fC [virtual]\fP"
This method is used during the first write pass of a write action to count the number of references to this object in the scene graph\&. 
.PP
Reimplemented in \fBSoBaseKit\fP, \fBSoFieldContainer\fP, and \fBSoGroup\fP\&.
.SS "SbBool SoBase::shouldWrite (void)"
Returns \fCTRUE\fP if this object should be written out during a write action\&. Will return \fCFALSE\fP if no references to this object has been made in the scene graph\&.
.PP
Note that connections from the fields of fieldcontainer objects is not alone a valid reason for writing out the object -- there must also be at least one reference directly from another \fBSoBase\fP (like a parent/child relationship, for instance)\&.
.PP
This method will return a valid result only during the second pass of write actions\&. 
.SS "void SoBase::incrementCurrentWriteCounter (void)\fC [static]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "void SoBase::decrementCurrentWriteCounter (void)\fC [static]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "\fBSoBase\fP * SoBase::getNamedBase (const \fBSbName\fP & name, \fBSoType\fP type)\fC [static]\fP"
Returns the object of \fItype\fP, or derived from \fItype\fP, registered under \fIname\fP\&. If several has been registered under the same name with the same type, returns the \fIlast\fP one which was registered\&.
.PP
If no object of a valid type or subtype has been registered with the given name, returns \fCNULL\fP\&. 
.SS "\fBint\fP SoBase::getNamedBases (const \fBSbName\fP & name, \fBSoBaseList\fP & baselist, \fBSoType\fP type)\fC [static]\fP"
Returns the number of objects of type \fItype\fP, or derived from \fItype\fP, registered under \fIname\fP\&.
.PP
All matches will also be appended to \fIbaselist\fP\&. 
.SS "SbBool SoBase::read (\fBSoInput\fP * in, \fBSoBase\fP *& base, \fBSoType\fP expectedtype)\fC [static]\fP"
Read next \fBSoBase\fP derived instance from the \fIin\fP stream, check that it is derived from \fIexpectedtype\fP and place a pointer to the newly allocated instance in \fIbase\fP\&.
.PP
\fCFALSE\fP is returned on read errors, mismatch with the \fIexpectedtype\fP, or if there are attempts at referencing (through the \fCUSE\fP keyword) unknown instances\&.
.PP
If we return \fCTRUE\fP with \fIbase\fP equal to \fCNULL\fP, three things might have happened:
.PP
.IP "1." 4
End-of-file\&. Use \fBSoInput::eof()\fP after calling this method to detect end-of-file conditions\&.
.IP "2." 4
\fIin\fP didn't have a valid identifier name at the stream for us to read\&. This happens either in the case of errors, or when all child nodes of a group has been read\&. Check if the next character in the stream is a '}' to detect the latter case\&.
.IP "3." 4
A child was given as the \fCNULL\fP keyword\&. This can happen when reading the contents of \fBSoSFNode\fP fields (note that NULL is not allowed for \fBSoMFNode\fP)
.PP
.PP
If \fCTRUE\fP is returned and \fIbase\fP is not \fCNULL\fP upon return, the instance was allocated and initialized according to what was read from the \fIin\fP stream\&. 
.SS "void SoBase::setInstancePrefix (const \fBSbString\fP & c)\fC [static]\fP"
Referenced instances of \fBSoBase\fP are written as 'DEF NamePrefixNumber' when exported\&. 'Name' is the name of the base instance from \fBsetName()\fP, 'Prefix' is common for all objects and can be set by this method (default is '+'), and 'Number' is a unique id which is necessary if multiple objects have the same name\&.
.PP
If you want the prefix to be something else than '+', use this method\&. 
.SS "void SoBase::setTraceRefs (SbBool trace)\fC [static]\fP"
Set to \fCTRUE\fP to activate debugging of reference counting, which could aid in finding hard to track down problems with accesses to freed memory or memory leaks\&. Note: this will produce lots of debug information in any 'normal' running system, so use sensibly\&.
.PP
The reference tracing functionality will be disabled in 'release
versions' of the Coin library\&. 
.SS "SbBool SoBase::getTraceRefs (void)\fC [static]\fP"
Return the status of the reference tracing flag\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetTraceRefs()\fP 
.RE
.PP

.SS "SbBool SoBase::connectRoute (\fBSoInput\fP * in, const \fBSbName\fP & fromnodename, const \fBSbName\fP & fromfieldname, const \fBSbName\fP & tonodename, const \fBSbName\fP & tofieldname)\fC [static]\fP"
Connect a route from the node named \fIfromnodename's\fP field \fIfromfieldname\fP to the node named \fItonodename's\fP field \fItofieldname\fP\&. This method will consider the fields types (event in, event out, etc) when connecting\&.
.PP
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2\&.1 API\&.
.PP
\fBSince:\fP
.RS 4
Coin 2\&.0 
.RE
.PP

.SS "void SoBase::assertAlive (void) const"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP
.PP
There are 4 bits allocated for each SoBase-object for a bitpattern that indicates the object is still 'alive'\&. The pattern is changed when the object is destructed\&. If this method is then called after destruction, an assert will hit\&.
.PP
This is used internally in Coin (in for instance \fBSoBase::ref()\fP) to try to detect when the instance has been prematurely destructed\&. This is a very common mistake to make by application programmers (letting the refcount dip to zero before it should, that is), so the extra piece of assistance through the accompanying assert() in this method to detect dangling references to the object, with subsequent memory corruption and mysterious crashes, should be a Good Thing\&.
.PP
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2\&.1 API\&.
.PP
\fBSince:\fP
.RS 4
Coin 2\&.0 
.RE
.PP

.SS "SbBool SoBase::readRoute (\fBSoInput\fP * in)\fC [static]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP
.PP
Reads a (VRML97) ROUTE\&. We decided to also add support for routes in Coin, as a generic feature, since we think it is nicer than setting up field connections inside the nodes\&. 
.SS "void SoBase::destroy (void)\fC [protected]\fP, \fC [virtual]\fP"
Cleans up all hanging references to and from this instance, and then commits suicide\&.
.PP
Called automatically when the reference count goes to zero\&. 
.PP
Reimplemented in \fBSoProto\fP\&.
.SS "SbBool SoBase::hasMultipleWriteRefs (void) const\fC [protected]\fP"
Returns \fCTRUE\fP if this object will be written more than once upon export\&. Note that the result from this method is only valid during the second pass of a write action (and partly during the COUNT_REFS pass)\&. 
.SS "SbBool SoBase::writeHeader (\fBSoOutput\fP * out, SbBool isgroup, SbBool isengine) const\fC [protected]\fP"
Write out the header of any \fBSoBase\fP derived object\&. The header consists of the \fCDEF\fP keyword and the object name (if the object has a name, otherwise these will be skipped), the class name and a left bracket\&.
.PP
Alternatively, the object representation may be made up of just the \fCUSE\fP keyword plus the object name, if this is the second or subsequent reference written to the file\&.
.PP
If the object has been completed just by writing the header (which will be the case if we're writing multiple references of an object), we return \fCTRUE\fP, otherwise \fCFALSE\fP\&.
.PP
If we return \fCFALSE\fP (i\&.e\&. there's more to write), we will increment the indentation level\&.
.PP
\fBSee also:\fP
.RS 4
\fBwriteFooter()\fP, \fBSoOutput::indent()\fP 
.RE
.PP

.SS "void SoBase::writeFooter (\fBSoOutput\fP * out) const\fC [protected]\fP"
This method will terminate the block representing an \fBSoBase\fP derived object\&. 
.SS "const char * SoBase::getFileFormatName (void) const\fC [protected]\fP, \fC [virtual]\fP"
Returns the class name this object should be written under\&. Default string returned is the name of the class from the type system\&.
.PP
User extensions nodes and engines override this method to return the name of the extension (instead of 'UnknownNode' or 'UnknownEngine')\&. 
.PP
Reimplemented in \fBSoProtoInstance\fP\&.
.SS "SbBool SoBase::readInstance (\fBSoInput\fP * in, unsigned short flags)\fC [protected]\fP, \fC [pure virtual]\fP"
This method is mainly intended for internal use during file import operations\&.
.PP
It reads a definition of an instance from the input stream \fIin\fP\&. The input stream state points to the start of a serialized / persistant representation of an instance of this class type\&.
.PP
\fCTRUE\fP or \fCFALSE\fP is returned, depending on if the instantiation and configuration of the new object of this class type went ok or not\&. The import process should be robust and handle corrupted input streams by returning \fCFALSE\fP\&.
.PP
\fIflags\fP is used internally during binary import when reading user extension nodes, group nodes or engines\&. 
.PP
Implemented in \fBSoNode\fP, \fBSoBaseKit\fP, \fBSoWWWInline\fP, \fBSoFieldContainer\fP, \fBSoVRMLSwitch\fP, \fBSoVRMLLOD\fP, \fBSoInteractionKit\fP, \fBSoTextureCubeMap\fP, \fBSoNodeKitListPart\fP, \fBSoSeparator\fP, \fBSoTexture2\fP, \fBSoImage\fP, \fBSoVRMLParent\fP, \fBSoTexture3\fP, \fBSoShaderObject\fP, \fBSoGroup\fP, \fBSoProto\fP, \fBSoFile\fP, \fBSoVRMLImageTexture\fP, \fBSoNormalBinding\fP, \fBSoEngine\fP, \fBSoProtoInstance\fP, \fBSoBumpMap\fP, \fBSoVertexAttribute\fP, \fBSoTextureCoordinateBinding\fP, \fBSoVRMLBackground\fP, \fBSoNodeEngine\fP, and \fBSoVRMLPixelTexture\fP\&.
.SS "uint32_t SoBase::getCurrentWriteCounter (void)\fC [static]\fP, \fC [protected]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
