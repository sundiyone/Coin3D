.TH "heap.h" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
heap.h
.SH SYNOPSIS
.br
.PP
\fC#include <Inventor/C/basic\&.h>\fP
.br

.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef \fBint\fP \fBcc_heap_compare_cb\fP(void *o1, void *o2)"
.br
.ti -1c
.RI "typedef struct \fBcc_heap\fP \fBcc_heap\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBcc_heap\fP * \fBcc_heap_construct\fP (unsigned \fBint\fP size, \fBcc_heap_compare_cb\fP *comparecb, SbBool support_remove)"
.br
.ti -1c
.RI "void \fBcc_heap_destruct\fP (\fBcc_heap\fP *h)"
.br
.ti -1c
.RI "void \fBcc_heap_clear\fP (\fBcc_heap\fP *h)"
.br
.ti -1c
.RI "void \fBcc_heap_add\fP (\fBcc_heap\fP *h, void *o)"
.br
.ti -1c
.RI "void * \fBcc_heap_get_top\fP (\fBcc_heap\fP *h)"
.br
.ti -1c
.RI "void * \fBcc_heap_extract_top\fP (\fBcc_heap\fP *h)"
.br
.ti -1c
.RI "\fBint\fP \fBcc_heap_remove\fP (\fBcc_heap\fP *h, void *o)"
.br
.ti -1c
.RI "unsigned \fBint\fP \fBcc_heap_elements\fP (\fBcc_heap\fP *h)"
.br
.ti -1c
.RI "SbBool \fBcc_heap_empty\fP (\fBcc_heap\fP *h)"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "\fBint\fP cc_heap_compare_cb"
A type definition for heap compare callback function\&. 
.SS "struct \fBcc_heap\fP \fBcc_heap\fP"
A type definition for the cc_heap structure 
.SH "Function Documentation"
.PP 
.SS "\fBcc_heap\fP* cc_heap_construct (unsigned \fBint\fP size, \fBcc_heap_compare_cb\fP * comparecb, SbBool support_remove)"
Construct a heap\&. \fIsize\fP is the initial array size\&.
.PP
\fIcomparecb\fP should return a negative value if the first element is less than the second, zero if they are equal and a positive value if the first element is greater than the second\&.
.PP
\fIsupport_remove\fP specifies if the heap should support removal of elements (other than the top element) after they are added; this requires use of a hash table to be efficent, but as a slight runtime overhead will be incurred for the add and extract_top functions the support can be disabled if you don't need it\&. 
.SS "void cc_heap_destruct (\fBcc_heap\fP * h)"
Destruct the heap \fIh\fP\&. 
.SS "void cc_heap_clear (\fBcc_heap\fP * h)"
Clear/remove all elements in the heap \fIh\fP\&. 
.SS "void cc_heap_add (\fBcc_heap\fP * h, void * o)"
Add the element \fIo\fP to the heap \fIh\fP\&. 
.SS "void* cc_heap_get_top (\fBcc_heap\fP * h)"
Returns the top element from the heap \fIh\fP\&. If the heap is empty, NULL is returned\&. 
.SS "void* cc_heap_extract_top (\fBcc_heap\fP * h)"
Returns and removes the top element from the heap \fIh\fP\&. If the heap is empty, NULL is returned\&. 
.SS "\fBint\fP cc_heap_remove (\fBcc_heap\fP * h, void * o)"
Remove \fIo\fP from the heap \fIh\fP; if present TRUE is returned, otherwise FALSE\&. Please note that the heap must have been created with support_remove\&. 
.SS "unsigned \fBint\fP cc_heap_elements (\fBcc_heap\fP * h)"
Returns the number of elements in the heap \fIh\fP\&. 
.SS "SbBool cc_heap_empty (\fBcc_heap\fP * h)"
Returns TRUE of the heap \fIh\fP is empty; otherwise FALSE\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
