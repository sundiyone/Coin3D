.TH "SoIntersectionDetectionAction" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SoIntersectionDetectionAction \- The \fBSoIntersectionDetectionAction\fP class is for detecting intersecting primitives in a scene\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Inventor/collision/SoIntersectionDetectionAction\&.h>\fP
.PP
Inherits \fBSoAction\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBResp\fP { \fBNEXT_PRIMITIVE\fP, \fBNEXT_SHAPE\fP, \fBABORT\fP }"
.br
.ti -1c
.RI "typedef \fBSoCallbackAction::Response\fP \fBSoIntersectionVisitationCB\fP(void *closure, const \fBSoPath\fP *where)"
.br
.ti -1c
.RI "typedef SbBool \fBSoIntersectionFilterCB\fP(void *closure, const \fBSoPath\fP *p1, const \fBSoPath\fP *p2)"
.br
.ti -1c
.RI "typedef Resp \fBSoIntersectionCB\fP(void *closure, const \fBSoIntersectingPrimitive\fP *p1, const \fBSoIntersectingPrimitive\fP *p2)"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fBSoType\fP \fBgetTypeId\fP (void) const"
.br
.ti -1c
.RI "void \fBsetIntersectionDetectionEpsilon\fP (float epsilon)"
.br
.ti -1c
.RI "float \fBgetIntersectionDetectionEpsilon\fP (void) const"
.br
.ti -1c
.RI "void \fBsetTypeEnabled\fP (\fBSoType\fP type, SbBool enable)"
.br
.ti -1c
.RI "SbBool \fBisTypeEnabled\fP (\fBSoType\fP type, SbBool checkgroups=FALSE) const"
.br
.ti -1c
.RI "void \fBsetManipsEnabled\fP (SbBool enable)"
.br
.ti -1c
.RI "SbBool \fBisManipsEnabled\fP (void) const"
.br
.ti -1c
.RI "void \fBsetDraggersEnabled\fP (SbBool enable)"
.br
.ti -1c
.RI "SbBool \fBisDraggersEnabled\fP (void) const"
.br
.ti -1c
.RI "void \fBsetShapeInternalsEnabled\fP (SbBool enable)"
.br
.ti -1c
.RI "SbBool \fBisShapeInternalsEnabled\fP (void) const"
.br
.ti -1c
.RI "void \fBaddVisitationCallback\fP (\fBSoType\fP type, SoIntersectionVisitationCB *cb, void *closure)"
.br
.ti -1c
.RI "void \fBremoveVisitationCallback\fP (\fBSoType\fP type, SoIntersectionVisitationCB *cb, void *closure)"
.br
.ti -1c
.RI "virtual void \fBapply\fP (\fBSoNode\fP *node)"
.br
.ti -1c
.RI "virtual void \fBapply\fP (\fBSoPath\fP *path)"
.br
.ti -1c
.RI "virtual void \fBapply\fP (const \fBSoPathList\fP &paths, SbBool obeysRules=FALSE)"
.br
.ti -1c
.RI "virtual void \fBsetFilterCallback\fP (SoIntersectionFilterCB *cb, void *closure=NULL)"
.br
.ti -1c
.RI "virtual void \fBaddIntersectionCallback\fP (SoIntersectionCB *cb, void *closure=NULL)"
.br
.ti -1c
.RI "virtual void \fBremoveIntersectionCallback\fP (SoIntersectionCB *cb, void *closure=NULL)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBSoType\fP \fBgetClassTypeId\fP (void)"
.br
.ti -1c
.RI "static void \fBaddMethod\fP (const \fBSoType\fP type, \fBSoActionMethod\fP method)"
.br
.ti -1c
.RI "static void \fBenableElement\fP (const \fBSoType\fP type, const \fBint\fP stackindex)"
.br
.ti -1c
.RI "static void \fBinitClass\fP (void)"
.br
.ti -1c
.RI "static void \fBsetIntersectionEpsilon\fP (float epsilon)"
.br
.ti -1c
.RI "static float \fBgetIntersectionEpsilon\fP (void)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual const \fBSoEnabledElementsList\fP & \fBgetEnabledElements\fP (void) const"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static \fBSoEnabledElementsList\fP * \fBgetClassEnabledElements\fP (void)"
.br
.ti -1c
.RI "static \fBSoActionMethodList\fP * \fBgetClassActionMethods\fP (void)"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
The \fBSoIntersectionDetectionAction\fP class is for detecting intersecting primitives in a scene\&. 

Note that only collisions between actual geometry in the scene is detected, so the contents of some special nodes like e\&.g\&. \fBSoText2\fP and \fBSoImage\fP (which projects to screen-plane bitmap graphics, and not actual polygons) will not be considered for collision detection\&.
.PP
Note also that the \fBSoIntersectionDetectionAction\fP class is not a high-performance component in Coin\&. Using it in a continuous manner over complex scene graphs is doomed to be a performance killer\&.
.PP
Below is a simple usage example for this class\&. It was written as a stand-alone framework set up for profiling and optimization of the \fBSoIntersectionDetectionAction\fP\&. It tests intersection of all shapes against each other for the loaded file\&.
.PP
.PP
.nf
#include <cstdlib>
#include <Inventor/SbTime\&.h>
#include <Inventor/SoDB\&.h>
#include <Inventor/SoInteraction\&.h>
#include <Inventor/collision/SoIntersectionDetectionAction\&.h>
#include <Inventor/errors/SoDebugError\&.h>
#include <Inventor/nodekits/SoNodeKit\&.h>
#include <Inventor/nodes/SoSeparator\&.h>

static SoIntersectionDetectionAction::Resp
intersectionCB(void * closure,
               const SoIntersectingPrimitive * pr1,
               const SoIntersectingPrimitive * pr2)
{
  (void)fprintf(stdout, "intersection hit!\n");
  return SoIntersectionDetectionAction::NEXT_PRIMITIVE;
}

int
main(int argc, char ** argv)
{
  SoDB::init();
  SoNodeKit::init();
  SoInteraction::init();

  if (argc != 2) {
    (void)fprintf(stderr, "\n\tUsage: testapp <filename\&.iv>\n\n");
    exit(1);
  }

  SoInput in;
  SbBool ok = in\&.openFile(argv[1]);
  assert(ok);
  SoSeparator * root = SoDB::readAll(&in);
  assert(root);

  root->ref();

  SoIntersectionDetectionAction ida;
  ida\&.addIntersectionCallback(intersectionCB, NULL);
  ida\&.setManipsEnabled(FALSE);
  ida\&.setDraggersEnabled(FALSE);
  ida\&.setIntersectionDetectionEpsilon(10\&.0f);

  SbTime starttime = SbTime::getTimeOfDay();
  SoDebugError::postInfo("main", "SoIntersectionDetectionAction::apply");

  ida\&.apply(root);

  SoDebugError::postInfo("main", "apply() done after %f seconds\&.",
                         (SbTime::getTimeOfDay() - starttime)\&.getValue());

  root->unref();

  return 0;
}
.fi
.PP
.PP
\fBSince:\fP
.RS 4
Coin 2\&.1 
.PP
TGS Inventor 2\&.4 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "\fBSoType\fP SoIntersectionDetectionAction::getTypeId (void) const\fC [virtual]\fP"
Returns the type identification of an action derived from a class inheriting \fBSoAction\fP\&. This is used for run-time type checking and 'downward' casting\&.
.PP
Usage example:
.PP
.PP
.nf
void bar(SoAction * action)
{
  if (action->getTypeId() == SoGLRenderAction::getClassTypeId()) {
    // safe downward cast, know the type
    SoGLRenderAction * glrender = (SoGLRenderAction *)action;
  }
  return; // ignore if not renderaction
}
.fi
.PP
.PP
For application programmers wanting to extend the library with new actions: this method needs to be overridden in \fIall\fP subclasses\&. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through Inventor/nodes/SoSubAction\&.h: SO_ACTION_SOURCE, SO_ACTION_INIT_CLASS and SO_ACTION_CONSTRUCTOR\&.
.PP
For more information on writing Coin extensions, see the \fBSoAction\fP class documentation\&.
.PP
Returns the actual type id of an object derived from a class inheriting \fBSoAction\fP\&. Needs to be overridden in \fIall\fP subclasses\&. 
.PP
Implements \fBSoAction\fP\&.
.SS "void SoIntersectionDetectionAction::addMethod (const \fBSoType\fP type, \fBSoActionMethod\fP method)\fC [static]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "void SoIntersectionDetectionAction::enableElement (const \fBSoType\fP type, const \fBint\fP stackindex)\fC [static]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "const \fBSoEnabledElementsList\fP & SoIntersectionDetectionAction::getEnabledElements (void) const\fC [protected]\fP, \fC [virtual]\fP"
Returns a list of the elements used by action instances of this class upon traversal operations\&. 
.PP
Reimplemented from \fBSoAction\fP\&.
.SS "void SoIntersectionDetectionAction::setIntersectionDetectionEpsilon (float epsilon)"
Sets the intersection detection distance epsilon value for the action object\&. This overrides the global value\&.
.PP
See also \fBSoIntersectionDetectionAction::setIntersectionEpsilon()\fP for important information about how this setting influences performance\&. 
.SS "float SoIntersectionDetectionAction::getIntersectionDetectionEpsilon (void) const"
Returns the set intersection detection distance epsilon value for the action object\&. 
.SS "void SoIntersectionDetectionAction::setIntersectionEpsilon (float epsilon)\fC [static]\fP"
Sets the global intersection detection distance epsilon value\&.
.PP
This makes primitives within the epsilon distance be considered to intersect each other\&.
.PP
This will affect all intersection detection action objects in use that don't have a locally set value\&.
.PP
The epsilon value is a worldspace value\&.
.PP
Be aware that increasing the epsilon value can \fIdramatically\fP increase the number of primitive intersection tests being done to decide intersections\&. Increasing the epsilon value can therefore cause serious slow-downs in the running time of the intersections checks\&. 
.SS "float SoIntersectionDetectionAction::getIntersectionEpsilon (void)\fC [static]\fP"
Returns the globally set intersection detection distance epsilon value\&. 
.SS "void SoIntersectionDetectionAction::setTypeEnabled (\fBSoType\fP type, SbBool enable)"
Sets whether nodes of specific types (including derived objects) should be tested for intersection or not\&.
.PP
\fBSee also:\fP
.RS 4
\fBisTypeEnabled()\fP, \fBsetManipsEnabled()\fP, \fBsetDraggersEnabled()\fP 
.RE
.PP

.SS "SbBool SoIntersectionDetectionAction::isTypeEnabled (\fBSoType\fP type, SbBool checkgroups = \fCFALSE\fP) const"
Returns whether nodes of specific types are enabled or not\&. The \fIcheckgroups\fP argument can be set to TRUE if you wan't the return value to reflect whether the node will be implicit enabled/disabled through the settings controlled by the \fBsetManipsEnabled()\fP and \fBsetDraggersEnabled()\fP functions\&.
.PP
The default is that all node types are enabled\&.
.PP
Note that derivation checks are not performed - the type needs to be the exact same type as has been disabled with \fBsetTypeEnabled()\fP
.PP
\fBSee also:\fP
.RS 4
\fBsetTypeEnabled()\fP 
.RE
.PP

.SS "void SoIntersectionDetectionAction::setManipsEnabled (SbBool enable)"
Sets whether manipulators in the scene graph should be tested for intersection with other geometry or not\&.
.PP
Note that when draggers are disabled with \fBsetDraggersEnabled()\fP, this setting has no effect - manipulators are disabled too\&.
.PP
\fBSee also:\fP
.RS 4
\fBisManipsEnabled()\fP, \fBsetDraggersEnabled()\fP, \fBsetTypeEnabled()\fP 
.RE
.PP

.SS "SbBool SoIntersectionDetectionAction::isManipsEnabled (void) const"
Returns whether the actions is set up to test intersection on manipulators in the scene or not\&.
.PP
Note that when draggers are disabled with \fBsetDraggersEnabled()\fP, this setting has no effect - manipulators are disabled too\&.
.PP
The default is that manipulators are enabled for intersection testing with other geometry in the scene\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetManipsEnabled()\fP 
.RE
.PP

.SS "void SoIntersectionDetectionAction::setDraggersEnabled (SbBool enable)"
Sets whether draggers in the scene graph should be tested for intersection with other geometry or not\&.
.PP
Note that when you disable draggers, manipulators are also automatically disabled, although the isManipsDisabled() setting might reflect otherwise\&.
.PP
\fBSee also:\fP
.RS 4
\fBisDraggersEnabled()\fP, \fBsetManipsEnabled()\fP, \fBsetTypeEnabled()\fP 
.RE
.PP

.SS "SbBool SoIntersectionDetectionAction::isDraggersEnabled (void) const"
Returns whether the actions is set up to test intersection on draggers in the scene or not\&.
.PP
The default is that draggers are enabled for intersection testing with other geometry in the scene\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetDraggersEnabled()\fP 
.RE
.PP

.SS "void SoIntersectionDetectionAction::setShapeInternalsEnabled (SbBool enable)"
Sets whether nodes in the scene graph should be checked for intersecting primitives within themselves\&.
.PP
Default is \fCFALSE\fP\&.
.PP
\fBSee also:\fP
.RS 4
\fBisShapeInternalsEnabled()\fP 
.RE
.PP

.SS "SbBool SoIntersectionDetectionAction::isShapeInternalsEnabled (void) const"
Returns whether nodes in the scene graph will be checked for intersecting primitives within themselves\&.
.PP
The default value for this setting is \fCFALSE\fP\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetShapeInternalsEnabled()\fP 
.RE
.PP

.SS "void SoIntersectionDetectionAction::addVisitationCallback (\fBSoType\fP type, SoIntersectionVisitationCB * cb, void * closure)"
The scene graph traversal can be controlled with callbacks which you set with this method\&. Use just like you would use \fBSoCallbackAction::addPreCallback()\fP\&.
.PP
\fBSee also:\fP
.RS 4
\fBSoCallbackAction::addPreCallback()\fP 
.RE
.PP

.SS "void SoIntersectionDetectionAction::removeVisitationCallback (\fBSoType\fP type, SoIntersectionVisitationCB * cb, void * closure)"
The scene graph traversal can be controlled with callbacks which you remove with this method\&. Use just like you would use SoCallbackAction::removePreCallback()\&.
.PP
\fBSee also:\fP
.RS 4
SoCallbackAction::removePreCallback() 
.RE
.PP

.SS "void SoIntersectionDetectionAction::apply (\fBSoNode\fP * root)\fC [virtual]\fP"
Applies the action to the scene graph rooted at \fIroot\fP\&.
.PP
Note that you should \fInot\fP apply an action to a node with a zero reference count\&. The behavior in that case is undefined\&. 
.PP
Reimplemented from \fBSoAction\fP\&.
.SS "void SoIntersectionDetectionAction::apply (\fBSoPath\fP * path)\fC [virtual]\fP"
Applies the action to the parts of the graph defined by \fIpath\fP\&.
.PP
Note that an \fBSoPath\fP will also contain all nodes that may influence e\&.g\&. geometry nodes in the path\&. So for instance applying an \fBSoGLRenderAction\fP on an \fBSoPath\fP will render that path as expected in the view, where geometry will get its materials, textures, and other appearance settings correctly\&.
.PP
If the \fIpath\fP ends in an \fBSoGroup\fP node, the action will also traverse the tail node's children\&. 
.PP
Reimplemented from \fBSoAction\fP\&.
.SS "void SoIntersectionDetectionAction::apply (const \fBSoPathList\fP & pathlist, SbBool obeysrules = \fCFALSE\fP)\fC [virtual]\fP"
Applies action to the graphs defined by \fIpathlist\fP\&. If \fIobeysrules\fP is set to \fCTRUE\fP, \fIpathlist\fP must obey the following four conditions (which is the case for path lists returned from search actions for non-group nodes and path lists returned from picking actions):
.PP
All paths must start at the same head node\&. All paths must be sorted in traversal order\&. The paths must be unique\&. No path can continue through the end point of another path\&.
.PP
\fBSee also:\fP
.RS 4
\fBSoAction::apply(SoPath * path)\fP 
.RE
.PP

.PP
Reimplemented from \fBSoAction\fP\&.
.SS "void SoIntersectionDetectionAction::setFilterCallback (SoIntersectionFilterCB * cb, void * closure = \fCNULL\fP)\fC [virtual]\fP"
This callback is called when two shapes are found to have intersecting bounding boxes, and are about to be checked for real intersection between their primitives\&.
.PP
When intersection epsilon values are in use, bounding box intersection testing is done approximately and will trigger the filter callback on boxes that are further from each other than the epsilon length\&.
.PP
If the callback returns TRUE, the intersection test will be performed\&. If the callback returns FALSE, the intersection testing will be skipped\&.
.PP
The API allows only one filter callback\&. 
.SS "void SoIntersectionDetectionAction::addIntersectionCallback (SoIntersectionCB * cb, void * closure = \fCNULL\fP)\fC [virtual]\fP"
Adds a callback to be called when two intersecting primitives are found in the scene\&.
.PP
If the callback returns ABORT, the intersection detection is aborted\&. If the callback returns NEXT_SHAPE, the intersection detection between these two shapes are aborted and the action continues checking other shapes\&. If the callback returns NEXT_PRIMITIVE, the intersection detection testing continues checking the other primitives in these two shapes\&.
.PP
\fBSee also:\fP
.RS 4
\fBremoveIntersectionCallback()\fP 
.RE
.PP

.SS "void SoIntersectionDetectionAction::removeIntersectionCallback (SoIntersectionCB * cb, void * closure = \fCNULL\fP)\fC [virtual]\fP"
Removes a callback set with \fBaddIntersectionCallback()\fP\&.
.PP
\fBSee also:\fP
.RS 4
\fBaddIntersectionCallback()\fP 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
