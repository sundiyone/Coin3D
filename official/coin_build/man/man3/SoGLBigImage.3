.TH "SoGLBigImage" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SoGLBigImage \- The \fBSoGLBigImage\fP class is used to handle 2D OpenGL textures of any size\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <include/Inventor/misc/SoGLBigImage\&.h>\fP
.PP
Inherits \fBSoGLImage\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSoGLBigImage\fP ()"
.br
.ti -1c
.RI "virtual void \fBunref\fP (\fBSoState\fP *state=NULL)"
.br
.ti -1c
.RI "virtual \fBSoType\fP \fBgetTypeId\fP (void) const"
.br
.ti -1c
.RI "virtual void \fBsetData\fP (const \fBSbImage\fP *image, const \fBWrap\fP wraps=REPEAT, const \fBWrap\fP wrapt=REPEAT, const float quality=0\&.5f, const int border=0, SoState *createinstate=NULL)"
.br
.ti -1c
.RI "virtual void \fBsetData\fP (const \fBSbImage\fP *image, const \fBWrap\fP wraps, const \fBWrap\fP wrapt, const \fBWrap\fP wrapr, const float quality=0\&.5f, const int border=0, SoState *createinstate=NULL)"
.br
.ti -1c
.RI "\fBint\fP \fBinitSubImages\fP (const \fBSbVec2s\fP &subimagesize) const"
.br
.ti -1c
.RI "void \fBhandleSubImage\fP (const \fBint\fP idx, \fBSbVec2f\fP &start, \fBSbVec2f\fP &end, \fBSbVec2f\fP &tcmul)"
.br
.ti -1c
.RI "void \fBapplySubImage\fP (\fBSoState\fP *state, const \fBint\fP idx, const float quality, const \fBSbVec2s\fP &projsize)"
.br
.ti -1c
.RI "SbBool \fBexceededChangeLimit\fP (void)"
.br
.ti -1c
.RI "virtual \fBSoGLDisplayList\fP * \fBgetGLDisplayList\fP (\fBSoState\fP *state)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBSoType\fP \fBgetClassTypeId\fP (void)"
.br
.ti -1c
.RI "static \fBint\fP \fBsetChangeLimit\fP (const \fBint\fP limit)"
.br
.ti -1c
.RI "static void \fBinitClass\fP (void)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBunrefOldDL\fP (\fBSoState\fP *state, const uint32_t maxage)"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
The \fBSoGLBigImage\fP class is used to handle 2D OpenGL textures of any size\&. 

This class is internal\&. To enable/disable big-image texture handling you should use the \fBSoTextureScalePolicy\fP node\&.
.PP
The technique used is the following: split the texture into x*y equal size blocks\&. All these subtextures are of size 2^n, and are typically quite small (256x256 or smaller)\&. Each triangle is clipped, based on the texture coordinates, into several smaller triangles\&. The triangles will then be guaranteed to use only one subtexture\&. Then the triangles are projected onto the screen, and the maximum projected size for each subtexture is calculated\&. Subtextures outside the viewport will be culled\&. Each subtexture is then sampled down to a 2^n value close to the projected size, and a GL texture is created with this size\&. This GL texture is used when rendering triangles that are clipped into that subtexture\&.
.PP
Mipmapping is disabled for \fBSoGLBigImage\fP\&. Aliasing problems shouldn't occur because the projected size of the texture is calculated on the fly\&. When mipmapping is enabled, the amount of texture memory used is doubled, and creating the texture object is much slower, so we avoid this for \fBSoGLBigImage\fP\&.
.PP
Be aware that this class is an extension for Coin, and it is not available in the original SGI Open Inventor v2\&.1 API\&.
.PP
\fBSince:\fP
.RS 4
Coin 2\&.0 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "SoGLBigImage::SoGLBigImage (void)"
Constructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "void SoGLBigImage::unref (\fBSoState\fP * state = \fCNULL\fP)\fC [virtual]\fP"
This class has a private destuctor since we want users to supply the current GL state when deleting the image\&. This is to make sure gl texture objects are freed as soon as possible\&. If you supply NULL to this method, the gl texture objects won't be deleted until the next time an GLRenderAction is applied in the image's cache context(s)\&. 
.PP
Reimplemented from \fBSoGLImage\fP\&.
.SS "\fBSoType\fP SoGLBigImage::getTypeId (void) const\fC [virtual]\fP"
Returns the type id for an \fBSoGLImage\fP instance\&. 
.PP
Reimplemented from \fBSoGLImage\fP\&.
.SS "void SoGLBigImage::setData (const \fBSbImage\fP * image, const \fBWrap\fP wraps = \fCREPEAT\fP, const \fBWrap\fP wrapt = \fCREPEAT\fP, const float quality = \fC0\&.5f\fP, const \fBint\fP border = \fC0\fP, \fBSoState\fP * createinstate = \fCNULL\fP)\fC [virtual]\fP"
Convenience 2D wrapper function around the 3D \fBsetData()\fP\&. 
.PP
Reimplemented from \fBSoGLImage\fP\&.
.SS "void SoGLBigImage::setData (const \fBSbImage\fP * image, const \fBWrap\fP wraps, const \fBWrap\fP wrapt, const \fBWrap\fP wrapr, const float quality = \fC0\&.5f\fP, const \fBint\fP border = \fC0\fP, \fBSoState\fP * createinstate = \fCNULL\fP)\fC [virtual]\fP"
Sets the data for this GL image\&. Should only be called when one of the parameters have changed, since this will cause the GL texture object to be recreated\&. Caller is responsible for sending legal Wrap values\&. CLAMP_TO_EDGE is only supported on OpenGL v1\&.2 implementations, and as an extension on some earlier SGI implementations (GL_SGIS_texture_edge_clamp)\&.
.PP
For now, if quality > 0\&.5 when created, we create mipmaps, otherwise a regular texture is created\&. Be aware, if you for instance create a texture with texture quality 0\&.4, and then later try to apply the texture with a texture quality greater than 0\&.5, the texture object will be recreated as a mipmap texture object\&. This will happen only once though, of course\&.
.PP
If \fIborder\fP != 0, the OpenGL texture will be created with this border size\&. Be aware that this might be extremely slow on most PC hardware\&.
.PP
Normally, the OpenGL texture object isn't created until the first time it is needed, but if \fIcreateinstate\fP is != NULL, the texture object is created immediately\&. This is useful if you use a temporary buffer to hold the texture data\&. Be careful when using this feature, since the texture data might be needed at a later stage (for instance to create a texture object for another context)\&. It will not be possible to create texture objects for other cache contexts when \fIcreateinstate\fP is != NULL\&.
.PP
Also if \fIcreateinstate\fP is supplied, and all the attributes are the same as the current data in the image, glTexSubImage() will be used to insert the image data instead of creating a new texture object\&. This is much faster on most OpenGL drivers, and is very useful, for instance when doing animated textures\&.
.PP
If you supply NULL for \fIimage\fP, the instance will be reset, causing all display lists and memory to be freed\&. 
.PP
Reimplemented from \fBSoGLImage\fP\&.
.SS "SbBool SoGLBigImage::exceededChangeLimit (void)"
To avoid doing too much work in one frame, there is a limit on the number of subtextures that can be changed each frame\&. If this limit is exceeded, this function will return TRUE, otherwise FALSE\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetChangeLimit()\fP 
.RE
.PP

.SS "\fBint\fP SoGLBigImage::setChangeLimit (const \fBint\fP limit)\fC [static]\fP"
Sets the change limit\&. Returns the old limit\&.
.PP
\fBSee also:\fP
.RS 4
\fBexceededChangeLimit()\fP 
.RE
.PP
\fBSince:\fP
.RS 4
Coin 2\&.3 
.RE
.PP

.SS "\fBSoGLDisplayList\fP * SoGLBigImage::getGLDisplayList (\fBSoState\fP * state)\fC [virtual]\fP"
Returns or creates a \fBSoGLDisplayList\fP to be used for rendering\&. Returns NULL if no SoDLDisplayList could be created\&. 
.PP
Reimplemented from \fBSoGLImage\fP\&.
.SS "void SoGLBigImage::unrefOldDL (\fBSoState\fP * state, const uint32_t maxage)\fC [protected]\fP, \fC [virtual]\fP"
Virtual method that will be called once each frame\&. The method should unref display lists that has an age bigger or equal to \fImaxage\fP, and increment the age for other display lists\&. 
.PP
Reimplemented from \fBSoGLImage\fP\&.
.SS "void SoGLBigImage::initClass (void)\fC [static]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
