.TH "SoOrthographicCamera" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SoOrthographicCamera \- The \fBSoOrthographicCamera\fP class defines a camera node with orthographic rendering\&.
.PP
Orthographic rendering will not give a particularly realistic impression of the scene, but non-realistic rendering is for various reasons widely used in applications for e\&.g\&. Computer Aided Design\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Inventor/nodes/SoOrthographicCamera\&.h>\fP
.PP
Inherits \fBSoCamera\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fBSoType\fP \fBgetTypeId\fP (void) const"
.br
.RI "Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. "
.ti -1c
.RI "\fBSoOrthographicCamera\fP (void)"
.br
.ti -1c
.RI "virtual void \fBscaleHeight\fP (float scalefactor)"
.br
.ti -1c
.RI "virtual \fBSbViewVolume\fP \fBgetViewVolume\fP (float useaspectratio=0\&.0f) const"
.br
.ti -1c
.RI "virtual void \fBviewBoundingBox\fP (const \fBSbBox3f\fP &box, float aspect, float slack)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBSoType\fP \fBgetClassTypeId\fP (void)"
.br
.ti -1c
.RI "static void \fBinitClass\fP (void)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBSoSFFloat\fP \fBheight\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual const \fBSoFieldData\fP * \fBgetFieldData\fP (void) const"
.br
.ti -1c
.RI "virtual \fB~SoOrthographicCamera\fP ()"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static const \fBSoFieldData\fP ** \fBgetFieldDataPtr\fP (void)"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
The \fBSoOrthographicCamera\fP class defines a camera node with orthographic rendering\&.
.PP
Orthographic rendering will not give a particularly realistic impression of the scene, but non-realistic rendering is for various reasons widely used in applications for e\&.g\&. Computer Aided Design\&. 

Also, a simple technique for drawing overlay / HUD style graphics (often appearing to be in 2D) can be implemented by setting up a 'sub scene graph' with an \fBSoOrthographicCamera\fP and the geometry\&. As a simple demonstration of this concept, load this file into e\&.g\&. the ExaminerViewer:
.PP
.PP
.nf
#Inventor V2.1 ascii

Separator {
   PerspectiveCamera { position 0 0 5 }
   Cone { }

   Separator {
      OrthographicCamera {
         position -0.75 -0.75 2
      }
      BaseColor { rgb 1 1 0 }
      Sphere { radius 0.2 }
   }
}
.fi
.PP
.PP
You will likely encounter Z-buffer issues with this technique which makes the overlay / HUD graphics end up interspersed with the 'real' geometry\&. If so, this can be solved by e\&.g\&. inserting an \fBSoCallback\fP node in the sub-scene, where you let the callback disable the depth buffer with glDisable(GL_DEPTH_TEST)\&.
.PP
\fBFILE FORMAT/DEFAULTS:\fP 
.PP
.nf
OrthographicCamera {
    viewportMapping ADJUST_CAMERA
    position 0 0 1
    orientation 0 0 1  0
    nearDistance 1
    farDistance 10
    aspectRatio 1
    focalDistance 5
    height 2
}

.fi
.PP
 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SoOrthographicCamera::SoOrthographicCamera (void)"
Constructor\&. 
.SS "SoOrthographicCamera::~SoOrthographicCamera ()\fC [protected]\fP, \fC [virtual]\fP"
Destructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBSoType\fP SoOrthographicCamera::getTypeId (void) const\fC [virtual]\fP"

.PP
Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. Usage example:
.PP
.PP
.nf
void foo(SoNode * node)
{
  if (node->getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
.fi
.PP
.PP
For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in \fIall\fP subclasses\&. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance \fBInventor/nodes/SoSubNode\&.h\fP (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), \fBInventor/engines/SoSubEngine\&.h\fP (for engine classes) and so on\&.
.PP
For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups\&. 
.PP
Reimplemented from \fBSoCamera\fP\&.
.SS "const \fBSoFieldData\fP * SoOrthographicCamera::getFieldData (void) const\fC [protected]\fP, \fC [virtual]\fP"
Returns a pointer to the class-wide field data storage object for this instance\&. If no fields are present, returns \fCNULL\fP\&. 
.PP
Reimplemented from \fBSoCamera\fP\&.
.SS "void SoOrthographicCamera::scaleHeight (float scalefactor)\fC [virtual]\fP"
Scale \fBSoOrthographicCamera::height\fP by multiplying with \fIscalefactor\fP\&. 
.PP
Implements \fBSoCamera\fP\&.
.SS "\fBSbViewVolume\fP SoOrthographicCamera::getViewVolume (float useaspectratio = \fC0\&.0f\fP) const\fC [virtual]\fP"
Returns total view volume covered by the camera under the current settings\&.
.PP
This view volume is not adjusted to account for viewport mapping\&. If you want the same view volume as the one used during rendering, you should use getViewVolume(SbViewportRegion & vp, const SbMatrix & mm), or do something like this:
.PP
.PP
.nf
SbViewVolume vv;
float aspectratio = myviewport.getViewportAspectRatio();

switch (camera->viewportMapping.getValue()) {
case SoCamera::CROP_VIEWPORT_FILL_FRAME:
case SoCamera::CROP_VIEWPORT_LINE_FRAME:
case SoCamera::CROP_VIEWPORT_NO_FRAME:
  vv = camera->getViewVolume(0.0f);
  break;
case SoCamera::ADJUST_CAMERA:
  vv = camera->getViewVolume(aspectratio);
  if (aspectratio < 1.0f) vv.scale(1.0f / aspectratio);
  break;
case SoCamera::LEAVE_ALONE:
  vv = camera->getViewVolume(0.0f);
  break;
default:
  assert(0 && "unknown viewport mapping");
  break;
}.fi
.PP
.PP
Also, for the CROPPED viewport mappings, the viewport might be changed if the viewport aspect ratio is not equal to the camera aspect ratio\&. See the SoCamera::getView() source-code (private method) to see how this is done\&. 
.PP
Implements \fBSoCamera\fP\&.
.SS "void SoOrthographicCamera::viewBoundingBox (const \fBSbBox3f\fP & box, float aspect, float slack)\fC [virtual]\fP"
Convenience method for setting up the camera definition to cover the given bounding \fIbox\fP with the given \fIaspect\fP ratio\&. Multiplies the exact dimensions with a \fIslack\fP factor to have some space between the rendered model and the borders of the rendering area\&.
.PP
If you define your own camera node class, be aware that this method should \fInot\fP set the orientation field of the camera, only the position, focal distance and near and far clipping planes\&. 
.PP
Implements \fBSoCamera\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBSoSFFloat\fP SoOrthographicCamera::height"
Height of viewport in world-space scale\&. Defaults to 2\&.0 units\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
