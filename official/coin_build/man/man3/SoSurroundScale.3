.TH "SoSurroundScale" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SoSurroundScale \- The \fBSoSurroundScale\fP class is used to automatically scale geometry to surround other geometry\&.
.PP
This node calculates a transformation (a translation and a scale) which will, when the node is traversed, be appended to the current model matrix, making a default cube placed directly to the right of this node in the graph surround geometry to the right of the container branch this node is on\&. The container is specified by the field \fBSoSurroundScale::numNodesUpToContainer\fP\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Inventor/nodes/SoSurroundScale\&.h>\fP
.PP
Inherits \fBSoTransformation\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fBSoType\fP \fBgetTypeId\fP (void) const"
.br
.RI "Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. "
.ti -1c
.RI "\fBSoSurroundScale\fP (void)"
.br
.ti -1c
.RI "void \fBinvalidate\fP (void)"
.br
.ti -1c
.RI "virtual void \fBdoAction\fP (\fBSoAction\fP *action)"
.br
.ti -1c
.RI "void \fBsetDoingTranslations\fP (const SbBool val)"
.br
.ti -1c
.RI "SbBool \fBisDoingTranslations\fP (void)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBSoType\fP \fBgetClassTypeId\fP (void)"
.br
.ti -1c
.RI "static void \fBinitClass\fP (void)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBSoSFInt32\fP \fBnumNodesUpToContainer\fP"
.br
.ti -1c
.RI "\fBSoSFInt32\fP \fBnumNodesUpToReset\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual const \fBSoFieldData\fP * \fBgetFieldData\fP (void) const"
.br
.ti -1c
.RI "virtual \fB~SoSurroundScale\fP ()"
.br
.ti -1c
.RI "virtual void \fBcallback\fP (\fBSoCallbackAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBGLRender\fP (\fBSoGLRenderAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBgetBoundingBox\fP (\fBSoGetBoundingBoxAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBgetMatrix\fP (\fBSoGetMatrixAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBpick\fP (\fBSoPickAction\fP *action)"
.br
.ti -1c
.RI "void \fBupdateMySurroundParams\fP (\fBSoAction\fP *action, const \fBSbMatrix\fP &inv)"
.br
.ti -1c
.RI "void \fBsetIgnoreInBbox\fP (const SbBool val)"
.br
.ti -1c
.RI "SbBool \fBisIgnoreInBbox\fP (void)"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static const \fBSoFieldData\fP ** \fBgetFieldDataPtr\fP (void)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBSbVec3f\fP \fBcachedScale\fP"
.br
.ti -1c
.RI "\fBSbVec3f\fP \fBcachedInvScale\fP"
.br
.ti -1c
.RI "\fBSbVec3f\fP \fBcachedTranslation\fP"
.br
.ti -1c
.RI "SbBool \fBcacheOK\fP"
.br
.ti -1c
.RI "SbBool \fBdoTranslations\fP"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
The \fBSoSurroundScale\fP class is used to automatically scale geometry to surround other geometry\&.
.PP
This node calculates a transformation (a translation and a scale) which will, when the node is traversed, be appended to the current model matrix, making a default cube placed directly to the right of this node in the graph surround geometry to the right of the container branch this node is on\&. The container is specified by the field \fBSoSurroundScale::numNodesUpToContainer\fP\&. 

When calculating the bounding box to be surrounded, the bounding box action will be applied to the container node, and the bounding box calculations will be reset after traversing the node specified by the field \fBSoSurroundScale::numNodesUpToReset\fP\&.
.PP
A way of thinking of the container node is that there exists a path from the root-node to the \fBSoSurroundScale\fP node\&. This path has a number of nodes in it\&. numNodesUpToContainer is the number of nodes in the path from the \fBSoSurroundScale\fP node towards the root node\&. When having counted numNodesUpToContainer from the \fBSoSurroundScale\fP node, you will have reached the container node\&. The container node is the seed-node that the bounding box is calculated from\&. All nodes lower than the seed-node will be a part of the bounding box unless they are closer to the \fBSoSurroundScale\fP node than numNodesUpToReset\&.
.PP
To make sure the node(s) that are to be scaled by the \fBSoSurroundScale\fP node aren't a part of the bounding box, the numNodesUpToReset is used\&. It is also the number of nodes up from the \fBSoSurroundScale\fP node towards the root node\&. The meaning of numNodesUpToReset is that nodes that are closer to the SoSurroundNode than the node at position numNodesUpToReset are not to be used for bounding box calculations\&.
.PP
Here's a complete, stand-alone example which sets up an \fBSoTrackballDragger\fP (connected to a cube), and uses an \fBSoSurroundScale\fP node to make it auto-scale to the size of the high cube and translates it an offset to one side of the cube:
.PP
.PP
.nf
#include <Inventor/Qt/SoQt\&.h>
#include <Inventor/Qt/viewers/SoQtExaminerViewer\&.h>
#include <Inventor/draggers/SoTrackballDragger\&.h>
#include <Inventor/nodes/SoAntiSquish\&.h>
#include <Inventor/nodes/SoSeparator\&.h>
#include <Inventor/nodes/SoCube\&.h>
#include <Inventor/nodes/SoSurroundScale\&.h>
#include <Inventor/nodes/SoRotation\&.h>
#include <Inventor/nodes/SoTranslation\&.h>


int
main(int argc, char **argv)
{
  QWidget * window = SoQt::init(argv[0]);
  if (window == NULL) exit(1);

  SoSeparator * root = new SoSeparator;
  root->ref();

  SoSeparator * surroundsep = new SoSeparator;
  root->addChild(surroundsep);

  SoTranslation * translation = new SoTranslation;
  translation->translation = SbVec3f(12, 0, 0);
  surroundsep->addChild(translation);

  SoSurroundScale * ss = new SoSurroundScale;
  ss->numNodesUpToReset = 1;
  ss->numNodesUpToContainer = 2;
  surroundsep->addChild(ss);

  SoAntiSquish * antisquish = new SoAntiSquish;
  antisquish->sizing = SoAntiSquish::BIGGEST_DIMENSION;
  surroundsep->addChild(antisquish);

  SoTrackballDragger * dragger = new SoTrackballDragger;
  surroundsep->addChild(dragger);

  SoRotation * rotation = new SoRotation;
  rotation->rotation\&.connectFrom(& dragger->rotation);
  root->addChild(rotation);

  SoCube * cube = new SoCube;
  cube->height = 10\&.0f;
  root->addChild(cube);

  SoQtExaminerViewer * viewer = new SoQtExaminerViewer(window);
  viewer->setSceneGraph(root);
  viewer->setViewing(FALSE);
  viewer->setDecoration(FALSE);
  viewer->show();

  SoQt::show(window);
  SoQt::mainLoop();

  delete viewer;
  root->unref();

  return 0;
}
.fi
.PP
.PP
It might be easier to see how the \fBSoSurroundScale\fP node works in the above example by looking at the actual scenegraph:
.PP
.PP
.nf
#Inventor V2\&.1 ascii

Separator {
   Separator {
      Translation {
         translation 12 0 0
      }
      SurroundScale {
         numNodesUpToContainer 2
         numNodesUpToReset 1
      }
      AntiSquish {
         sizing BIGGEST_DIMENSION
      }
      DEF mydragger TrackballDragger {
      }
   }
   Rotation {
      rotation 0 0 1  0 =
      USE mydragger \&. rotation
   }
   Cube {
      height 10
   }
}
.fi
.PP
.PP
This node is internally used by manipulators to make it possible for them to scale their dragger's geometry to match the scenegraph geometry it is modifying, as is demonstrated above (but outside of the context of a manipulator)\&.
.PP
It is also generally useful for application programmers who want any particular piece of geometry surround other geometry of unknown or changing extent\&.
.PP
\fBSoSurroundScale\fP nodes in the scenegraph are often paired up with \fBSoAntiSquish\fP nodes to get uniform scaling along all three principal axes, as has also been done in the above example\&.
.PP
\fBFILE FORMAT/DEFAULTS:\fP 
.PP
.nf
SurroundScale {
    numNodesUpToContainer 0
    numNodesUpToReset 0
}

.fi
.PP
.PP
\fBSee also:\fP
.RS 4
\fBSoAntiSquish\fP 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "SoSurroundScale::SoSurroundScale (void)"
Constructor\&. 
.SS "SoSurroundScale::~SoSurroundScale ()\fC [protected]\fP, \fC [virtual]\fP"
Destructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBSoType\fP SoSurroundScale::getTypeId (void) const\fC [virtual]\fP"

.PP
Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. Usage example:
.PP
.PP
.nf
void foo(SoNode * node)
{
  if (node->getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
.fi
.PP
.PP
For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in \fIall\fP subclasses\&. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance \fBInventor/nodes/SoSubNode\&.h\fP (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), \fBInventor/engines/SoSubEngine\&.h\fP (for engine classes) and so on\&.
.PP
For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups\&. 
.PP
Reimplemented from \fBSoTransformation\fP\&.
.SS "const \fBSoFieldData\fP * SoSurroundScale::getFieldData (void) const\fC [protected]\fP, \fC [virtual]\fP"
Returns a pointer to the class-wide field data storage object for this instance\&. If no fields are present, returns \fCNULL\fP\&. 
.PP
Reimplemented from \fBSoTransformation\fP\&.
.SS "void SoSurroundScale::invalidate (void)"
Invalidates the cached transformation, forcing a recalculation to be done the next time this node is traversed\&. 
.SS "void SoSurroundScale::doAction (\fBSoAction\fP * action)\fC [virtual]\fP"
This function performs the typical operation of a node for any action\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoSurroundScale::setDoingTranslations (const SbBool val)"
Sets whether the translation part of the transformation should be ignored or not\&. Default behavior is to translate\&. 
.SS "SbBool SoSurroundScale::isDoingTranslations (void)"
Returns whether the translation part of the transformation should be ignored or not\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetDoingTranslations()\fP 
.RE
.PP

.SS "void SoSurroundScale::callback (\fBSoCallbackAction\fP * action)\fC [protected]\fP, \fC [virtual]\fP"
Action method for \fBSoCallbackAction\fP\&.
.PP
Simply updates the state according to how the node behaves for the render action, so the application programmer can use the \fBSoCallbackAction\fP for extracting information about the scene graph\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoSurroundScale::GLRender (\fBSoGLRenderAction\fP * action)\fC [protected]\fP, \fC [virtual]\fP"
Action method for the \fBSoGLRenderAction\fP\&.
.PP
This is called during rendering traversals\&. Nodes influencing the rendering state in any way or who wants to throw geometry primitives at OpenGL overrides this method\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoSurroundScale::getBoundingBox (\fBSoGetBoundingBoxAction\fP * action)\fC [protected]\fP, \fC [virtual]\fP"
Action method for the \fBSoGetBoundingBoxAction\fP\&.
.PP
Calculates bounding box and center coordinates for node and modifies the values of the \fIaction\fP to encompass the bounding box for this node and to shift the center point for the scene more towards the one for this node\&.
.PP
Nodes influencing how geometry nodes calculates their bounding box also overrides this method to change the relevant state variables\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoSurroundScale::getMatrix (\fBSoGetMatrixAction\fP * action)\fC [protected]\fP, \fC [virtual]\fP"
Action method for \fBSoGetMatrixAction\fP\&.
.PP
Updates \fIaction\fP by accumulating with the transformation matrix of this node (if any)\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoSurroundScale::pick (\fBSoPickAction\fP * action)\fC [protected]\fP, \fC [virtual]\fP"
Action method for \fBSoPickAction\fP\&.
.PP
Does common processing for \fBSoPickAction\fP \fIaction\fP instances\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoSurroundScale::updateMySurroundParams (\fBSoAction\fP * action, const \fBSbMatrix\fP & inv)\fC [protected]\fP"
Calculates the translation and scale needed to make a default cube surround geometry to the right of the branch this node is on\&. 
.SS "void SoSurroundScale::setIgnoreInBbox (const SbBool val)\fC [protected]\fP"
Sets whether bounding box calculations in \fBSoGetBoundingBoxAction\fP should be affected by this node\&.
.PP
Default is to ignore our bounding box calculations\&. 
.SS "SbBool SoSurroundScale::isIgnoreInBbox (void)\fC [protected]\fP"
Returns the value of the flag that decides whether bounding box calculations in \fBSoGetBoundingBoxAction\fP should be affected by this node\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetIgnoreInBbox()\fP 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "\fBSoSFInt32\fP SoSurroundScale::numNodesUpToContainer"
Number of nodes in the path counting from this and 'upwards' to the container node\&. 
.SS "\fBSoSFInt32\fP SoSurroundScale::numNodesUpToReset"
Number of nodes in the path counting from this and 'upwards' to the node where we will reset the bounding box value\&. 
.SS "SoSurroundScale::cachedScale\fC [protected]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "SoSurroundScale::cachedInvScale\fC [protected]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "SoSurroundScale::cachedTranslation\fC [protected]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "SoSurroundScale::cacheOK\fC [protected]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "SoSurroundScale::doTranslations\fC [protected]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
