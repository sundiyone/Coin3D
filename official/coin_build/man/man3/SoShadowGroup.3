.TH "SoShadowGroup" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SoShadowGroup \- The \fBSoShadowGroup\fP node is a group node used for shadow rendering\&.
.PP
Children of this node can recieve shadows, and cast shadows on other children\&. Use the \fBSoShadowStyle\fP node to control shadow casters and shadow receivers\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <FXViz/nodes/SoShadowGroup\&.h>\fP
.PP
Inherits \fBSoSeparator\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBVisibilityFlag\fP { \fBABSOLUTE_RADIUS\fP, \fBLONGEST_BBOX_EDGE_FACTOR\fP, \fBPROJECTED_BBOX_DEPTH_FACTOR\fP }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fBSoType\fP \fBgetTypeId\fP (void) const"
.br
.RI "Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. "
.ti -1c
.RI "\fBSoShadowGroup\fP (void)"
.br
.ti -1c
.RI "virtual void \fBGLRenderBelowPath\fP (\fBSoGLRenderAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBGLRenderInPath\fP (\fBSoGLRenderAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBnotify\fP (\fBSoNotList\fP *nl)"
.br
.ti -1c
.RI "void \fBenableSubgraphSearchOnNotify\fP (const SbBool onoff)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBSoType\fP \fBgetClassTypeId\fP (void)"
.br
.ti -1c
.RI "static void \fBinitClass\fP (void)"
.br
.ti -1c
.RI "static void \fBinit\fP (void)"
.br
.ti -1c
.RI "static SbBool \fBisSupported\fP (void)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBSoSFBool\fP \fBisActive\fP"
.br
.ti -1c
.RI "\fBSoSFFloat\fP \fBintensity\fP"
.br
.ti -1c
.RI "\fBSoSFFloat\fP \fBprecision\fP"
.br
.ti -1c
.RI "\fBSoSFFloat\fP \fBquality\fP"
.br
.ti -1c
.RI "\fBSoSFFloat\fP \fBsmoothBorder\fP"
.br
.ti -1c
.RI "\fBSoSFBool\fP \fBshadowCachingEnabled\fP"
.br
.ti -1c
.RI "\fBSoSFFloat\fP \fBvisibilityNearRadius\fP"
.br
.ti -1c
.RI "\fBSoSFFloat\fP \fBvisibilityRadius\fP"
.br
.ti -1c
.RI "\fBSoSFEnum\fP \fBvisibilityFlag\fP"
.br
.ti -1c
.RI "\fBSoSFFloat\fP \fBepsilon\fP"
.br
.ti -1c
.RI "\fBSoSFFloat\fP \fBthreshold\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual const \fBSoFieldData\fP * \fBgetFieldData\fP (void) const"
.br
.ti -1c
.RI "virtual \fB~SoShadowGroup\fP ()"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static const \fBSoFieldData\fP ** \fBgetFieldDataPtr\fP (void)"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
The \fBSoShadowGroup\fP node is a group node used for shadow rendering\&.
.PP
Children of this node can recieve shadows, and cast shadows on other children\&. Use the \fBSoShadowStyle\fP node to control shadow casters and shadow receivers\&. 

Please note that all shadow casters will be rendered twice\&. Once to create the shadow map, and once for normal rendering\&. If you're having performance issues, you should consider reducing the number of shadow casters\&.
.PP
The algorithm used to render the shadows is Variance Shadow Maps (http://www.punkuser.net/vsm/)\&. As an extra bonus, all geometry rendered with shadows can also be rendered with per fragment phong lighting\&.
.PP
This node will search its subgraph and calculate shadows for all \fBSoSpotLight\fP nodes\&. The node will use one texture unit for each spot light, so for this node to work 100%, you need to have num-spotlights free texture units while rendering the subgraph\&.
.PP
Currently, we only support scenes with maximum two texture units active while doing shadow rendering (unit 0 and unit 1)\&. This is due to the fact that we emulate the OpenGL shading model in a shader program, and we're still working on creating a solution that updates the shader program during the scene graph traversal\&. Right now a shader program is created when entering the \fBSoShadowGroup\fP node, and this is used for the entire subgraph\&.
.PP
\fBFILE FORMAT/DEFAULTS:\fP 
.PP
.nf
SoShadowGroup {
  isActive TRUE
  intensity 0\&.5
  precision 0\&.5
  quality 0\&.5
  shadowCachingEnabled TRUE
  visibilityRadius -1\&.0
  visibilityFlag LONGEST_BBOX_EDGE_FACTOR

  epsilon 0\&.00001
  threshold 0\&.1
  smoothBorder 0\&.0

}

.fi
.PP
.PP
Example scene graph: 
.PP
.nf
#Inventor V2\&.1 ascii

# to get some lighting when headlight is turned off in the viewer
DirectionalLight { direction 0 0 -1 intensity 0\&.2 }

ShadowGroup {
  quality 1 # to get per pixel lighting

  ShadowStyle { style NO_SHADOWING }

  SpotLight {
    location -8 -8 8\&.0
    direction 1 1 -1
    cutOffAngle 0\&.35
    dropOffRate 0\&.7
  }

  ShadowStyle { style CASTS_SHADOW_AND_SHADOWED }

  Separator {
    Complexity { value 1\&.0 }
    Material { diffuseColor 1 1 0 specularColor 1 1 1 shininess 0\&.9 }
    Shuttle { translation0 -3 1 0 translation1 3 -5 0 speed 0\&.25 on TRUE }
    Translation { translation -5 0 2 }
    Sphere { radius 2\&.0 }
  }

  Separator {
    Material { diffuseColor 1 0 0 specularColor 1 1 1 shininess 0\&.9 }
    Shuttle { translation0 0 -5 0 translation1 0 5 0 speed 0\&.15 on TRUE }
    Translation { translation 0 0 -3 }
    Cube { depth 1\&.8 }
  }
  Separator {
    Material { diffuseColor 0 1 0 specularColor 1 1 1 shininess 0\&.9 }
    Shuttle { translation0 -5 0 0 translation1 5 0 0 speed 0\&.3 on TRUE }
    Translation { translation 0 0 -3 }
    Cube { }
  }

  ShadowStyle { style SHADOWED }
  Coordinate3 { point [ -10 -10 -3, 10 -10 -3, 10 10 -3, -10 10 -3 ] }
  Material { specularColor 1 1 1 shininess 0\&.9 }

  Complexity { textureQuality 0\&.1 }
  Texture2 { image 2 2 3 0xffffff 0x225588 0x225588 0xffffff }
  Texture2Transform { scaleFactor 4 4 }
  FaceSet { numVertices 4 }
}

.fi
.PP
.PP
\fBSince:\fP
.RS 4
Coin 2\&.5 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "SoShadowGroup::SoShadowGroup (void)"
Default constructor\&. 
.SS "SoShadowGroup::~SoShadowGroup ()\fC [protected]\fP, \fC [virtual]\fP"
Destructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBSoType\fP SoShadowGroup::getTypeId (void) const\fC [virtual]\fP"

.PP
Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. Usage example:
.PP
.PP
.nf
void foo(SoNode * node)
{
  if (node->getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
.fi
.PP
.PP
For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in \fIall\fP subclasses\&. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance \fBInventor/nodes/SoSubNode\&.h\fP (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), \fBInventor/engines/SoSubEngine\&.h\fP (for engine classes) and so on\&.
.PP
For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups\&. 
.PP
Reimplemented from \fBSoSeparator\fP\&.
.SS "const \fBSoFieldData\fP * SoShadowGroup::getFieldData (void) const\fC [protected]\fP, \fC [virtual]\fP"
Returns a pointer to the class-wide field data storage object for this instance\&. If no fields are present, returns \fCNULL\fP\&. 
.PP
Reimplemented from \fBSoSeparator\fP\&.
.SS "SbBool SoShadowGroup::isSupported (void)\fC [static]\fP"
Reports whether or not the shadow nodes can be used successfully on the current system\&.
.PP
The result will depend on the specific qualities of the graphics card and OpenGL driver on the system\&.
.PP
An important note about this function:
.PP
The API design of this function has a serious shortcoming, as features of OpenGL should be tested within an OpenGL context, and this function does not provide any means of specifying the context\&. It is implemented in this manner to match the function signature in TGS Inventor, for compatibility reasons\&.
.PP
(A temporary offscreen OpenGL context is set up for the feature tests\&. This should usually be sufficient to decide whether or not the graphics driver / card supports the features needed for rendering shadows\&.)
.PP
\fBSince:\fP
.RS 4
Coin 3\&.1 
.RE
.PP

.SS "void SoShadowGroup::GLRenderBelowPath (\fBSoGLRenderAction\fP * action)\fC [virtual]\fP"
SGI Open Inventor v2\&.1 obsoleted support for \fBSoGLRenderAction::addMethod()\fP\&. Instead, \fBGLRender()\fP might be called directly, and to optimize traversal, the \fBSoSeparator\fP node calls GLRenderBelowPath whenever the path code is BELOW_PATH or NO_PATH (path code is guaranteed not to change)\&. To be compatible with SGI's Inventor (and thereby also TGS') we have chosen to follow their implementation in this respect\&.
.PP
\fBSoSeparator::GLRenderBelowPath()\fP do not traverse its children using \fBSoChildList::traverse()\fP, but calls \fBGLRenderBelowPath()\fP directly for all its children\&. 
.PP
Reimplemented from \fBSoSeparator\fP\&.
.SS "void SoShadowGroup::GLRenderInPath (\fBSoGLRenderAction\fP * action)\fC [virtual]\fP"
Implements the SoAction::IN_PATH traversal method for the rendering action\&. 
.PP
Reimplemented from \fBSoSeparator\fP\&.
.SS "void SoShadowGroup::notify (\fBSoNotList\fP * l)\fC [virtual]\fP"
Notifies all auditors for this instance when changes are made\&. 
.PP
Reimplemented from \fBSoSeparator\fP\&.
.SS "void SoShadowGroup::enableSubgraphSearchOnNotify (const SbBool onoff)"
By default, the \fBSoShadowGroup\fP node will search its subgraph for new spot lights whenever a group node under it is touched\&. However, this might lead to bad performance in some cases so it's possible to disable this feature using this method\&. If you do disable this feature, make sure you enable it again before inserting a new spot light, or insert all spot lights in the scene graph before you render the scene once, and just set 'on' to FALSE if you want to toggle spot lights on/off on the fly\&.
.PP
\fBSince:\fP
.RS 4
Coin 2\&.6 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "\fBSoSFBool\fP SoShadowGroup::isActive"
Use this field to turn shadow rendering for the subgraph on/off\&. Default value is TRUE\&. 
.SS "\fBSoSFFloat\fP SoShadowGroup::intensity"
Not used yet\&. Provided for TGS Inventor compatibility\&. 
.SS "\fBSoSFFloat\fP SoShadowGroup::precision"
Use to calculate the size of the shadow map\&. A precision of 1\&.0 means the maximum shadow buffer size will be used (typically 2048x2048 on current graphics cards)\&. Default value is 0\&.5\&. 
.SS "\fBSoSFFloat\fP SoShadowGroup::quality"
Can be used to tune the shader program complexity\&. A higher value will mean that more calculations are done per-fragment instead of per-vertex\&. Default value is 0\&.5\&. 
.SS "\fBSoSFInt32\fP SoShadowGroup::smoothBorder"
SoShadowGroup::VisibilityFlag SoShadowGroup::ABSOLUTE_RADIUS
.PP
The absolute values of visibilityNearRadius and visibilityRadius will be used\&.
.PP
SoShadowGroup::VisibilityFlag SoShadowGroup::LONGEST_BBOX_EDGE_FACTOR
.PP
The longest bbox edge will be used to determine near and far clipping planes\&.
.PP
SoShadowGroup::VisibilityFlag SoShadowGroup::PROJECTED_BBOX_DEPTH_FACTOR
.PP
The bbox depth (projected to face the camera) will be used to calculate the clipping planes\&.
.PP
We have some problems with this feature so it's not supported at the moment\&.
.PP
Used to add shadow border smoothing\&. This is currently done as a post processing step on the shadow map\&. The algorithm used is Gauss Smoothing, but in the future we'll probably change this, and use a summed area sampling merhod instead\&. The value should be a number between 0 (no smoothing), and 1 (max smoothing)\&.
.PP
If you want to enable smoothing, choosing a low value (~0\&.1) works best in the current implementation\&.
.PP
Default value is 0\&.0\&. 
.SS "\fBSoSFBool\fP SoShadowGroup::shadowCachingEnabled"
Not used yet\&. Provided for TGS Inventor compatibility\&. 
.SS "\fBSoSFFloat\fP SoShadowGroup::visibilityNearRadius"
Can be used to manually set the near clipping plane of the shadow maps\&. If a negative value is provided, the group will calculate a near plane based on the bounding box of the children\&. Default value is -1\&.0\&.
.PP
\fBSee also:\fP
.RS 4
\fBvisibilityFlag\fP 
.RE
.PP

.SS "\fBSoSFFloat\fP SoShadowGroup::visibilityRadius"
Can be used to manually set the far clipping plane of the shadow maps\&. If a negative value is provided, the group will calculate a near plane based on the bounding box of the children\&. Default value is -1\&.0\&.
.PP
\fBSee also:\fP
.RS 4
\fBvisibilityFlag\fP 
.RE
.PP

.SS "\fBSoSFEnum\fP SoShadowGroup::visibilityFlag"
Determines how visibilityRadius and visibilitNearRadius is used to calculate near and far clipping planes for the shadow volume\&. 
.SS "\fBSoSFFloat\fP SoShadowGroup::epsilon"
Epsilon is used to offset the shadow map depth from the model depth\&. Should be set to as low a number as possible without causing flickering in the shadows or on non-shadowed objects\&. Default value is 0\&.00001\&. 
.SS "\fBSoSFFloat\fP SoShadowGroup::threshold"
Can be used to avoid light bleeding in merged shadows cast from different objects\&.
.PP
A threshold to completely eliminate all light bleeding can be computed from the ratio of overlapping occluder distances from the light's perspective\&. See http://forum.beyond3d.com/showthread.php?t=38165 for a discussion about this problem\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
