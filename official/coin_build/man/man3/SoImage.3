.TH "SoImage" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SoImage \- The \fBSoImage\fP class draws a 2D image on the viewport\&.
.PP
An image can be specified either by using the image field, or by specifying a filename\&. If width and or height is specified, the image will be resized to match those values before it is displayed\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Inventor/nodes/SoImage\&.h>\fP
.PP
Inherits \fBSoShape\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBVertAlignment\fP { \fBBOTTOM\fP, \fBHALF\fP, \fBTOP\fP }"
.br
.ti -1c
.RI "enum \fBHorAlignment\fP { \fBLEFT\fP, \fBCENTER\fP, \fBRIGHT\fP }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fBSoType\fP \fBgetTypeId\fP (void) const"
.br
.RI "Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. "
.ti -1c
.RI "\fBSoImage\fP (void)"
.br
.ti -1c
.RI "virtual void \fBGLRender\fP (\fBSoGLRenderAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBrayPick\fP (\fBSoRayPickAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBgetPrimitiveCount\fP (\fBSoGetPrimitiveCountAction\fP *action)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBSoType\fP \fBgetClassTypeId\fP (void)"
.br
.ti -1c
.RI "static void \fBinitClass\fP (void)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBSoSFInt32\fP \fBwidth\fP"
.br
.ti -1c
.RI "\fBSoSFInt32\fP \fBheight\fP"
.br
.ti -1c
.RI "\fBSoSFEnum\fP \fBvertAlignment\fP"
.br
.ti -1c
.RI "\fBSoSFEnum\fP \fBhorAlignment\fP"
.br
.ti -1c
.RI "\fBSoSFImage\fP \fBimage\fP"
.br
.ti -1c
.RI "\fBSoSFString\fP \fBfilename\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual const \fBSoFieldData\fP * \fBgetFieldData\fP (void) const"
.br
.ti -1c
.RI "virtual \fB~SoImage\fP ()"
.br
.ti -1c
.RI "virtual void \fBgeneratePrimitives\fP (\fBSoAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBcomputeBBox\fP (\fBSoAction\fP *action, \fBSbBox3f\fP &box, \fBSbVec3f\fP &center)"
.br
.ti -1c
.RI "virtual SbBool \fBreadInstance\fP (\fBSoInput\fP *in, unsigned short flags)"
.br
.ti -1c
.RI "virtual void \fBnotify\fP (\fBSoNotList\fP *list)"
.br
.ti -1c
.RI "\fBint\fP \fBgetReadStatus\fP (void)"
.br
.ti -1c
.RI "void \fBsetReadStatus\fP (SbBool flag)"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static const \fBSoFieldData\fP ** \fBgetFieldDataPtr\fP (void)"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
The \fBSoImage\fP class draws a 2D image on the viewport\&.
.PP
An image can be specified either by using the image field, or by specifying a filename\&. If width and or height is specified, the image will be resized to match those values before it is displayed\&. 

The current modelview matrix will be used to find the viewport position, and the image is rendered in that position, with z-buffer testing activated\&.
.PP
Here's a simple, stand-alone example on how to set up and show an \fBSoImage\fP:
.PP
.PP
.nf
#include <stdlib\&.h>
#include <Inventor/Qt/SoQt\&.h>
#include <Inventor/Qt/viewers/SoQtExaminerViewer\&.h>
#include <Inventor/nodes/SoSeparator\&.h>
#include <Inventor/nodes/SoCamera\&.h>
#include <Inventor/nodes/SoCube\&.h>
#include <Inventor/nodes/SoImage\&.h>

static void
mandel(double sr, double si, double width, double height,
       int bwidth, int bheight, int mult, unsigned char * bmp, int n)
{
  double zr, zr_old, zi, cr, ci;
  int w;

  for (int y=0; y<bheight; y++)
    for (int x=0; x<bwidth; x++) {
      cr = ((double)(x)/(double)(bwidth))*width+sr;
      ci = ((double)(y)/(double)(bheight))*height+si;
      zr = zi = 0\&.0;
      for (w = 0; (w < n) && (zr*zr + zi*zi)<n; w++) {
        zr_old = zr;
        zr = zr*zr - zi*zi + cr;
        zi = 2*zr_old*zi + ci;
      }
      bmp[y*bwidth+x] = w*mult;
    }
}

int
main(int argc, char ** argv)
{
  QWidget * mainwin = SoQt::init(argv[0]);

  SoSeparator * root = new SoSeparator;
  root->ref();

  const int IMGWIDTH = 256;
  const int IMGHEIGHT = 256;
  unsigned char * img = new unsigned char[IMGWIDTH * IMGHEIGHT];
  mandel(-0\&.5, 0\&.6, 0\&.025, 0\&.025, IMGWIDTH, IMGHEIGHT, 1, img, 256);

  SoImage * nimage = new SoImage;
  nimage->vertAlignment = SoImage::HALF;
  nimage->horAlignment = SoImage::CENTER;
  nimage->image\&.setValue(SbVec2s(IMGWIDTH, IMGHEIGHT), 1, img);

  SoCube * cube = new SoCube;

  root->addChild(cube);
  root->addChild(nimage);

  SoQtExaminerViewer * viewer = new SoQtExaminerViewer(mainwin);
  viewer->setSceneGraph(root);
  viewer->setTitle("SoImage use");
  viewer->show();

  SoCamera * cam = viewer->getCamera();
  cam->position = SbVec3f(0, 0, 50);
  cam->focalDistance = 50;

  SoQt::show(mainwin);
  SoQt::mainLoop();

  delete viewer;
  root->unref();
  delete img;
  return 0;
}
.fi
.PP
.PP
Note that an \fBSoImage\fP node in the scene graph will have it's positioning / rendering influenced by the current viewport and camera\&. This has important implications for how to layout your scene graph for the best possible rendering performance\&. See the note about this issue in the \fBSoText2\fP class documentation\&.
.PP
\fBSoScale\fP nodes can not be used to influence the dimensions of the rendering output of \fBSoImage\fP nodes\&.
.PP
\fBFILE FORMAT/DEFAULTS:\fP 
.PP
.nf
Image {
    width -1
    height -1
    vertAlignment BOTTOM
    horAlignment LEFT
    image 0 0 0

    filename ""
}

.fi
.PP
.PP
\fBSince:\fP
.RS 4
TGS Inventor 2\&.5 
.PP
Coin 1\&.0 
.RE
.PP

.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBSoImage::VertAlignment\fP"
Vertical alignment for image\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIBOTTOM \fP\fP
Vertical alignment at bottom of image\&. 
.TP
\fB\fIHALF \fP\fP
Vertical alignment at center of image\&. 
.TP
\fB\fITOP \fP\fP
Vertical alignment at top of image\&. 
.SS "enum \fBSoImage::HorAlignment\fP"
Horizontal alignment for image\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fILEFT \fP\fP
Horizontal alignment at left border\&. 
.TP
\fB\fICENTER \fP\fP
Horizontal alignment at center of image\&. 
.TP
\fB\fIRIGHT \fP\fP
Horizontal alignment ar right border\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SoImage::SoImage (void)"
Constructor\&. 
.SS "SoImage::~SoImage ()\fC [protected]\fP, \fC [virtual]\fP"
Destructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBSoType\fP SoImage::getTypeId (void) const\fC [virtual]\fP"

.PP
Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. Usage example:
.PP
.PP
.nf
void foo(SoNode * node)
{
  if (node->getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
.fi
.PP
.PP
For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in \fIall\fP subclasses\&. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance \fBInventor/nodes/SoSubNode\&.h\fP (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), \fBInventor/engines/SoSubEngine\&.h\fP (for engine classes) and so on\&.
.PP
For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups\&. 
.PP
Reimplemented from \fBSoShape\fP\&.
.SS "const \fBSoFieldData\fP * SoImage::getFieldData (void) const\fC [protected]\fP, \fC [virtual]\fP"
Returns a pointer to the class-wide field data storage object for this instance\&. If no fields are present, returns \fCNULL\fP\&. 
.PP
Reimplemented from \fBSoShape\fP\&.
.SS "void SoImage::GLRender (\fBSoGLRenderAction\fP * action)\fC [virtual]\fP"
Action method for the \fBSoGLRenderAction\fP\&.
.PP
This is called during rendering traversals\&. Nodes influencing the rendering state in any way or who wants to throw geometry primitives at OpenGL overrides this method\&. 
.PP
Reimplemented from \fBSoShape\fP\&.
.SS "void SoImage::rayPick (\fBSoRayPickAction\fP * action)\fC [virtual]\fP"
Calculates picked point based on primitives generated by subclasses\&. 
.PP
Reimplemented from \fBSoShape\fP\&.
.SS "void SoImage::getPrimitiveCount (\fBSoGetPrimitiveCountAction\fP * action)\fC [virtual]\fP"
Action method for the \fBSoGetPrimitiveCountAction\fP\&.
.PP
Calculates the number of triangle, line segment and point primitives for the node and adds these to the counters of the \fIaction\fP\&.
.PP
Nodes influencing how geometry nodes calculates their primitive count also overrides this method to change the relevant state variables\&. 
.PP
Reimplemented from \fBSoShape\fP\&.
.SS "void SoImage::generatePrimitives (\fBSoAction\fP * action)\fC [protected]\fP, \fC [virtual]\fP"
Will generate a textured quad, representing the image in 3D\&. 
.PP
Implements \fBSoShape\fP\&.
.SS "void SoImage::computeBBox (\fBSoAction\fP * action, \fBSbBox3f\fP & box, \fBSbVec3f\fP & center)\fC [protected]\fP, \fC [virtual]\fP"
Implemented by \fBSoShape\fP subclasses to let the \fBSoShape\fP superclass know the exact size and weighted center point of the shape's bounding box\&.
.PP
The bounding box and center point should be calculated and returned in the local coordinate system\&.
.PP
The method implements action behavior for shape nodes for \fBSoGetBoundingBoxAction\fP\&. It is invoked from \fBSoShape::getBoundingBox()\fP\&. (Subclasses should \fInot\fP override \fBSoNode::getBoundingBox()\fP\&.)
.PP
The \fIbox\fP parameter sent in is guaranteed to be an empty box, while \fIcenter\fP is undefined upon function entry\&. 
.PP
Implements \fBSoShape\fP\&.
.SS "SbBool SoImage::readInstance (\fBSoInput\fP * in, unsigned short flags)\fC [protected]\fP, \fC [virtual]\fP"
This method is mainly intended for internal use during file import operations\&.
.PP
It reads a definition of an instance from the input stream \fIin\fP\&. The input stream state points to the start of a serialized / persistant representation of an instance of this class type\&.
.PP
\fCTRUE\fP or \fCFALSE\fP is returned, depending on if the instantiation and configuration of the new object of this class type went ok or not\&. The import process should be robust and handle corrupted input streams by returning \fCFALSE\fP\&.
.PP
\fIflags\fP is used internally during binary import when reading user extension nodes, group nodes or engines\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoImage::notify (\fBSoNotList\fP * l)\fC [protected]\fP, \fC [virtual]\fP"
Notifies all auditors for this instance when changes are made\&. 
.PP
Reimplemented from \fBSoShape\fP\&.
.SS "\fBint\fP SoImage::getReadStatus (void)\fC [protected]\fP"
Returns \fITRUE\fP if node was read ok\&. 
.SS "void SoImage::setReadStatus (SbBool flag)\fC [protected]\fP"
Set read status for this node\&. 
.SH "Member Data Documentation"
.PP 
.SS "\fBSoSFInt32\fP SoImage::width"
If bigger than 0, resize image to this width before rendering\&. Default value is -1 (ie 'don't resize')\&. 
.SS "\fBSoSFInt32\fP SoImage::height"
If bigger than 0, resize image to this height before rendering\&. Default value is -1 (ie 'don't resize')\&. 
.SS "\fBSoSFEnum\fP SoImage::vertAlignment"
Vertical alignment\&. Default value is \fBSoImage::BOTTOM\fP\&. 
.SS "\fBSoSFEnum\fP SoImage::horAlignment"
Horizontal alignment\&. Default value is \fBSoImage::LEFT\fP\&. 
.SS "\fBSoSFImage\fP SoImage::image"
Inline image data\&. Default empty\&. 
.SS "\fBSoSFString\fP SoImage::filename"
Image filename\&. Default empty\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
