.TH "wpool.h" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
wpool.h
.SH SYNOPSIS
.br
.PP
\fC#include <Inventor/C/basic\&.h>\fP
.br
\fC#include <Inventor/C/threads/common\&.h>\fP
.br

.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void \fBcc_wpool_f\fP(void *)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBcc_wpool\fP * \fBcc_wpool_construct\fP (\fBint\fP numworkers)"
.br
.ti -1c
.RI "void \fBcc_wpool_destruct\fP (\fBcc_wpool\fP *pool)"
.br
.ti -1c
.RI "\fBint\fP \fBcc_wpool_get_num_workers\fP (\fBcc_wpool\fP *pool)"
.br
.ti -1c
.RI "void \fBcc_wpool_set_num_workers\fP (\fBcc_wpool\fP *pool, \fBint\fP newnum)"
.br
.ti -1c
.RI "void \fBcc_wpool_wait_all\fP (\fBcc_wpool\fP *pool)"
.br
.ti -1c
.RI "SbBool \fBcc_wpool_try_begin\fP (\fBcc_wpool\fP *pool, \fBint\fP numworkersneeded)"
.br
.ti -1c
.RI "void \fBcc_wpool_begin\fP (\fBcc_wpool\fP *pool, \fBint\fP numworkersneeded)"
.br
.ti -1c
.RI "void \fBcc_wpool_start_worker\fP (\fBcc_wpool\fP *pool, cc_wpool_f *workfunc, void *closure)"
.br
.ti -1c
.RI "void \fBcc_wpool_end\fP (\fBcc_wpool\fP *pool)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "\fBcc_wpool\fP* cc_wpool_construct (\fBint\fP numworkers)"
Construct worker pool\&. 
.SS "void cc_wpool_destruct (\fBcc_wpool\fP * pool)"
Destruct worker pool\&. Will wait for all jobs in progress to finish 
.SS "\fBint\fP cc_wpool_get_num_workers (\fBcc_wpool\fP * pool)"
Returns the number of workers in the pool\&. 
.SS "void cc_wpool_set_num_workers (\fBcc_wpool\fP * pool, \fBint\fP newnum)"
Sets the number of workers in the pool\&. 
.SS "void cc_wpool_wait_all (\fBcc_wpool\fP * pool)"
Wait for all pool workers to finish working and go into idle state\&. This method should only be called by the thread controlling the pool\&. A pool worker should not call this method, since it will obviously never return from here (it will never go idle)\&. 
.SS "SbBool cc_wpool_try_begin (\fBcc_wpool\fP * pool, \fBint\fP numworkersneeded)"
Locks the pool so that workers can be started using the \fBcc_wpool_start_worker()\fP method\&. \fInumworkersneeded\fP should contain the minumum number of workers that is needed\&. If \fInumworkersneeded\fP workers are available, the pool will be locked and TRUE is returned\&. Otherwise FALSE is returned\&.
.PP
Usage pseudocode:
.PP
.PP
.nf
int numworkers = 5;

if (cc_wpool_begin(pool, numworkers)) {
  for (int i = 0; i < numworkers; i++) {
    cc_wpool_start_worker(my_work[i], my_closure[i]);
  }
  cc_wpool_end(pool);
}
.fi
.PP
.PP
Important! If too few workers are available, the pool will not be locked and \fBcc_wpool_end()\fP should not be called\&.
.PP
\fBSee also:\fP
.RS 4
\fBcc_wpool_start_worker()\fP, \fBcc_wpool_end()\fP 
.RE
.PP

.SS "void cc_wpool_begin (\fBcc_wpool\fP * pool, \fBint\fP numworkersneeded)"
Wait for \fInumworkersneeded\fP workers to become idle\&. When returning from this call, the pool will be locked, and up to \fInumworkersneeded\fP can be started using the \fBcc_wpool_start_worker()\fP method\&. Remember to call \fBcc_wpool_end()\fP to unlock the pool again\&.
.PP
\fBSee also:\fP
.RS 4
\fBcc_wpool_try_begin()\fP 
.RE
.PP

.SS "void cc_wpool_start_worker (\fBcc_wpool\fP * pool, cc_wpool_f * workfunc, void * closure)"
Starts a worker\&. The pool must be locked (using \fBcc_wpool_begin()\fP) before calling this method\&.
.PP
\fBSee also:\fP
.RS 4
\fBcc_wpool_begin()\fP , \fBcc_wpool_end()\fP 
.RE
.PP

.SS "void cc_wpool_end (\fBcc_wpool\fP * pool)"
Unlocks the pool after a \fBcc_wpool_begin()\fP, \fBcc_wpool_start_worker()\fP sequence\&.
.PP
Please note that if \fBcc_wpool_begin()\fP returns 0, you should not call \fBcc_wpool_end()\fP\&.
.PP
\fBSee also:\fP
.RS 4
\fBcc_wpool_begin()\fP, \fBcc_wpool_start_worker()\fP 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
