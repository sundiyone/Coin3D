.TH "SbDPRotation" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SbDPRotation \- The \fBSbDPRotation\fP class represents a rotation in 3D space using double precision data\&.
.PP
\fBSbDPRotation\fP is used extensively throughout the Coin library\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Inventor/SbDPRotation\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSbDPRotation\fP (void)"
.br
.ti -1c
.RI "\fBSbDPRotation\fP (const \fBSbVec3d\fP &axis, const double radians)"
.br
.ti -1c
.RI "\fBSbDPRotation\fP (const double q[4])"
.br
.ti -1c
.RI "\fBSbDPRotation\fP (const double q0, const double q1, const double q2, const double q3)"
.br
.ti -1c
.RI "\fBSbDPRotation\fP (const \fBSbDPMatrix\fP &m)"
.br
.ti -1c
.RI "\fBSbDPRotation\fP (const \fBSbVec3d\fP &rotateFrom, const \fBSbVec3d\fP &rotateTo)"
.br
.ti -1c
.RI "const double * \fBgetValue\fP (void) const"
.br
.ti -1c
.RI "void \fBgetValue\fP (double &q0, double &q1, double &q2, double &q3) const"
.br
.ti -1c
.RI "\fBSbDPRotation\fP & \fBsetValue\fP (const double q0, const double q1, const double q2, const double q3)"
.br
.ti -1c
.RI "void \fBgetValue\fP (\fBSbVec3d\fP &axis, double &radians) const"
.br
.ti -1c
.RI "void \fBgetValue\fP (\fBSbDPMatrix\fP &matrix) const"
.br
.ti -1c
.RI "\fBSbDPRotation\fP & \fBinvert\fP (void)"
.br
.ti -1c
.RI "\fBSbDPRotation\fP \fBinverse\fP (void) const"
.br
.ti -1c
.RI "\fBSbDPRotation\fP & \fBsetValue\fP (const double q[4])"
.br
.ti -1c
.RI "\fBSbDPRotation\fP & \fBsetValue\fP (const \fBSbDPMatrix\fP &m)"
.br
.ti -1c
.RI "\fBSbDPRotation\fP & \fBsetValue\fP (const \fBSbVec3d\fP &axis, const double radians)"
.br
.ti -1c
.RI "\fBSbDPRotation\fP & \fBsetValue\fP (const \fBSbVec3d\fP &rotateFrom, const \fBSbVec3d\fP &rotateTo)"
.br
.ti -1c
.RI "SbBool \fBequals\fP (const \fBSbDPRotation\fP &r, double tolerance) const"
.br
.ti -1c
.RI "void \fBmultVec\fP (const \fBSbVec3d\fP &src, \fBSbVec3d\fP &dst) const"
.br
.ti -1c
.RI "void \fBscaleAngle\fP (const double scaleFactor)"
.br
.ti -1c
.RI "void \fBprint\fP (FILE *fp) const"
.br
.ti -1c
.RI "\fBSbDPRotation\fP & \fBoperator*=\fP (const \fBSbDPRotation\fP &q)"
.br
.ti -1c
.RI "\fBSbDPRotation\fP & \fBoperator*=\fP (const double s)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBSbDPRotation\fP \fBslerp\fP (const \fBSbDPRotation\fP &rot0, const \fBSbDPRotation\fP &rot1, double t)"
.br
.ti -1c
.RI "static \fBSbDPRotation\fP \fBidentity\fP (void)"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "\fBint\fP \fBoperator==\fP (const \fBSbDPRotation\fP &q1, const \fBSbDPRotation\fP &q2)"
.br
.ti -1c
.RI "\fBint\fP \fBoperator!=\fP (const \fBSbDPRotation\fP &q1, const \fBSbDPRotation\fP &q2)"
.br
.ti -1c
.RI "\fBSbDPRotation\fP \fBoperator*\fP (const \fBSbDPRotation\fP &q1, const \fBSbDPRotation\fP &q2)"
.br
.in -1c
.SH "Detailed Description"
.PP 
The \fBSbDPRotation\fP class represents a rotation in 3D space using double precision data\&.
.PP
\fBSbDPRotation\fP is used extensively throughout the Coin library\&. 

An \fBSbDPRotation\fP is stored internally as a quaternion for speed and storage reasons, but inquiries can be done to get and set axis and angle values for convenience\&.
.PP
\fBSee also:\fP
.RS 4
\fBSbDPMatrix\fP 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "SbDPRotation::SbDPRotation (void)"
The default constructor just initializes a valid rotation\&. The actual value is unspecified, and you should not depend on it\&. 
.SS "SbDPRotation::SbDPRotation (const \fBSbVec3d\fP & axis, const double radians)"
Construct a new \fBSbDPRotation\fP object initialized with the given axis-of-rotation and rotation angle\&. 
.SS "SbDPRotation::SbDPRotation (const double q[4])"
Construct a new \fBSbDPRotation\fP object initialized with the given quaternion components\&.
.PP
The array must be ordered as follows:
.PP
q[0] = x, q[1] = y, q[2] = z and q[3] = w, where the quaternion is specified by q=w+xi+yj+zk\&. 
.SS "SbDPRotation::SbDPRotation (const double q0, const double q1, const double q2, const double q3)"
Construct a new \fBSbDPRotation\fP object initialized with the given quaternion components\&. 
.SS "SbDPRotation::SbDPRotation (const \fBSbDPMatrix\fP & m)"
Construct a new \fBSbDPRotation\fP object initialized with the given rotation matrix\&. 
.SS "SbDPRotation::SbDPRotation (const \fBSbVec3d\fP & rotateFrom, const \fBSbVec3d\fP & rotateTo)"
Construct a rotation which is the minimum rotation necessary to make vector \fIrotateFrom\fP point in the direction of vector \fIrotateTo\fP\&. 
.SH "Member Function Documentation"
.PP 
.SS "const double * SbDPRotation::getValue (void) const"
Return pointer to an array with the rotation expressed as four quaternion values\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetValue()\fP\&. 
.RE
.PP

.SS "void SbDPRotation::getValue (double & q0, double & q1, double & q2, double & q3) const"
Return the four quaternion components representing the rotation\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetValue()\fP\&. 
.RE
.PP

.SS "\fBSbDPRotation\fP & SbDPRotation::setValue (const double q0, const double q1, const double q2, const double q3)"
Set the rotation\&.
.PP
\fBSee also:\fP
.RS 4
\fBgetValue()\fP\&. 
.RE
.PP

.SS "void SbDPRotation::getValue (\fBSbVec3d\fP & axis, double & radians) const"
Return the rotation in the form of an axis-of-rotation and a rotation angle\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetValue()\fP\&. 
.RE
.PP

.SS "void SbDPRotation::getValue (\fBSbDPMatrix\fP & matrix) const"
Return this rotation in the form of a matrix\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetValue()\fP\&. 
.RE
.PP

.SS "\fBSbDPRotation\fP & SbDPRotation::invert (void)"
Invert the rotation\&. Returns reference to self\&.
.PP
\fBSee also:\fP
.RS 4
\fBinverse()\fP 
.RE
.PP

.SS "\fBSbDPRotation\fP SbDPRotation::inverse (void) const"
Non-destructively inverses the rotation and returns the result\&.
.PP
\fBSee also:\fP
.RS 4
\fBinvert()\fP 
.RE
.PP

.SS "\fBSbDPRotation\fP & SbDPRotation::setValue (const double q[4])"
Reset the rotation by the four quaternions in the array\&.
.PP
\fBSee also:\fP
.RS 4
\fBgetValue()\fP\&. 
.RE
.PP

.SS "\fBSbDPRotation\fP & SbDPRotation::setValue (const \fBSbDPMatrix\fP & m)"
Set the rotation from the components of the given matrix\&. Returns reference to self\&.
.PP
\fBSee also:\fP
.RS 4
\fBgetValue()\fP\&. 
.RE
.PP

.SS "\fBSbDPRotation\fP & SbDPRotation::setValue (const \fBSbVec3d\fP & axis, const double radians)"
Reset rotation with the given axis-of-rotation and rotation angle\&. Returns reference to self\&.
.PP
Make sure \fIaxis\fP is not the null vector when calling this method\&.
.PP
\fBSee also:\fP
.RS 4
\fBgetValue()\fP\&. 
.RE
.PP

.SS "\fBSbDPRotation\fP & SbDPRotation::setValue (const \fBSbVec3d\fP & rotateFrom, const \fBSbVec3d\fP & rotateTo)"
Construct a rotation which is the minimum rotation necessary to make vector \fIrotateFrom\fP point in the direction of vector \fIrotateTo\fP\&.
.PP
Returns reference to self\&.
.PP
\fBSee also:\fP
.RS 4
\fBgetValue()\fP\&. 
.RE
.PP

.SS "SbBool SbDPRotation::equals (const \fBSbDPRotation\fP & r, double tolerance) const"
Check the internal quaternion representation vectors for equality within the given tolerance\&. 
.SS "void SbDPRotation::multVec (const \fBSbVec3d\fP & src, \fBSbVec3d\fP & dst) const"
Rotate the \fIsrc\fP vector and put the result in \fIdst\fP\&. 
.SS "void SbDPRotation::scaleAngle (const double scaleFactor)"
Scale the angle of rotation by \fIscaleFactor\fP\&. 
.SS "\fBSbDPRotation\fP slerp (const \fBSbDPRotation\fP & rot0, const \fBSbDPRotation\fP & rot1, double t)\fC [static]\fP"
Interpolates along the shortest path between the two rotation positions (from \fIrot0\fP to \fIrot1\fP)\&.
.PP
Returns the \fBSbDPRotation\fP which will rotate \fIrot0\fP the given part \fIt\fP of the spherical distance towards \fIrot1\fP, where \fIt=0\fP will yield \fIrot0\fP and \fIt=1\fP will yield \fIrot1\fP\&.
.PP
\fIt\fP should be in the interval [0, 1]\&. 
.SS "\fBSbDPRotation\fP SbDPRotation::identity (void)\fC [static]\fP"
Returns an identity rotation\&. 
.SS "void SbDPRotation::print (FILE * fp) const"
Dump the state of this object to the \fIfile\fP stream\&. Only works in debug version of library, method does nothing in an optimized compile\&. 
.SS "\fBSbDPRotation\fP & SbDPRotation::operator*= (const \fBSbDPRotation\fP & q)"
Multiplies the quaternions\&.
.PP
Note that order is important when combining quaternions with the multiplication operator\&. 
.SS "\fBSbDPRotation\fP & SbDPRotation::operator*= (const double s)"
Multiplies components of quaternion with scalar value \fIs\fP\&. Returns reference to self\&. 
.SH "Friends And Related Function Documentation"
.PP 
.SS "\fBint\fP operator== (const \fBSbDPRotation\fP & q1, const \fBSbDPRotation\fP & q2)\fC [friend]\fP"
Check if the two rotations are equal\&.
.PP
\fBSee also:\fP
.RS 4
\fBequals()\fP\&. 
.RE
.PP

.SS "\fBint\fP operator!= (const \fBSbDPRotation\fP & q1, const \fBSbDPRotation\fP & q2)\fC [friend]\fP"
Check if the two rotations are unequal\&.
.PP
\fBSee also:\fP
.RS 4
\fBequals()\fP\&. 
.RE
.PP

.SS "\fBSbDPRotation\fP operator* (const \fBSbDPRotation\fP & q1, const \fBSbDPRotation\fP & q2)\fC [friend]\fP"
Multiplies the two rotations and returns the result\&.
.PP
Note that order is important when combining quaternions with the multiplication operator\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
