.TH "SoMaterial" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SoMaterial \- The \fBSoMaterial\fP class is a node type for setting up material values for scene geometry\&.
.PP
After traversing an \fBSoMaterial\fP node, subsequent shape nodes with geometry in the scene graph will use values from the material 'pool' of the traversal state set up from nodes of this type\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Inventor/nodes/SoMaterial\&.h>\fP
.PP
Inherits \fBSoNode\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fBSoType\fP \fBgetTypeId\fP (void) const"
.br
.RI "Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. "
.ti -1c
.RI "\fBSoMaterial\fP (void)"
.br
.ti -1c
.RI "virtual void \fBdoAction\fP (\fBSoAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBGLRender\fP (\fBSoGLRenderAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBcallback\fP (\fBSoCallbackAction\fP *action)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBSoType\fP \fBgetClassTypeId\fP (void)"
.br
.ti -1c
.RI "static void \fBinitClass\fP (void)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBSoMFColor\fP \fBambientColor\fP"
.br
.ti -1c
.RI "\fBSoMFColor\fP \fBdiffuseColor\fP"
.br
.ti -1c
.RI "\fBSoMFColor\fP \fBspecularColor\fP"
.br
.ti -1c
.RI "\fBSoMFColor\fP \fBemissiveColor\fP"
.br
.ti -1c
.RI "\fBSoMFFloat\fP \fBshininess\fP"
.br
.ti -1c
.RI "\fBSoMFFloat\fP \fBtransparency\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual const \fBSoFieldData\fP * \fBgetFieldData\fP (void) const"
.br
.ti -1c
.RI "virtual \fB~SoMaterial\fP ()"
.br
.ti -1c
.RI "virtual void \fBnotify\fP (\fBSoNotList\fP *list)"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static const \fBSoFieldData\fP ** \fBgetFieldDataPtr\fP (void)"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
The \fBSoMaterial\fP class is a node type for setting up material values for scene geometry\&.
.PP
After traversing an \fBSoMaterial\fP node, subsequent shape nodes with geometry in the scene graph will use values from the material 'pool' of the traversal state set up from nodes of this type\&. 

For detailed information on the various components, see the OpenGL color model, presented in the chapter 'Colors and Coloring' (chapter 2\&.13 in the OpenGL 1\&.4 specification)\&.
.PP
Note that values from a material node will \fIreplace\fP the previous values from the traversal state, they will \fInot\fP accumulate\&. That's the case even when e\&.g\&. material changes are \fIimplicit\fP in an iv-file, as illustrated by the following example:
.PP
Also note that support for multiple values in ambientColor, emissiveColor, specularColor and shininess was obsoleted in Open Inventor 2\&.1\&. The reason for this design change was performance driven, since it's relatively slow to change the OpenGL material properties\&. Changing the diffuse color value is fast though, so it's still possible to have multiple diffuseColor and transparency values\&.
.PP
.PP
.nf
#Inventor V2.1 ascii

Material { ambientColor 1 0 0 }
Cone { }

Translation { translation 5 0 0 }

Material { }
Sphere { }
.fi
.PP
.PP
(The \fBSoSphere\fP will not 'inherit' the \fBSoMaterial::ambientColor\fP from the first \fBSoMaterial\fP node, even though it is not explicitly set in the second material node\&. The default value of \fBSoMaterial::ambientColor\fP will be used\&.)
.PP
Note that nodes imported as part of a VRML V1\&.0 file has a special case, where the fields \fBSoMaterial::ambientColor\fP, \fBSoMaterial::diffuseColor\fP and \fBSoMaterial::specularColor\fP contains zero values, and \fBSoMaterial::emissiveColor\fP contains one or more values\&. The values in \fBSoMaterial::emissiveColor\fP should then be treated as precalculated lighting, and the other fields should be ignored\&.
.PP
You can detect this case by checking the values of the material elements when the scene graph is traversed using an \fBSoCallbackAction\fP\&. \fBSoDiffuseColorElement\fP, \fBSoAmbientColorElement\fP, and \fBSoSpecularColorElement\fP will contain one value with a completely black color (0\&.0f, 0\&.0f, 0\&.0f), \fBSoShininessElement\fP will contain one value of 0\&.0f, and \fBSoEmissiveColorElement\fP will contain one or more values\&. It is done like this to make rendering work correctly on systems that do not test for this specific case\&.
.PP
You should only check for this case when you're traversing a VRML V1\&.0 file scene graph, of course\&. See \fBSoNode::getNodeType()\fP for information about how nodes can be tested for whether or not they have been imported or otherwise set up as of VRML1 type versus Inventor type\&.
.PP
When the scene graph is rendered using an \fBSoGLRenderAction\fP, the elements will be set differently to optimize rendering\&. The \fBSoDiffuseColorElement\fP will be set to the values in \fBSoMaterial::emissiveColor\fP, and the light model will be set to \fBSoLightModel::BASE_COLOR\fP\&.
.PP
The \fBSoMaterial::transparency\fP values will always be treated normally\&.
.PP
Here is a very simple usage example:
.PP
.PP
.nf
#Inventor V2.1 ascii

Separator {
   Coordinate3 {
      point [ 0 0 0, 1 0 0, 1 1 0 ]
   }

   Material {
      diffuseColor [ 1 0 0, 1 1 0, 0 0 1 ]
   }

   MaterialBinding {
      value PER_VERTEX
   }

   IndexedFaceSet {
      coordIndex [ 0, 1, 2, -1 ]
   }
}
.fi
.PP
.PP
\fBFILE FORMAT/DEFAULTS:\fP 
.PP
.nf
Material {
    ambientColor 0\&.2 0\&.2 0\&.2
    diffuseColor 0\&.8 0\&.8 0\&.8
    specularColor 0 0 0
    emissiveColor 0 0 0
    shininess 0\&.2
    transparency 0
}

.fi
.PP
.PP
\fBSee also:\fP
.RS 4
\fBSoMaterialBinding\fP, \fBSoBaseColor\fP, \fBSoPackedColor\fP 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "SoMaterial::SoMaterial (void)"
Constructor\&. 
.SS "SoMaterial::~SoMaterial ()\fC [protected]\fP, \fC [virtual]\fP"
Destructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBSoType\fP SoMaterial::getTypeId (void) const\fC [virtual]\fP"

.PP
Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. Usage example:
.PP
.PP
.nf
void foo(SoNode * node)
{
  if (node->getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
.fi
.PP
.PP
For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in \fIall\fP subclasses\&. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance \fBInventor/nodes/SoSubNode\&.h\fP (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), \fBInventor/engines/SoSubEngine\&.h\fP (for engine classes) and so on\&.
.PP
For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups\&. 
.PP
Implements \fBSoBase\fP\&.
.SS "const \fBSoFieldData\fP * SoMaterial::getFieldData (void) const\fC [protected]\fP, \fC [virtual]\fP"
Returns a pointer to the class-wide field data storage object for this instance\&. If no fields are present, returns \fCNULL\fP\&. 
.PP
Reimplemented from \fBSoFieldContainer\fP\&.
.SS "void SoMaterial::doAction (\fBSoAction\fP * action)\fC [virtual]\fP"
This function performs the typical operation of a node for any action\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoMaterial::GLRender (\fBSoGLRenderAction\fP * action)\fC [virtual]\fP"
Action method for the \fBSoGLRenderAction\fP\&.
.PP
This is called during rendering traversals\&. Nodes influencing the rendering state in any way or who wants to throw geometry primitives at OpenGL overrides this method\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoMaterial::callback (\fBSoCallbackAction\fP * action)\fC [virtual]\fP"
Action method for \fBSoCallbackAction\fP\&.
.PP
Simply updates the state according to how the node behaves for the render action, so the application programmer can use the \fBSoCallbackAction\fP for extracting information about the scene graph\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoMaterial::notify (\fBSoNotList\fP * l)\fC [protected]\fP, \fC [virtual]\fP"
Notifies all auditors for this instance when changes are made\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBSoMFColor\fP SoMaterial::ambientColor"
Ambient material part color values\&. Will by default contain a single color value of [0\&.2, 0\&.2, 0\&.2] (ie dark gray)\&.
.PP
The ambient part of the material is not influenced by any lightsources, and should be thought of conceptually as the constant, but small contribution of light to a scene 'seeping in' from everywhere\&.
.PP
(Think of the ambient contribution in the context that there's always photons fizzing around everywhere -- even in a black, lightsource-less room, for instance)\&.
.PP
Only the first value in this field will be used\&. All other values will be ignored\&.
.PP
\fBSee also:\fP
.RS 4
\fBSoEnvironment::ambientIntensity\fP 
.RE
.PP

.SS "\fBSoMFColor\fP SoMaterial::diffuseColor"
Diffuse material part color values\&. This field is by default initialized to contain a single color value of [0\&.8, 0\&.8, 0\&.8] (light gray)\&.
.PP
The diffuse part is combined with the light emitted from the scene's light sources\&.
.PP
Traditional Open Inventor uses the same override bit for both diffuse color and transparency\&. To get around this problem if you need to override one without the other, set the environment variable 'COIN_SEPARATE_DIFFUSE_TRANSPARENCY_OVERRIDE'\&. This is a Coin extension, and will not work on the other Open Inventor implementations\&. 
.SS "\fBSoMFColor\fP SoMaterial::specularColor"
Specular material part color values\&. Defaults to a single color value of [0, 0, 0] (black)\&.
.PP
Only the first value in this field will be used\&. All other values will be ignored\&. 
.SS "\fBSoMFColor\fP SoMaterial::emissiveColor"
The color of the light 'emitted' by the subsequent geometry, independent of lighting / shading\&.
.PP
Defaults to contain a single color value of [0, 0, 0] (black, ie no contribution)\&.
.PP
Only the first value in this field will be used\&. All other values will be ignored\&. 
.SS "\fBSoMFFloat\fP SoMaterial::shininess"
Shininess values\&. Decides how the light from light sources are distributed across the geometry surfaces\&. Valid range is from 0\&.0 (which gives a dim appearance), to 1\&.0 (glossy-looking surfaces)\&.
.PP
Defaults to contain a single value of 0\&.2\&.
.PP
Only the first value in this field will be used\&. All other values will be ignored\&. 
.SS "\fBSoMFFloat\fP SoMaterial::transparency"
Transparency values\&. Valid range is from 0\&.0 (completely opaque, which is the default) to 1\&.0 (completely transparent, i\&.e\&. invisible)\&.
.PP
Defaults to contain a single value of 0\&.0\&.
.PP
Traditional Open Inventor uses the same override bit for both transparency and diffuse color\&. To get around this problem if you need to override one without the other, set the environment variable 'COIN_SEPARATE_DIFFUSE_TRANSPARENCY_OVERRIDE'\&. This is a Coin extension, and will not work on the other Open Inventor implementations\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
