.TH "SoTimerQueueSensor" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SoTimerQueueSensor \- The \fBSoTimerQueueSensor\fP class is the abstract base class for sensors triggering on certain timer events\&.
.PP
Timer sensors triggers upon specific points in time\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Inventor/sensors/SoTimerQueueSensor\&.h>\fP
.PP
Inherits \fBSoSensor\fP\&.
.PP
Inherited by \fBSoAlarmSensor\fP, and \fBSoTimerSensor\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSoTimerQueueSensor\fP (void)"
.br
.ti -1c
.RI "\fBSoTimerQueueSensor\fP (\fBSoSensorCB\fP *\fBfunc\fP, void *data)"
.br
.ti -1c
.RI "virtual \fB~SoTimerQueueSensor\fP (void)"
.br
.ti -1c
.RI "const \fBSbTime\fP & \fBgetTriggerTime\fP (void) const"
.br
.ti -1c
.RI "virtual void \fBschedule\fP (void)"
.br
.ti -1c
.RI "virtual void \fBunschedule\fP (void)"
.br
.ti -1c
.RI "virtual SbBool \fBisScheduled\fP (void) const"
.br
.ti -1c
.RI "virtual void \fBtrigger\fP (void)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBsetTriggerTime\fP (const \fBSbTime\fP &time)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "SbBool \fBscheduled\fP"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
The \fBSoTimerQueueSensor\fP class is the abstract base class for sensors triggering on certain timer events\&.
.PP
Timer sensors triggers upon specific points in time\&. 

This class is an abstract superclass which collects the common interface of the various non-abstract timer sensor classes\&. See the documentation of the subclasses for information on what ways there are to specify base times, intervals, alarm-style single triggering, repeated triggers, etc\&.
.PP
Note that Coin timer sensors should in no way be considered 'hard
real-time'\&. That is, you can \fInot\fP expect a timer to always trigger at the exact moment it was set up for\&. Delays in triggering could be due to other activities in Coin, a task suspended, or heavy load from other applications on the system\&. These situations could all cause the processing of sensor queues (from SoQt / SoWin / SoXt / whatever) to be slightly delayed, thereby causing delays in timer sensor triggering\&.
.PP
On modern systems, a timer will usually trigger within a few milliseconds of it's designated time, though\&.
.PP
If a timer sensor can not trigger at the exact moment it has been scheduled, it will be triggered at the first opportunity after the scheduled time has passed\&.
.PP
Here's a simple usage example\&. It's a stand-alone example, which only demonstrates how to set up a repeating timer sensor with a callback:
.PP
.PP
.nf
#include <Inventor/Xt/SoXt\&.h>
#include <Inventor/sensors/SoTimerSensor\&.h>
#include <stdio\&.h>

static void
timeSensorCallback(void * data, SoSensor * sensor)
{
  SbTime time = SbTime::getTimeOfDay();
  SbString string = time\&.format("%S\&.%i");
  (void)printf("%s\n", string\&.getString());
}


int
main(int argc, char ** argv)
{ 
  SoXt::init("test");

  SoTimerSensor * timeSensor = new SoTimerSensor;
  timeSensor->setFunction(timeSensorCallback);
  timeSensor->setBaseTime(SbTime::getTimeOfDay());
  timeSensor->setInterval(1\&.0f);
  timeSensor->schedule();

  SoXt::mainLoop();
  return 0;
}
.fi
.PP
 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SoTimerQueueSensor::SoTimerQueueSensor (void)"
Default constructor\&. 
.SS "SoTimerQueueSensor::SoTimerQueueSensor (\fBSoSensorCB\fP * func, void * data)"
Constructor taking as arguments the sensor callback function and the userdata which will be passed the callback\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetFunction()\fP, \fBsetData()\fP 
.RE
.PP

.SS "SoTimerQueueSensor::~SoTimerQueueSensor (void)\fC [virtual]\fP"
Destructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "const \fBSbTime\fP & SoTimerQueueSensor::getTriggerTime (void) const"
Returns the time at which the sensor will trigger\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetTriggerTime()\fP 
.RE
.PP

.SS "void SoTimerQueueSensor::schedule (void)\fC [virtual]\fP"
Put the sensor in the global timer queue\&.
.PP
\fBSee also:\fP
.RS 4
\fBunschedule()\fP, \fBisScheduled()\fP 
.RE
.PP

.PP
Implements \fBSoSensor\fP\&.
.PP
Reimplemented in \fBSoTimerSensor\fP, and \fBSoAlarmSensor\fP\&.
.SS "void SoTimerQueueSensor::unschedule (void)\fC [virtual]\fP"
Remove sensor from the timer queue, without triggering it first\&.
.PP
\fBSee also:\fP
.RS 4
\fBschedule()\fP, \fBisScheduled()\fP 
.RE
.PP

.PP
Implements \fBSoSensor\fP\&.
.PP
Reimplemented in \fBSoTimerSensor\fP\&.
.SS "SbBool SoTimerQueueSensor::isScheduled (void) const\fC [virtual]\fP"
Check if this sensor is scheduled for triggering\&.
.PP
\fBSee also:\fP
.RS 4
\fBschedule()\fP, \fBunschedule()\fP 
.RE
.PP

.PP
Implements \fBSoSensor\fP\&.
.SS "void SoTimerQueueSensor::trigger (void)\fC [virtual]\fP"
Trigger the sensor's callback function\&. 
.PP
Reimplemented from \fBSoSensor\fP\&.
.SS "void SoTimerQueueSensor::setTriggerTime (const \fBSbTime\fP & time)\fC [protected]\fP"
Set absolute time at which to trigger sensor\&.
.PP
\fBSee also:\fP
.RS 4
\fBgetTriggerTime()\fP 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "SbBool SoTimerQueueSensor::scheduled\fC [protected]\fP"
\fCTRUE\fP if the sensor is currently scheduled\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
