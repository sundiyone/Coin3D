.TH "SoInput" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SoInput \- The \fBSoInput\fP class is an abstraction of file import functionality\&.
.PP
This class takes care of most of the chores of doing data import in Coin\&. It puts a layer of abstraction over the read operations to make it transparent for the rest of the Coin code whether or not we're reading from a file, from a memory buffer or from stdin\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Inventor/SoInput\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSoInput\fP (void)"
.br
.ti -1c
.RI "\fBSoInput\fP (\fBSoInput\fP *dictIn)"
.br
.ti -1c
.RI "\fBSoProto\fP * \fBfindProto\fP (const \fBSbName\fP &name)"
.br
.ti -1c
.RI "void \fBaddProto\fP (\fBSoProto\fP *proto)"
.br
.ti -1c
.RI "void \fBpushProto\fP (\fBSoProto\fP *proto)"
.br
.ti -1c
.RI "\fBSoProto\fP * \fBgetCurrentProto\fP (void) const"
.br
.ti -1c
.RI "void \fBpopProto\fP (void)"
.br
.ti -1c
.RI "void \fBaddRoute\fP (const \fBSbName\fP &fromnode, const \fBSbName\fP &fromfield, const \fBSbName\fP &tonode, const \fBSbName\fP &tofield)"
.br
.ti -1c
.RI "SbBool \fBcheckISReference\fP (\fBSoFieldContainer\fP *container, const \fBSbName\fP &fieldname, SbBool &readok)"
.br
.ti -1c
.RI "virtual \fB~SoInput\fP (void)"
.br
.ti -1c
.RI "virtual void \fBsetFilePointer\fP (FILE *newFP)"
.br
.ti -1c
.RI "virtual SbBool \fBopenFile\fP (const char *fileName, SbBool okIfNotFound=FALSE)"
.br
.ti -1c
.RI "virtual SbBool \fBpushFile\fP (const char *fileName)"
.br
.ti -1c
.RI "virtual void \fBcloseFile\fP (void)"
.br
.ti -1c
.RI "virtual SbBool \fBisValidFile\fP (void)"
.br
.ti -1c
.RI "virtual SbBool \fBisValidBuffer\fP (void)"
.br
.ti -1c
.RI "virtual FILE * \fBgetCurFile\fP (void) const"
.br
.ti -1c
.RI "virtual const char * \fBgetCurFileName\fP (void) const"
.br
.ti -1c
.RI "virtual void \fBsetBuffer\fP (const void *bufpointer, size_t bufsize)"
.br
.ti -1c
.RI "void \fBsetStringArray\fP (const char *strings[])"
.br
.ti -1c
.RI "virtual size_t \fBgetNumBytesRead\fP (void) const"
.br
.ti -1c
.RI "virtual \fBSbString\fP \fBgetHeader\fP (void)"
.br
.ti -1c
.RI "virtual float \fBgetIVVersion\fP (void)"
.br
.ti -1c
.RI "virtual SbBool \fBisBinary\fP (void)"
.br
.ti -1c
.RI "virtual SbBool \fBget\fP (char &c)"
.br
.ti -1c
.RI "virtual SbBool \fBgetASCIIBuffer\fP (char &c)"
.br
.ti -1c
.RI "virtual SbBool \fBgetASCIIFile\fP (char &c)"
.br
.ti -1c
.RI "virtual SbBool \fBreadHex\fP (uint32_t &l)"
.br
.ti -1c
.RI "virtual SbBool \fBread\fP (char &c)"
.br
.ti -1c
.RI "virtual SbBool \fBread\fP (char &c, SbBool skip)"
.br
.ti -1c
.RI "virtual SbBool \fBread\fP (\fBSbString\fP &s)"
.br
.ti -1c
.RI "virtual SbBool \fBread\fP (\fBSbName\fP &n, SbBool validIdent=FALSE)"
.br
.ti -1c
.RI "virtual SbBool \fBread\fP (\fBint\fP &i)"
.br
.ti -1c
.RI "virtual SbBool \fBread\fP (unsigned \fBint\fP &i)"
.br
.ti -1c
.RI "virtual SbBool \fBread\fP (short &s)"
.br
.ti -1c
.RI "virtual SbBool \fBread\fP (unsigned short &s)"
.br
.ti -1c
.RI "virtual SbBool \fBread\fP (float &f)"
.br
.ti -1c
.RI "virtual SbBool \fBread\fP (double &d)"
.br
.ti -1c
.RI "virtual SbBool \fBreadByte\fP (int8_t &b)"
.br
.ti -1c
.RI "virtual SbBool \fBreadByte\fP (uint8_t &b)"
.br
.ti -1c
.RI "virtual SbBool \fBreadBinaryArray\fP (unsigned char *c, \fBint\fP length)"
.br
.ti -1c
.RI "virtual SbBool \fBreadBinaryArray\fP (int32_t *l, \fBint\fP length)"
.br
.ti -1c
.RI "virtual SbBool \fBreadBinaryArray\fP (float *f, \fBint\fP length)"
.br
.ti -1c
.RI "virtual SbBool \fBreadBinaryArray\fP (double *d, \fBint\fP length)"
.br
.ti -1c
.RI "virtual SbBool \fBeof\fP (void) const"
.br
.ti -1c
.RI "SbBool \fBisFileVRML1\fP (void)"
.br
.ti -1c
.RI "SbBool \fBisFileVRML2\fP (void)"
.br
.ti -1c
.RI "virtual void \fBresetFilePointer\fP (FILE *fptr)"
.br
.ti -1c
.RI "virtual void \fBgetLocationString\fP (\fBSbString\fP &string) const"
.br
.ti -1c
.RI "virtual void \fBputBack\fP (const char c)"
.br
.ti -1c
.RI "virtual void \fBputBack\fP (const char *str)"
.br
.ti -1c
.RI "virtual void \fBaddReference\fP (const \fBSbName\fP &name, \fBSoBase\fP *base, SbBool addToGlobalDict=TRUE)"
.br
.ti -1c
.RI "virtual void \fBremoveReference\fP (const \fBSbName\fP &name)"
.br
.ti -1c
.RI "virtual \fBSoBase\fP * \fBfindReference\fP (const \fBSbName\fP &name) const"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static void \fBaddDirectoryFirst\fP (const char *dirName)"
.br
.ti -1c
.RI "static void \fBaddDirectoryLast\fP (const char *dirName)"
.br
.ti -1c
.RI "static void \fBaddEnvDirectoriesFirst\fP (const char *envVarName, const char *separator=':\\')"
.br
.ti -1c
.RI "static void \fBaddEnvDirectoriesLast\fP (const char *envVarName, const char *separator=':\\')"
.br
.ti -1c
.RI "static void \fBremoveDirectory\fP (const char *dirName)"
.br
.ti -1c
.RI "static void \fBclearDirectories\fP (void)"
.br
.ti -1c
.RI "static const \fBSbStringList\fP & \fBgetDirectories\fP (void)"
.br
.ti -1c
.RI "static void \fBinit\fP (void)"
.br
.ti -1c
.RI "static \fBSbString\fP \fBgetPathname\fP (const char *const filename)"
.br
.ti -1c
.RI "static \fBSbString\fP \fBgetPathname\fP (const \fBSbString\fP &s)"
.br
.ti -1c
.RI "static \fBSbString\fP \fBgetBasename\fP (const char *const filename)"
.br
.ti -1c
.RI "static \fBSbString\fP \fBgetBasename\fP (const \fBSbString\fP &s)"
.br
.ti -1c
.RI "static \fBSbString\fP \fBsearchForFile\fP (const \fBSbString\fP &basename, const \fBSbStringList\fP &directories, const \fBSbStringList\fP &subdirectories)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual SbBool \fBpopFile\fP (void)"
.br
.ti -1c
.RI "void \fBsetIVVersion\fP (float version)"
.br
.ti -1c
.RI "FILE * \fBfindFile\fP (const char *fileName, \fBSbString\fP &fullName)"
.br
.ti -1c
.RI "void \fBinitFile\fP (FILE *newFP, const char *fileName, \fBSbString\fP *fullName, SbBool openedHere, \fBSbDict\fP *refDict=NULL)"
.br
.ti -1c
.RI "SbBool \fBcheckHeader\fP (SbBool bValidateBufferHeader=FALSE)"
.br
.ti -1c
.RI "SbBool \fBfromBuffer\fP (void) const"
.br
.ti -1c
.RI "SbBool \fBskipWhiteSpace\fP (void)"
.br
.ti -1c
.RI "size_t \fBfreeBytesInBuf\fP (void) const"
.br
.ti -1c
.RI "SbBool \fBreadInteger\fP (int32_t &l)"
.br
.ti -1c
.RI "SbBool \fBreadUnsignedInteger\fP (uint32_t &l)"
.br
.ti -1c
.RI "SbBool \fBreadReal\fP (double &d)"
.br
.ti -1c
.RI "SbBool \fBreadUnsignedIntegerString\fP (char *str)"
.br
.ti -1c
.RI "\fBint\fP \fBreadDigits\fP (char *str)"
.br
.ti -1c
.RI "\fBint\fP \fBreadHexDigits\fP (char *str)"
.br
.ti -1c
.RI "\fBint\fP \fBreadChar\fP (char *str, char charToRead)"
.br
.ti -1c
.RI "SbBool \fBmakeRoomInBuf\fP (size_t nBytes)"
.br
.ti -1c
.RI "void \fBconvertShort\fP (char *from, short *s)"
.br
.ti -1c
.RI "void \fBconvertInt32\fP (char *from, int32_t *l)"
.br
.ti -1c
.RI "void \fBconvertFloat\fP (char *from, float *f)"
.br
.ti -1c
.RI "void \fBconvertDouble\fP (char *from, double *d)"
.br
.ti -1c
.RI "void \fBconvertShortArray\fP (char *from, short *to, \fBint\fP len)"
.br
.ti -1c
.RI "void \fBconvertInt32Array\fP (char *from, int32_t *to, \fBint\fP len)"
.br
.ti -1c
.RI "void \fBconvertFloatArray\fP (char *from, float *to, \fBint\fP len)"
.br
.ti -1c
.RI "void \fBconvertDoubleArray\fP (char *from, double *to, \fBint\fP len)"
.br
.ti -1c
.RI "SbBool \fBisFileURL\fP (const char *url)"
.br
.ti -1c
.RI "char * \fBURLToFile\fP (char *out_buf, const char *in_buf)"
.br
.ti -1c
.RI "SbBool \fBIsURL\fP (const char *c_strng)"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static void \fBsetDirectories\fP (\fBSbStringList\fP *dirs)"
.br
.in -1c
.SH "Detailed Description"
.PP 
The \fBSoInput\fP class is an abstraction of file import functionality\&.
.PP
This class takes care of most of the chores of doing data import in Coin\&. It puts a layer of abstraction over the read operations to make it transparent for the rest of the Coin code whether or not we're reading from a file, from a memory buffer or from stdin\&. 

\fBSoInput\fP also takes care of checking file validity, aswell as handling information about features in the various file formats which are supported\&.
.PP
Example usage: 
.PP
.nf
int
main(void)
{
  SoDB::init();

  SoInput in;
  if (in\&.openFile("fab_model\&.iv")) {
    SoSeparator * root = SoDB::readAll(&in);
    if (root) {
      // Do stuff with the imported scene graph here
      // \&.\&.\&.
      return 0;
    }
  }

  return 1;
}

.fi
.PP
.PP
Important note: there are several public and protected methods which makes it possible to pass in or get returned FILE* structures in this class\&. Do \fInot\fP use these methods when the Coin library has been compiled as an MSWindows DLL, as passing FILE* instances back or forth to DLLs is dangerous and will most likely cause a crash\&. This is an intrinsic limitation for MSWindows DLLs\&.
.PP
This class supports one environment variable called COIN_SOINPUT_SEARCH_GLOBAL_DICT\&. When set to '1', the global dictionary is searched after the current file dictionary when resolving USE keywords\&. This makes it possible to reference nodes in other files\&. The reason for introducing this feature is that the \fBSoFile\fP node rereads the file whenever the name field changes\&. The first time the file is read, it's possible to reference nodes in the parent file, using the USE keyword\&. But, when the file is reread this is no longer possible, since the reading now starts at the \fBSoFile\fP node, with an empty dictionary\&.
.PP
\fBSee also:\fP
.RS 4
\fBSoOutput\fP, \fBSoDB\fP 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "SoInput::SoInput (void)"
Constructor\&. If no filepointer is set, input will be read from stdin\&. 
.SS "SoInput::SoInput (\fBSoInput\fP * dictIn)"
A constructor which copies the reference mappings from \fIdictIn\fP upon initialization\&. 
.SS "SoInput::~SoInput (void)\fC [virtual]\fP"
Destructor\&. Runs \fBSoInput::closeFile()\fP to close any open files\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBSoProto\fP * SoInput::findProto (const \fBSbName\fP & name)"
Searches for PROTO named \fIname\fP\&. This function will only return PROTOs that have been read by the current \fBSoInput\fP instance\&.
.PP
\fBSince:\fP
.RS 4
Coin 2\&.3 
.RE
.PP

.SS "void SoInput::addProto (\fBSoProto\fP * proto)"
Adds a Proto which should be active in the current scope\&.
.PP
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2\&.1 API\&.
.PP
\fBSince:\fP
.RS 4
Coin 2\&.0 
.RE
.PP

.SS "void SoInput::pushProto (\fBSoProto\fP * proto)"
Pushed a Proto onto the Proto stack\&. The Proto stack is used during VRML2 file parsing\&.
.PP
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2\&.1 API\&.
.PP
\fBSee also:\fP
.RS 4
\fBpopProto()\fP 
.RE
.PP
\fBSince:\fP
.RS 4
Coin 2\&.0 
.RE
.PP

.SS "\fBSoProto\fP * SoInput::getCurrentProto (void) const"
Returns the Proto at the top of the Proto stack\&.
.PP
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2\&.1 API\&.
.PP
\fBSee also:\fP
.RS 4
\fBpushProto()\fP 
.RE
.PP
\fBSince:\fP
.RS 4
Coin 2\&.0 
.RE
.PP

.SS "void SoInput::popProto (void)"
Pops a Proto off the Proto stack\&.
.PP
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2\&.1 API\&.
.PP
\fBSee also:\fP
.RS 4
\fBpushProto()\fP 
.RE
.PP
\fBSince:\fP
.RS 4
Coin 2\&.0 
.RE
.PP

.SS "void SoInput::addRoute (const \fBSbName\fP & fromnode, const \fBSbName\fP & fromfield, const \fBSbName\fP & tonode, const \fBSbName\fP & tofield)"
Adds a ROUTE from /a fromnode's , to \fItonode's\fP tofield\&. This makes it possible to defines ROUTEs in files before the \fIfromnode\fP or \fItonode\fP is parsed\&.
.PP
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2\&.1 API\&.
.PP
\fBSince:\fP
.RS 4
Coin 2\&.0 
.RE
.PP

.SS "SbBool SoInput::checkISReference (\fBSoFieldContainer\fP * container, const \fBSbName\fP & fieldname, SbBool & readok)"
Checks if the next bytes in \fIin\fP is the IS keyword\&. Returns \fCTRUE\fP if the IS keyword was found, \fIreadok\fP will be set to \fCFALSE\fP if some error occured while searching for the IS keyword\&.
.PP
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2\&.1 API\&.
.PP
\fBSince:\fP
.RS 4
Coin 2\&.0 
.RE
.PP

.SS "void SoInput::setFilePointer (FILE * newFP)\fC [virtual]\fP"
Uses the given file pointer as the input file\&. The input stack of files will be emptied first\&. Closing a file passed in by it's file pointer is the library user's responsibility\&.
.PP
Important note: do \fInot\fP use this method when the Coin library has been compiled as an MSWindows DLL, as passing FILE* instances back or forth to DLLs is dangerous and will most likely cause a crash\&. This is an intrinsic limitation for MSWindows DLLs\&.
.PP
Note that it is not allowed to pass a FILE* to a gzip-compressed file under Mac OS X\&.
.PP
\fBSee also:\fP
.RS 4
\fBopenFile()\fP, \fBcloseFile()\fP 
.RE
.PP

.SS "SbBool SoInput::openFile (const char * fileName, SbBool okIfNotFound = \fCFALSE\fP)\fC [virtual]\fP"
Open the given file, and make it the only one in the file stack\&. If \fIokIfNotFound\fP is \fCFALSE\fP, show a warning message if the file could not be opened\&.
.PP
Returns \fCTRUE\fP if file could be opened for reading, \fCFALSE\fP otherwise\&.
.PP
Note: even if your attempt at opening a file is unsuccessful, the \fBSoInput\fP instance will \fInot\fP default to reading from stdin after a call has been made to this method\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetFilePointer()\fP, \fBpushFile()\fP, \fBcloseFile()\fP 
.RE
.PP

.SS "SbBool SoInput::pushFile (const char * filename)\fC [virtual]\fP"
Push a new file on top of the stack\&. Further read operations will take place with the new file until it reaches end-of-file, upon when the file will be popped of the stack and we'll continue with the next file in the stack\&.
.PP
Returns \fCTRUE\fP if the file could be opened for reading, \fCFALSE\fP otherwise\&.
.PP
\fBSee also:\fP
.RS 4
\fBopenFile()\fP 
.RE
.PP

.SS "void SoInput::closeFile (void)\fC [virtual]\fP"
Removes all files from the internal stack\&. Any files opened by \fBopenFile()\fP or \fBpushFile()\fP will also be closed, but not the files coming from \fBsetFilePointer()\fP -- which are the responsibility of the caller\&.
.PP
You usually don't need to call this method explicitly, as it will automatically be triggered by the \fBSoInput\fP destructor to close any open files when the \fBSoInput\fP instance goes out of scope\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetFilePointer()\fP, \fBopenFile()\fP, \fBpushFile()\fP 
.RE
.PP

.SS "SbBool SoInput::isValidFile (void)\fC [virtual]\fP"
Checks to see if the current file is a valid file which can be read by the Coin library\&.
.PP
When reading files through e\&.g\&. \fBSoDB::readAll()\fP, this is automatically checked for you, so application code should usually not need to use this method\&. 
.SS "SbBool SoInput::isValidBuffer (void)\fC [virtual]\fP"
Returns \fCTRUE\fP if the current text buffer represents a valid iv-file which can be read by the Coin library\&.
.PP
When reading files through e\&.g\&. \fBSoDB::readAll()\fP, this is automatically checked for you, so application code should usually not need to use this method\&. 
.SS "FILE * SoInput::getCurFile (void) const\fC [virtual]\fP"
Returns file pointer of the file on top of the input stack\&. If the 'file' is actually a memory buffer, returns \fCNULL\fP\&.
.PP
Important note: do \fInot\fP use this method when the Coin library has been compiled as an MSWindows DLL, as passing FILE* instances back or forth to DLLs is dangerous and will most likely cause a crash\&. This is an intrinsic limitation for MSWindows DLLs\&.
.PP
\fBSee also:\fP
.RS 4
\fBgetCurFileName()\fP 
.RE
.PP

.SS "const char * SoInput::getCurFileName (void) const\fC [virtual]\fP"
Returns the name of the file on top of the input stack\&. \fCNULL\fP will be returned if the toplevel 'file' is a memory buffer\&.
.PP
\fBSee also:\fP
.RS 4
\fBgetCurFile()\fP 
.RE
.PP

.SS "void SoInput::setBuffer (const void * bufpointer, size_t bufsize)\fC [virtual]\fP"
Sets up the input stream for reading from a memory buffer\&. Closes all open files in the file stack first\&.
.PP
In the original SGI Inventor API this method was designed as 'char * bufpointer', Coin followed this until Coin 3, but changed the signature to const from Coin 4\&.0\&. 
.SS "void SoInput::setStringArray (const char * strings[])"
Sets up the input stream for reading from the strings pointed to by a NULL-terminated array of string pointers\&. It is intended for reading memory-inlined scene graphs\&.
.PP
The rationale for this function is that there is a compiler portability problem with compiling large, static string buffers\&. Some compilers have fixed max-lengths on this feature, just over 1KB, which obviously becomes a problem real fast\&. This method lets you specify the buffer as an array of smaller string buffers, typically one string for each line in the Inventor file\&.
.PP
.PP
.nf
SoNode *
makeSceneGraph(void) {
  static const char * inlinescenegraph[] = {
    "#Inventor V2\&.1 ascii\n",
    "\n",
    "Separator {\n",
    "  Cube {\n",
    "  }\n",
    "}\n",
    NULL
  };
  SoInput in;
  if ( !in\&.setStringArray(inlinescenegraph) ) return NULL;
  return SoDB::readAll(&in);
}
.fi
.PP
.PP
\fBSee also:\fP
.RS 4
\fBsetBuffer()\fP
.RE
.PP
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2\&.1 API\&.
.PP
\fBSince:\fP
.RS 4
Coin 2\&.1 
.RE
.PP

.SS "size_t SoInput::getNumBytesRead (void) const\fC [virtual]\fP"
Returns number of bytes read so far from the current file or memory buffer\&. You can only use this method while you're reading the file\&. When the reading has finished, the current file is popped off the file stack, and a more or less random number is returned\&. You should use the stat() system call to find the size of a file (or fseek() and ftell())\&. 
.SS "\fBSbString\fP SoInput::getHeader (void)\fC [virtual]\fP"
Returns header of current file\&. 
.SS "float SoInput::getIVVersion (void)\fC [virtual]\fP"
Returns the library version needed to read a file with the given header\&. If the header of the current file is not valid, this method returns \fI0\&.0f\fP\&. 
.SS "SbBool SoInput::isBinary (void)\fC [virtual]\fP"
Returns \fCTRUE\fP if the current file is in binary format\&. 
.SS "SbBool SoInput::get (char & c)\fC [virtual]\fP"
Get next character in current stream\&. Returns \fCFALSE\fP on end of file\&.
.PP
\fBSee also:\fP
.RS 4
\fBread()\fP 
.RE
.PP

.SS "SbBool SoInput::getASCIIBuffer (char & c)\fC [virtual]\fP"
Returns next character in current stream\&. Don't use this method -- \fBSoInput\fP is supposed to \fIhide\fP whether or not you are reading from file or memory\&. It is only included for compatibility reasons\&. 
.SS "SbBool SoInput::getASCIIFile (char & c)\fC [virtual]\fP"
Returns next character in current stream\&. Don't use this method -- \fBSoInput\fP is supposed to \fIhide\fP whether or not you are reading from file or memory\&. It is only included for compatibility reasons\&. 
.SS "SbBool SoInput::readHex (uint32_t & l)\fC [virtual]\fP"
Reads an unsigned integer in hexidecimal format from the current stream\&. Note that no error checking is done to see if it actually is a hex format value\&.
.PP
A number in hexadecimal format must have the '0x' prefix\&.
.PP
Returns \fCFALSE\fP if end of file is encountered\&. 
.SS "SbBool SoInput::read (char & c)\fC [virtual]\fP"
Skips whitespace and reads next character in input stream\&. Returns \fCFALSE\fP if encountering end of file\&. 
.SS "SbBool SoInput::read (char & c, SbBool skip)\fC [virtual]\fP"
Reads next character in input stream, returns \fCFALSE\fP if encountering end of file\&. If \fIskip\fP is \fCTRUE\fP, skips whitespace before reading a character\&. 
.SS "SbBool SoInput::read (\fBSbString\fP & s)\fC [virtual]\fP"
Skips whitespace and extracts string\&. A string can be placed within quotes, in which case we will return all characters between the quotes (including spaces, tabs, newlines, etc)\&. A quote character (i\&.e\&. \fC"'') can also be part of the string, but must then be preceded by a\fP\\'' character\&.
.PP
A string not contained in quotes is terminated by the first following whitespace character\&.
.PP
Returns \fCFALSE\fP upon encountering end of file (EOF) before the string is fully parsed, or any other error\&. Note: This function does not return \fCFALSE\fP when encountering all EOFs\&. When multiple files are on the stack and a string is being parsed (the parser has found one or more valid characters) and EOF is encountered, the parsing stops and the read string along with \fCTRUE\fP is returned\&. The next time the read method is called, the stack is popped and a read string from the next file is returned - not always returning \fCFALSE\fP between the files (though it might on certain circumstances)\&. The solution to this is to test for end of file after each successive read operation\&. 
.SS "SbBool SoInput::read (\fBSbName\fP & n, SbBool validIdent = \fCFALSE\fP)\fC [virtual]\fP"
Read a name from the current stream and place it in \fIn\fP\&.
.PP
This method should not be used specifically to read all instances of \fBSbName\fP\&. The semantics of the interface is such that it is designed to handle identifier tokens from the Inventor / VRML file formats\&. I\&.e\&. cases where node names, node types and field names are to be read\&. If your goal is to read the value of a \fBSbName\fP field that is not any of the above, and at least when the string might be quoted, then you should most likely use \fBSoInput::read(SbString &)\fP instead\&.
.PP
If \fIvalidIdent\fP is \fCTRUE\fP the name needs to be a valid identifier (no reserved characters etc), while \fIvalidIdent\fP equal to \fCFALSE\fP means we'll just read characters for the next word until we hit whitespace or one of the '{'/'}' delimiters\&.
.PP
Returns \fCFALSE\fP on encountering end of file before a full name has been read -- if \fIvalidIdent\fP is also \fCFALSE\fP\&. If \fIvalidIdent\fP is passed as \fCTRUE\fP, the return value will be \fCFALSE\fP if no valid name was found, but \fInot\fP necessarily on end of file\&. 
.SS "SbBool SoInput::read (\fBint\fP & i)\fC [virtual]\fP"
Read integer from current file or buffer position and place it in \fIi\fP\&. Returns \fCFALSE\fP if we hit end of file prematurely\&. 
.SS "SbBool SoInput::read (unsigned \fBint\fP & i)\fC [virtual]\fP"
Read unsigned integer from current file or buffer position and place it in \fIi\fP\&. Returns \fCFALSE\fP if we hit end of file prematurely\&. 
.SS "SbBool SoInput::read (short & s)\fC [virtual]\fP"
Read short integer from current file or buffer position and place it in \fIs\fP\&. Returns \fCFALSE\fP if we hit end of file prematurely\&. 
.SS "SbBool SoInput::read (unsigned short & s)\fC [virtual]\fP"
Read unsigned short integer from current file or buffer position and place it in \fIs\fP\&. Returns \fCFALSE\fP if we hit end of file prematurely\&. 
.SS "SbBool SoInput::read (float & f)\fC [virtual]\fP"
Read float value from current file or buffer position and place it in \fIf\fP\&. Returns \fCFALSE\fP if we hit end of file prematurely\&. 
.SS "SbBool SoInput::read (double & d)\fC [virtual]\fP"
Read double value from current file or buffer position and place it in \fId\fP\&. Returns \fCFALSE\fP if we hit end of file prematurely\&. 
.SS "SbBool SoInput::readByte (int8_t & b)\fC [virtual]\fP"
Read signed byte integer from current file or buffer position and place it in \fIb\fP\&. Returns \fCFALSE\fP if we hit end of file prematurely\&. 
.SS "SbBool SoInput::readByte (uint8_t & b)\fC [virtual]\fP"
Read unsigned byte integer from current file or buffer position and place it in \fIb\fP\&. Returns \fCFALSE\fP if we hit end of file prematurely\&. 
.SS "SbBool SoInput::readBinaryArray (unsigned char * c, \fBint\fP length)\fC [virtual]\fP"
Reads \fIlength\fP characters from the current stream into \fIc\fP\&. Returns \fCFALSE\fP if end of file is encountered before the given number of bytes could be read\&. 
.SS "SbBool SoInput::readBinaryArray (int32_t * l, \fBint\fP length)\fC [virtual]\fP"
Reads \fIlength\fP 32-bit integers from the current stream into \fIl\fP\&. Returns \fCFALSE\fP if end of file is encountered before the given number of integers could be read\&. 
.SS "SbBool SoInput::readBinaryArray (float * f, \fBint\fP length)\fC [virtual]\fP"
Reads \fIlength\fP floats from the current stream into \fIf\fP\&. Returns \fCFALSE\fP if end of file is encountered before the given number of binary float values could be read\&. 
.SS "SbBool SoInput::readBinaryArray (double * d, \fBint\fP length)\fC [virtual]\fP"
Reads \fIlength\fP double floats from the current stream into \fId\fP\&. Returns \fCFALSE\fP if end of file is encountered before the given number of binary double float values could be read\&. 
.SS "SbBool SoInput::eof (void) const\fC [virtual]\fP"
Returns \fCTRUE\fP if we are at the end of the current stream, otherwise \fCFALSE\fP\&. 
.SS "SbBool SoInput::isFileVRML1 (void)"
Returns \fCTRUE\fP if current file is a VRML V1\&.0 file\&.
.PP
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2\&.1 API\&. 
.SS "SbBool SoInput::isFileVRML2 (void)"
Returns \fCTRUE\fP if current file is a VRML 2 / VRML97 file\&.
.PP
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2\&.1 API\&. 
.SS "void SoInput::resetFilePointer (FILE * fptr)\fC [virtual]\fP"
This function has been obsoleted in Coin\&. 
.SS "void SoInput::getLocationString (\fBSbString\fP & str) const\fC [virtual]\fP"
Places the current line number location and file name in a string which is to be used in the output upon read errors\&. 
.SS "void SoInput::putBack (const char c)\fC [virtual]\fP"
Insert character \fIc\fP in stream at the current position\&. 
.SS "void SoInput::putBack (const char * str)\fC [virtual]\fP"
Insert string \fIstr\fP in stream at the current position\&. 
.SS "void SoInput::addReference (const \fBSbName\fP & name, \fBSoBase\fP * base, SbBool addToGlobalDict = \fCTRUE\fP)\fC [virtual]\fP"
Adds a name<->\fBSoBase\fP mapping to our dictionary\&.
.PP
\fBSee also:\fP
.RS 4
\fBfindReference()\fP, \fBremoveReference()\fP 
.RE
.PP

.SS "void SoInput::removeReference (const \fBSbName\fP & name)\fC [virtual]\fP"
Removes a name<->\fBSoBase\fP mapping from our dictionary\&.
.PP
\fBSee also:\fP
.RS 4
\fBfindReference()\fP, \fBaddReference()\fP 
.RE
.PP

.SS "\fBSoBase\fP * SoInput::findReference (const \fBSbName\fP & name) const\fC [virtual]\fP"
Finds an \fBSoBase\fP derived object which has been mapped to \fIname\fP earlier during the import process\&.
.PP
The Coin library will by default only search through the previously loaded nodes from the \fIsame\fP file\&. By setting the environment variable \fCCOIN_SOINPUT_SEARCH_GLOBAL_DICT\fP to '1', you can force the import process to search for USE-references through \fIall\fP nodes that has been loaded or otherwise instantiated\&.
.PP
\fBSee also:\fP
.RS 4
\fBaddReference()\fP, \fBremoveReference()\fP 
.RE
.PP

.SS "void SoInput::addDirectoryFirst (const char * dirName)\fC [static]\fP"
Add a directory to the search list\&. The added directory will be searched before any of the other directories in the list\&.
.PP
\fBSee also:\fP
.RS 4
\fBaddDirectoryLast()\fP, \fBaddEnvDirectoriesFirst()\fP, \fBaddEnvDirectoriesLast()\fP 
.PP
\fBremoveDirectory()\fP, \fBclearDirectories()\fP 
.RE
.PP

.SS "void SoInput::addDirectoryLast (const char * dirName)\fC [static]\fP"
Add a directory to the search list\&. The added directory will be searched after any of the other directories in the list\&.
.PP
\fBSee also:\fP
.RS 4
\fBaddDirectoryFirst()\fP, \fBaddEnvDirectoriesFirst()\fP, \fBaddEnvDirectoriesLast()\fP 
.PP
\fBremoveDirectory()\fP, \fBclearDirectories()\fP 
.RE
.PP

.SS "void SoInput::addEnvDirectoriesFirst (const char * envVarName, const char * separator = \fC':\\t '\fP)\fC [static]\fP"
Add in front of the list all directories in the environment variable \fIenvVarName\fP\&. The \fIseparator\fP string should contain all characters to be interpreted as separators in the environment variable string list\&. The default separators are ':', tab and space\&.
.PP
\fBSee also:\fP
.RS 4
\fBaddDirectoryFirst()\fP, \fBaddDirectoryLast()\fP 
.PP
\fBaddEnvDirectoriesLast()\fP 
.PP
\fBremoveDirectory()\fP, \fBclearDirectories()\fP 
.RE
.PP

.SS "void SoInput::addEnvDirectoriesLast (const char * envVarName, const char * separator = \fC':\\t '\fP)\fC [static]\fP"
Add at the end of the list all directories in the environment variable \fIenvVarName\fP\&. The \fIseparator\fP string should contain all characters to be interpreted as separators in the environment variable string list\&. The default separators are ':', tab and space\&.
.PP
\fBSee also:\fP
.RS 4
\fBaddDirectoryFirst()\fP, \fBaddDirectoryLast()\fP 
.PP
\fBaddEnvDirectoriesFirst()\fP 
.PP
\fBremoveDirectory()\fP, \fBclearDirectories()\fP 
.RE
.PP

.SS "void SoInput::removeDirectory (const char * dirName)\fC [static]\fP"
Remove the given directory from the directory search list\&.
.PP
The search list is scanned from last to first for the directory name, so directories can easily be 'stacked' by pushing with \fBaddDirectoryLast()\fP and then removed with this method\&.
.PP
\fBSee also:\fP
.RS 4
\fBaddDirectoryFirst()\fP, \fBaddDirectoryLast()\fP 
.PP
\fBaddEnvDirectoriesFirst()\fP, \fBaddEnvDirectoriesLast()\fP 
.PP
\fBclearDirectories()\fP 
.RE
.PP

.SS "void SoInput::clearDirectories (void)\fC [static]\fP"
Remove all entries from the directory search list\&.
.PP
\fBSee also:\fP
.RS 4
\fBaddDirectoryFirst()\fP, \fBaddDirectoryLast()\fP 
.PP
\fBaddEnvDirectoriesFirst()\fP, \fBaddEnvDirectoriesLast()\fP 
.PP
\fBremoveDirectory()\fP 
.RE
.PP

.SS "const \fBSbStringList\fP & SoInput::getDirectories (void)\fC [static]\fP"
Returns the list of directories which'll be searched upon loading Coin and VRML format files\&. Directory searches will be done whenever any external references appears in a file, for instance to texture images\&. 
.SS "void SoInput::init (void)\fC [static]\fP"
Initialize static variables in class\&. Called from \fBSoDB::init()\fP\&. 
.SS "\fBSbString\fP SoInput::getPathname (const char *const filename)\fC [static]\fP"
Finds and returns the part of the given filename which is the directory path name\&. 
.SS "\fBSbString\fP SoInput::getPathname (const \fBSbString\fP & s)\fC [static]\fP"
Finds and returns the part of the given filename which is the directory path name\&. 
.SS "\fBSbString\fP SoInput::getBasename (const char *const filename)\fC [static]\fP"
Finds and returns the part of the given filename which is the base name (i\&.e\&. the filename without the leading directory path)\&. 
.SS "\fBSbString\fP SoInput::getBasename (const \fBSbString\fP & s)\fC [static]\fP"
Finds and returns the part of the given filename which is the base name (i\&.e\&. the filename without the leading directory path)\&. 
.SS "\fBSbString\fP SoInput::searchForFile (const \fBSbString\fP & basename, const \fBSbStringList\fP & directories, const \fBSbStringList\fP & subdirectories)\fC [static]\fP"
Given a \fIbasename\fP for a file and an array of \fIdirectories\fP to search, returns the full name of the file found\&.
.PP
In addition to looking at the root of each directory in \fIdirectories\fP, all \fIsubdirectories\fP is also searched for each item in \fIdirectories\fP\&.
.PP
If no file matching \fIbasename\fP could be found in any of the directories, returns an empty string\&.
.PP
This method is a Coin extension, not part of the original Inventor API\&. 
.SS "SbBool SoInput::popFile (void)\fC [protected]\fP, \fC [virtual]\fP"
Pop the topmost file off the stack\&. Returns \fCFALSE\fP if there was no files on the stack to pop\&. A file is only popped when there is more than one file on the stack\&.
.PP
\fBSee also:\fP
.RS 4
\fBpushFile()\fP, \fBopenFile()\fP, \fBcloseFile()\fP 
.RE
.PP

.SS "void SoInput::setIVVersion (float version)\fC [protected]\fP"
Changes the file format version number for the stream at the top of the stack\&. 
.SS "FILE * SoInput::findFile (const char * basename, \fBSbString\fP & fullname)\fC [protected]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP
.PP
Return the currently active stream\&.
.PP
Scan through the include directories in order and try to find a file with the given name in any one of them\&. If file is found, put the full name with complete path from current directory of process into \fIfullname\fP, open the file and return the file pointer\&.
.PP
If the file could either not be found or not opened for reading, return \fCNULL\fP\&.
.PP
Important note: do \fInot\fP use this method when the Coin library has been compiled as an MSWindows DLL, as passing FILE* instances back or forth to DLLs is dangerous and will most likely cause a crash\&. This is an intrinsic limitation for MSWindows DLLs\&. 
.SS "void SoInput::initFile (FILE * newFP, const char * fileName, \fBSbString\fP * fullName, SbBool openedHere, \fBSbDict\fP * refDict = \fCNULL\fP)\fC [protected]\fP"
This function has been obsoleted in Coin\&. 
.SS "SbBool SoInput::checkHeader (SbBool bValidateBufferHeader = \fCFALSE\fP)\fC [protected]\fP"
Returns \fCTRUE\fP if the current stream has had it's header parsed\&. If it hasn't, this method will attempt to read the header and returns \fCTRUE\fP if it could be done\&.
.PP
If \fIbValidateBufferHeader\fP is \fCTRUE\fP, the returned flag will also be \fCFALSE\fP if the file stream header was not of a supported file format type\&. 
.SS "SbBool SoInput::fromBuffer (void) const\fC [protected]\fP"
Returns \fCTRUE\fP if the current input stream is fetching data from a memory buffer, or \fCFALSE\fP if the input is from a file\&. 
.SS "SbBool SoInput::skipWhiteSpace (void)\fC [protected]\fP"
Move file pointer past whitespace in the current file or buffer\&. Returns \fCFALSE\fP if end of file is encountered\&. 
.SS "size_t SoInput::freeBytesInBuf (void) const\fC [protected]\fP"
This function has been obsoleted in Coin\&. 
.SS "SbBool SoInput::readInteger (int32_t & l)\fC [protected]\fP"
Reads 32-bit signed integer value from the current stream\&. Returns \fCFALSE\fP if we hit end of file prematurely\&. 
.SS "SbBool SoInput::readUnsignedInteger (uint32_t & l)\fC [protected]\fP"
Reads 32-bit unsigned integer value from the current stream\&. Returns \fCFALSE\fP if we hit end of file prematurely\&. 
.SS "SbBool SoInput::readReal (double & d)\fC [protected]\fP"
Reads a double-precision floating point value from the current stream\&. Returns \fCFALSE\fP if we hit end of file prematurely or if no valid string representing a value could be read\&. 
.SS "SbBool SoInput::readUnsignedIntegerString (char * str)\fC [protected]\fP"
Reads a set of bytes from the stream making up an unsigned integer and puts them at \fIstr\fP\&.
.PP
Returns \fCFALSE\fP if no string representing an unsigned integer could be read\&. 
.SS "\fBint\fP SoInput::readDigits (char * str)\fC [protected]\fP"
Read decimal base digits from the current input stream into \fIstr\fP and returns the number of characters read\&. 
.SS "\fBint\fP SoInput::readHexDigits (char * str)\fC [protected]\fP"
Read hexadecimal base digits from the current input stream into \fIstr\fP and returns the number of characters read\&. 
.SS "\fBint\fP SoInput::readChar (char * s, char charToRead)\fC [protected]\fP"
Reads the next character in stream and compares it to \fIcharToRead\fP\&. Returns \fC1\fP on success, \fC0\fP on failure\&. Failure may come from either end of file, or from the next character in the stream being different than \fIcharToRead\fP\&. 
.SS "SbBool SoInput::makeRoomInBuf (size_t nBytes)\fC [protected]\fP"
This function has been obsoleted in Coin\&. 
.SS "void SoInput::convertShort (char * from, short * s)\fC [protected]\fP"
Convert the bytes at \fIfrom\fP (which must be a short integer in network format (i\&.e\&. most significant byte first)) to a short integer in native format which is put at the \fIs\fP pointer\&. 
.SS "void SoInput::convertInt32 (char * from, int32_t * l)\fC [protected]\fP"
Convert the bytes at \fIfrom\fP (which must be a 32-bit integer in network format (i\&.e\&. most significant byte first)) to a 32-bit integer in native format which is put at the \fIl\fP pointer\&. 
.SS "void SoInput::convertFloat (char * from, float * f)\fC [protected]\fP"
Convert the bytes at \fIfrom\fP (which must be a single-precision floating point number in network format) to a single-precision floating point number in native format which is put at the \fIf\fP pointer\&. 
.SS "void SoInput::convertDouble (char * from, double * d)\fC [protected]\fP"
Convert the bytes at \fIfrom\fP (which must be a double-precision floating point number in network format) to a double-precision floating point number in native format which is put at the \fId\fP pointer\&. 
.SS "void SoInput::convertShortArray (char * from, short * to, \fBint\fP len)\fC [protected]\fP"
Convert a block of short numbers in network format to native format\&.
.PP
\fBSee also:\fP
.RS 4
\fBconvertShort()\fP 
.RE
.PP

.SS "void SoInput::convertInt32Array (char * from, int32_t * to, \fBint\fP len)\fC [protected]\fP"
Convert a block of 32-bit integer numbers in network format to native format\&.
.PP
\fBSee also:\fP
.RS 4
\fBconvertInt32()\fP 
.RE
.PP

.SS "void SoInput::convertFloatArray (char * from, float * to, \fBint\fP len)\fC [protected]\fP"
Convert a block of single-precision floating point numbers in network format to native format\&.
.PP
\fBSee also:\fP
.RS 4
\fBconvertFloat()\fP 
.RE
.PP

.SS "void SoInput::convertDoubleArray (char * from, double * to, \fBint\fP len)\fC [protected]\fP"
Convert a block of double-precision floating point numbers in network format to native format\&.
.PP
\fBSee also:\fP
.RS 4
\fBconvertDouble()\fP 
.RE
.PP

.SS "SbBool SoInput::isFileURL (const char * url)\fC [protected]\fP"
This function is part of the TGS Inventor API, but is not implemented in Coin\&. 
.SS "char * SoInput::URLToFile (char * out_buf, const char * in_buf)\fC [protected]\fP"
This function is part of the TGS Inventor API, but is not implemented in Coin\&. 
.SS "SbBool SoInput::IsURL (const char * c_strng)\fC [protected]\fP"
This function is part of the TGS Inventor API, but is not implemented in Coin\&. 
.SS "void SoInput::setDirectories (\fBSbStringList\fP * dirs)\fC [static]\fP, \fC [protected]\fP"
Set up the directory search path directly with the list of directories in \fIdirs\fP\&. Note that '\&.' should be part of the directory list if you want to handle files specified by a relative path\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
