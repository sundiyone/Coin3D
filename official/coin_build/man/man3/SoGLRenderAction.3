.TH "SoGLRenderAction" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SoGLRenderAction \- The \fBSoGLRenderAction\fP class renders the scene graph with OpenGL calls\&.
.PP
Applying this method at a root node for a scene graph, path or pathlist will render all geometry contained within that instance to the current OpenGL context\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Inventor/actions/SoGLRenderAction\&.h>\fP
.PP
Inherits \fBSoAction\fP\&.
.PP
Inherited by \fBSoBoxHighlightRenderAction\fP, and \fBSoLineHighlightRenderAction\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBTransparencyType\fP { \fBSCREEN_DOOR\fP, \fBADD\fP, \fBDELAYED_ADD\fP, \fBSORTED_OBJECT_ADD\fP, \fBBLEND\fP, \fBDELAYED_BLEND\fP, \fBSORTED_OBJECT_BLEND\fP, \fBSORTED_OBJECT_SORTED_TRIANGLE_ADD\fP, \fBSORTED_OBJECT_SORTED_TRIANGLE_BLEND\fP, \fBNONE\fP, \fBSORTED_LAYERS_BLEND\fP }"
.br
.ti -1c
.RI "enum \fBTransparentDelayedObjectRenderType\fP { \fBONE_PASS\fP, \fBNONSOLID_SEPARATE_BACKFACE_PASS\fP }"
.br
.ti -1c
.RI "enum \fBAbortCode\fP { \fBCONTINUE\fP, \fBABORT\fP, \fBPRUNE\fP, \fBDELAY\fP }"
.br
.ti -1c
.RI "enum \fBSortedObjectOrderStrategy\fP { \fBBBOX_CENTER\fP, \fBBBOX_CLOSEST_CORNER\fP, \fBBBOX_FARTHEST_CORNER\fP, \fBCUSTOM_CALLBACK\fP }"
.br
.ti -1c
.RI "typedef \fBAbortCode\fP \fBSoGLRenderAbortCB\fP(void *userdata)"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fBSoType\fP \fBgetTypeId\fP (void) const"
.br
.ti -1c
.RI "\fBSoGLRenderAction\fP (const \fBSbViewportRegion\fP &viewportregion)"
.br
.ti -1c
.RI "virtual \fB~SoGLRenderAction\fP (void)"
.br
.ti -1c
.RI "void \fBsetViewportRegion\fP (const \fBSbViewportRegion\fP &newregion)"
.br
.ti -1c
.RI "const \fBSbViewportRegion\fP & \fBgetViewportRegion\fP (void) const"
.br
.ti -1c
.RI "void \fBsetUpdateArea\fP (const \fBSbVec2f\fP &origin, const \fBSbVec2f\fP &size)"
.br
.ti -1c
.RI "void \fBgetUpdateArea\fP (\fBSbVec2f\fP &origin, \fBSbVec2f\fP &size) const"
.br
.ti -1c
.RI "void \fBsetAbortCallback\fP (\fBSoGLRenderAbortCB\fP *const func, void *const userdata)"
.br
.ti -1c
.RI "void \fBgetAbortCallback\fP (\fBSoGLRenderAbortCB\fP *&func_out, void *&userdata_out) const"
.br
.ti -1c
.RI "void \fBsetTransparencyType\fP (const \fBTransparencyType\fP type)"
.br
.ti -1c
.RI "\fBTransparencyType\fP \fBgetTransparencyType\fP (void) const"
.br
.ti -1c
.RI "void \fBsetTransparentDelayedObjectRenderType\fP (\fBTransparentDelayedObjectRenderType\fP type)"
.br
.ti -1c
.RI "\fBTransparentDelayedObjectRenderType\fP \fBgetTransparentDelayedObjectRenderType\fP (void) const"
.br
.ti -1c
.RI "void \fBsetSmoothing\fP (const SbBool smooth)"
.br
.ti -1c
.RI "SbBool \fBisSmoothing\fP (void) const"
.br
.ti -1c
.RI "void \fBsetNumPasses\fP (const \fBint\fP num)"
.br
.ti -1c
.RI "\fBint\fP \fBgetNumPasses\fP (void) const"
.br
.ti -1c
.RI "void \fBsetPassUpdate\fP (const SbBool flag)"
.br
.ti -1c
.RI "SbBool \fBisPassUpdate\fP (void) const"
.br
.ti -1c
.RI "void \fBsetPassCallback\fP (\fBSoGLRenderPassCB\fP *const func, void *const userdata)"
.br
.ti -1c
.RI "void \fBsetCacheContext\fP (const uint32_t context)"
.br
.ti -1c
.RI "uint32_t \fBgetCacheContext\fP (void) const"
.br
.ti -1c
.RI "void \fBaddDelayedPath\fP (\fBSoPath\fP *path)"
.br
.ti -1c
.RI "SbBool \fBisRenderingDelayedPaths\fP (void) const"
.br
.ti -1c
.RI "SbBool \fBhandleTransparency\fP (SbBool istransparent=FALSE)"
.br
.ti -1c
.RI "void \fBsetCurPass\fP (const \fBint\fP passnum, const \fBint\fP numpasses)"
.br
.ti -1c
.RI "\fBint\fP \fBgetCurPass\fP (void) const"
.br
.ti -1c
.RI "SbBool \fBabortNow\fP (void)"
.br
.ti -1c
.RI "void \fBsetRenderingIsRemote\fP (SbBool isremote)"
.br
.ti -1c
.RI "SbBool \fBgetRenderingIsRemote\fP (void) const"
.br
.ti -1c
.RI "virtual void \fBinvalidateState\fP (void)"
.br
.ti -1c
.RI "void \fBaddPreRenderCallback\fP (SoGLPreRenderCB *func, void *userdata)"
.br
.ti -1c
.RI "void \fBremovePreRenderCallback\fP (SoGLPreRenderCB *func, void *userdata)"
.br
.ti -1c
.RI "void \fBsetSortedLayersNumPasses\fP (\fBint\fP num)"
.br
.ti -1c
.RI "\fBint\fP \fBgetSortedLayersNumPasses\fP (void) const"
.br
.ti -1c
.RI "void \fBsetSortedObjectOrderStrategy\fP (const \fBSortedObjectOrderStrategy\fP strategy, \fBSoGLSortedObjectOrderCB\fP *cb=NULL, void *closure=NULL)"
.br
.ti -1c
.RI "void \fBsetDelayedObjDepthWrite\fP (SbBool write)"
.br
.ti -1c
.RI "SbBool \fBgetDelayedObjDepthWrite\fP (void) const"
.br
.ti -1c
.RI "SbBool \fBisRenderingTranspPaths\fP (void) const"
.br
.ti -1c
.RI "SbBool \fBisRenderingTranspBackfaces\fP (void) const"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBSoType\fP \fBgetClassTypeId\fP (void)"
.br
.ti -1c
.RI "static void \fBaddMethod\fP (const \fBSoType\fP type, \fBSoActionMethod\fP method)"
.br
.ti -1c
.RI "static void \fBenableElement\fP (const \fBSoType\fP type, const \fBint\fP stackindex)"
.br
.ti -1c
.RI "static void \fBinitClass\fP (void)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual const \fBSoEnabledElementsList\fP & \fBgetEnabledElements\fP (void) const"
.br
.ti -1c
.RI "virtual void \fBbeginTraversal\fP (\fBSoNode\fP *node)"
.br
.ti -1c
.RI "virtual void \fBendTraversal\fP (\fBSoNode\fP *node)"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static \fBSoEnabledElementsList\fP * \fBgetClassEnabledElements\fP (void)"
.br
.ti -1c
.RI "static \fBSoActionMethodList\fP * \fBgetClassActionMethods\fP (void)"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
The \fBSoGLRenderAction\fP class renders the scene graph with OpenGL calls\&.
.PP
Applying this method at a root node for a scene graph, path or pathlist will render all geometry contained within that instance to the current OpenGL context\&. 
.SH "Member Typedef Documentation"
.PP 
.SS "typedef SoGLRenderAction::SoGLRenderAbortCB"
Abort callbacks should be of this type\&. 
.PP
\fBSee also:\fP
.RS 4
\fBsetAbortCallback()\fP 
.RE
.PP

.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBSoGLRenderAction::TransparencyType\fP"
Various settings for how to do rendering of transparent objects in the scene\&. Some of the settings will provide faster rendering, while others give you better quality rendering\&.
.PP
Note that doing correct rendering of \fImultiple\fP transparent objects often fails, because to be 100% correct, all polygons needs to be rendered in sorted order, and polygons can't intersect each other\&. In a dynamic scene graph it is often impossible to guarantee that no polygons intersect, and finding an algorithm that does correct sorting of polygons for all possible cases is very hard and time-consuming\&.
.PP
The highest quality transparency mode in the original SGI / TGS Open Inventor is \fBSoGLRenderAction::SORTED_OBJECT_BLEND\fP, where all transparent objects are rendered in sorted order in a rendering pass after all opaque objects\&. However, this mode does not sort the polygons, and if you have an object where some polygon A is behind some other polygon B, the transparency will only be correct if A happens to be rendered before B\&. For other camera angles, where B is behind A, the transparency will not be correct\&.
.PP
In Coin we have a new transparency mode that solves some of these problems: \fBSoGLRenderAction::SORTED_OBJECT_SORTED_TRIANGLE_BLEND\fP\&. In addition to sorting the objects, all polygons inside each object is also sorted back-to-front when rendering\&. But, if you have intersecting objects and/or intersecting polygons, even this transparency mode will fail\&. Also, because of the polygon sorting, this transparency mode is quite slow\&. It is possible to speed things up using the \fBSoTransparencyType\fP node, though, which enables you to set different transparency modes for different parts of the scene graph\&. If you have only have a few objects where you need to sort the polygons, you can use \fBSoGLRenderAction::SORTED_OBJECT_SORTED_TRIANGLE_BLEND\fP for those, and for instance \fBSoGLRenderAction::SORTED_OBJECT_BLEND\fP for all other transparent objects\&.
.PP
The highest quality transparency mode in Coin is \fBSoGLRenderAction::SORTED_LAYERS_BLEND\fP\&. It is also the only mode that overrides all other modes in the scenegraph\&.
.PP
(One important note about this mode: we've had reports from users that some OpenGL drivers -- possibly particular for some Mac OS X systems -- significantly degrades rendering performance\&. So be careful and test your application on a wide variety of run-time systems when using \fBSoGLRenderAction::SORTED_LAYERS_BLEND\fP\&.)
.PP
\fBSee also:\fP
.RS 4
\fBSoTransparencyType\fP 
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISCREEN_DOOR \fP\fP
Transparent triangles are rendered with a dither pattern\&. This is a fast (on most GFX cards) but not-so-high-quality transparency mode\&.
.PP
One particular feature of this mode is that you are guaranteed that it always renders the transparent parts of the scene correct with regard to internal depth ordering of objects / polygons, something which is not the case for any other transparency mode\&.
.PP
Polygons rendered with only transparent textures are not shown as being transparent when using this mode\&. The reason being that the SCREEN_DOOR mode is working on polygons, not pixels\&. To render polygons with dither pattern, a material node has to be inserted into the scenegraph with it's transparency field set\&. 
.TP
\fB\fIADD \fP\fP
Transparent objects are rendered using additive alpha blending\&. Additive blending is probably mostly used to create special transparency effects\&. The new pixel color is calculated as the current pixel color plus the source pixel color multiplied with the source pixel alpha value\&. 
.TP
\fB\fIDELAYED_ADD \fP\fP
\fBSoGLRenderAction::DELAYED_ADD\fP Transparent objects are rendered using additive alpha blending, in a second rendering pass with depth buffer updates disabled\&. 
.TP
\fB\fISORTED_OBJECT_ADD \fP\fP
Transparent objects are rendered using additive alpha blending\&. Opaque objects are rendered first, and transparent objects are rendered back to front with z-buffer updates disabled\&. 
.TP
\fB\fIBLEND \fP\fP
Transparent objects are rendered using multiplicative alpha blending\&.
.PP
Multiplicative alpha blending is the blending type that is most often used to render transparent objects\&. The new pixel value is calculated as the old pixel color multiplied with one minus the source alpha value, plus the source pixel color multiplied with the source alpha value\&.
.PP
We recommend that you use this transparency mode if you have only one transparent object in your scene, and you know that it will be rendered after the opaque objects\&. 
.TP
\fB\fIDELAYED_BLEND \fP\fP
Transparent objects are rendered using multiplicative alpha blending, in a second rendering pass with depth buffer updates disabled\&.
.PP
Use this transparency type when you have one transparent object, or several transparent object that you know will never overlap (when projected to screen)\&. Since the transparent objects are rendered after opaque ones, you'll not have to worry about putting the transparent objects at the end of your scene graph\&. It will not be as fast as the BLEND transparency type, of course, since the scene graph is traversed twice\&. 
.TP
\fB\fISORTED_OBJECT_BLEND \fP\fP
Transparent objects are rendered using multiplicative alpha blending, Opaque objects are rendered first, and transparent objects are rendered back to front with z-buffer updates disabled\&.
.PP
Use this transparency mode when you have several transparent object that you know might overlap (when projected to screen)\&. This method will require 1 + num_transparent_objects rendering passes\&. Path traversal is used when rendering transparent objects, of course, but it might still be slow if you have lots of state changes before your transparent object\&. When using this mode, we recommend placing the transparent objects as early as possible in the scene graph to minimize traversal overhead\&. 
.TP
\fB\fISORTED_OBJECT_SORTED_TRIANGLE_ADD \fP\fP
This transparency type is a Coin extension versus the original SGI Open Inventor API\&.
.PP
Transparent objects are rendered back to front, and triangles in each object are sorted back to front before rendering\&.
.PP
See description for SORTED_OBJECT_SORTED_TRIANGLE_BLEND for more information about this transparency type\&. 
.TP
\fB\fISORTED_OBJECT_SORTED_TRIANGLE_BLEND \fP\fP
This transparency type is a Coin extension versus the original SGI Open Inventor API\&.
.PP
Transparent objects are rendered back to front, and triangles in each object are sorted back to front before rendering\&.
.PP
Use this transparency type when you have one (or more) transparent object(s) where you know triangles might overlap inside the object\&. This transparency type might be very slow if you have an object with lots of triangles, since all triangles have to be sorted before rendering, and an unoptimized rendering loop is used when rendering\&. Lines and points are not sorted before rendering\&. They are rendered as in the normal SORTED_OBJECT_BLEND transparency type\&.
.PP
Please note that this transparency mode does not guarantee 'correct' transparency rendering\&. It is almost impossible to find an algorithm that will sort triangles correctly in all cases, and intersecting triangles are not handled\&. Also, since each object is handled separately, two intersecting object will lead to incorrect transparency\&. 
.TP
\fB\fINONE \fP\fP
This transparency type is a Coin extension versus the Open Inventor API\&.
.PP
Turns off transparency for objects, even if transparency is set using an \fBSoMaterial\fP node\&.
.PP
\fBSince:\fP
.RS 4
Coin 1\&.0 
.RE
.PP

.TP
\fB\fISORTED_LAYERS_BLEND \fP\fP
This transparency type is a Coin extension versus the original SGI Open Inventor API\&.
.PP
By using this transparency type, the \fBSoGLRenderAction\fP will render normal and intersecting transparent objects correctly independent of rendering order\&. It is the only transparency type rendering mode which is guaranteed to do so\&.
.PP
This mode is different from all other modes in that it overrides the \fBSoTransparencyType\fP nodes in the scenegraph; all objects are drawn using SORTED_LAYERS_BLEND\&.
.PP
There are currently two separate code paths for this mode\&. Both paths are heavily based on OpenGL extensions\&. The first method is based on extensions which are only available on NVIDIA chipsets (GeForce3 and above, except GeForce4 MX)\&. These extensions are \fCGL_NV_texture_shader\fP, \fCGL_NV_texture_rectangle\fP or \fCGL_EXT_texture_rectangle\fP, \fCGL_NV_register_combiners\fP, \fCGL_ARB_shadow\fP and \fCGL_ARB_depth_texture\fP\&. Please note that this transparency type occupy all four texture units on the NVIDIA card for all the rendering passes, except the first\&. Textured surfaces will therefore only be textured if they are not occluded by another transparent surface\&.
.PP
The second method utilise the \fCGL_ARB_fragment_program\fP extension\&. This extension is currently supported by the GeForceFX family and the Radeon 9500 and above\&. This technique is faster than the pure NVIDIA method\&. The fragment program method will automatically be chosen if possible\&. Please note that one should beware not to place the near-plane too close to the camera due to the lack of floating point precision control in fragment programs\&. Doing so may lead to loss of precision around the edges and 'jaggedness' of the transparent geometry\&.
.PP
Setting the environment variable COIN_SORTED_LAYERS_USE_NVIDIA_RC to '1' will force the use of former code path instead of the latter, even if it is available\&.
.PP
A rendering context with >= 24 bits depth buffer and 8 bits alpha channel must be the current rendering context for this blending mode to actually become activated\&. If the current rendering canvas does not have these properties, Coin will fall back on a simpler transparency handling mode\&. If you are using one of the window-system binding libraries provided by Kongsberg Oil & Gas Technologies, e\&.g\&. SoXt, SoQt or SoWin, you will need to explicitly enable this in your viewer\&. See the API documentation of the \fCsetAlphaChannel()\fP method of either SoXtGLWidget, SoQtGLWidget or SoWinGLWidget\&.
.PP
The detection of whether or not the SORTED_LAYERS_BLEND mode can be used will be done automatically by the Coin internals\&. If one or more of the necessary conditions listed above are unavailable, \fBSoGLRenderAction::SORTED_OBJECT_BLEND\fP will be used as the transparency type instead\&.
.PP
To be able to render correct transparency independent of object order, one have to render in multiple passes\&. This technique is based on depth-peeling which strips away depth layers with each successive pass\&. The number of passes is therefore an indication of how deep into the scene transparent surfaces will be rendered with transparency\&. A higher number will lead to a lower framerate but higher quality for scenes with a lot of transparent surfaces\&. The default number of passes is '4'\&. This number can be specified using the \fBSoGLRenderAction::setSortedLayersNumPasses()\fP or by letting the environment variable \fCCOIN_NUM_SORTED_LAYERS_PASSES\fP or \fCOIV_NUM_SORTED_LAYERS_PASSES\fP specify the number of passes\&.
.PP
A more detailed presentation of the algorithm is written by Cass Everitt at NVIDIA;
.PP
'Interactive Order-Independent Transparency' http:://developer.nvidia.com/object/order_independent_transparency.html
.PP
\fBSince:\fP
.RS 4
Coin 2\&.2 
.PP
TGS Inventor 4\&.0 
.RE
.PP

.SS "enum \fBSoGLRenderAction::TransparentDelayedObjectRenderType\fP"
Enumerates the render types of transparent objects\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIONE_PASS \fP\fP
Normal one pass rendering\&. This might cause artifacts for non-solid objects\&. 
.TP
\fB\fINONSOLID_SEPARATE_BACKFACE_PASS \fP\fP
Non-solid objects are handled in an extra rendering pass\&. Backfacing polygons are rendered in the first pass, and the front facing in the second pass\&. 
.SS "enum \fBSoGLRenderAction::AbortCode\fP"
The return codes which an SoGLRenderAbortCB callback function should use\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetAbortCallback()\fP 
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fICONTINUE \fP\fP
Continue rendering as usual\&. 
.TP
\fB\fIABORT \fP\fP
Abort the rendering action immediately\&. 
.TP
\fB\fIPRUNE \fP\fP
Do not render the current node or any of its children, but continue the rendering traversal\&. 
.TP
\fB\fIDELAY \fP\fP
Delay rendering of the current node (and its children) until the next rendering pass\&. 
.SS "enum \fBSoGLRenderAction::SortedObjectOrderStrategy\fP"
Used for enumerating the different transparency sorting strategies\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetSortedObjectOrderStrategy()\fP\&. 
.RE
.PP
\fBSince:\fP
.RS 4
Coin 2\&.5 
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIBBOX_CENTER \fP\fP
Do the sorting based on the center of the object bounding box\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetSortedObjectOrderStrategy()\fP\&. 
.RE
.PP
\fBSince:\fP
.RS 4
Coin 2\&.5 
.RE
.PP

.TP
\fB\fIBBOX_CLOSEST_CORNER \fP\fP
Do the sorting based on the bounding box corner closest to the camera\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetSortedObjectOrderStrategy()\fP\&. 
.RE
.PP
\fBSince:\fP
.RS 4
Coin 2\&.5 
.RE
.PP

.TP
\fB\fIBBOX_FARTHEST_CORNER \fP\fP
Do the sorting based on the bounding box corner farthest from the camera\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetSortedObjectOrderStrategy()\fP\&. 
.RE
.PP
\fBSince:\fP
.RS 4
Coin 2\&.5 
.RE
.PP

.TP
\fB\fICUSTOM_CALLBACK \fP\fP
Use a custom callback to determine the sorting order\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetSortedObjectOrderStrategy()\fP\&. 
.RE
.PP
\fBSince:\fP
.RS 4
Coin 2\&.5 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "SoGLRenderAction::SoGLRenderAction (const \fBSbViewportRegion\fP & viewportregion)"
Constructor\&. Sets up the render action for rendering within the given \fIviewportregion\fP\&. 
.SS "SoGLRenderAction::~SoGLRenderAction (void)\fC [virtual]\fP"
Destructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBSoType\fP SoGLRenderAction::getTypeId (void) const\fC [virtual]\fP"
Returns the type identification of an action derived from a class inheriting \fBSoAction\fP\&. This is used for run-time type checking and 'downward' casting\&.
.PP
Usage example:
.PP
.PP
.nf
void bar(SoAction * action)
{
  if (action->getTypeId() == SoGLRenderAction::getClassTypeId()) {
    // safe downward cast, know the type
    SoGLRenderAction * glrender = (SoGLRenderAction *)action;
  }
  return; // ignore if not renderaction
}
.fi
.PP
.PP
For application programmers wanting to extend the library with new actions: this method needs to be overridden in \fIall\fP subclasses\&. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through Inventor/nodes/SoSubAction\&.h: SO_ACTION_SOURCE, SO_ACTION_INIT_CLASS and SO_ACTION_CONSTRUCTOR\&.
.PP
For more information on writing Coin extensions, see the \fBSoAction\fP class documentation\&.
.PP
Returns the actual type id of an object derived from a class inheriting \fBSoAction\fP\&. Needs to be overridden in \fIall\fP subclasses\&. 
.PP
Implements \fBSoAction\fP\&.
.PP
Reimplemented in \fBSoBoxHighlightRenderAction\fP, and \fBSoLineHighlightRenderAction\fP\&.
.SS "void SoGLRenderAction::addMethod (const \fBSoType\fP type, \fBSoActionMethod\fP method)\fC [static]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "void SoGLRenderAction::enableElement (const \fBSoType\fP type, const \fBint\fP stackindex)\fC [static]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "const \fBSoEnabledElementsList\fP & SoGLRenderAction::getEnabledElements (void) const\fC [protected]\fP, \fC [virtual]\fP"
Returns a list of the elements used by action instances of this class upon traversal operations\&. 
.PP
Reimplemented from \fBSoAction\fP\&.
.PP
Reimplemented in \fBSoBoxHighlightRenderAction\fP, and \fBSoLineHighlightRenderAction\fP\&.
.SS "void SoGLRenderAction::setViewportRegion (const \fBSbViewportRegion\fP & newregion)"
Sets the viewport region for rendering\&. This will then override the region passed in with the constructor\&. 
.SS "const \fBSbViewportRegion\fP & SoGLRenderAction::getViewportRegion (void) const"
Returns the viewport region for the rendering action\&. 
.SS "void SoGLRenderAction::setUpdateArea (const \fBSbVec2f\fP & origin, const \fBSbVec2f\fP & size)"
Sets the area of the OpenGL context canvas we should render into\&.
.PP
The coordinates for \fIorigin\fP and \fIsize\fP should be normalized to be within [0\&.0, 1\&.0]\&. The default settings are <0\&.0, 0\&.0> for the \fIorigin\fP and <1\&.0, 1\&.0> for the \fIsize\fP, using the full size of the rendering canvas\&. 
.SS "void SoGLRenderAction::getUpdateArea (\fBSbVec2f\fP & origin, \fBSbVec2f\fP & size) const"
Returns information about the area of the rendering context window to be updated\&. 
.SS "void SoGLRenderAction::setAbortCallback (\fBSoGLRenderAbortCB\fP *const func, void *const userdata)"
Sets the abort callback\&. The abort callback is called by the action for each node during traversal to check for abort conditions\&.
.PP
The callback method should return one of the \fBSoGLRenderAction::AbortCode\fP enum values to indicate how the action should proceed further\&.
.PP
Since the client SoGLRenderAbortCB callback function only has a single void* argument for the userdata, one has to do some additional work to find out which node the callback was made for\&. One can do this by for instance passing along the action pointer as userdata, and then call the \fBSoGLRenderAction::getCurPath()\fP method\&. The tail of the path will then be the last traversed node\&. Like this:
.PP
.PP
.nf
// set up so we can abort or otherwise intervene with the render
// traversal:
myRenderAction->setAbortCallback(MyRenderCallback, myRenderAction);

// [\&.\&.\&.]

SoGLRenderAction::AbortCode
MyRenderCallback(void * userdata)
{
  SoGLRenderAction * action = (SoGLRenderAction *)userdata;
  SoNode * lastnode = action->getCurPath()->getTail();

  // [\&.\&.\&.]
  return SoGLRenderAction::CONTINUE;
}
.fi
.PP
.PP
\fBSee also:\fP
.RS 4
\fBSoGLRenderAction::AbortCode\fP 
.RE
.PP

.SS "void SoGLRenderAction::getAbortCallback (\fBSoGLRenderAbortCB\fP *& func_out, void *& userdata_out) const"
Returns the abort callback settings\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetAbortCallback\fP 
.RE
.PP
\fBSince:\fP
.RS 4
Coin 3\&.0 
.RE
.PP

.SS "void SoGLRenderAction::setTransparencyType (const \fBTransparencyType\fP type)"
Sets the transparency rendering method for transparent objects in the scene graph\&.
.PP
\fBSee also:\fP
.RS 4
\fBSoGLRenderAction::TransparencyType\fP 
.RE
.PP

.SS "\fBSoGLRenderAction::TransparencyType\fP SoGLRenderAction::getTransparencyType (void) const"
Returns the transparency rendering type\&. 
.SS "void SoGLRenderAction::setTransparentDelayedObjectRenderType (\fBTransparentDelayedObjectRenderType\fP type)"
Sets the render type of delayed or sorted transparent objects\&. Default is ONE_PASS\&.
.PP
\fBSince:\fP
.RS 4
Coin 3\&.0 
.RE
.PP

.SS "\fBSoGLRenderAction::TransparentDelayedObjectRenderType\fP SoGLRenderAction::getTransparentDelayedObjectRenderType (void) const"
Returns the render type of delayed or sorted transparent objects\&.
.PP
\fBSince:\fP
.RS 4
Coin 3\&.0 
.RE
.PP

.SS "void SoGLRenderAction::setSmoothing (const SbBool smooth)"
Sets (or unsets) smoothing\&. If the smoothing flag is \fCon\fP, Coin will try to use built-in features from the OpenGL implementation to smooth the appearance of otherwise jagged line and point primitives, calling
.PP
.PP
.nf
    glEnable(GL_POINT_SMOOTH);
    glEnable(GL_LINE_SMOOTH);
.fi
.PP
.PP
\&.\&.\&.before rendering the scene\&.
.PP
This is a simple (and computationally non-intensive) way of doing anti-aliasing\&.
.PP
Default value for this flag is to be \fCoff\fP\&. 
.SS "SbBool SoGLRenderAction::isSmoothing (void) const"
Returns whether smoothing is set or not\&. 
.SS "void SoGLRenderAction::setNumPasses (const \fBint\fP num)"
Sets the number of rendering passes\&. Default is 1, anything greater will enable antialiasing through the use of an OpenGL accumulation buffer\&. 
.SS "\fBint\fP SoGLRenderAction::getNumPasses (void) const"
Returns the number of rendering passes done on updates\&. 
.SS "void SoGLRenderAction::setPassUpdate (const SbBool flag)"
Sets whether each pass should render to screen or not\&. 
.SS "SbBool SoGLRenderAction::isPassUpdate (void) const"
Returns the value of the 'show intermediate updates' flag\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetPassUpdate()\fP 
.RE
.PP

.SS "void SoGLRenderAction::setPassCallback (\fBSoGLRenderPassCB\fP *const func, void *const userdata)"
Sets the pass callback\&. The callback is called between each rendering pass\&. 
.SS "void SoGLRenderAction::setCacheContext (const uint32_t context)"
Sets the OpenGL cache context key, which is used for deciding when to share OpenGL display lists\&.
.PP
Each \fBSoGLRenderAction\fP has a cache context id\&. This can be set using \fBSoGLRenderAction::setCacheContext()\fP\&. The cache context id must be unique, so that different texture objects and display lists are created for uncompatible GL contexts\&. For instance, when \fBSoGLRenderAction\fP traverses an \fBSoTexture2\fP node, the node checks if it has a texture object created for the cache context\&. If not, a new texture object will be created and used when rendering\&.
.PP
\fBSee also:\fP
.RS 4
\fBSoGLCacheContextElement::getUniqueCacheContext()\fP 
.RE
.PP

.SS "uint32_t SoGLRenderAction::getCacheContext (void) const"
Returns the cache context key for this rendering action instance\&. 
.SS "void SoGLRenderAction::addDelayedPath (\fBSoPath\fP * path)"
Adds a path to the list of paths to render after the current pass\&. 
.SS "SbBool SoGLRenderAction::isRenderingDelayedPaths (void) const"
Returns a flag indicating whether or not we are currently rendering from the list of delayed paths of the scene graph\&. 
.SS "SbBool SoGLRenderAction::handleTransparency (SbBool istransparent = \fCFALSE\fP)"
Used by shape nodes or others which need to know whether or not they should immediately render themselves or if they should wait until the next pass\&. It also enables/disabled blending based on the \fIistransparent\fP parameter\&.
.PP
If you're using an \fBSoCallback\fP or a non-shape node to render your geometry, you can use this function to make sure your node is only rendered once\&. This function consider the \fIistransparent\fP parameter, and when TRUE it will return TRUE on the first pass, and FALSE on the second pass\&. For non-transparent objects it returns FALSE on the first pass, TRUE on the second\&.
.PP
Please note that this function considers the current transparency type when deciding what to do\&. It will delay rendering only when the transparency type is DELAYED_* or SORTED_OBJECT_*\&. For other transparency types, transparent objects are rendered in the same pass as opaque objects\&. 
.SS "void SoGLRenderAction::setCurPass (const \fBint\fP passnum, const \fBint\fP numpasses)"
Sets the current rendering pass to \fIpassnum\fP\&. This can be used when antialiasing is controlled from outside the \fBSoGLRenderAction\fP instance\&. \fInumpasses\fP is the total number of rendering passes to be used\&.
.PP
Please note that this will disable any antialiasing set using the \fBsetNumPasses()\fP method\&. You can reenable the internal antialiasing again by calling \fBsetNumPasses()\fP
.PP
\fBSince:\fP
.RS 4
Coin 3\&.1 
.RE
.PP

.SS "\fBint\fP SoGLRenderAction::getCurPass (void) const"
Returns the number of the current rendering pass\&. 
.SS "SbBool SoGLRenderAction::abortNow (void)"
Returns \fCTRUE\fP if the render action should abort now based on user callback\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetAbortCallback()\fP 
.RE
.PP

.SS "void SoGLRenderAction::setRenderingIsRemote (SbBool isremote)"
Let \fBSoGLRenderAction\fP instance know if application is running on the local machine or if the rendering instructions are sent over the network\&.
.PP
The flag is used to optimize rendering\&. For instance should the displaylist caching strategy be influenced by this flag to be more aggressive with the caching when rendering instructions are passed over the network\&.
.PP
Default value is \fCFALSE\fP\&. The value of the flag will not be changed internally from the Coin library code, as it is meant to be controlled from client code -- typically from the SoQt / SoXt / SoWin / SoGtk libraries\&.
.PP
\fBSee also:\fP
.RS 4
\fBgetRenderingIsRemote()\fP 
.RE
.PP

.SS "SbBool SoGLRenderAction::getRenderingIsRemote (void) const"
Returns whether or not the application is running remotely\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetRenderingIsRemote()\fP 
.RE
.PP

.SS "void SoGLRenderAction::invalidateState (void)\fC [virtual]\fP"
Invalidates the state, forcing it to be recreated at the next \fBapply()\fP invocation\&. 
.PP
Reimplemented from \fBSoAction\fP\&.
.SS "void SoGLRenderAction::addPreRenderCallback (SoGLPreRenderCB * func, void * userdata)"
Adds a callback which is invoked right before the scene graph traversal starts\&. All necessary GL initialization is then done (e\&.g\&. the viewport is correctly set), and this callback can be useful to, for instance, clear the viewport before rendering, or draw a bitmap in the background before rendering etc\&.
.PP
The callback is only invoked once (before the first rendering pass) when multi pass rendering is enabled\&.
.PP
Please note that \fBSoSceneManager\fP usually adds a callback to clear the GL buffers in \fBSoSceneManager::render()\fP\&. So, if you plan to for instance draw an image in the color buffer using this callback, you should make sure that the scene manager doesn't clear the buffer\&. This can be done either by calling \fBSoSceneManager::render()\fP with both arguments FALSE, or, if you're using one of our GUI toolkits (SoXt/SoQt/SoGtk/SoWin), call setClearBeforeRender() on the viewer\&.
.PP
This method is an extension versus the Open Inventor API\&.
.PP
\fBSee also:\fP
.RS 4
\fBremovePreRenderCallback()\fP\&. 
.RE
.PP

.SS "void SoGLRenderAction::removePreRenderCallback (SoGLPreRenderCB * func, void * userdata)"
Removed a callback added with the \fBaddPreRenderCallback()\fP method\&.
.PP
This method is an extension versus the Open Inventor API\&.
.PP
\fBSee also:\fP
.RS 4
\fBaddPreRenderCallback()\fP 
.RE
.PP

.SS "void SoGLRenderAction::setSortedLayersNumPasses (\fBint\fP num)"
Sets the number of passes to render in \fBSoGLRenderAction::SORTED_LAYERS_BLEND\fP mode\&. Default number of passes is 4\&. This number can also be adjusted by setting the \fCCOIN_NUM_SORTED_LAYERS_PASSES\fP or \fCOIV_NUM_SORTED_LAYERS_PASSES\fP environment variable\&. 
.SS "\fBint\fP SoGLRenderAction::getSortedLayersNumPasses (void) const"
Returns the number of passes to render when in \fBSoGLRenderAction::SORTED_LAYERS_BLEND\fP mode\&. 
.SS "void SoGLRenderAction::setSortedObjectOrderStrategy (const \fBSortedObjectOrderStrategy\fP strategy, \fBSoGLSortedObjectOrderCB\fP * cb = \fCNULL\fP, void * closure = \fCNULL\fP)"
Sets the strategy used for sorting transparent objects\&.
.PP
The \fICUSTOM_CALLBACK\fP strategy enables the user to supply a callback which is called for each transparent shape\&. This strategy can be used if the built in sorting strategies aren't sufficient\&.
.PP
The callback should return a floating point value to be used when sorting the objects in Coin\&. This floating point value is interpreted as a distance to the camera, and objects with higher values will be sorted behind objects with lower values\&.
.PP
The callback will supply the \fBSoGLRenderAction\fP instance, and the path to the current object can be found using \fBSoAction::getCurPath()\fP\&.
.PP
\fBSince:\fP
.RS 4
Coin 2\&.5 
.RE
.PP

.SS "void SoGLRenderAction::setDelayedObjDepthWrite (SbBool write)"
Set whether depth buffer updates should be done when rendering delayed or sorted transparent objects\&.
.PP
\fBSince:\fP
.RS 4
Coin 3\&.0 
.RE
.PP

.SS "SbBool SoGLRenderAction::getDelayedObjDepthWrite (void) const"
Return whether depth buffer updates should be done when rendering delayed or sorted transparent objects\&. Default is FALSE\&.
.PP
\fBSince:\fP
.RS 4
Coin 3\&.0 
.RE
.PP

.SS "SbBool SoGLRenderAction::isRenderingTranspPaths (void) const"
Returns TRUE if the action is currently rendering delayed or sorted transparent objects\&.
.PP
\fBSince:\fP
.RS 4
Coin 3\&.0 
.RE
.PP

.SS "SbBool SoGLRenderAction::isRenderingTranspBackfaces (void) const"
Returns TRUE if the action is currently rendering backfacing polygons in NONSOLID_SEPARATE_BACKFACE_PASS mode\&.
.PP
\fBSince:\fP
.RS 4
Coin 3\&.0 
.RE
.PP

.SS "void SoGLRenderAction::beginTraversal (\fBSoNode\fP * node)\fC [protected]\fP, \fC [virtual]\fP"
This virtual method is called from \fBSoAction::apply()\fP, and is the entry point for the actual scenegraph traversal\&.
.PP
It can be overridden to initialize the action at traversal start, for specific initializations in the action subclasses inheriting \fBSoAction\fP\&.
.PP
Default method just calls \fBtraverse()\fP, which any overridden implementation of the method must do too (or call \fBSoAction::beginTraversal()\fP) to trigger the scenegraph traversal\&. 
.PP
Reimplemented from \fBSoAction\fP\&.
.SS "void SoGLRenderAction::endTraversal (\fBSoNode\fP * node)\fC [protected]\fP, \fC [virtual]\fP"
This virtual method can be overridden to execute code after the scene graph traversal\&. Default method does nothing\&. 
.PP
Reimplemented from \fBSoAction\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
