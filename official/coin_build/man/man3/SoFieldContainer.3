.TH "SoFieldContainer" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SoFieldContainer \- The \fBSoFieldContainer\fP class is a base class for all classes that contain fields\&.
.PP
The classes containing fields in Coin are the node and engine classes, so they are all subclasses of \fBSoFieldContainer\fP\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Inventor/fields/SoFieldContainer\&.h>\fP
.PP
Inherits \fBSoBase\fP\&.
.PP
Inherited by \fBSoEngine\fP, and \fBSoNode\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBsetToDefaults\fP (void)"
.br
.ti -1c
.RI "SbBool \fBhasDefaultValues\fP (void) const"
.br
.ti -1c
.RI "SbBool \fBfieldsAreEqual\fP (const \fBSoFieldContainer\fP *container) const"
.br
.ti -1c
.RI "void \fBcopyFieldValues\fP (const \fBSoFieldContainer\fP *container, SbBool copyconnections=FALSE)"
.br
.ti -1c
.RI "SbBool \fBset\fP (const char *const fielddata)"
.br
.ti -1c
.RI "void \fBget\fP (\fBSbString\fP &fielddata)"
.br
.ti -1c
.RI "virtual \fBint\fP \fBgetFields\fP (\fBSoFieldList\fP &l) const"
.br
.ti -1c
.RI "virtual \fBint\fP \fBgetAllFields\fP (\fBSoFieldList\fP &l) const"
.br
.ti -1c
.RI "virtual \fBSoField\fP * \fBgetField\fP (const \fBSbName\fP &name) const"
.br
.ti -1c
.RI "virtual \fBSoField\fP * \fBgetEventIn\fP (const \fBSbName\fP &name) const"
.br
.ti -1c
.RI "virtual \fBSoField\fP * \fBgetEventOut\fP (const \fBSbName\fP &name) const"
.br
.ti -1c
.RI "SbBool \fBgetFieldName\fP (const \fBSoField\fP *const field, \fBSbName\fP &name) const"
.br
.ti -1c
.RI "SbBool \fBenableNotify\fP (const SbBool flag)"
.br
.ti -1c
.RI "SbBool \fBisNotifyEnabled\fP (void) const"
.br
.ti -1c
.RI "SbBool \fBset\fP (const char *fielddata, \fBSoInput\fP *input)"
.br
.ti -1c
.RI "void \fBget\fP (\fBSbString\fP &fielddata, \fBSoOutput\fP *out)"
.br
.ti -1c
.RI "virtual void \fBnotify\fP (\fBSoNotList\fP *l)"
.br
.ti -1c
.RI "virtual SbBool \fBvalidateNewFieldValue\fP (\fBSoField\fP *field, void *newval)"
.br
.ti -1c
.RI "virtual void \fBaddWriteReference\fP (\fBSoOutput\fP *out, SbBool isfromfield=FALSE)"
.br
.ti -1c
.RI "virtual void \fBwriteInstance\fP (\fBSoOutput\fP *out)"
.br
.ti -1c
.RI "SbBool \fBgetIsBuiltIn\fP (void) const"
.br
.ti -1c
.RI "virtual const \fBSoFieldData\fP * \fBgetFieldData\fP (void) const"
.br
.ti -1c
.RI "virtual void \fBcopyContents\fP (const \fBSoFieldContainer\fP *from, SbBool copyconnections)"
.br
.ti -1c
.RI "virtual \fBSoFieldContainer\fP * \fBcopyThroughConnection\fP (void) const"
.br
.ti -1c
.RI "virtual void \fBgetFieldsMemorySize\fP (size_t &managed, size_t &unmanaged) const"
.br
.ti -1c
.RI "void \fBsetUserData\fP (void *userdata) const"
.br
.ti -1c
.RI "void * \fBgetUserData\fP (void) const"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static void \fBinitClass\fP (void)"
.br
.ti -1c
.RI "static \fBSoType\fP \fBgetClassTypeId\fP (void)"
.br
.ti -1c
.RI "static void \fBcleanupClass\fP (void)"
.br
.ti -1c
.RI "static void \fBinitCopyDict\fP (void)"
.br
.ti -1c
.RI "static void \fBaddCopy\fP (const \fBSoFieldContainer\fP *orig, const \fBSoFieldContainer\fP *copy)"
.br
.ti -1c
.RI "static \fBSoFieldContainer\fP * \fBcheckCopy\fP (const \fBSoFieldContainer\fP *orig)"
.br
.ti -1c
.RI "static \fBSoFieldContainer\fP * \fBfindCopy\fP (const \fBSoFieldContainer\fP *orig, const SbBool copyconnections)"
.br
.ti -1c
.RI "static void \fBcopyDone\fP (void)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBSoFieldContainer\fP (void)"
.br
.ti -1c
.RI "virtual \fB~SoFieldContainer\fP ()"
.br
.ti -1c
.RI "virtual SbBool \fBreadInstance\fP (\fBSoInput\fP *in, unsigned short flags)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "SbBool \fBisBuiltIn\fP"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
The \fBSoFieldContainer\fP class is a base class for all classes that contain fields\&.
.PP
The classes containing fields in Coin are the node and engine classes, so they are all subclasses of \fBSoFieldContainer\fP\&. 

\fBSoFieldContainer\fP provides methods for reading, writing, comparing for equality, doing copy operations, etc on fields\&.
.PP
\fBSee also:\fP
.RS 4
\fBSoField\fP 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "SoFieldContainer::SoFieldContainer (void)\fC [protected]\fP"
Constructor\&. 
.SS "SoFieldContainer::~SoFieldContainer ()\fC [protected]\fP, \fC [virtual]\fP"
Destructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "void SoFieldContainer::setToDefaults (void)"
This method sets all fields which we are parenting to their respective default values\&. 
.SS "SbBool SoFieldContainer::hasDefaultValues (void) const"
This method checks to see if the fields of this container have their default values, and returns \fCTRUE\fP if that is the case\&. 
.SS "SbBool SoFieldContainer::fieldsAreEqual (const \fBSoFieldContainer\fP * container) const"
This method returns \fCTRUE\fP if the values of the fields of this and \fIcontainer\fP are equal\&. 
.SS "void SoFieldContainer::copyFieldValues (const \fBSoFieldContainer\fP * container, SbBool copyconnections = \fCFALSE\fP)"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP
.PP
This method copies the field values from container into this\&. The fields are assumed to be of the same type\&. The \fIcopyconnections\fP flag decides whether the field connections are to be copied aswell\&. 
.SS "SbBool SoFieldContainer::set (const char *const fielddata)"
This method parses the values of one or more fields from the \fIfielddata\fP string\&.
.PP
The fields must be in the same format as the Open Inventor file format\&. \fCTRUE\fP is returned upon success, and \fCFALSE\fP otherwise\&.
.PP
\fBSee also:\fP
.RS 4
\fBget()\fP 
.RE
.PP

.SS "void SoFieldContainer::get (\fBSbString\fP & fielddata)"
This methods stores the field data in the given \fIfielddata\fP string\&. The format of the returned string follows the Open Inventor file format\&.
.PP
\fBSee also:\fP
.RS 4
\fBset()\fP 
.RE
.PP

.SS "\fBint\fP SoFieldContainer::getFields (\fBSoFieldList\fP & fields) const\fC [virtual]\fP"
This method adds the fields in this container to the \fIl\fP argument, and returns the number of fields added\&.
.PP
The virtual nature of this function means that it can be overridden to e\&.g\&. hide private fields\&. 
.SS "\fBint\fP SoFieldContainer::getAllFields (\fBSoFieldList\fP & fields) const\fC [virtual]\fP"
Returns VRML eventIn and eventOut fields in addition to the 'ordinary' fields\&.
.PP
\fBSee also:\fP
.RS 4
\fBgetFields()\fP 
.RE
.PP

.SS "\fBSoField\fP * SoFieldContainer::getField (const \fBSbName\fP & name) const\fC [virtual]\fP"
This method returns a pointer to the field with \fIname\fP, or \fCNULL\fP if no such field exists\&. 
.SS "\fBSoField\fP * SoFieldContainer::getEventIn (const \fBSbName\fP & name) const\fC [virtual]\fP"
This method returns a pointer to the eventIn with name \fIname\fP, or \fCNULL\fP if no such eventIn exists\&. 
.SS "\fBSoField\fP * SoFieldContainer::getEventOut (const \fBSbName\fP & name) const\fC [virtual]\fP"
This method returns a pointer to the eventOut with name \fIname\fP, or \fCNULL\fP if no such eventOut exists\&. 
.SS "SbBool SoFieldContainer::getFieldName (const \fBSoField\fP *const field, \fBSbName\fP & name) const"
Finds the name of the given \fIfield\fP and returns the value in the \fIname\fP argument\&.
.PP
\fCTRUE\fP is returned if the field is contained within this instance, and \fCFALSE\fP otherwise\&. 
.SS "SbBool SoFieldContainer::enableNotify (const SbBool enable)"
This method sets whether notification will be propagated on changing the values of the contained fields\&. The old value of the flag is returned\&.
.PP
Notification is default \fIon\fP\&. Turning off automatic notification can be useful for optimizing performance\&. During series of updates you may want to avoid the propagation of notifications upon every field value change if you make a lot of them\&. This is how you should handle those cases:
.PP
.PP
.nf
SbBool autonotify = node->enableNotify(FALSE);
// \&.\&.\&.
// Make modifications to fields of "node" here\&.
// \&.\&.\&.
node->enableNotify(autonotify);
node->touch();
.fi
.PP
.PP
\fBSee also:\fP
.RS 4
\fBisNotifyEnabled()\fP 
.RE
.PP

.SS "SbBool SoFieldContainer::isNotifyEnabled (void) const"
This method returns whether notification of changes to the field values in the container is propagated to its auditors\&.
.PP
\fBSee also:\fP
.RS 4
\fBenableNotify()\fP 
.RE
.PP

.SS "SbBool SoFieldContainer::set (const char * fielddata, \fBSoInput\fP * in)"
This method parses the values of one or more fields from the \fIfielddata\fP string\&.
.PP
The fields must be in the same format as the Open Inventor file format\&. \fCTRUE\fP is returned upon success, and \fCFALSE\fP otherwise\&.
.PP
We use the reference dictionary provided by \fIin\fP\&.
.PP
\fBSee also:\fP
.RS 4
\fBget()\fP 
.RE
.PP

.SS "void SoFieldContainer::get (\fBSbString\fP & fielddata, \fBSoOutput\fP * out)"
Put names and values of fields from this instance in the \fIfielddata\fP string\&. Fields will be separated in the returned string by end-of-line characters\&.
.PP
We use the reference dictionary provided by \fIout\fP\&.
.PP
\fBSee also:\fP
.RS 4
\fBset()\fP 
.RE
.PP

.SS "void SoFieldContainer::notify (\fBSoNotList\fP * l)\fC [virtual]\fP"
Notifies all auditors for this instance when changes are made\&. 
.PP
Reimplemented from \fBSoBase\fP\&.
.PP
Reimplemented in \fBSoNode\fP, \fBSoSceneTexture2\fP, \fBSoVRMLSwitch\fP, \fBSoVRMLLOD\fP, \fBSoProfilerStats\fP, \fBSoSceneTextureCubeMap\fP, \fBSoTextureCubeMap\fP, \fBSoText3\fP, \fBSoTexture2\fP, \fBSoImage\fP, \fBSoTexture3\fP, \fBSoVRMLGroup\fP, \fBSoVertexProperty\fP, \fBSoVRMLParent\fP, \fBSoVRMLTransform\fP, \fBSoVRMLVertexShape\fP, \fBSoShadowGroup\fP, \fBSoVRMLElevationGrid\fP, \fBSoAsciiText\fP, \fBSoVRMLShape\fP, \fBSoSeparator\fP, \fBSoVRMLScript\fP, \fBSoBumpMap\fP, \fBSoVRMLProximitySensor\fP, \fBSoVRMLExtrusion\fP, \fBSoSwitch\fP, \fBSoVRMLBillboard\fP, \fBSoVRMLText\fP, \fBSoVertexAttribute\fP, \fBSoMaterial\fP, \fBSoShape\fP, \fBSoLOD\fP, \fBSoVRMLTouchSensor\fP, \fBSoLevelOfDetail\fP, \fBSoVRMLIndexedLine\fP, \fBSoVRMLPixelTexture\fP, \fBSoVRMLAppearance\fP, \fBSoEngine\fP, \fBSoVRMLIndexedLineSet\fP, \fBSoVertexShape\fP, \fBSoIndexedLineSet\fP, \fBSoBlinker\fP, \fBSoPackedColor\fP, \fBSoVRMLVertexPoint\fP, \fBSoVRMLTimeSensor\fP, \fBSoVRMLCollision\fP, \fBSoVRMLGeometry\fP, \fBSoVRMLVertexLine\fP, \fBSoNodeEngine\fP, \fBSoVRMLIndexedShape\fP, and \fBSoIndexedPointSet\fP\&.
.SS "SbBool SoFieldContainer::validateNewFieldValue (\fBSoField\fP * field, void * newval)\fC [virtual]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP I can't make head or tails of this method, it seems to return TRUE no matter what the arguments are\&. 
.SS "void SoFieldContainer::addWriteReference (\fBSoOutput\fP * out, SbBool isfromfield = \fCFALSE\fP)\fC [virtual]\fP"
This method is used during the first write pass of a write action to count the number of references to this object in the scene graph\&. 
.PP
Reimplemented from \fBSoBase\fP\&.
.PP
Reimplemented in \fBSoBaseKit\fP, and \fBSoGroup\fP\&.
.SS "void SoFieldContainer::writeInstance (\fBSoOutput\fP * out)\fC [virtual]\fP"
Writes all the fields contained in this instance to the output stream within \fIout\fP\&.
.PP
This method is solely called from the write methods of fields\&.
.PP
Either from \fBSoField\fP if the write is done because of a field-to-field connection, or from one of the fields which may actually write \fBSoFieldContainer\fP instances, i\&.e\&. \fBSoSFNode\fP, \fBSoMFNode\fP, \fBSoSFEngine\fP, \fBSoMFEngine\fP, \fBSoSFPath\fP and \fBSoMFPath\fP\&.
.PP
This method, in addition to the ordinary write() method of \fBSoNode\fP, needs to be present since the fields don't have a write action instance in their writeValue() method, and \fBwriteInstance()\fP will create a new \fBSoWriteAction\fP and call continueToApply() on it\&. 
.PP
Reimplemented in \fBSoNode\fP, \fBSoTimeCounter\fP, \fBSoEngine\fP, \fBSoElapsedTime\fP, and \fBSoNodeEngine\fP\&.
.SS "SbBool SoFieldContainer::getIsBuiltIn (void) const"
Returns \fCTRUE\fP if this object is instantiated from one of the native Coin classes, \fCFALSE\fP if the object's class is outside the standard Coin library\&. 
.SS "const \fBSoFieldData\fP * SoFieldContainer::getFieldData (void) const\fC [virtual]\fP"
Returns a pointer to the class-wide field data storage object for this instance\&. If no fields are present, returns \fCNULL\fP\&. 
.PP
Reimplemented in \fBSoShaderStateMatrixParameter\fP, \fBSoShaderParameterMatrixArray\fP, \fBSoShaderParameterMatrix\fP, \fBSoShaderParameterArray4i\fP, \fBSoShaderParameterArray4f\fP, \fBSoShaderParameterArray3i\fP, \fBSoShaderParameterArray3f\fP, \fBSoShaderParameterArray2i\fP, \fBSoShaderParameterArray2f\fP, \fBSoShaderParameterArray1i\fP, \fBSoShaderParameterArray1f\fP, \fBSoShaderParameter4i\fP, \fBSoShaderParameter4f\fP, \fBSoShaderParameter3i\fP, \fBSoShaderParameter3f\fP, \fBSoShaderParameter2i\fP, \fBSoShaderParameter2f\fP, \fBSoShaderParameter1i\fP, \fBSoShaderParameter1f\fP, \fBSoUniformShaderParameter\fP, \fBSoExtSelection\fP, \fBSoShaderParameter\fP, \fBSoBaseKit\fP, \fBSoDragger\fP, \fBSoCamera\fP, \fBSoWWWInline\fP, \fBSoVRMLInline\fP, \fBSoEventCallback\fP, \fBSoShape\fP, \fBSoVRMLSwitch\fP, \fBSoTrackballDragger\fP, \fBSoNodeVisualize\fP, \fBSoProtoInstance\fP, \fBSoDirectionalLightManip\fP, \fBSoInteractionKit\fP, \fBSoVertexShape\fP, \fBSoSelection\fP, \fBSoVRMLElevationGrid\fP, \fBSoVRMLFontStyle\fP, \fBSoSpotLightManip\fP, \fBSoShaderProgram\fP, \fBSoTexture2\fP, \fBSoShaderObject\fP, \fBSoWWWAnchor\fP, \fBSoSTLFileKit\fP, \fBSoScrollingGraphKit\fP, \fBSoProfilerTopEngine\fP, \fBSoComposeMatrix\fP, \fBSoTransformManip\fP, \fBSoClipPlaneManip\fP, \fBSoPointLightManip\fP, \fBSoTextureCubeMap\fP, \fBSoTexture3\fP, \fBSoComposeRotation\fP, \fBSoComposeRotationFromTo\fP, \fBSoComposeVec2f\fP, \fBSoComposeVec4f\fP, \fBSoComposeVec3f\fP, \fBSoVRMLAudioClip\fP, \fBSoVRMLImageTexture\fP, \fBSoVRMLVertexShape\fP, \fBSoTransformerDragger\fP, \fBSoSpotLightDragger\fP, \fBSoRotateSphericalDragger\fP, \fBSoText3\fP, \fBSoSceneTexture2\fP, \fBSoSceneTextureCubeMap\fP, \fBSoImage\fP, \fBSoProfilerStats\fP, \fBSoDecomposeVec4f\fP, \fBSoDecomposeVec3f\fP, \fBSoDecomposeMatrix\fP, \fBSoDecomposeVec2f\fP, \fBSoVRMLMovieTexture\fP, \fBSoVRMLAnchor\fP, \fBSoVRMLIndexedFaceSet\fP, \fBSoVRMLViewpoint\fP, \fBSoScale2UniformDragger\fP, \fBSoTabPlaneDragger\fP, \fBSoTranslate1Dragger\fP, \fBSoTranslate2Dragger\fP, \fBSoHandleBoxDragger\fP, \fBSoRotor\fP, \fBSoGeoSeparator\fP, \fBSoGeoCoordinate\fP, \fBSoVertexProperty\fP, \fBSoShuttle\fP, \fBSoPendulum\fP, \fBSoSwitch\fP, \fBSoBumpMap\fP, \fBSoDecomposeRotation\fP, \fBSoVRMLDragSensor\fP, \fBSoVRMLSound\fP, \fBSoScale2Dragger\fP, \fBSoRotateCylindricalDragger\fP, \fBSoScale1Dragger\fP, \fBSoScaleUniformDragger\fP, \fBSoDirectionalLightDragger\fP, \fBSoJackDragger\fP, \fBSoRotateDiscDragger\fP, \fBSoCenterballDragger\fP, \fBSoTransformBoxDragger\fP, \fBSoNodeKitListPart\fP, \fBSoIndexedLineSet\fP, \fBSoIndexedFaceSet\fP, \fBSoFontStyle\fP, \fBSoIndexedTriangleStripSet\fP, \fBSoGeoLocation\fP, \fBSoCacheHint\fP, \fBSoForeignFileKit\fP, \fBSoShadowGroup\fP, \fBSoCalculator\fP, \fBSoComputeBoundingBox\fP, \fBSoVRMLBillboard\fP, \fBSoVRMLIndexedLineSet\fP, \fBSoVRMLNavigationInfo\fP, \fBSoVRMLTimeSensor\fP, \fBSoVRMLFog\fP, \fBSoVRMLBackground\fP, \fBSoVRMLText\fP, \fBSoPointLightDragger\fP, \fBSoDragPointDragger\fP, \fBSoTabBoxDragger\fP, \fBSoIndexedNurbsSurface\fP, \fBSoTextureCoordinatePlane\fP, \fBSoAsciiText\fP, \fBSoTexture3Transform\fP, \fBSoIndexedNurbsCurve\fP, \fBSoMaterial\fP, \fBSoSeparator\fP, \fBSoLocateHighlight\fP, \fBSoRotationXYZ\fP, \fBSoProfile\fP, \fBSoProfilerTopKit\fP, \fBSoProfilerVisualizeKit\fP, \fBSoGate\fP, \fBSoTimeCounter\fP, \fBSoElapsedTime\fP, \fBSoOneShot\fP, \fBSoVRMLGroup\fP, \fBSoVRMLPositionInterpolator\fP, \fBSoVRMLLOD\fP, \fBSoVRMLExtrusion\fP, \fBSoVRMLCollision\fP, \fBSoIndexedPointSet\fP, \fBSoSurroundScale\fP, \fBSoBlinker\fP, \fBSoListener\fP, \fBSoTextureCombine\fP, \fBSoEnvironment\fP, \fBSoGeoOrigin\fP, \fBSoTextureCoordinateReflectionMap\fP, \fBSoDrawStyle\fP, \fBSoNurbsCurve\fP, \fBSoTransform\fP, \fBSoFile\fP, \fBSoLOD\fP, \fBSoNurbsSurface\fP, \fBSoSelectOne\fP, \fBSoVRMLParent\fP, \fBSoVRMLOrientationInterpolator\fP, \fBSoVRMLSphereSensor\fP, \fBSoVRMLTextureTransform\fP, \fBSoVRMLProximitySensor\fP, \fBSoVRMLColorInterpolator\fP, \fBSoVRMLMaterial\fP, \fBSoNormal\fP, \fBSoShapeHints\fP, \fBSoBumpMapTransform\fP, \fBSoArray\fP, \fBSoText2\fP, \fBSoFaceSet\fP, \fBSoTexture2Transform\fP, \fBSoTextureCoordinateNormalMap\fP, \fBSoPolygonOffset\fP, \fBSoIndexedShape\fP, \fBSoDepthBuffer\fP, \fBSoLevelOfDetail\fP, \fBSoIndexedMarkerSet\fP, \fBSoCube\fP, \fBSoAntiSquish\fP, \fBSoShadowSpotLight\fP, \fBSoShadowDirectionalLight\fP, \fBSoBoolOperation\fP, \fBSoCounter\fP, \fBSoVRMLLight\fP, \fBSoVRMLVisibilitySensor\fP, \fBSoVRMLNormal\fP, \fBSoVRMLCoordinate\fP, \fBSoVRMLColor\fP, \fBSoVRMLCoordinateInterpolator\fP, \fBSoVRMLTouchSensor\fP, \fBSoVRMLInterpolator\fP, \fBSoVRMLVertexPoint\fP, \fBSoVRMLShape\fP, \fBSoVRMLPixelTexture\fP, \fBSoVRMLNormalInterpolator\fP, \fBSoVRMLAppearance\fP, \fBSoVRMLTextureCoordinate\fP, \fBSoTextureCoordinate3\fP, \fBSoSpotLight\fP, \fBSoComplexity\fP, \fBSoCylinder\fP, \fBSoCoordinate3\fP, \fBSoBaseColor\fP, \fBSoNurbsProfile\fP, \fBSoCoordinate4\fP, \fBSoLight\fP, \fBSoCone\fP, \fBSoNonIndexedShape\fP, \fBSoGeometryShader\fP, \fBSoPackedColor\fP, \fBSoHeightMapToNormalMap\fP, \fBSoTransformVec3f\fP, \fBSoTriggerAny\fP, \fBSoOnOff\fP, \fBSoConcatenate\fP, \fBSoVRMLPlaneSensor\fP, \fBSoVRMLCylinder\fP, \fBSoVRMLPointLight\fP, \fBSoVRMLTransform\fP, \fBSoVRMLGeometry\fP, \fBSoVRMLCone\fP, \fBSoVRMLSpotLight\fP, \fBSoVRMLScalarInterpolator\fP, \fBSoVRMLCylinderSensor\fP, \fBSoVRMLWorldInfo\fP, \fBSoVRMLVertexLine\fP, \fBSoHandleBoxManip\fP, \fBSoTrackballManip\fP, \fBSoTransformerManip\fP, \fBSoTransformBoxManip\fP, \fBSoTabBoxManip\fP, \fBSoCenterballManip\fP, \fBSoJackManip\fP, \fBSoSeparatorKit\fP, \fBSoClipPlane\fP, \fBSoRotation\fP, \fBSoUnits\fP, \fBSoTextureCoordinateObject\fP, \fBSoFrustumCamera\fP, \fBSoTranslation\fP, \fBSoNormalBinding\fP, \fBSoTextureCoordinateEnvironment\fP, \fBSoPickStyle\fP, \fBSoCallback\fP, \fBSoLightModel\fP, \fBSoTextureUnit\fP, \fBSoPathSwitch\fP, \fBSoGroup\fP, \fBSoPointSet\fP, \fBSoMarkerSet\fP, \fBSoVertexAttributeBinding\fP, \fBSoLineSet\fP, \fBSoTextureCoordinateBinding\fP, \fBSoTransparencyType\fP, \fBSoTextureCoordinate2\fP, \fBSoMatrixTransform\fP, \fBSoMaterialBinding\fP, \fBSoTriangleStripSet\fP, \fBSoSphere\fP, \fBSoDirectionalLight\fP, \fBSoPointLight\fP, \fBSoFont\fP, \fBSoResetTransform\fP, \fBSoTextureScalePolicy\fP, \fBSoQuadMesh\fP, \fBSoAlphaTest\fP, \fBSoScale\fP, \fBSoMultipleCopy\fP, \fBSoShadowStyle\fP, \fBSoShadowCulling\fP, \fBSoFieldConverter\fP, \fBSoInterpolate\fP, \fBSoTexture2Convert\fP, \fBSoVRMLBox\fP, \fBSoVRMLIndexedLine\fP, \fBSoVRMLSphere\fP, \fBSoVRMLPointSet\fP, \fBSoVRMLIndexedShape\fP, \fBSoVRMLTexture\fP, \fBSoVRMLDirectionalLight\fP, \fBSoAppearanceKit\fP, \fBSoSceneKit\fP, \fBSoLightKit\fP, \fBSoCameraKit\fP, \fBSoLinearProfile\fP, \fBSoTextureMatrixTransform\fP, \fBSoBumpMapCoordinate\fP, \fBSoProfileCoordinate3\fP, \fBSoColorIndex\fP, \fBSoTextureCoordinateDefault\fP, \fBSoFragmentShader\fP, \fBSoTransformSeparator\fP, \fBSoLabel\fP, \fBSoAnnotation\fP, \fBSoOrthographicCamera\fP, \fBSoProfileCoordinate2\fP, \fBSoReversePerspectiveCamera\fP, \fBSoPerspectiveCamera\fP, \fBSoInfo\fP, \fBSoVRMLSensor\fP, \fBSoShapeKit\fP, \fBSoWrapperKit\fP, \fBSoTextureCoordinateSphere\fP, \fBSoTextureCoordinateCylinder\fP, \fBSoTransformation\fP, \fBSoTextureCoordinateCube\fP, \fBSoTextureCoordinateFunction\fP, \fBSoInterpolateVec4f\fP, \fBSoInterpolateVec3f\fP, \fBSoInterpolateFloat\fP, \fBSoInterpolateRotation\fP, \fBSoInterpolateVec2f\fP, \fBSoVertexShader\fP, \fBSoTexture\fP, and \fBSoProfilerOverlayKit\fP\&.
.SS "void SoFieldContainer::copyContents (const \fBSoFieldContainer\fP * from, SbBool copyconnections)\fC [virtual]\fP"
Makes a deep copy of all data of \fIfrom\fP into this instance, \fIexcept\fP external scenegraph references if \fIcopyconnections\fP is \fCFALSE\fP\&.
.PP
This is the method that should be overridden by extension node / engine / dragger / whatever subclasses which needs to account for internal data that are not handled automatically\&.
.PP
For copying nodes from application code, you should not invoke this function directly, but rather call the \fBSoNode::copy()\fP function:
.PP
.PP
.nf
SoNode * mynewnode = templatenode->copy();
.fi
.PP
.PP
The same also goes for engines\&.
.PP
Make sure that when you override the \fBcopyContents()\fP method in your extension class that you also make it call upwards to it's parent superclass in the inheritance hierarchy, as \fBcopyContents()\fP in for instance \fBSoNode\fP and \fBSoFieldContainer\fP does important work\&. It should go something like this:
.PP
.PP
.nf
void
MyCoinExtensionNode::copyContents(const SoFieldContainer * from,
                                  SbBool copyconnections)
{
  // let parent superclasses do their thing (copy fields, copy
  // instance name, etc etc)
  SoNode::copyContents(from, copyconnections);

  // [\&.\&.then copy internal data\&.\&.]
}
.fi
.PP
 
.PP
Reimplemented in \fBSoNode\fP, \fBSoWWWInline\fP, \fBSoBaseKit\fP, \fBSoVRMLSwitch\fP, \fBSoVRMLLOD\fP, \fBSoInteractionKit\fP, \fBSoNodeKitListPart\fP, \fBSoVRMLParent\fP, \fBSoGroup\fP, \fBSoClipPlaneManip\fP, \fBSoDirectionalLightManip\fP, \fBSoVRMLShape\fP, \fBSoSpotLightManip\fP, \fBSoTransformManip\fP, \fBSoPointLightManip\fP, \fBSoVRMLScript\fP, \fBSoRotateSphericalDragger\fP, \fBSoRotateCylindricalDragger\fP, \fBSoFile\fP, \fBSoCallback\fP, \fBSoVertexAttribute\fP, \fBSoVRMLAppearance\fP, and \fBSoVRMLGeometry\fP\&.
.SS "\fBSoFieldContainer\fP * SoFieldContainer::copyThroughConnection (void) const\fC [virtual]\fP"
Return copy of this instance\&.
.PP
Note: default implementation just returns \fCthis\fP pointer, \fBSoNode\fP and \fBSoEngine\fP overrides this method to return the pointer to the actual copy\&. 
.PP
Reimplemented in \fBSoNode\fP, and \fBSoEngine\fP\&.
.SS "void SoFieldContainer::initCopyDict (void)\fC [static]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP
.PP
Initialize a dictionary hash storing pointers for original fieldcontainer instances and their copies during scene graph copy operations\&.
.PP
This method is called from the start of \fBSoNode::copy()\fP\&. 
.SS "void SoFieldContainer::addCopy (const \fBSoFieldContainer\fP * orig, const \fBSoFieldContainer\fP * copy)\fC [static]\fP"
Add a pair of pointers to an original fieldcontainer and a copy of it to an internal pointer dictionary used during scene graph copy operations\&. 
.SS "\fBSoFieldContainer\fP * SoFieldContainer::checkCopy (const \fBSoFieldContainer\fP * orig)\fC [static]\fP"
Returns the copy of \fIorig\fP, if any\&. If no copy exists, we return a \fCNULL\fP pointer\&. 
.SS "\fBSoFieldContainer\fP * SoFieldContainer::findCopy (const \fBSoFieldContainer\fP * orig, const SbBool copyconnections)\fC [static]\fP"
Returns a copy of \fIorig\fP\&.
.PP
If no copy has been made earlier when the function is called, a copy is made on-the-fly (which is the reason we need to pass along the \fIcopyconnections\fP flag)\&.
.PP
This method will also run the \fBcopyContents()\fP method on the copy, if it hasn't been run already\&. Note that if you call \fBcopyContents()\fP on the copy outside of this method, this will go undetected and the guts of \fIorig\fP will be copied multiple times into its copy\&.
.PP
If \fBcopyContents()\fP is called directly (instead of using copy()), it's assumed that the user only wants to copy the field values, and we just return NULL here\&. This is done to match how it's done in SGI Inventor\&.
.PP
\fBSee also:\fP
.RS 4
\fBcheckCopy()\fP 
.RE
.PP

.SS "void SoFieldContainer::copyDone (void)\fC [static]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP
.PP
Clean up the dictionary hash\&.
.PP
This method is called from the end of \fBSoNode::copy()\fP\&. 
.SS "void SoFieldContainer::getFieldsMemorySize (size_t & managed, size_t & unmanaged) const\fC [virtual]\fP"
Returns the data array sizes of the SoFieldData-registered multi-fields\&. The \fImanaged\fP argument returns the size of the fields that Coin manages the memory for, and the \fIunmanaged\fP argument returns the size of the data in the multi-fields controlled by the application through SoMField::setValuesPointer() which Coin will not delete\&.
.PP
Data that is kept in the object memory chunk (that is included when you do sizeof(object)) is not included in these values - only the memory that is managed in addtional memory chunks from the object chunk is returned\&.
.PP
Extension field types that are not known to the plain Coin library are not accounted for\&. This function is therefore virtual, so such extension field types can be added to the numbers for extension nodes\&.
.PP
This method is used for memory profiling purposes\&.
.PP
\fBSince:\fP
.RS 4
Coin 3\&.0 
.RE
.PP

.SS "void SoFieldContainer::setUserData (void * userdata) const"
Set a generic user data pointer for this field container\&.
.PP
This function can be used by the application programmer to, for instance, store a pointer to an application specific data structure that is in some way related to the field container\&. \fBgetUserData()\fP can later be used to retrieve the pointer\&.
.PP
\fBSee also:\fP
.RS 4
\fBgetUserData()\fP 
.RE
.PP
\fBSince:\fP
.RS 4
Coin 2\&.0 
.RE
.PP

.SS "void * SoFieldContainer::getUserData (void) const"
Return the generic user data pointer for this field container, or NULL if no user data has been set\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetUserData()\fP 
.RE
.PP
\fBSince:\fP
.RS 4
Coin 2\&.0 
.RE
.PP

.SS "SbBool SoFieldContainer::readInstance (\fBSoInput\fP * in, unsigned short flags)\fC [protected]\fP, \fC [virtual]\fP"
This method is mainly intended for internal use during file import operations\&.
.PP
It reads a definition of an instance from the input stream \fIin\fP\&. The input stream state points to the start of a serialized / persistant representation of an instance of this class type\&.
.PP
\fCTRUE\fP or \fCFALSE\fP is returned, depending on if the instantiation and configuration of the new object of this class type went ok or not\&. The import process should be robust and handle corrupted input streams by returning \fCFALSE\fP\&.
.PP
\fIflags\fP is used internally during binary import when reading user extension nodes, group nodes or engines\&. 
.PP
Implements \fBSoBase\fP\&.
.PP
Reimplemented in \fBSoNode\fP, \fBSoBaseKit\fP, \fBSoWWWInline\fP, \fBSoVRMLSwitch\fP, \fBSoVRMLLOD\fP, \fBSoInteractionKit\fP, \fBSoTextureCubeMap\fP, \fBSoNodeKitListPart\fP, \fBSoSeparator\fP, \fBSoTexture2\fP, \fBSoImage\fP, \fBSoVRMLParent\fP, \fBSoTexture3\fP, \fBSoShaderObject\fP, \fBSoGroup\fP, \fBSoProto\fP, \fBSoFile\fP, \fBSoVRMLImageTexture\fP, \fBSoNormalBinding\fP, \fBSoEngine\fP, \fBSoProtoInstance\fP, \fBSoBumpMap\fP, \fBSoVertexAttribute\fP, \fBSoTextureCoordinateBinding\fP, \fBSoVRMLBackground\fP, \fBSoNodeEngine\fP, and \fBSoVRMLPixelTexture\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "SbBool SoFieldContainer::isBuiltIn\fC [protected]\fP"
Flag for storing whether or not this class instance is a built-in class or not\&. By knowing the difference between a class which is native Coin or a user extension, it is possible to automatically store and read extension nodes and engines\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
