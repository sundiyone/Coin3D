.TH "SbString" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SbString \- The \fBSbString\fP class is a string class with convenience functions for string operations\&.
.PP
This is the class used for storing and working with character strings\&. It automatically takes care of supporting all the 'bookkeeping' tasks usually associated with working with character strings, like memory allocation and deallocation etc\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Inventor/SbString\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSbString\fP (void)"
.br
.ti -1c
.RI "\fBSbString\fP (const char *s)"
.br
.ti -1c
.RI "\fBSbString\fP (const wchar_t *s)"
.br
.ti -1c
.RI "\fBSbString\fP (const char *s, \fBint\fP start, \fBint\fP end)"
.br
.ti -1c
.RI "\fBSbString\fP (const \fBSbString\fP &s)"
.br
.ti -1c
.RI "\fBSbString\fP (const \fBint\fP digits)"
.br
.ti -1c
.RI "\fB~SbString\fP ()"
.br
.ti -1c
.RI "uint32_t \fBhash\fP (void) const"
.br
.ti -1c
.RI "\fBint\fP \fBgetLength\fP (void) const"
.br
.ti -1c
.RI "void \fBmakeEmpty\fP (SbBool freeold=TRUE)"
.br
.ti -1c
.RI "const char * \fBgetString\fP (void) const"
.br
.ti -1c
.RI "\fBSbString\fP \fBgetSubString\fP (\fBint\fP startidx, \fBint\fP endidx=\-1) const"
.br
.ti -1c
.RI "void \fBdeleteSubString\fP (\fBint\fP startidx, \fBint\fP endidx=\-1)"
.br
.ti -1c
.RI "void \fBaddIntString\fP (const \fBint\fP value)"
.br
.ti -1c
.RI "char \fBoperator[]\fP (\fBint\fP index) const"
.br
.ti -1c
.RI "\fBSbString\fP & \fBoperator=\fP (const char *s)"
.br
.ti -1c
.RI "\fBSbString\fP & \fBoperator=\fP (const \fBSbString\fP &s)"
.br
.ti -1c
.RI "\fBSbString\fP & \fBoperator+=\fP (const char *s)"
.br
.ti -1c
.RI "\fBSbString\fP & \fBoperator+=\fP (const \fBSbString\fP &s)"
.br
.ti -1c
.RI "\fBSbString\fP & \fBoperator+=\fP (const char c)"
.br
.ti -1c
.RI "\fBint\fP \fBoperator!\fP (void) const"
.br
.ti -1c
.RI "\fBint\fP \fBcompareSubString\fP (const char *text, \fBint\fP offset=0) const"
.br
.ti -1c
.RI "\fBSbString\fP & \fBsprintf\fP (const char *formatstr,\&.\&.\&.)"
.br
.ti -1c
.RI "\fBSbString\fP & \fBvsprintf\fP (const char *formatstr, va_list args)"
.br
.ti -1c
.RI "void \fBapply\fP (char(*func)(char input))"
.br
.ti -1c
.RI "\fBint\fP \fBfind\fP (const \fBSbString\fP &s) const"
.br
.ti -1c
.RI "SbBool \fBfindAll\fP (const \fBSbString\fP &s, \fBSbIntList\fP &found) const"
.br
.ti -1c
.RI "\fBSbString\fP \fBlower\fP () const"
.br
.ti -1c
.RI "\fBSbString\fP \fBupper\fP () const"
.br
.ti -1c
.RI "void \fBprint\fP (std::FILE *fp) const"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static uint32_t \fBhash\fP (const char *s)"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "\fBint\fP \fBoperator==\fP (const \fBSbString\fP &sbstr, const char *s)"
.br
.ti -1c
.RI "\fBint\fP \fBoperator==\fP (const char *s, const \fBSbString\fP &sbstr)"
.br
.ti -1c
.RI "\fBint\fP \fBoperator==\fP (const \fBSbString\fP &str1, const \fBSbString\fP &str2)"
.br
.ti -1c
.RI "\fBint\fP \fBoperator!=\fP (const \fBSbString\fP &sbstr, const char *s)"
.br
.ti -1c
.RI "\fBint\fP \fBoperator!=\fP (const char *s, const \fBSbString\fP &sbstr)"
.br
.ti -1c
.RI "\fBint\fP \fBoperator!=\fP (const \fBSbString\fP &str1, const \fBSbString\fP &str2)"
.br
.ti -1c
.RI "\fBint\fP \fBoperator<\fP (const \fBSbString\fP &sbstr, const char *s)"
.br
.ti -1c
.RI "\fBint\fP \fBoperator<\fP (const char *s, const \fBSbString\fP &sbstr)"
.br
.ti -1c
.RI "\fBint\fP \fBoperator<\fP (const \fBSbString\fP &str1, const \fBSbString\fP &str2)"
.br
.ti -1c
.RI "\fBint\fP \fBoperator>\fP (const \fBSbString\fP &sbstr, const char *s)"
.br
.ti -1c
.RI "\fBint\fP \fBoperator>\fP (const char *s, const \fBSbString\fP &sbstr)"
.br
.ti -1c
.RI "\fBint\fP \fBoperator>\fP (const \fBSbString\fP &str1, const \fBSbString\fP &str2)"
.br
.ti -1c
.RI "const \fBSbString\fP \fBoperator+\fP (const \fBSbString\fP &str1, const \fBSbString\fP &str2)"
.br
.ti -1c
.RI "const \fBSbString\fP \fBoperator+\fP (const \fBSbString\fP &sbstr, const char *s)"
.br
.ti -1c
.RI "const \fBSbString\fP \fBoperator+\fP (const char *s, const \fBSbString\fP &sbstr)"
.br
.in -1c
.SH "Detailed Description"
.PP 
The \fBSbString\fP class is a string class with convenience functions for string operations\&.
.PP
This is the class used for storing and working with character strings\&. It automatically takes care of supporting all the 'bookkeeping' tasks usually associated with working with character strings, like memory allocation and deallocation etc\&. 

This class should also be well suited for use by the application programmer throughout the application using the Coin library\&.
.PP
\fBSee also:\fP
.RS 4
\fBSbName\fP 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "SbString::SbString (void)\fC [inline]\fP"
This is the default constructor\&. It initializes the string to be empty\&. 
.SS "SbString::SbString (const char * str)\fC [inline]\fP"
This constructor assigns from the given string\&. 
.SS "SbString::SbString (const wchar_t * str)\fC [inline]\fP"
This constructor converts the given string to UTF-8 and assigns it\&. 
.SS "SbString::SbString (const char * str, \fBint\fP start, \fBint\fP end)\fC [inline]\fP"
This constructor constructs a string from the given substring from \fIstart\fP to \fIend\fP indices inclusive\&. If \fIend\fP is -1, the substring from \fIstart\fP until the end of the string is used\&. 
.SS "SbString::SbString (const \fBSbString\fP & str)\fC [inline]\fP"
This is the copy constructor\&. 
.SS "SbString::SbString (const \fBint\fP digits)\fC [inline]\fP"
Construct an \fBSbString\fP instance containing the \fIdigits\fP of the integer argument\&. 
.SS "SbString::~SbString ()\fC [inline]\fP"
The destructor\&. Deallocates any internal resources used during the lifetime of the \fBSbString\fP instance\&. 
.SH "Member Function Documentation"
.PP 
.SS "uint32_t SbString::hash (void) const\fC [inline]\fP"
This method returns a reasonable hash value for the current string\&.
.PP
\fBSee also:\fP
.RS 4
uint32_t \fBSbString::hash(const char * s)\fP 
.RE
.PP

.SS "uint32_t SbString::hash (const char * s)\fC [inline]\fP, \fC [static]\fP"
This static method returns a hash value for the given string\&. 
.SS "\fBint\fP SbString::getLength (void) const\fC [inline]\fP"
This method returns the length of the string\&. 
.SS "void SbString::makeEmpty (SbBool freeold = \fCTRUE\fP)\fC [inline]\fP"
This method clears the string, making it an empty string ('')\&. If \fIfreeold\fP is \fCTRUE\fP (which is the default), the memory used by the old string is freed\&. Otherwise, memory will be kept and reused when the string is manipulated later\&. 
.SS "const char * SbString::getString (void) const\fC [inline]\fP"
This method returns the pointer to the string (character array)\&. 
.SS "\fBSbString\fP SbString::getSubString (\fBint\fP startidx, \fBint\fP endidx = \fC\-1\fP) const\fC [inline]\fP"
This method returns a new string which contains a substring defined by the given indices \fIstartidx\fP and \fIendidx\fP (inclusive)\&.
.PP
If \fIendidx\fP is -1, the substring from \fIstartidx\fP to the end of the string is used\&.
.PP
This will return a string which is (\fIendidx\fP - \fIstartidx\fP + 1) characters long, i\&.e\&. if this string is 'foo/bar' and we call by SbString::getSubString(0, 3), the returned string will be 'foo/'\&. 
.SS "void SbString::deleteSubString (\fBint\fP startidx, \fBint\fP endidx = \fC\-1\fP)\fC [inline]\fP"
This method deletes the substring defined by \fIstartidx\fP and \fIendidx\fP (inclusive)\&. If \fIendidx\fP is -1, the substring from \fIstartidx\fP to the end of the string is deleted\&. 
.SS "void SbString::addIntString (const \fBint\fP value)\fC [inline]\fP"
Constructs a string from the given integer (e\&.g\&. intToString(42) creates the string '42'), and adds this to the contents of the string\&. 
.SS "char SbString::operator[] (\fBint\fP index) const\fC [inline]\fP"
Returns character at position \fIindex\fP in the string\&.
.PP
\fBSee also:\fP
.RS 4
\fBgetSubString()\fP 
.RE
.PP

.SS "\fBSbString\fP & SbString::operator= (const char * str)\fC [inline]\fP"
This is the assignment operator\&. 
.SS "\fBSbString\fP & SbString::operator= (const \fBSbString\fP & str)\fC [inline]\fP"
Assign from the given string\&. 
.SS "\fBSbString\fP & SbString::operator+= (const char * str)\fC [inline]\fP"
Concatenate the given string to the end of the current one\&. 
.SS "\fBSbString\fP & SbString::operator+= (const \fBSbString\fP & str)\fC [inline]\fP"
Concatenate the given string to the end of the current one\&. 
.SS "\fBSbString\fP & SbString::operator+= (const char c)\fC [inline]\fP"
Concatenate the given character to the end of the current string\&.
.PP
\fBNote:\fP
.RS 4
This member function is not compatible with OpenInventor\&. 
.RE
.PP

.SS "\fBint\fP SbString::operator! (void) const\fC [inline]\fP"
This unary operator results in \fCTRUE\fP if the current string is empty ('') or \fCFALSE\fP otherwise\&. 
.SS "\fBint\fP SbString::compareSubString (const char * text, \fBint\fP offset = \fC0\fP) const\fC [inline]\fP"
Uses \fItext\fP as a substring to be compared to the string, starting at offset \fIoffset\fP\&. Return value is 0 upon success, and the failing character comparison difference upon failure\&. 
.SS "\fBSbString\fP & SbString::sprintf (const char * formatstr,  \&.\&.\&.)\fC [inline]\fP"
Set \fBSbString\fP instance to the formatted string \fIformatstr\fP, replacing the current contents\&. The control characters within \fIformatstr\fP and the remaining arguments should follow the conventions of the printf() call\&.
.PP
Note that this function is not part of the original Open Inventor API\&. 
.SS "\fBSbString\fP & SbString::vsprintf (const char * formatstr, va_list args)\fC [inline]\fP"
Set \fBSbString\fP instance to the formatted string \fIformatstr\fP, replacing the current contents\&. The control characters within \fIformatstr\fP and the arguments of the \fIargs\fP argument list should follow the conventions of the printf() call\&.
.PP
Note that this function is not part of the original Open Inventor API\&. 
.SS "\fBint\fP SbString::find (const \fBSbString\fP & strarg) const"
If \fIs\fP is found, the method returns the first index where \fIs\fP starts\&. Otherwise it returns -1\&.
.PP
Note: \fBSbString::find()\fP is a Coin specific extension to the original Open Inventor API\&.
.PP
\fBSee also:\fP
.RS 4
\fBSbString::findAll()\fP 
.RE
.PP
\fBSince:\fP
.RS 4
Coin 2\&.0 
.RE
.PP

.SS "SbBool SbString::findAll (const \fBSbString\fP & strarg, \fBSbIntList\fP & found) const"
All occurences of \fIstr\fP is represented in \fIfound\fP as indices to the characters where \fIstr\fP starts\&. If 1 or more is found, \fCTRUE\fP is returned, else \fCFALSE\fP is returned\&.
.PP
Note: \fBSbString::findAll()\fP is an extension to the original Open Inventor API\&.
.PP
\fBSee also:\fP
.RS 4
\fBSbString::find()\fP 
.RE
.PP
\fBSince:\fP
.RS 4
Coin 2\&.0 
.RE
.PP

.SS "\fBSbString\fP SbString::lower () const"
Converts all of the characters to lowercase using tolower()\&.
.PP
\fBSince:\fP
.RS 4
Coin 3\&.1 
.RE
.PP

.SS "\fBSbString\fP SbString::upper () const"
Converts all of the characters to uppercase using toupper()\&.
.PP
\fBSince:\fP
.RS 4
Coin 3\&.1 
.RE
.PP

.SS "void SbString::print (std::FILE * fp) const"
Dump the state of this object to the \fIfile\fP stream\&. Only works in debug version of library, method does nothing in an optimized compile\&. 
.SH "Friends And Related Function Documentation"
.PP 
.SS "\fBint\fP operator== (const \fBSbString\fP & str, const char * s)\fC [friend]\fP"
Equality operator\&. Check if the strings have the same contents\&. 
.SS "\fBint\fP operator== (const char * s, const \fBSbString\fP & str)\fC [friend]\fP"
Equality operator\&. Check if the strings have the same contents\&. 
.SS "\fBint\fP operator== (const \fBSbString\fP & str1, const \fBSbString\fP & str2)\fC [friend]\fP"
Equality operator\&. Check if the strings have the same contents\&. 
.SS "\fBint\fP \fBoperator!\fP= (const \fBSbString\fP & str, const char * s)\fC [friend]\fP"
Inequality operator\&. 
.SS "\fBint\fP \fBoperator!\fP= (const char * s, const \fBSbString\fP & str)\fC [friend]\fP"
Inequality operator\&. 
.SS "\fBint\fP \fBoperator!\fP= (const \fBSbString\fP & str1, const \fBSbString\fP & str2)\fC [friend]\fP"
Inequality operator\&. 
.SS "\fBint\fP operator< (const \fBSbString\fP & str, const char * s)\fC [friend]\fP"
Less than operator\&. Results in \fCTRUE\fP if the first character that does not match has a lower value in \fIstr\fP than in \fIs\fP\&. 
.SS "\fBint\fP operator< (const char * s, const \fBSbString\fP & str)\fC [friend]\fP"
Less than operator\&. Results in \fCTRUE\fP if the first character that does not match has a lower value in \fIs\fP than in \fIstr\fP\&. 
.SS "\fBint\fP operator< (const \fBSbString\fP & str1, const \fBSbString\fP & str2)\fC [friend]\fP"
Less than operator\&. Results in \fCTRUE\fP if the first character that does not match has a lower value in \fIstr1\fP than in \fIstr2\fP\&. 
.SS "\fBint\fP operator> (const \fBSbString\fP & str, const char * s)\fC [friend]\fP"
Greater than operator\&. Results in \fCTRUE\fP if the first character that does not match has a higher value in \fIstr\fP than in \fIs\fP\&. 
.SS "\fBint\fP operator> (const char * s, const \fBSbString\fP & str)\fC [friend]\fP"
Greater than operator\&. Results in \fCTRUE\fP if the first character that does not match has a higher value in \fIs\fP than in \fIstr\fP\&. 
.SS "\fBint\fP operator> (const \fBSbString\fP & str1, const \fBSbString\fP & str2)\fC [friend]\fP"
Greater than operator\&. Results in \fCTRUE\fP if the first character that does not match has a higher value in \fIstr1\fP than in \fIstr2\fP\&. 
.SS "const \fBSbString\fP operator+ (const \fBSbString\fP & str1, const \fBSbString\fP & str2)\fC [friend]\fP"
Addition operator\&. 
.SS "const \fBSbString\fP operator+ (const \fBSbString\fP & sbstr, const char * s)\fC [friend]\fP"
Addition operator\&. 
.SS "const \fBSbString\fP operator+ (const char * s, const \fBSbString\fP & sbstr)\fC [friend]\fP"
Addition operator\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
