.TH "SoBaseKit" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SoBaseKit \- The \fBSoBaseKit\fP class is the toplevel superclass for nodekits\&.
.PP
Node kits are collections of nodes and other node kits (from here on node kits which are part of some other node kit, will only be referred to as nodes or parts, see catalogs and parts), organized in a way that is convenient for its use\&. A node kit inherits \fBSoNode\fP and can thus be inserted into a scenegraph as any other node\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Inventor/nodekits/SoBaseKit\&.h>\fP
.PP
Inherits \fBSoNode\fP\&.
.PP
Inherited by \fBSoAppearanceKit\fP, \fBSoCameraKit\fP, \fBSoForeignFileKit\fP, \fBSoInteractionKit\fP, \fBSoLightKit\fP, \fBSoNodeVisualize\fP, \fBSoProfilerOverlayKit\fP, \fBSoProfilerVisualizeKit\fP, \fBSoSceneKit\fP, \fBSoScrollingGraphKit\fP, and \fBSoSeparatorKit\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fBSoType\fP \fBgetTypeId\fP (void) const"
.br
.RI "Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. "
.ti -1c
.RI "\fBSoBaseKit\fP (void)"
.br
.ti -1c
.RI "virtual const \fBSoNodekitCatalog\fP * \fBgetNodekitCatalog\fP (void) const"
.br
.ti -1c
.RI "virtual \fBSoNode\fP * \fBgetPart\fP (const \fBSbName\fP &partname, SbBool makeifneeded)"
.br
.ti -1c
.RI "\fBSbString\fP \fBgetPartString\fP (const \fBSoBase\fP *part)"
.br
.ti -1c
.RI "virtual \fBSoNodeKitPath\fP * \fBcreatePathToPart\fP (const \fBSbName\fP &partname, SbBool makeifneeded, const \fBSoPath\fP *pathtoextend=NULL)"
.br
.ti -1c
.RI "virtual SbBool \fBsetPart\fP (const \fBSbName\fP &partname, \fBSoNode\fP *from)"
.br
.ti -1c
.RI "SbBool \fBset\fP (const char *namevaluepairliststring)"
.br
.ti -1c
.RI "SbBool \fBset\fP (const char *partnamestring, const char *parameterstring)"
.br
.ti -1c
.RI "virtual void \fBdoAction\fP (\fBSoAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBcallback\fP (\fBSoCallbackAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBGLRender\fP (\fBSoGLRenderAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBgetBoundingBox\fP (\fBSoGetBoundingBoxAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBgetMatrix\fP (\fBSoGetMatrixAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBhandleEvent\fP (\fBSoHandleEventAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBrayPick\fP (\fBSoRayPickAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBsearch\fP (\fBSoSearchAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBwrite\fP (\fBSoWriteAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBgetPrimitiveCount\fP (\fBSoGetPrimitiveCountAction\fP *action)"
.br
.ti -1c
.RI "virtual \fBSoChildList\fP * \fBgetChildren\fP (void) const"
.br
.ti -1c
.RI "void \fBprintDiagram\fP (void)"
.br
.ti -1c
.RI "void \fBprintSubDiagram\fP (const \fBSbName\fP &rootname, \fBint\fP level)"
.br
.ti -1c
.RI "void \fBprintTable\fP (void)"
.br
.ti -1c
.RI "virtual void \fBaddWriteReference\fP (\fBSoOutput\fP *out, SbBool isfromfield=FALSE)"
.br
.ti -1c
.RI "SbBool \fBforceChildDrivenWriteRefs\fP (\fBSoOutput\fP *out)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBSoType\fP \fBgetClassTypeId\fP (void)"
.br
.ti -1c
.RI "static void \fBinitClass\fP (void)"
.br
.ti -1c
.RI "static const \fBSoNodekitCatalog\fP * \fBgetClassNodekitCatalog\fP (void)"
.br
.ti -1c
.RI "static SbBool \fBisSearchingChildren\fP (void)"
.br
.ti -1c
.RI "static void \fBsetSearchingChildren\fP (const SbBool newval)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual const \fBSoFieldData\fP * \fBgetFieldData\fP (void) const"
.br
.ti -1c
.RI "virtual \fB~SoBaseKit\fP ()"
.br
.ti -1c
.RI "virtual \fBSoNode\fP * \fBaddToCopyDict\fP (void) const"
.br
.ti -1c
.RI "virtual void \fBcopyContents\fP (const \fBSoFieldContainer\fP *fromfc, SbBool copyconnections)"
.br
.ti -1c
.RI "\fBSoGroup\fP * \fBgetContainerNode\fP (const \fBSbName\fP &listname, SbBool makeifneeded=TRUE)"
.br
.ti -1c
.RI "virtual \fBSoNode\fP * \fBgetAnyPart\fP (const \fBSbName\fP &partname, SbBool makeifneeded, SbBool leafcheck=FALSE, SbBool publiccheck=FALSE)"
.br
.ti -1c
.RI "virtual \fBSoNodeKitPath\fP * \fBcreatePathToAnyPart\fP (const \fBSbName\fP &partname, SbBool makeifneeded, SbBool leafcheck=FALSE, SbBool publiccheck=FALSE, const \fBSoPath\fP *pathtoextend=NULL)"
.br
.ti -1c
.RI "virtual SbBool \fBsetAnyPart\fP (const \fBSbName\fP &partname, \fBSoNode\fP *from, SbBool anypart=TRUE)"
.br
.ti -1c
.RI "void \fBcreateNodekitPartsList\fP (void)"
.br
.ti -1c
.RI "void \fBcreateFieldList\fP (void)"
.br
.ti -1c
.RI "virtual void \fBcreateDefaultParts\fP (void)"
.br
.ti -1c
.RI "const SoNodekitParts * \fBgetNodekitPartsList\fP (void) const"
.br
.ti -1c
.RI "const \fBSbList\fP< \fBSoSFNode\fP * > & \fBgetCatalogInstances\fP (void) const"
.br
.ti -1c
.RI "void \fBcatalogError\fP (void)"
.br
.ti -1c
.RI "virtual SbBool \fBsetUpConnections\fP (SbBool onoff, SbBool doitalways=FALSE)"
.br
.ti -1c
.RI "virtual SbBool \fBreadInstance\fP (\fBSoInput\fP *in, unsigned short flags)"
.br
.ti -1c
.RI "virtual void \fBsetDefaultOnNonWritingFields\fP (void)"
.br
.ti -1c
.RI "void \fBcountMyFields\fP (\fBSoOutput\fP *out)"
.br
.ti -1c
.RI "virtual SbBool \fBsetPart\fP (const \fBint\fP partNum, \fBSoNode\fP *node)"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static const \fBSoFieldData\fP ** \fBgetFieldDataPtr\fP (void)"
.br
.ti -1c
.RI "static const \fBSoNodekitCatalog\fP ** \fBgetClassNodekitCatalogPtr\fP (void)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBSoSFNode\fP \fBcallbackList\fP"
.br
.ti -1c
.RI "\fBSoChildList\fP * \fBchildren\fP"
.br
.ti -1c
.RI "SbBool \fBconnectionsSetUp\fP"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
The \fBSoBaseKit\fP class is the toplevel superclass for nodekits\&.
.PP
Node kits are collections of nodes and other node kits (from here on node kits which are part of some other node kit, will only be referred to as nodes or parts, see catalogs and parts), organized in a way that is convenient for its use\&. A node kit inherits \fBSoNode\fP and can thus be inserted into a scenegraph as any other node\&. 

The organizing of the nodes and node kits of some node kit, is done through catalogs\&. A node kit's catalog describes the nodes that can be members of the node kit\&. These members are called parts\&. Thus a node kit has a catalog describing the parts that it offers to the user\&.
.PP
Each part in the catalog has some values saying something about the part itself and about the role the part plays in the scenegraph\&. Those values are:
.PP
.IP "\fBName \fP" 1c
The name of the part\&. 
.IP "\fBType \fP" 1c
The part's node type\&. 
.IP "\fBDefault Type \fP" 1c
If the part's type is an abstract superclass, this value will hold the default subclass used by this part\&. 
.IP "\fBCreated by Default? \fP" 1c
Holds \fCTRUE\fP if the part should be instantiated when the node kit is instantiated, otherwise the part is kept empty until it is set by some of the means applicable\&. 
.IP "\fBParent Name \fP" 1c
The name of the part that is this part's parent\&. 
.IP "\fBRight Sibling \fP" 1c
The name of the part that is the part immediately to the right of this part in the node kit scenegraph\&. 
.IP "\fBIs it a List? \fP" 1c
Holds \fCTRUE\fP if the part is a list, otherwise it is \fCFALSE\fP\&. See \fBSoNodeKitListPart\fP for more info on node kit lists\&. 
.IP "\fBList Cointainer Type \fP" 1c
The type of group node used to hold the items if the part is a list\&. 
.IP "\fBList Element Type \fP" 1c
The types of nodes that is allowed to be held by this part if the part is a list\&. 
.IP "\fBIs It Public? \fP" 1c
Holds \fCTRUE\fP if the part should be publically available, otherwise it holds \fCFALSE\fP\&. 
.PP
.PP
Node kits use lazy instantiation when it creates it's parts\&. This means that the nodes making up the parts of the nodekit only are created when they are needed\&. If the 'Created by Default?' holds TRUE, then the part is created when the node kit itself is instantiated\&. If not, parts are created when they are requested through \fBSoBaseKit::getPart()\fP or the SO_GET_PART() macro, or created with \fBSoBaseKit::set()\fP\&. Also, if a part is set with \fBSoBaseKit::setPart()\fP or the SO_SET_PART() macro, any previously uncreated parts above the set part in the hierarchy, is created automatically\&.
.PP
The advantages of using node kits to represent a scenegraph are many\&. 
.PD 0

.IP "\(bu" 2
Since a node kit collects nodes into a single unit, it becomes an extra abstraction layer for the application programmer\&. Such a layer can represent a model of a human being as one unit where subunits as arms, legs, textures, etc are contained within\&. Thus we can instantiate a model of a human by creating an instance of the node kit, instead of having to create a possibly large amount of nodes needed for such a model\&. 
.IP "\(bu" 2
A part of the node kit doesn't have one specific setup\&. A shape part can e\&.g\&. be swapped with any other shape, since they are of the same type\&. If the node kit of a human has a part called 'head' which is of type \fBSoShape\fP, it might default to a sphere\&. But if the programmer thinks that a cube might fit better, one can set the 'head' part to a cube instead, or maybe a face set representing a complex model of a head\&. 
.IP "\(bu" 2
Node kits can have as simple or as complex catalogs as needed\&. The nodes included in the node kit can, if needed, represent the whole range of Inventor features\&. One part can as easily be of a node kit type, making it possible to create hierarchies of node kits\&. Having a node kit of a human, it might be feasible to have sub node kits describing the different body parts\&. 
.IP "\(bu" 2
Node kits are an efficient way of creating scenegraphs\&. If some part of it isn't needed at the moment of node kit instantiation, they aren't created\&. Thus parts are only created when needed, either by the application or some other part\&. 
.IP "\(bu" 2
The application code becomes smaller and easier to read, as the node kits provides simple routines for creating and setting parts\&. 
.IP "\(bu" 2
New node kits can be created through subclassing to obtain simple setups of scenegraphs best fitted to the application\&.
.PP
The usage of a node kit is straightforward\&. Below follows a code example showing some simple \fBSoShapeKit\fP usage\&.
.PP
.PP
.nf
#include <Inventor/Qt/SoQt\&.h>
#include <Inventor/Qt/viewers/SoQtExaminerViewer\&.h>
#include <Inventor/nodekits/SoShapeKit\&.h>
#include <Inventor/nodes/SoSeparator\&.h>
#include <Inventor/nodes/SoCube\&.h>

int
main(int argc, char ** argv)
{
  QWidget * window = SoQt::init(argv[0]);

  SoQtExaminerViewer * viewer = new SoQtExaminerViewer(window);

  // Instantiating a shape kit, by default creating a simple sphere\&.
  SoShapeKit * shapekit = new SoShapeKit;
  // Swapping the sphere with a cube\&.
  shapekit->setPart("shape", new SoCube);
  // Setting the cube to be rendered in the color red\&. The shape kit
  // has a SoAppearanceKit as one of it's parts\&. The "material" part
  // used to set the color of the shape, really belongs the
  // appearance kit\&. If the SoShapeKit::set() is used, it will
  // check if some of its sub kits has a part with the name given,
  // and delegate the setting to the correct kit\&.
  shapekit->set("material", "diffuseColor 1 0 0");

  SoSeparator * newroot = new SoSeparator;
  newroot->ref();

  newroot->addChild(shapekit);

  viewer->setSceneGraph(newroot);

  viewer->show();
  SoQt::show(window);

  SoQt::mainLoop();
  delete viewer;

  newroot->unref();
  return 0;
}
.fi
.PP
.PP
The above code snippet will produce a viewer with a side view to the scene shown below:
.PP
 Rendering of Example Scenegraph
.PP
Notice that the code needed for creating this simple shape using a shape kit, amounts to this:
.PP
.PP
.nf
SoShapeKit * shapekit = new SoShapeKit;

shapekit->setPart("shape", new SoCube);
shapekit->set("material", "diffuseColor 1 0 0");
.fi
.PP
.PP
\&.\&.while doing it without shape kits amounts to this:
.PP
.PP
.nf
SoSeparator * root = new SoSeparator;
SoMaterial * material = new SoMaterial;
material->diffuseColor\&.setValue(1,0,0);
root->addChild(material);
root->addChild(new SoCube);
.fi
.PP
.PP
\&.\&.so even for this miniscule mock-up example, you save on code verbosity and complexity\&.
.PP
For extending the Coin library with your own classes, we strongly recommend that you make yourself acquainted with the excellent «The Inventor Toolmaker» book (ISBN 0-201-62493-1), which describes the tasks involved in detail\&. This book was written by the original SGI Inventor designers and explains many of the underlying design ideas, aswell as having lots of hands-on examples on how to extend the Coin toolkit in ways that are true to the fundamental design ideas\&. («The Inventor Toolmaker» is also available at SGI's online library, at no cost\&. See \fCDownload The Inventor Toolmaker\fP\&.) Reading the sourcecode of the built-in classes in Coin should also provide very helpful\&.
.PP
Following is a complete example of a node kit extension\&. The node kit is a kit which automatically scales a shape so it will be the same size in screen-pixels, no matter which distance it is from the camera\&. This is useful for marker graphics\&. The shape defaults to a cube, but can be set by the programmer to any shape or scene sub-graph\&.
.PP
The header file:
.PP
.PP
.nf
// Copyright (C) Kongsberg Oil & Gas Technologies\&. All rights reserved\&.

#ifndef COIN_SHAPESCALE_H
#define COIN_SHAPESCALE_H
#include <Inventor/nodekits/SoSubKit\&.h>
#include <Inventor/nodekits/SoBaseKit\&.h>
#include <Inventor/fields/SoSFFloat\&.h>

class SbViewport;
class SoState;
class SbColor;
class SbVec2s;

class ShapeScale : public SoBaseKit {
  typedef SoBaseKit inherited;

  SO_KIT_HEADER(ShapeScale);

  SO_KIT_CATALOG_ENTRY_HEADER(topSeparator);
  SO_KIT_CATALOG_ENTRY_HEADER(scale);
  SO_KIT_CATALOG_ENTRY_HEADER(shape);

 public:
  ShapeScale(void);
  static void initClass(void);

  SoSFFloat active;
  SoSFFloat projectedSize;

 protected:
  virtual void GLRender(SoGLRenderAction * action);
  virtual ~ShapeScale();
};

#endif // ! SHAPESCALE_H
.fi
.PP
.PP
The source code for the example:
.PP
.PP
.nf
// Copyright (C) Kongsberg Oil & Gas Technologies\&. All rights reserved\&.

//  The ShapeScale class is used for scaling a shape based on
//  projected size\&.
//
//  This nodekit can be inserted in your scene graph to add for
//  instance 3D markers that will be of a constant projected size\&.
//
//  The marker shape is stored in the "shape" part\&. Any kind of node
//  can be used, even group nodes with several shapes, but the
//  marker shape should be approximately of unit size, and with a
//  center position in (0, 0, 0)\&.


//  SoSFFloat ShapeScale::active
//  Turns the scaling on/off\&. Default value is TRUE\&.


//  SoSFFloat ShapeScale::projectedSize
//  The requested projected size of the shape\&. Default value is 5\&.0\&.

#include "ShapeScale\&.h"

#include <Inventor/actions/SoGLRenderAction\&.h>
#include <Inventor/nodes/SoShape\&.h>
#include <Inventor/nodes/SoScale\&.h>
#include <Inventor/nodes/SoCube\&.h>
#include <Inventor/nodes/SoSeparator\&.h>
#include <Inventor/elements/SoViewVolumeElement\&.h>
#include <Inventor/elements/SoViewportRegionElement\&.h>
#include <Inventor/elements/SoModelMatrixElement\&.h>

SO_KIT_SOURCE(ShapeScale);


//  Constructor\&.
ShapeScale::ShapeScale(void)
{
  SO_KIT_CONSTRUCTOR(ShapeScale);

  SO_KIT_ADD_FIELD(active, (TRUE));
  SO_KIT_ADD_FIELD(projectedSize, (5\&.0f));

  SO_KIT_ADD_CATALOG_ENTRY(topSeparator, SoSeparator, FALSE, this, \x0, FALSE);
  SO_KIT_ADD_CATALOG_ABSTRACT_ENTRY(shape, SoNode, SoCube, TRUE, topSeparator, \x0, TRUE);
  SO_KIT_ADD_CATALOG_ENTRY(scale, SoScale, FALSE, topSeparator, shape, FALSE);

  SO_KIT_INIT_INSTANCE();
}


// Destructor\&.
ShapeScale::~ShapeScale()
{
}

// Initializes this class\&. Call before using it\&.

void
ShapeScale::initClass(void)
{
  SO_KIT_INIT_CLASS(ShapeScale, SoBaseKit, "BaseKit");
}

static void
update_scale(SoScale * scale, const SbVec3f & v)
{
  // only write to field when scaling has changed\&.
  if (scale->scaleFactor\&.getValue() != v) {
    scale->scaleFactor = v;
  }
}

// Overridden to (re)initialize scaling before rendering marker\&.
void
ShapeScale::GLRender(SoGLRenderAction * action)
{
  SoState * state = action->getState();

  SoScale * scale = (SoScale*) this->getAnyPart(SbName("scale"), TRUE);
  if (!this->active\&.getValue()) {
    update_scale(scale, SbVec3f(1\&.0f, 1\&.0f, 1\&.0f));
  }
  else {
    const SbViewportRegion & vp = SoViewportRegionElement::get(state);
    const SbViewVolume & vv = SoViewVolumeElement::get(state);
    SbVec3f center(0\&.0f, 0\&.0f, 0\&.0f);
    float nsize = this->projectedSize\&.getValue() / float(vp\&.getViewportSizePixels()[1]);
    SoModelMatrixElement::get(state)\&.multVecMatrix(center, center); // transform to WCS
    float scalefactor = vv\&.getWorldToScreenScale(center, nsize);
    update_scale(scale, SbVec3f(scalefactor, scalefactor, scalefactor));
  }
  inherited::GLRender(action);
}
.fi
.PP
.PP
And a complete example showing how one can use this node kit:
.PP
.PP
.nf
// Copyright (C) Kongsberg Oil & Gas Technologies\&. All rights reserved\&.

#include <Inventor/Qt/SoQt\&.h>
#include <Inventor/Qt/viewers/SoQtExaminerViewer\&.h>
#include <Inventor/SoInput\&.h>
#include <Inventor/SoOutput\&.h>
#include <Inventor/SoPickedPoint\&.h>
#include <Inventor/actions/SoRayPickAction\&.h>
#include <Inventor/events/SoMouseButtonEvent\&.h>
#include <Inventor/nodes/SoBaseColor\&.h>
#include <Inventor/nodes/SoCube\&.h>
#include <Inventor/nodes/SoEventCallback\&.h>
#include <Inventor/nodes/SoSeparator\&.h>
#include <Inventor/nodes/SoSwitch\&.h>
#include <Inventor/nodes/SoTranslation\&.h>
#include <assert\&.h>
#include <stdlib\&.h>
#include <time\&.h>

#include "ShapeScale\&.h"

// Returns random value between 0\&.0f and 1\&.0f\&.
static float
normalized_rand(void)
{
  return float(rand())/float(RAND_MAX);
}

static SoSeparator *
construct_new_marker(const SbVec3f & v)
{
  SoSeparator * markerroot = new SoSeparator;

  SoTranslation * t = new SoTranslation;
  t->translation = v;
  markerroot->addChild(t);

  ShapeScale * kit = new ShapeScale;
  kit->active = TRUE;
  kit->projectedSize = 5\&.0f;

  // create the marker
  SoSeparator * markersep = new SoSeparator;

  SoBaseColor * mat = new SoBaseColor;
  mat->rgb\&.setValue(normalized_rand(), normalized_rand(), normalized_rand());
  markersep->addChild(mat);

  // marker shape should be unit size, with center in (0\&.0f, 0\&.0f, 0\&.0f)
  SoCube * cube = new SoCube;
  cube->width = 1\&.0f;
  cube->height = 1\&.0f;
  cube->depth = 1\&.0f;

  markersep->addChild(cube);
  kit->setPart("shape", markersep);
  markerroot->addChild(kit);

  return markerroot;
}

static void
event_cb(void * ud, SoEventCallback * n)
{
  const SoMouseButtonEvent * mbe = (SoMouseButtonEvent *)n->getEvent();

  if (mbe->getButton() == SoMouseButtonEvent::BUTTON1 &&
    mbe->getState() == SoButtonEvent::DOWN) {

    SoQtExaminerViewer * viewer = (SoQtExaminerViewer *)ud;

    SoRayPickAction rp(viewer->getViewportRegion());
    rp\&.setPoint(mbe->getPosition());
    rp\&.apply(viewer->getSceneManager()->getSceneGraph());

    SoPickedPoint * point = rp\&.getPickedPoint();
    if (point == NULL) {
      (void)fprintf(stderr, "\n** miss! **\n\n");
      return;
    }

    n->setHandled();

    const SoPath * p = rp\&.getCurPath();

    for (int i = 0; i < p->getLength(); i++) {
      SoNode * n = p->getNodeFromTail(i);
      if (n->isOfType(SoGroup::getClassTypeId())) {
        SoGroup * g = (SoGroup *)n;
        g->addChild(construct_new_marker(point->getPoint()));
        break;
      }
    }
  }
}

void
show_instructions(void)
{
  (void)fprintf(stdout,
    "\nThis example program demonstrates the use of the ShapeScale nodekit\&.\n"
    "\nQuick instructions:\n\n"
    "  * place the marker by clicking on a shape with the left mouse button\n"
    "  * hit ESC to toggle back and forth to view mode\n"
    "  * zoom back and forth to see how the markers stay the same size\n\n");
}

int
main(int argc, char ** argv)
{
  if (argc != 2) {
    (void) fprintf(stderr,"\nSpecify an Inventor file as argument\&.\n");
    return -1;
  }

  QWidget * window = SoQt::init(argv[0]);
  ShapeScale::initClass(); // init our extension nodekit

  SoQtExaminerViewer * ex1 = new SoQtExaminerViewer(window);

  SoInput input;
  SbBool ok = input\&.openFile(argv[1]);
  if (!ok) {
    (void) fprintf(stderr, "Unable to open file: %s\n", argv[1]);
    return -1;
  }

  SoSeparator * root = SoDB::readAll(&input);

  if (root == NULL) {
    (void) fprintf(stderr, "Unable to read file: %s\n", argv[1]);
    return -1;
  }

  show_instructions();

  SoSeparator * newroot = new SoSeparator;
  newroot->ref();

  newroot->addChild(root);

  // create event callback and marker nodes
  SoSeparator * sep = new SoSeparator;
  newroot->addChild(sep);

  SoEventCallback * ecb = new SoEventCallback;
  ecb->addEventCallback(SoMouseButtonEvent::getClassTypeId(), event_cb, ex1);
  sep->addChild(ecb);

  ex1->setSceneGraph(newroot);
  ex1->setTransparencyType(SoGLRenderAction::SORTED_OBJECT_BLEND);
  ex1->setViewing(FALSE);

  ex1->show();
  SoQt::show(window);

  SoQt::mainLoop();
  delete ex1;

  newroot->unref();
  return 0;
}
.fi
.PP
 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SoBaseKit::SoBaseKit (void)"
Constructor\&.
.PP
This is the top-level superclass of all node kit and dragger classes\&. The catalog structure of \fBSoBaseKit\fP is as follows:
.PP
.PP
.nf
CLASS SoBaseKit
-->"this"
-->   "callbackList"
.fi
.PP
.PP
(See \fBSoBaseKit::printDiagram()\fP for information about the output formatting\&.)
.PP
Detailed information on catalog parts:
.PP
.PP
.nf
CLASS SoBaseKit
PVT   "this",  SoBaseKit  ---
      "callbackList",  SoNodeKitListPart [ SoCallback, SoEventCallback ]
.fi
.PP
.PP
(See \fBSoBaseKit::printTable()\fP for information about the output formatting\&.)
.PP
As can be seen from the catalog, all node kits can have a callback node in front of all other nodes in the kit\&. This is handy for catching events that should go to application processing\&. 
.SS "SoBaseKit::~SoBaseKit ()\fC [protected]\fP, \fC [virtual]\fP"
Destructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBSoType\fP SoBaseKit::getTypeId (void) const\fC [virtual]\fP"

.PP
Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. Usage example:
.PP
.PP
.nf
void foo(SoNode * node)
{
  if (node->getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
.fi
.PP
.PP
For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in \fIall\fP subclasses\&. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance \fBInventor/nodes/SoSubNode\&.h\fP (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), \fBInventor/engines/SoSubEngine\&.h\fP (for engine classes) and so on\&.
.PP
For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups\&. 
.PP
Implements \fBSoBase\fP\&.
.PP
Reimplemented in \fBSoDragger\fP, \fBSoTrackballDragger\fP, \fBSoNodeVisualize\fP, \fBSoInteractionKit\fP, \fBSoSTLFileKit\fP, \fBSoScrollingGraphKit\fP, \fBSoTransformerDragger\fP, \fBSoSpotLightDragger\fP, \fBSoRotateSphericalDragger\fP, \fBSoScale2UniformDragger\fP, \fBSoTabPlaneDragger\fP, \fBSoTranslate1Dragger\fP, \fBSoTranslate2Dragger\fP, \fBSoHandleBoxDragger\fP, \fBSoScale2Dragger\fP, \fBSoRotateCylindricalDragger\fP, \fBSoScale1Dragger\fP, \fBSoScaleUniformDragger\fP, \fBSoDirectionalLightDragger\fP, \fBSoJackDragger\fP, \fBSoRotateDiscDragger\fP, \fBSoCenterballDragger\fP, \fBSoTransformBoxDragger\fP, \fBSoForeignFileKit\fP, \fBSoPointLightDragger\fP, \fBSoDragPointDragger\fP, \fBSoTabBoxDragger\fP, \fBSoProfilerTopKit\fP, \fBSoProfilerVisualizeKit\fP, \fBSoSeparatorKit\fP, \fBSoAppearanceKit\fP, \fBSoSceneKit\fP, \fBSoLightKit\fP, \fBSoCameraKit\fP, \fBSoShapeKit\fP, \fBSoWrapperKit\fP, and \fBSoProfilerOverlayKit\fP\&.
.SS "const \fBSoFieldData\fP * SoBaseKit::getFieldData (void) const\fC [protected]\fP, \fC [virtual]\fP"
Returns a pointer to the class-wide field data storage object for this instance\&. If no fields are present, returns \fCNULL\fP\&. 
.PP
Reimplemented from \fBSoFieldContainer\fP\&.
.PP
Reimplemented in \fBSoDragger\fP, \fBSoTrackballDragger\fP, \fBSoNodeVisualize\fP, \fBSoInteractionKit\fP, \fBSoSTLFileKit\fP, \fBSoScrollingGraphKit\fP, \fBSoTransformerDragger\fP, \fBSoSpotLightDragger\fP, \fBSoRotateSphericalDragger\fP, \fBSoScale2UniformDragger\fP, \fBSoTabPlaneDragger\fP, \fBSoTranslate1Dragger\fP, \fBSoTranslate2Dragger\fP, \fBSoHandleBoxDragger\fP, \fBSoScale2Dragger\fP, \fBSoRotateCylindricalDragger\fP, \fBSoScale1Dragger\fP, \fBSoScaleUniformDragger\fP, \fBSoDirectionalLightDragger\fP, \fBSoJackDragger\fP, \fBSoRotateDiscDragger\fP, \fBSoCenterballDragger\fP, \fBSoTransformBoxDragger\fP, \fBSoForeignFileKit\fP, \fBSoPointLightDragger\fP, \fBSoDragPointDragger\fP, \fBSoTabBoxDragger\fP, \fBSoProfilerTopKit\fP, \fBSoProfilerVisualizeKit\fP, \fBSoSeparatorKit\fP, \fBSoAppearanceKit\fP, \fBSoSceneKit\fP, \fBSoLightKit\fP, \fBSoCameraKit\fP, \fBSoShapeKit\fP, \fBSoWrapperKit\fP, and \fBSoProfilerOverlayKit\fP\&.
.SS "const \fBSoNodekitCatalog\fP * SoBaseKit::getClassNodekitCatalog (void)\fC [static]\fP"
Returns the nodekit catalog which defines the layout of this class' kit\&. 
.SS "const \fBSoNodekitCatalog\fP * SoBaseKit::getNodekitCatalog (void) const\fC [virtual]\fP"
Returns the nodekit catalog which defines the layout of this class' kit\&. 
.PP
Reimplemented in \fBSoDragger\fP, \fBSoTrackballDragger\fP, \fBSoNodeVisualize\fP, \fBSoInteractionKit\fP, \fBSoSTLFileKit\fP, \fBSoScrollingGraphKit\fP, \fBSoTransformerDragger\fP, \fBSoSpotLightDragger\fP, \fBSoRotateSphericalDragger\fP, \fBSoScale2UniformDragger\fP, \fBSoTabPlaneDragger\fP, \fBSoTranslate1Dragger\fP, \fBSoTranslate2Dragger\fP, \fBSoHandleBoxDragger\fP, \fBSoScale2Dragger\fP, \fBSoRotateCylindricalDragger\fP, \fBSoScale1Dragger\fP, \fBSoScaleUniformDragger\fP, \fBSoDirectionalLightDragger\fP, \fBSoJackDragger\fP, \fBSoRotateDiscDragger\fP, \fBSoCenterballDragger\fP, \fBSoTransformBoxDragger\fP, \fBSoForeignFileKit\fP, \fBSoPointLightDragger\fP, \fBSoDragPointDragger\fP, \fBSoTabBoxDragger\fP, \fBSoProfilerTopKit\fP, \fBSoProfilerVisualizeKit\fP, \fBSoSeparatorKit\fP, \fBSoAppearanceKit\fP, \fBSoSceneKit\fP, \fBSoLightKit\fP, \fBSoCameraKit\fP, \fBSoShapeKit\fP, \fBSoWrapperKit\fP, and \fBSoProfilerOverlayKit\fP\&.
.SS "\fBSoNode\fP * SoBaseKit::getPart (const \fBSbName\fP & partname, SbBool makeifneeded)\fC [virtual]\fP"
Returns a pointer to the node part with \fIpartname\fP\&.
.PP
This method calls \fBSoBaseKit::getAnyPart()\fP with \fIleafcheck\fP and \fIpubliccheck\fP both set to \fCTRUE\fP\&.
.PP
See the documentation of \fBSoBaseKit::getAnyPart()\fP for information on how to use \fIpartname\fP and \fImakeifneeded\fP, and what you can expect to get returned from this method\&. 
.SS "\fBSbString\fP SoBaseKit::getPartString (const \fBSoBase\fP * part)"
Returns the full path name to a catalog part, given the part's current item pointer\&. 
.SS "\fBSoNodeKitPath\fP * SoBaseKit::createPathToPart (const \fBSbName\fP & partname, SbBool makeifneeded, const \fBSoPath\fP * pathtoextend = \fCNULL\fP)\fC [virtual]\fP"
Calls \fBSoBaseKit::createPathToAnyPart()\fP with \fIleafcheck\fP \fCTRUE\fP, and \fIpubliccheck\fP \fCTRUE\fP (and other arguments as given to this function)\&.
.PP
See \fBSoBaseKit::createPathToAnyPart()\fP for documentation\&. 
.SS "SbBool SoBaseKit::setPart (const \fBSbName\fP & partname, \fBSoNode\fP * from)\fC [virtual]\fP"
Sets the catalog part given by \fIpartname\fP to the \fIfrom\fP node pointer\&. 
.PP
Reimplemented in \fBSoInteractionKit\fP\&.
.SS "SbBool SoBaseKit::set (const char * namevaluepairliststring)"
Sets nodekit part field values\&. The input argument string is of the format:
.PP
.PP
.nf
partname {
  fieldname fieldval
  fieldname fieldval
  [\&.\&.\&.]
}
partname {
  fieldname fieldval
  fieldname fieldval
  [\&.\&.\&.]
}
[\&.\&.\&.]
.fi
.PP
.PP
(Whitespace layout is ignored, as always for Inventor format input strings\&.)
.PP
Here's an example, changing several values of the camera part of an \fBSoCameraKit\fP instance:
.PP
.PP
.nf
kit->set("camera { heightAngle 0\&.3927  nearDistance 1\&.1  farDistance 999\&.9 }");
.fi
.PP
 
.SS "SbBool SoBaseKit::set (const char * partnamestring, const char * parameterstring)"
This just overloads the other \fBSoBaseKit::set()\fP method, and provides a way to set a part value by using a separate input argument for the name of the part and the name of the field (i\&.e\&. parameter) settings\&. 
.SS "void SoBaseKit::doAction (\fBSoAction\fP * action)\fC [virtual]\fP"
This function performs the typical operation of a node for any action\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoBaseKit::callback (\fBSoCallbackAction\fP * action)\fC [virtual]\fP"
Action method for \fBSoCallbackAction\fP\&.
.PP
Simply updates the state according to how the node behaves for the render action, so the application programmer can use the \fBSoCallbackAction\fP for extracting information about the scene graph\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.PP
Reimplemented in \fBSoDragger\fP\&.
.SS "void SoBaseKit::GLRender (\fBSoGLRenderAction\fP * action)\fC [virtual]\fP"
Action method for the \fBSoGLRenderAction\fP\&.
.PP
This is called during rendering traversals\&. Nodes influencing the rendering state in any way or who wants to throw geometry primitives at OpenGL overrides this method\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.PP
Reimplemented in \fBSoTabPlaneDragger\fP, and \fBSoDragger\fP\&.
.SS "void SoBaseKit::getBoundingBox (\fBSoGetBoundingBoxAction\fP * action)\fC [virtual]\fP"
Action method for the \fBSoGetBoundingBoxAction\fP\&.
.PP
Calculates bounding box and center coordinates for node and modifies the values of the \fIaction\fP to encompass the bounding box for this node and to shift the center point for the scene more towards the one for this node\&.
.PP
Nodes influencing how geometry nodes calculates their bounding box also overrides this method to change the relevant state variables\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.PP
Reimplemented in \fBSoDragger\fP, and \fBSoCenterballDragger\fP\&.
.SS "void SoBaseKit::getMatrix (\fBSoGetMatrixAction\fP * action)\fC [virtual]\fP"
Action method for \fBSoGetMatrixAction\fP\&.
.PP
Updates \fIaction\fP by accumulating with the transformation matrix of this node (if any)\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.PP
Reimplemented in \fBSoCenterballDragger\fP, and \fBSoDragger\fP\&.
.SS "void SoBaseKit::handleEvent (\fBSoHandleEventAction\fP * action)\fC [virtual]\fP"
Action method for \fBSoHandleEventAction\fP\&.
.PP
Inspects the event data from \fIaction\fP, and processes it if it is something which this node should react to\&.
.PP
Nodes influencing relevant state variables for how event handling is done also overrides this method\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.PP
Reimplemented in \fBSoDragger\fP, and \fBSoNodeVisualize\fP\&.
.SS "void SoBaseKit::rayPick (\fBSoRayPickAction\fP * action)\fC [virtual]\fP"
Action method for \fBSoRayPickAction\fP\&.
.PP
Checks the ray specification of the \fIaction\fP and tests for intersection with the data of the node\&.
.PP
Nodes influencing relevant state variables for how picking is done also overrides this method\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.PP
Reimplemented in \fBSoDragger\fP\&.
.SS "void SoBaseKit::search (\fBSoSearchAction\fP * action)\fC [virtual]\fP"
Action method for \fBSoSearchAction\fP\&.
.PP
Compares the search criteria from the \fIaction\fP to see if this node is a match\&. Searching is done by matching up \fIall\fP criteria set up in the \fBSoSearchAction\fP -- if \fIany\fP of the requested criteria is a miss, the search is not deemed successful for the node\&.
.PP
\fBSee also:\fP
.RS 4
\fBSoSearchAction\fP 
.RE
.PP

.PP
Reimplemented from \fBSoNode\fP\&.
.PP
Reimplemented in \fBSoDragger\fP\&.
.SS "void SoBaseKit::write (\fBSoWriteAction\fP * action)\fC [virtual]\fP"
Action method for \fBSoWriteAction\fP\&.
.PP
Writes out a node object, and any connected nodes, engines etc, if necessary\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.PP
Reimplemented in \fBSoDragger\fP\&.
.SS "void SoBaseKit::getPrimitiveCount (\fBSoGetPrimitiveCountAction\fP * action)\fC [virtual]\fP"
Action method for the \fBSoGetPrimitiveCountAction\fP\&.
.PP
Calculates the number of triangle, line segment and point primitives for the node and adds these to the counters of the \fIaction\fP\&.
.PP
Nodes influencing how geometry nodes calculates their primitive count also overrides this method to change the relevant state variables\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.PP
Reimplemented in \fBSoDragger\fP\&.
.SS "\fBSoChildList\fP * SoBaseKit::getChildren (void) const\fC [virtual]\fP"
Returns list of children for this node\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoBaseKit::printDiagram (void)"
Print out the full nodekit catalog structure\&. Just invokes \fBSoBaseKit::printSubDiagram()\fP on the catalog root\&. Useful for debugging\&.
.PP
Example output:
.PP
.PP
.nf
CLASS SoWrapperKit
-->"this"
      "callbackList"
      "topSeparator"
         "pickStyle"
         "appearance"
         "units"
         "transform"
         "texture2Transform"
         "childList"
-->      "localTransform"
-->      "contents"
.fi
.PP
.PP
The arrows denote new entries in the catalog for the particular class versus it's superclass\&. (Apart from the root entry, of course\&.)
.PP
For a more detailed catalog dump, see \fBSoBaseKit::printTable()\fP\&. 
.SS "void SoBaseKit::printSubDiagram (const \fBSbName\fP & rootname, \fBint\fP level)"
Print out the nodekit catalog structure from \fIrootname\fP and downwards in the catalog tree, with indentation starting at \fIlevel\fP\&.
.PP
\fBSee also:\fP
.RS 4
\fBprintDiagram()\fP 
.RE
.PP

.SS "void SoBaseKit::printTable (void)"
Write the complete nodekit catalog in table form\&.
.PP
Example output:
.PP
.PP
.nf
CLASS SoWrapperKit
PVT   "this",  SoWrapperKit  ---
      "callbackList",  SoNodeKitListPart [ SoCallback, SoEventCallback ]
PVT   "topSeparator",  SoSeparator  ---
      "pickStyle",  SoPickStyle  ---
      "appearance",  SoAppearanceKit  ---
      "units",  SoUnits  ---
      "transform",  SoTransform  ---
      "texture2Transform",  SoTexture2Transform  ---
      "childList",  SoNodeKitListPart [ SoShapeKit, SoSeparatorKit ]
      "localTransform",  SoTransform  ---
      "contents",  SoSeparator  ---
.fi
.PP
.PP
\fCPVT\fP denotes that it's a private entry in the catalog, then follows the part name and the part type\&. If the part is a list, the allowed node types for the list is given in square brackets, and if not there's a triple hyphen\&. If the part type is abstract, the default part type will be listed last (not shown in the example output above)\&. 
.SS "void SoBaseKit::addWriteReference (\fBSoOutput\fP * out, SbBool isfromfield = \fCFALSE\fP)\fC [virtual]\fP"
This method is used during the first write pass of a write action to count the number of references to this object in the scene graph\&. 
.PP
Reimplemented from \fBSoFieldContainer\fP\&.
.SS "SbBool SoBaseKit::forceChildDrivenWriteRefs (\fBSoOutput\fP * out)"
Returns \fCTRUE\fP if kit should write\&. This happens if \fBshouldWrite()\fP returns \fCTRUE\fP, or if any of the children (recursively) should write\&. 
.SS "SbBool SoBaseKit::isSearchingChildren (void)\fC [static]\fP"
Returns the value of the flag indicating whether or not the kit parts are searched during \fBSoSearchAction\fP traversal\&.
.PP
\fBSee also:\fP
.RS 4
\fBSoBaseKit::setSearchingChildren()\fP 
.RE
.PP

.SS "void SoBaseKit::setSearchingChildren (const SbBool newval)\fC [static]\fP"
Set whether or not the kit parts should be searched during \fBSoSearchAction\fP traversal\&. The default value is \fCFALSE\fP\&. 
.SS "const \fBSoNodekitCatalog\fP ** SoBaseKit::getClassNodekitCatalogPtr (void)\fC [static]\fP, \fC [protected]\fP"
Returns the pointer to the pointer of the nodekit catalog for this class\&. 
.SS "\fBSoNode\fP * SoBaseKit::addToCopyDict (void) const\fC [protected]\fP, \fC [virtual]\fP"
Add a copy of this node and (recursively) all children to the copy dictionary of \fBSoFieldContainer\fP if this has not already been done\&.
.PP
Used internally during copy operations\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoBaseKit::copyContents (const \fBSoFieldContainer\fP * from, SbBool copyconnections)\fC [protected]\fP, \fC [virtual]\fP"
Makes a deep copy of all data of \fIfrom\fP into this instance, \fIexcept\fP external scenegraph references if \fIcopyconnections\fP is \fCFALSE\fP\&.
.PP
This is the method that should be overridden by extension node / engine / dragger / whatever subclasses which needs to account for internal data that are not handled automatically\&.
.PP
For copying nodes from application code, you should not invoke this function directly, but rather call the \fBSoNode::copy()\fP function:
.PP
.PP
.nf
SoNode * mynewnode = templatenode->copy();
.fi
.PP
.PP
The same also goes for engines\&.
.PP
Make sure that when you override the \fBcopyContents()\fP method in your extension class that you also make it call upwards to it's parent superclass in the inheritance hierarchy, as \fBcopyContents()\fP in for instance \fBSoNode\fP and \fBSoFieldContainer\fP does important work\&. It should go something like this:
.PP
.PP
.nf
void
MyCoinExtensionNode::copyContents(const SoFieldContainer * from,
                                  SbBool copyconnections)
{
  // let parent superclasses do their thing (copy fields, copy
  // instance name, etc etc)
  SoNode::copyContents(from, copyconnections);

  // [\&.\&.then copy internal data\&.\&.]
}
.fi
.PP
 
.PP
Reimplemented from \fBSoNode\fP\&.
.PP
Reimplemented in \fBSoInteractionKit\fP, \fBSoRotateSphericalDragger\fP, and \fBSoRotateCylindricalDragger\fP\&.
.SS "\fBSoGroup\fP * SoBaseKit::getContainerNode (const \fBSbName\fP & listname, SbBool makeifneeded = \fCTRUE\fP)\fC [protected]\fP"
Returns a pointer to the group node above an \fBSoNodeKitListPart\fP in the catalog given by \fIlistname\fP\&.
.PP
If the list part (and its container) was not yet constructed, they will be so if \fImakeifneeded\fP is \fCTRUE\fP (otherwise, \fCNULL\fP will be returned)\&. 
.SS "\fBSoNode\fP * SoBaseKit::getAnyPart (const \fBSbName\fP & partname, SbBool makeifneeded, SbBool leafcheck = \fCFALSE\fP, SbBool publiccheck = \fCFALSE\fP)\fC [protected]\fP, \fC [virtual]\fP"
Returns catalog part of the given \fIpartname\fP\&.
.PP
If the \fIpartname\fP part is not in the nodekit's catalog, return \fCNULL\fP\&.
.PP
If the part is specified in the catalog, but has not yet been made, the function will either construct the part (if \fImakeifneeded\fP is \fCTRUE\fP) or just return \fCNULL\fP (if \fImakeifneeded\fP is \fCFALSE\fP)\&.
.PP
If \fIleafcheck\fP is \fCTRUE\fP, a pointer to the part will only be returned if it's a leaf in the catalog (otherwise \fCNULL\fP is returned)\&.
.PP
If \fIpubliccheck\fP is \fCTRUE\fP, a pointer to the part will only be returned if it's a public catalog part (otherwise \fCNULL\fP is returned)\&.
.PP
The \fIpartname\fP input argument should be given as a \fI'path'\fP of catalog part names down to the wanted leaf part\&. The syntax for specifiying \fIpartname\fP 'paths' is as follows (given in Backus-Naur Form (BNF)):
.PP
.PP
.nf
BNF:

partname = singlename | compoundname
compoundname = singlename | compoundname.singlename
singlename = singlepartname | singlelistelementname
singlelistelementname = singlelistname[idx]

singlepartname is name of a part ("ordinary", nodekit or list)
singlelistname is name of a part which is a list
idx is an integer value
.fi
.PP
 
.SS "\fBSoNodeKitPath\fP * SoBaseKit::createPathToAnyPart (const \fBSbName\fP & partname, SbBool makeifneeded, SbBool leafcheck = \fCFALSE\fP, SbBool publiccheck = \fCFALSE\fP, const \fBSoPath\fP * pathtoextend = \fCNULL\fP)\fC [protected]\fP, \fC [virtual]\fP"
Return path with nested \fBSoNodeKit\fP instances down in the catalog hierarchy given by \fIpartname\fP\&.
.PP
If the trailing part has not been made and \fImakeifneeded\fP is \fCTRUE\fP, make an instance of the part type and insert into the catalog, as done in \fBsetAnyPart()\fP\&.
.PP
If \fIleafcheck\fP is \fCTRUE\fP, ignore non-leaf catalog node entries\&. If \fIpubliccheck\fP is \fCTRUE\fP, ignore private catalog entries\&.
.PP
\fIpathtoextend\fP is a path through the nodekit instance catalog hierarchy, where we should pick up and continue to create the path from where \fIpathtoextend\fP terminates\&. If \fIpathtoextend\fP is \fCNULL\fP, we simply start at the 'this' toplevel node\&.
.PP
Returns \fCNULL\fP on failure, for any of the possible reasons described above (part ends in non-leaf or private catalog entry, part is not syntactically valid or refers to non-existing catalog entries)\&. 
.SS "SbBool SoBaseKit::setAnyPart (const \fBSbName\fP & partname, \fBSoNode\fP * from, SbBool anypart = \fCTRUE\fP)\fC [protected]\fP, \fC [virtual]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "void SoBaseKit::createNodekitPartsList (void)\fC [protected]\fP"
Not part of the Coin API\&.
.PP
It is supposed to create the SoNodekitParts class instance\&. Since this class can only be used by \fBSoBaseKit\fP (all members are private, with \fBSoBaseKit\fP as friend), we decided to not support this class, and solve the problem of recording which parts are created in an alternative way\&. 
.SS "void SoBaseKit::createFieldList (void)\fC [protected]\fP"
Replaces the \fBcreateNodekitPartsList()\fP method\&.
.PP
Sets up the list of \fBSoSFNode\fP fields with node pointers to the instances in our catalog\&. 
.SS "void SoBaseKit::createDefaultParts (void)\fC [protected]\fP, \fC [virtual]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "const SoNodekitParts * SoBaseKit::getNodekitPartsList (void) const\fC [protected]\fP"
In Open Inventor, this method returns a pointer to a private class\&. It will always return \fCNULL\fP in Coin\&.
.PP
\fBSee also:\fP
.RS 4
\fBcreateNodekitPartsList()\fP 
.RE
.PP

.SS "const \fBSbList\fP< \fBSoSFNode\fP * > & SoBaseKit::getCatalogInstances (void) const\fC [protected]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "void SoBaseKit::catalogError (void)\fC [protected]\fP"
Obsoleted from the API in Coin\&. 
.SS "SbBool SoBaseKit::setUpConnections (SbBool onoff, SbBool doitalways = \fCFALSE\fP)\fC [protected]\fP, \fC [virtual]\fP"
Sets up all internal connections for instances of this class\&.
.PP
(This method will usually not be of interest to the application programmer, unless you want to extend the library with new custom nodekits or dragger classes\&. If so, see the \fBSoBaseKit\fP class documentation\&.) 
.PP
Reimplemented in \fBSoTransformerDragger\fP, \fBSoHandleBoxDragger\fP, \fBSoInteractionKit\fP, \fBSoDragPointDragger\fP, \fBSoTransformBoxDragger\fP, \fBSoTrackballDragger\fP, \fBSoCenterballDragger\fP, \fBSoTabPlaneDragger\fP, \fBSoTabBoxDragger\fP, \fBSoSpotLightDragger\fP, \fBSoSeparatorKit\fP, \fBSoTranslate2Dragger\fP, \fBSoRotateSphericalDragger\fP, \fBSoRotateCylindricalDragger\fP, \fBSoTranslate1Dragger\fP, \fBSoDirectionalLightDragger\fP, \fBSoScale2UniformDragger\fP, \fBSoJackDragger\fP, \fBSoScale2Dragger\fP, \fBSoScale1Dragger\fP, \fBSoScaleUniformDragger\fP, \fBSoRotateDiscDragger\fP, and \fBSoPointLightDragger\fP\&.
.SS "SbBool SoBaseKit::readInstance (\fBSoInput\fP * in, unsigned short flags)\fC [protected]\fP, \fC [virtual]\fP"
This method is mainly intended for internal use during file import operations\&.
.PP
It reads a definition of an instance from the input stream \fIin\fP\&. The input stream state points to the start of a serialized / persistant representation of an instance of this class type\&.
.PP
\fCTRUE\fP or \fCFALSE\fP is returned, depending on if the instantiation and configuration of the new object of this class type went ok or not\&. The import process should be robust and handle corrupted input streams by returning \fCFALSE\fP\&.
.PP
\fIflags\fP is used internally during binary import when reading user extension nodes, group nodes or engines\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.PP
Reimplemented in \fBSoInteractionKit\fP\&.
.SS "void SoBaseKit::setDefaultOnNonWritingFields (void)\fC [protected]\fP, \fC [virtual]\fP"
(Be aware that this method is unlikely to be of interest to the application programmer who does not want to extend the library with new custom nodekits or draggers\&. If you indeed \fIare\fP writing extensions, see the information in the \fBSoBaseKit\fP class documentation\&.)
.PP
This is a virtual method, and the code in it should call \fBSoField::setDefault()\fP with argument \fCTRUE\fP on part fields that should not be written upon scenegraph export operations\&.
.PP
This is typically done when:
.PP
.PD 0
.IP "1." 4
field value is \fCNULL\fP and part is \fCNULL\fP by default 
.PP

.IP "2." 4
it is a leaf \fBSoGroup\fP or \fBSoSeparator\fP node with no children 
.PP

.IP "3." 4
it is a leaf listpart with no children and an \fBSoGroup\fP or \fBSoSeparator\fP container 
.PP

.IP "4." 4
it is a non-leaf part and it's of \fBSoGroup\fP type and all fields are at their default values 
.PP

.PP
.PP
Subclasses should usually override this to do additional settings for new member fields\&. From the subclass, do remember to call 'upwards' to your superclass' \fBsetDefaultOnNonWritingFields()\fP method\&. 
.PP
Reimplemented in \fBSoTransformerDragger\fP, \fBSoDragger\fP, \fBSoHandleBoxDragger\fP, \fBSoInteractionKit\fP, \fBSoDragPointDragger\fP, \fBSoTransformBoxDragger\fP, \fBSoTrackballDragger\fP, \fBSoCenterballDragger\fP, \fBSoTabPlaneDragger\fP, \fBSoTabBoxDragger\fP, \fBSoSpotLightDragger\fP, \fBSoSeparatorKit\fP, \fBSoDirectionalLightDragger\fP, \fBSoShapeKit\fP, \fBSoJackDragger\fP, and \fBSoPointLightDragger\fP\&.
.SS "void SoBaseKit::countMyFields (\fBSoOutput\fP * out)\fC [protected]\fP"
Reference count the write connections to nodes in the catalog\&. 
.SS "SbBool SoBaseKit::setPart (const \fBint\fP partnum, \fBSoNode\fP * node)\fC [protected]\fP, \fC [virtual]\fP"
Sets parts, updates nodekit scene graph, and makes sure graph is valid with respect to right siblings and parent\&. This method is virtual to enable subclasses to detect when a part changes value\&.
.PP
This method is not part of the original SGI Open Inventor API, but is an extension specific to Coin\&. 
.PP
Reimplemented in \fBSoInteractionKit\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBSoChildList\fP * SoBaseKit::children\fC [protected]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "SbBool SoBaseKit::connectionsSetUp\fC [protected]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
