.TH "SoGetBoundingBoxAction" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SoGetBoundingBoxAction \- The \fBSoGetBoundingBoxAction\fP class calculates bounding boxes for nodes and subgraphs\&.
.PP
If this action is applied to a path or scene graph root, it will calculate the bounding box and the center point of the geometry contained within the scene\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Inventor/actions/SoGetBoundingBoxAction\&.h>\fP
.PP
Inherits \fBSoAction\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBResetType\fP { \fBTRANSFORM\fP = 0x1, \fBBBOX\fP = 0x2, \fBALL\fP = TRANSFORM | BBOX }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fBSoType\fP \fBgetTypeId\fP (void) const"
.br
.ti -1c
.RI "\fBSoGetBoundingBoxAction\fP (const \fBSbViewportRegion\fP &vp)"
.br
.ti -1c
.RI "virtual \fB~SoGetBoundingBoxAction\fP (void)"
.br
.ti -1c
.RI "void \fBsetViewportRegion\fP (const \fBSbViewportRegion\fP &newregion)"
.br
.ti -1c
.RI "const \fBSbViewportRegion\fP & \fBgetViewportRegion\fP (void) const"
.br
.ti -1c
.RI "\fBSbBox3f\fP \fBgetBoundingBox\fP (void) const"
.br
.ti -1c
.RI "\fBSbXfBox3f\fP & \fBgetXfBoundingBox\fP (void)"
.br
.ti -1c
.RI "const \fBSbVec3f\fP & \fBgetCenter\fP (void) const"
.br
.ti -1c
.RI "void \fBsetInCameraSpace\fP (const SbBool flag)"
.br
.ti -1c
.RI "SbBool \fBisInCameraSpace\fP (void) const"
.br
.ti -1c
.RI "void \fBsetResetPath\fP (const \fBSoPath\fP *path, const SbBool resetbefore=TRUE, const \fBResetType\fP what=ALL)"
.br
.ti -1c
.RI "const \fBSoPath\fP * \fBgetResetPath\fP (void) const"
.br
.ti -1c
.RI "SbBool \fBisResetPath\fP (void) const"
.br
.ti -1c
.RI "SbBool \fBisResetBefore\fP (void) const"
.br
.ti -1c
.RI "\fBSoGetBoundingBoxAction::ResetType\fP \fBgetWhatReset\fP (void) const"
.br
.ti -1c
.RI "void \fBcheckResetBefore\fP (void)"
.br
.ti -1c
.RI "void \fBcheckResetAfter\fP (void)"
.br
.ti -1c
.RI "void \fBextendBy\fP (const \fBSbBox3f\fP &box)"
.br
.ti -1c
.RI "void \fBextendBy\fP (const \fBSbXfBox3f\fP &box)"
.br
.ti -1c
.RI "void \fBsetCenter\fP (const \fBSbVec3f\fP &center, const SbBool transformcenter)"
.br
.ti -1c
.RI "SbBool \fBisCenterSet\fP (void) const"
.br
.ti -1c
.RI "void \fBresetCenter\fP (void)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBSoType\fP \fBgetClassTypeId\fP (void)"
.br
.ti -1c
.RI "static void \fBaddMethod\fP (const \fBSoType\fP type, \fBSoActionMethod\fP method)"
.br
.ti -1c
.RI "static void \fBenableElement\fP (const \fBSoType\fP type, const \fBint\fP stackindex)"
.br
.ti -1c
.RI "static void \fBinitClass\fP (void)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual const \fBSoEnabledElementsList\fP & \fBgetEnabledElements\fP (void) const"
.br
.ti -1c
.RI "virtual void \fBbeginTraversal\fP (\fBSoNode\fP *node)"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static \fBSoEnabledElementsList\fP * \fBgetClassEnabledElements\fP (void)"
.br
.ti -1c
.RI "static \fBSoActionMethodList\fP * \fBgetClassActionMethods\fP (void)"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
The \fBSoGetBoundingBoxAction\fP class calculates bounding boxes for nodes and subgraphs\&.
.PP
If this action is applied to a path or scene graph root, it will calculate the bounding box and the center point of the geometry contained within the scene\&. 

You don't have to apply an \fBSoGetBoundingBoxAction\fP to the \fIroot\fP of a scene\&. When using the action, you will get the bounding box of the node you are applying it to and that node's sub-tree in the scene graph (if any)\&.
.PP
The calculated bounding box will be in the local coordinates of that sub-tree\&. If applying it to a scene graph root node, the calculated bounding box will be in global coordinates\&.
.PP
The use of bounding boxes is ubiquitous within the Coin library\&. It is needed for the correct execution of and for performance enhancements during rendering, picking, caching, culling, etc\&.
.PP
\fBSoSeparator\fP nodes are aggressively caching the results of bounding box calculations, so that they are really only re-calculated whenever the scenegraph rooted below any \fBSoSeparator\fP node has been modified\&. This means that applying this action to scenegraphs, or parts of scenegraphs, should be very quick on successive runs for 'static' parts of the scene\&.
.PP
Note that the algorithm used is not guaranteed to always give an exact bounding box: it combines bounding boxes in pairs and extends one of them to contain the other\&. Since the boxes need not be parallel to the principal axes the new box might not be a perfect fit for the box not extended (it's coordinate system has been changed)\&.
.PP
Note also that what is returned from \fBgetBoundingBox()\fP will be projected so as to be oriented along the principal axes, which can often cause it to become quite a lot larger than what it was before projection\&. For client code to obtain the best bounding box that Coin can calculate (and which will usually be exact), you need to use the \fBgetXfBoundingBox()\fP method after having applied the \fBSoGetBoundingBoxAction\fP\&.
.PP
\fBSee also:\fP
.RS 4
\fBSoSeparator::boundingBoxCaching\fP 
.RE
.PP

.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBSoGetBoundingBoxAction::ResetType\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SoGetBoundingBoxAction::SoGetBoundingBoxAction (const \fBSbViewportRegion\fP & vp)"
Constructor\&.
.PP
It might seem unnecessary to have to pass in a viewport region argument to calculate bounding boxes, but there is a good reason for this: a few shape nodes needs to know the viewport region to calculate their bounding box -- these include \fBSoText2\fP and \fBSoImage\fP, among others\&.
.PP
What is particular about these shapes is that they are fundamentally 2D shapes, but they are being rendered on the screen 'surface' as if they were in a 3D scene\&. (This is possible because we can match each pixel's depth value against the 3D shapes in the scene\&.)
.PP
To compute an accurate 3D bounding box of a shape rendered in 2D on the screen 'surface', you need to 'de-project' the screen-space area it occupies to a 2D rectangle placed at some depth in the scene\&. This 'de-projecting' operation needs to know about the dimensions of the viewport\&.
.PP
Also, some 3D shapes like for instance \fBSoNurbsSurface\fP, get slightly distorted if there's an \fBSoComplexity\fP node in the scenegraph with the \fBSoComplexity::value\fP field set to SCREEN_SPACE\&. Then it is also necessary to know the viewport region to find out how to accurately calculate the bounding box of those shapes\&.
.PP
You would usually want to pass in a viewport region equal to the layout of the current renderarea canvas\&. If you have a viewer or So available, you can get hold of the viewport region data simply by doing
.PP
.PP
.nf
const SbViewportRegion & vpreg = viewer->getViewportRegion();
.fi
.PP
.PP
(If you don't have a viewer or renderarea available in your application at the point where you want to get the bounding box, it probably doesn't matter much what you set it to\&. The accuracy of the bounding box calculation might be slightly wrong versus the actual rendered appearance of the scene, but this is usually not noticable\&.) 
.SS "SoGetBoundingBoxAction::~SoGetBoundingBoxAction (void)\fC [virtual]\fP"
Destructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBSoType\fP SoGetBoundingBoxAction::getTypeId (void) const\fC [virtual]\fP"
Returns the type identification of an action derived from a class inheriting \fBSoAction\fP\&. This is used for run-time type checking and 'downward' casting\&.
.PP
Usage example:
.PP
.PP
.nf
void bar(SoAction * action)
{
  if (action->getTypeId() == SoGLRenderAction::getClassTypeId()) {
    // safe downward cast, know the type
    SoGLRenderAction * glrender = (SoGLRenderAction *)action;
  }
  return; // ignore if not renderaction
}
.fi
.PP
.PP
For application programmers wanting to extend the library with new actions: this method needs to be overridden in \fIall\fP subclasses\&. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through Inventor/nodes/SoSubAction\&.h: SO_ACTION_SOURCE, SO_ACTION_INIT_CLASS and SO_ACTION_CONSTRUCTOR\&.
.PP
For more information on writing Coin extensions, see the \fBSoAction\fP class documentation\&.
.PP
Returns the actual type id of an object derived from a class inheriting \fBSoAction\fP\&. Needs to be overridden in \fIall\fP subclasses\&. 
.PP
Implements \fBSoAction\fP\&.
.SS "void SoGetBoundingBoxAction::addMethod (const \fBSoType\fP type, \fBSoActionMethod\fP method)\fC [static]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "void SoGetBoundingBoxAction::enableElement (const \fBSoType\fP type, const \fBint\fP stackindex)\fC [static]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "const \fBSoEnabledElementsList\fP & SoGetBoundingBoxAction::getEnabledElements (void) const\fC [protected]\fP, \fC [virtual]\fP"
Returns a list of the elements used by action instances of this class upon traversal operations\&. 
.PP
Reimplemented from \fBSoAction\fP\&.
.SS "void SoGetBoundingBoxAction::setViewportRegion (const \fBSbViewportRegion\fP & newregion)"
Set a new viewport region with this method, if it has changed from the one passed in with the constructor\&. 
.SS "const \fBSbViewportRegion\fP & SoGetBoundingBoxAction::getViewportRegion (void) const"
Returns the viewport region used by the action instance\&. 
.SS "\fBSbBox3f\fP SoGetBoundingBoxAction::getBoundingBox (void) const"
Returns the projected bounding box after (or during) traversal\&. 
.SS "\fBSbXfBox3f\fP & SoGetBoundingBoxAction::getXfBoundingBox (void)"
Returns the bounding box and transformation matrix to global coordinates\&. Use after (or during) traversal\&. 
.SS "const \fBSbVec3f\fP & SoGetBoundingBoxAction::getCenter (void) const"
Returns center point of scene after the action has been applied\&.
.PP
This might differ from the geometric center of the bounding box, as shape nodes may 'weight' the center point according to various criteria (i\&.e\&. a faceset could for instance weight the center point according to the area within its bounding box where there are more polygons)\&. 
.SS "void SoGetBoundingBoxAction::setInCameraSpace (const SbBool on)"
Sets whether the returned bounding box should be calculated in the coordinate system of the camera space or not\&. 
.SS "SbBool SoGetBoundingBoxAction::isInCameraSpace (void) const"
Returns whether the bounding box returned is to be in camera space\&. 
.SS "void SoGetBoundingBoxAction::setResetPath (const \fBSoPath\fP * path, const SbBool resetbefore = \fCTRUE\fP, const \fBResetType\fP what = \fCALL\fP)"
Forces the computed bounding box to be reset and the transformation to be identity before or after the tail node of \fIpath\fP, depending on the \fIresetbefore\fP argument\&. \fCNULL\fP can be specified for the \fIpath\fP argument to disable this behavior\&.
.PP
\fBSee also:\fP
.RS 4
\fBgetResetPath()\fP, \fBisResetPath()\fP, \fBisResetBefore()\fP, \fBgetWhatReset()\fP 
.RE
.PP

.SS "const \fBSoPath\fP * SoGetBoundingBoxAction::getResetPath (void) const"
Returns the reset path (or \fCNULL\fP)\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetResetPath()\fP, \fBisResetPath()\fP, \fBisResetBefore()\fP, \fBgetWhatReset()\fP 
.RE
.PP

.SS "SbBool SoGetBoundingBoxAction::isResetPath (void) const"
Returns whether a reset path is set or not\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetResetPath()\fP, \fBgetResetPath()\fP, \fBisResetBefore()\fP, \fBgetWhatReset()\fP 
.RE
.PP

.SS "SbBool SoGetBoundingBoxAction::isResetBefore (void) const"
Returns whether the bounding box and transformation is reset before or after the tail node of the reset path\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetResetPath()\fP, \fBgetResetPath()\fP, \fBisResetPath()\fP, \fBgetWhatReset()\fP 
.RE
.PP

.SS "\fBSoGetBoundingBoxAction::ResetType\fP SoGetBoundingBoxAction::getWhatReset (void) const"
Returns what type of reset has been specified for the reset path\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetResetPath()\fP, \fBgetResetPath()\fP, \fBisResetPath()\fP, \fBisResetBefore()\fP 
.RE
.PP

.SS "void SoGetBoundingBoxAction::checkResetBefore (void)"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP Called before node traversal of each node (from \fBSoNode\fP action method)\&. 
.SS "void SoGetBoundingBoxAction::checkResetAfter (void)"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP Called after node traversal of each node (from \fBSoNode\fP action method)\&. 
.SS "void SoGetBoundingBoxAction::extendBy (const \fBSbBox3f\fP & box)"
Extend bounding box by the given \fIbox\fP\&. Called from nodes during traversal\&.
.PP
Should usually not be of interest to application programmers, unless you're extending Coin with your own shapenode extension classes\&. 
.SS "void SoGetBoundingBoxAction::extendBy (const \fBSbXfBox3f\fP & box)"
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&. 
.SS "void SoGetBoundingBoxAction::setCenter (const \fBSbVec3f\fP & centerarg, const SbBool transformcenter)"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP Set a new center point during traversal\&. 
.SS "SbBool SoGetBoundingBoxAction::isCenterSet (void) const"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP Query about the center point during traversal\&. 
.SS "void SoGetBoundingBoxAction::resetCenter (void)"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP Reset the scene center point during traversal\&. 
.SS "void SoGetBoundingBoxAction::beginTraversal (\fBSoNode\fP * node)\fC [protected]\fP, \fC [virtual]\fP"
This virtual method is called from \fBSoAction::apply()\fP, and is the entry point for the actual scenegraph traversal\&.
.PP
It can be overridden to initialize the action at traversal start, for specific initializations in the action subclasses inheriting \fBSoAction\fP\&.
.PP
Default method just calls \fBtraverse()\fP, which any overridden implementation of the method must do too (or call \fBSoAction::beginTraversal()\fP) to trigger the scenegraph traversal\&. 
.PP
Reimplemented from \fBSoAction\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
