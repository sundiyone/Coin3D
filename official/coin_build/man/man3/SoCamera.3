.TH "SoCamera" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SoCamera \- The \fBSoCamera\fP class is the abstract base class for camera definition nodes\&.
.PP
To be able to view a scene, one needs to have a camera in the scene graph\&. A camera node will set up the projection and viewing matrices for rendering of the geometry in the scene\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Inventor/nodes/SoCamera\&.h>\fP
.PP
Inherits \fBSoNode\fP\&.
.PP
Inherited by \fBSoFrustumCamera\fP, \fBSoOrthographicCamera\fP, and \fBSoPerspectiveCamera\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBViewportMapping\fP { \fBCROP_VIEWPORT_FILL_FRAME\fP, \fBCROP_VIEWPORT_LINE_FRAME\fP, \fBCROP_VIEWPORT_NO_FRAME\fP, \fBADJUST_CAMERA\fP, \fBLEAVE_ALONE\fP }"
.br
.ti -1c
.RI "enum \fBStereoMode\fP { \fBMONOSCOPIC\fP, \fBLEFT_VIEW\fP, \fBRIGHT_VIEW\fP }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fBSoType\fP \fBgetTypeId\fP (void) const"
.br
.RI "Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. "
.ti -1c
.RI "\fBSbViewVolume\fP \fBgetViewVolume\fP (const \fBSbViewportRegion\fP &vp, \fBSbViewportRegion\fP &resultvp, const \fBSbMatrix\fP &mm=\fBSbMatrix::identity\fP()) const"
.br
.ti -1c
.RI "void \fBpointAt\fP (const \fBSbVec3f\fP &targetpoint)"
.br
.ti -1c
.RI "void \fBpointAt\fP (const \fBSbVec3f\fP &targetpoint, const \fBSbVec3f\fP &upvector)"
.br
.ti -1c
.RI "virtual void \fBscaleHeight\fP (float scalefactor)=0"
.br
.ti -1c
.RI "virtual \fBSbViewVolume\fP \fBgetViewVolume\fP (float useaspectratio=0\&.0f) const =0"
.br
.ti -1c
.RI "void \fBviewAll\fP (\fBSoNode\fP *const sceneroot, const \fBSbViewportRegion\fP &vpregion, const float slack=1\&.0f)"
.br
.ti -1c
.RI "void \fBviewAll\fP (\fBSoPath\fP *const path, const \fBSbViewportRegion\fP &vpregion, const float slack=1\&.0f)"
.br
.ti -1c
.RI "\fBSbViewportRegion\fP \fBgetViewportBounds\fP (const \fBSbViewportRegion\fP &region) const"
.br
.ti -1c
.RI "void \fBsetStereoMode\fP (\fBStereoMode\fP mode)"
.br
.ti -1c
.RI "\fBStereoMode\fP \fBgetStereoMode\fP (void) const"
.br
.ti -1c
.RI "void \fBsetStereoAdjustment\fP (float adjustment)"
.br
.ti -1c
.RI "float \fBgetStereoAdjustment\fP (void) const"
.br
.ti -1c
.RI "void \fBsetBalanceAdjustment\fP (float adjustment)"
.br
.ti -1c
.RI "float \fBgetBalanceAdjustment\fP (void) const"
.br
.ti -1c
.RI "virtual void \fBdoAction\fP (\fBSoAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBcallback\fP (\fBSoCallbackAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBGLRender\fP (\fBSoGLRenderAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBaudioRender\fP (\fBSoAudioRenderAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBgetBoundingBox\fP (\fBSoGetBoundingBoxAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBgetMatrix\fP (\fBSoGetMatrixAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBhandleEvent\fP (\fBSoHandleEventAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBrayPick\fP (\fBSoRayPickAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBgetPrimitiveCount\fP (\fBSoGetPrimitiveCountAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBviewBoundingBox\fP (const \fBSbBox3f\fP &box, float aspect, float slack)=0"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBSoType\fP \fBgetClassTypeId\fP (void)"
.br
.ti -1c
.RI "static void \fBinitClass\fP (void)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBSoSFEnum\fP \fBviewportMapping\fP"
.br
.ti -1c
.RI "\fBSoSFVec3f\fP \fBposition\fP"
.br
.ti -1c
.RI "\fBSoSFRotation\fP \fBorientation\fP"
.br
.ti -1c
.RI "\fBSoSFFloat\fP \fBaspectRatio\fP"
.br
.ti -1c
.RI "\fBSoSFFloat\fP \fBnearDistance\fP"
.br
.ti -1c
.RI "\fBSoSFFloat\fP \fBfarDistance\fP"
.br
.ti -1c
.RI "\fBSoSFFloat\fP \fBfocalDistance\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual const \fBSoFieldData\fP * \fBgetFieldData\fP (void) const"
.br
.ti -1c
.RI "\fBSoCamera\fP (void)"
.br
.ti -1c
.RI "virtual \fB~SoCamera\fP ()"
.br
.ti -1c
.RI "virtual void \fBjitter\fP (\fBint\fP numpasses, \fBint\fP curpass, const \fBSbViewportRegion\fP &vpreg, \fBSbVec3f\fP &jitteramount) const"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static const \fBSoFieldData\fP ** \fBgetFieldDataPtr\fP (void)"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
The \fBSoCamera\fP class is the abstract base class for camera definition nodes\&.
.PP
To be able to view a scene, one needs to have a camera in the scene graph\&. A camera node will set up the projection and viewing matrices for rendering of the geometry in the scene\&. 

This node just defines the abstract interface by collecting common fields that all camera type nodes needs\&. Use the non-abstract camera node subclasses within a scene graph\&. The ones that are default part of the Coin library are \fBSoPerspectiveCamera\fP and \fBSoOrthographicCamera\fP, which uses the two different projections given by their name\&.
.PP
Note that the viewer components of the GUI glue libraries of Coin (SoXt, SoQt, SoWin, etc) will automatically insert a camera into a scene graph if none has been defined\&.
.PP
It is possible to have more than one camera in a scene graph\&. One common trick is for instance to use a second camera to display static geometry or overlay geometry (e\&.g\&. for head-up displays ('HUD')), as shown by this example code:
.PP
.PP
.nf
#include <Inventor/Qt/SoQt\&.h>
#include <Inventor/Qt/viewers/SoQtExaminerViewer\&.h>
#include <Inventor/nodes/SoNodes\&.h>

int
main(int argc, char ** argv)
{
  QWidget * mainwin = SoQt::init(argv[0]);

  SoSeparator * root = new SoSeparator;
  root->ref();

  // Adds a camera and a red cone\&. The first camera found in the
  // scene graph by the SoQtExaminerViewer will be picked up and
  // initialized automatically\&.

  root->addChild(new SoPerspectiveCamera);
  SoMaterial * material = new SoMaterial;
  material->diffuseColor\&.setValue(1\&.0, 0\&.0, 0\&.0);
  root->addChild(material);
  root->addChild(new SoCone);


  // Set up a second camera for the remaining geometry\&. This camera
  // will not be picked up and influenced by the viewer, so the
  // geometry will be kept static\&.

  SoPerspectiveCamera * pcam = new SoPerspectiveCamera;
  pcam->position = SbVec3f(0, 0, 5);
  pcam->nearDistance = 0\&.1;
  pcam->farDistance = 10;
  root->addChild(pcam);

  // Adds a green cone to demonstrate static geometry\&.

  SoMaterial * greenmaterial = new SoMaterial;
  greenmaterial->diffuseColor\&.setValue(0, 1\&.0, 0\&.0);
  root->addChild(greenmaterial);
  root->addChild(new SoCone);


  SoQtExaminerViewer * viewer = new SoQtExaminerViewer(mainwin);
  viewer->setSceneGraph(root);
  viewer->show();

  SoQt::show(mainwin);
  SoQt::mainLoop();

  delete viewer;
  root->unref();
  return 0;
}
.fi
.PP
.PP
NB: The support for multiple cameras in Coin is limited, and problems with multiple cameras will be considered fixed on a case by case basis\&. 
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBSoCamera::ViewportMapping\fP"
Enumerates the available possibilities for how the render frame should map the viewport\&. 
.SS "enum \fBSoCamera::StereoMode\fP"
Enumerates the possible stereo modes\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIMONOSCOPIC \fP\fP
No stereo\&. 
.TP
\fB\fILEFT_VIEW \fP\fP
Left view\&. 
.TP
\fB\fIRIGHT_VIEW \fP\fP
Right view\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SoCamera::SoCamera (void)\fC [protected]\fP"
Constructor\&. 
.SS "SoCamera::~SoCamera ()\fC [protected]\fP, \fC [virtual]\fP"
Destructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBSoType\fP SoCamera::getTypeId (void) const\fC [virtual]\fP"

.PP
Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. Usage example:
.PP
.PP
.nf
void foo(SoNode * node)
{
  if (node->getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
.fi
.PP
.PP
For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in \fIall\fP subclasses\&. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance \fBInventor/nodes/SoSubNode\&.h\fP (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), \fBInventor/engines/SoSubEngine\&.h\fP (for engine classes) and so on\&.
.PP
For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups\&. 
.PP
Implements \fBSoBase\fP\&.
.PP
Reimplemented in \fBSoFrustumCamera\fP, \fBSoOrthographicCamera\fP, \fBSoReversePerspectiveCamera\fP, and \fBSoPerspectiveCamera\fP\&.
.SS "const \fBSoFieldData\fP * SoCamera::getFieldData (void) const\fC [protected]\fP, \fC [virtual]\fP"
Returns a pointer to the class-wide field data storage object for this instance\&. If no fields are present, returns \fCNULL\fP\&. 
.PP
Reimplemented from \fBSoFieldContainer\fP\&.
.PP
Reimplemented in \fBSoFrustumCamera\fP, \fBSoOrthographicCamera\fP, \fBSoReversePerspectiveCamera\fP, and \fBSoPerspectiveCamera\fP\&.
.SS "\fBSbViewVolume\fP SoCamera::getViewVolume (const \fBSbViewportRegion\fP & vp, \fBSbViewportRegion\fP & resultvp, const \fBSbMatrix\fP & mm = \fC\fBSbMatrix::identity\fP()\fP) const"
Convenience method which returns the actual view volume used when rendering, adjusted for the current viewport mapping\&.
.PP
Supply the view's viewport in \fIvp\fP\&. If the viewport mapping is one of CROP_VIEWPORT_FILL_FRAME, CROP_VIEWPORT_LINE_FRAME or CROP_VIEWPORT_NO_FRAME, \fIresultvp\fP will be modified to contain the resulting viewport\&.
.PP
If you got any transformations in front of the camera, \fImm\fP should contain this transformation\&.
.PP
\fBSince:\fP
.RS 4
Coin 4\&.0 
.RE
.PP

.SS "void SoCamera::pointAt (const \fBSbVec3f\fP & targetpoint)"
Reorients the camera so that it points towards \fItargetpoint\fP\&. The positive y-axis is used as the up vector of the camera, unless the new camera direction is parallel to this axis, in which case the positive z-axis will be used instead\&. 
.SS "void SoCamera::pointAt (const \fBSbVec3f\fP & targetpoint, const \fBSbVec3f\fP & upvector)"
Reorients the camera so that it points towards \fItargetpoint\fP, using \fIupvector\fP as the camera up vector\&.
.PP
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2\&.1 API\&. 
.SS "void SoCamera::scaleHeight (float scalefactor)\fC [pure virtual]\fP"
Sets a \fIscalefactor\fP for the height of the camera viewport\&. What 'viewport height' means exactly in this context depends on the camera model\&. See documentation in subclasses\&. 
.PP
Implemented in \fBSoFrustumCamera\fP, \fBSoOrthographicCamera\fP, and \fBSoPerspectiveCamera\fP\&.
.SS "\fBSbViewVolume\fP SoCamera::getViewVolume (float useaspectratio = \fC0\&.0f\fP) const\fC [pure virtual]\fP"
Returns total view volume covered by the camera under the current settings\&.
.PP
This view volume is not adjusted to account for viewport mapping\&. If you want the same view volume as the one used during rendering, you should use getViewVolume(SbViewportRegion & vp, const SbMatrix & mm), or do something like this:
.PP
.PP
.nf
SbViewVolume vv;
float aspectratio = myviewport.getViewportAspectRatio();

switch (camera->viewportMapping.getValue()) {
case SoCamera::CROP_VIEWPORT_FILL_FRAME:
case SoCamera::CROP_VIEWPORT_LINE_FRAME:
case SoCamera::CROP_VIEWPORT_NO_FRAME:
  vv = camera->getViewVolume(0.0f);
  break;
case SoCamera::ADJUST_CAMERA:
  vv = camera->getViewVolume(aspectratio);
  if (aspectratio < 1.0f) vv.scale(1.0f / aspectratio);
  break;
case SoCamera::LEAVE_ALONE:
  vv = camera->getViewVolume(0.0f);
  break;
default:
  assert(0 && "unknown viewport mapping");
  break;
}.fi
.PP
.PP
Also, for the CROPPED viewport mappings, the viewport might be changed if the viewport aspect ratio is not equal to the camera aspect ratio\&. See the SoCamera::getView() source-code (private method) to see how this is done\&. 
.PP
Implemented in \fBSoFrustumCamera\fP, \fBSoOrthographicCamera\fP, and \fBSoPerspectiveCamera\fP\&.
.SS "void SoCamera::viewAll (\fBSoNode\fP *const sceneroot, const \fBSbViewportRegion\fP & vpregion, const float slack = \fC1\&.0f\fP)"
Position the camera so that all geometry of the scene from \fIsceneroot\fP is contained in the view volume of the camera, while keeping the camera orientation constant\&.
.PP
Finds the bounding box of the scene and calls \fBSoCamera::viewBoundingBox()\fP\&. A bounding sphere will be calculated from the scene bounding box, so the camera will 'view all' even when the scene is rotated, in any way\&.
.PP
The \fIslack\fP argument gives a multiplication factor to the distance the camera is supposed to move out from the \fIsceneroot\fP mid-point\&.
.PP
A value less than 1\&.0 for the \fIslack\fP argument will therefore cause the camera to come closer to the scene, a value of 1\&.0 will position the camera as exactly outside the scene bounding sphere, and a value larger than 1\&.0 will give 'extra slack' versus the scene bounding sphere\&. 
.SS "void SoCamera::viewAll (\fBSoPath\fP *const path, const \fBSbViewportRegion\fP & vpregion, const float slack = \fC1\&.0f\fP)"
Position the camera so all geometry of the scene in \fIpath\fP is contained in the view volume of the camera\&.
.PP
Finds the bounding box of the scene and calls \fBSoCamera::viewBoundingBox()\fP\&. 
.SS "\fBSbViewportRegion\fP SoCamera::getViewportBounds (const \fBSbViewportRegion\fP & region) const"
Based in the \fBSoCamera::viewportMapping\fP setting, convert the values of \fIregion\fP to the viewport region we will actually render into\&. 
.SS "void SoCamera::setStereoMode (\fBStereoMode\fP mode)"
Sets the stereo mode\&. 
.SS "\fBSoCamera::StereoMode\fP SoCamera::getStereoMode (void) const"
Returns the stereo mode\&. 
.SS "void SoCamera::setStereoAdjustment (float adjustment)"
Sets the stereo adjustment\&. This is the distance between the left and right 'eye' when doing stereo rendering\&.
.PP
When doing stereo rendering, Coin will render two views, one for the left eye, and one for the right eye\&. The stereo adjustment is, a bit simplified, how much the camera is translated along the local X-axis between the left and the right view\&.
.PP
The default distance is 0\&.1, which is chosen since it's the approximate distance between the human eyes\&.
.PP
To create a nice looking and visible stereo effect, the application programmer will often have to adjust this value\&. If all you want to do is examine simple stand-alone 3D objects, it is possible to calculate a stereo offset based on the bounding box of the 3D model (or scale the model down to an appropriate size)\&.
.PP
However, if you have a large scene, where you want to fly around in the scene, and see stereo on different objects as you approach them, you can't calculate the stereo offset based on the bounding box of the scene, but rather use a stereo offset based on the scale of the individual objects/details you want to examine\&.
.PP
Please note that it's important to set a sensible focal distance when doing stereo rendering\&. See \fBsetBalanceAdjustment()\fP for information about how the focal distance affects the stereo rendering\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetBalanceAdjustment()\fP 
.RE
.PP

.SS "float SoCamera::getStereoAdjustment (void) const"
Returns the stereo adjustment\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetStereoAdjustment()\fP 
.RE
.PP

.SS "void SoCamera::setBalanceAdjustment (float adjustment)"
Sets the stereo balance adjustment\&. This is a factor that enables you to move the zero parallax plane\&. Geometry in front of the zero parallax plane will appear to be in front of the screen\&.
.PP
The balance adjustment is multiplied with the focal distance to find the zero parallax plane\&. The default value is 1\&.0, and the zero parallax plane is then at the focal point\&.
.PP
\fBSee also:\fP
.RS 4
\fBSoCamera::focalDistance\fP 
.RE
.PP

.SS "float SoCamera::getBalanceAdjustment (void) const"
Returns the stereo balance adjustment\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetBalanceAdjustment()\fP 
.RE
.PP

.SS "void SoCamera::doAction (\fBSoAction\fP * action)\fC [virtual]\fP"
This function performs the typical operation of a node for any action\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoCamera::callback (\fBSoCallbackAction\fP * action)\fC [virtual]\fP"
Action method for \fBSoCallbackAction\fP\&.
.PP
Simply updates the state according to how the node behaves for the render action, so the application programmer can use the \fBSoCallbackAction\fP for extracting information about the scene graph\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoCamera::GLRender (\fBSoGLRenderAction\fP * action)\fC [virtual]\fP"
Action method for the \fBSoGLRenderAction\fP\&.
.PP
This is called during rendering traversals\&. Nodes influencing the rendering state in any way or who wants to throw geometry primitives at OpenGL overrides this method\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoCamera::audioRender (\fBSoAudioRenderAction\fP * action)\fC [virtual]\fP"
Action method for \fBSoAudioRenderAction\fP\&.
.PP
Does common processing for \fBSoAudioRenderAction\fP \fIaction\fP instances\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoCamera::getBoundingBox (\fBSoGetBoundingBoxAction\fP * action)\fC [virtual]\fP"
Action method for the \fBSoGetBoundingBoxAction\fP\&.
.PP
Calculates bounding box and center coordinates for node and modifies the values of the \fIaction\fP to encompass the bounding box for this node and to shift the center point for the scene more towards the one for this node\&.
.PP
Nodes influencing how geometry nodes calculates their bounding box also overrides this method to change the relevant state variables\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoCamera::getMatrix (\fBSoGetMatrixAction\fP * action)\fC [virtual]\fP"
Action method for \fBSoGetMatrixAction\fP\&.
.PP
Updates \fIaction\fP by accumulating with the transformation matrix of this node (if any)\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoCamera::handleEvent (\fBSoHandleEventAction\fP * action)\fC [virtual]\fP"
Picking actions can be triggered during handle event action traversal, and to do picking we need to know the camera state\&.
.PP
\fBSee also:\fP
.RS 4
\fBSoCamera::rayPick()\fP 
.RE
.PP

.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoCamera::rayPick (\fBSoRayPickAction\fP * action)\fC [virtual]\fP"
Action method for \fBSoRayPickAction\fP\&.
.PP
Checks the ray specification of the \fIaction\fP and tests for intersection with the data of the node\&.
.PP
Nodes influencing relevant state variables for how picking is done also overrides this method\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoCamera::getPrimitiveCount (\fBSoGetPrimitiveCountAction\fP * action)\fC [virtual]\fP"
Action method for the \fBSoGetPrimitiveCountAction\fP\&.
.PP
Calculates the number of triangle, line segment and point primitives for the node and adds these to the counters of the \fIaction\fP\&.
.PP
Nodes influencing how geometry nodes calculates their primitive count also overrides this method to change the relevant state variables\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoCamera::viewBoundingBox (const \fBSbBox3f\fP & box, float aspect, float slack)\fC [pure virtual]\fP"
Convenience method for setting up the camera definition to cover the given bounding \fIbox\fP with the given \fIaspect\fP ratio\&. Multiplies the exact dimensions with a \fIslack\fP factor to have some space between the rendered model and the borders of the rendering area\&.
.PP
If you define your own camera node class, be aware that this method should \fInot\fP set the orientation field of the camera, only the position, focal distance and near and far clipping planes\&. 
.PP
Implemented in \fBSoFrustumCamera\fP, \fBSoOrthographicCamera\fP, and \fBSoPerspectiveCamera\fP\&.
.SS "void SoCamera::jitter (\fBint\fP numpasses, \fBint\fP curpass, const \fBSbViewportRegion\fP & vpreg, \fBSbVec3f\fP & jitteramount) const\fC [protected]\fP, \fC [virtual]\fP"
'Jitter' the camera according to the current rendering pass (\fIcurpass\fP), to get an antialiased rendering of the scene when doing multipass rendering\&. 
.SH "Member Data Documentation"
.PP 
.SS "\fBSoSFEnum\fP SoCamera::viewportMapping"
Set up how the render frame should map the viewport\&. The default is SoCamera::ADJUST_CAMERA\&. 
.SS "\fBSoSFVec3f\fP SoCamera::position"
Camera position\&. Defaults to <0,0,1>\&. 
.SS "\fBSoSFRotation\fP SoCamera::orientation"
Camera orientation specified as a rotation value from the default orientation where the camera is pointing along the negative z-axis, with 'up' along the positive y-axis\&.
.PP
E\&.g\&., to rotate the camera to point along the X axis:
.PP
.PP
.nf
mycamera->orientation\&.setValue(SbRotation(SbVec3f(0, 1, 0), M_PI / 2\&.0f));
.fi
.PP
.PP
For queries, e\&.g\&. to get the current 'up' and 'look at' vectors of the camera:
.PP
.PP
.nf
SbRotation camrot = mycamera->orientation\&.getValue();

SbVec3f upvec(0, 1, 0); // init to default up vector
camrot\&.multVec(upvec, upvec);

SbVec3f lookat(0, 0, -1); // init to default view direction vector
camrot\&.multVec(lookat, lookat);
.fi
.PP
 
.SS "\fBSoSFFloat\fP SoCamera::aspectRatio"
Aspect ratio for the camera (i\&.e\&. width / height)\&. Defaults to 1\&.0\&. 
.SS "\fBSoSFFloat\fP SoCamera::nearDistance"
Distance from camera position to the near clipping plane in the camera's view volume\&.
.PP
Default value is 1\&.0\&. Value must be larger than 0\&.0, or it will not be possible to construct a valid viewing volume (for perspective rendering, at least)\&.
.PP
If you use one of the viewer components from the So[Xt|Qt|Win|Gtk] GUI libraries provided Kongsberg Oil & Gas Technologies, they will automatically update this value for the scene camera according to the scene bounding box\&. Ditto for the far clipping plane\&.
.PP
\fBSee also:\fP
.RS 4
\fBSoCamera::farDistance\fP 
.RE
.PP

.SS "\fBSoSFFloat\fP SoCamera::farDistance"
Distance from camera position to the far clipping plane in the camera's view volume\&.
.PP
Default value is 10\&.0\&. Must be larger than the \fBSoCamera::nearDistance\fP value, or it will not be possible to construct a valid viewing volume\&.
.PP
Note that the range [nearDistance, farDistance] decides the dynamic range of the Z-buffer in the underlying polygon-rendering rasterizer\&. What this means is that if the near and far clipping planes of the camera are wide apart, the possibility of visual artifacts will increase\&. The artifacts will manifest themselves in the form of flickering of primitives close in depth\&.
.PP
It is therefore a good idea to keep the near and far clipping planes of your camera(s) as closely fitted around the geometry of the scene graph as possible\&.
.PP
\fBSee also:\fP
.RS 4
\fBSoCamera::nearDistance\fP, \fBSoPolygonOffset\fP 
.RE
.PP

.SS "\fBSoSFFloat\fP SoCamera::focalDistance"
Distance from camera position to center of scene\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
