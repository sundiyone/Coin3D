.TH "SoShape" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SoShape \- The \fBSoShape\fP class is the superclass for geometry shapes\&.
.PP
The node types which have actual geometry to render inherits this class\&. For convenience, the \fBSoShape\fP class contains various common code used by the subclasses\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Inventor/nodes/SoShape\&.h>\fP
.PP
Inherits \fBSoNode\fP\&.
.PP
Inherited by \fBSoAsciiText\fP, \fBSoCone\fP, \fBSoCube\fP, \fBSoCylinder\fP, \fBSoImage\fP, \fBSoIndexedNurbsCurve\fP, \fBSoIndexedNurbsSurface\fP, \fBSoNurbsCurve\fP, \fBSoNurbsSurface\fP, \fBSoSphere\fP, \fBSoText2\fP, \fBSoText3\fP, \fBSoVertexShape\fP, and \fBSoVRMLGeometry\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBTriangleShape\fP { \fBTRIANGLE_STRIP\fP, \fBTRIANGLE_FAN\fP, \fBTRIANGLES\fP, \fBPOLYGON\fP, \fBQUADS\fP, \fBQUAD_STRIP\fP, \fBPOINTS\fP, \fBLINES\fP, \fBLINE_STRIP\fP }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fBSoType\fP \fBgetTypeId\fP (void) const"
.br
.RI "Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. "
.ti -1c
.RI "virtual SbBool \fBaffectsState\fP (void) const"
.br
.ti -1c
.RI "virtual void \fBnotify\fP (\fBSoNotList\fP *nl)"
.br
.ti -1c
.RI "virtual void \fBgetBoundingBox\fP (\fBSoGetBoundingBoxAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBGLRender\fP (\fBSoGLRenderAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBrayPick\fP (\fBSoRayPickAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBcallback\fP (\fBSoCallbackAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBcomputeBBox\fP (\fBSoAction\fP *action, \fBSbBox3f\fP &box, \fBSbVec3f\fP &center)=0"
.br
.ti -1c
.RI "virtual void \fBgetPrimitiveCount\fP (\fBSoGetPrimitiveCountAction\fP *action)"
.br
.ti -1c
.RI "const \fBSoBoundingBoxCache\fP * \fBgetBoundingBoxCache\fP (void) const"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBSoType\fP \fBgetClassTypeId\fP (void)"
.br
.ti -1c
.RI "static void \fBinitClass\fP (void)"
.br
.ti -1c
.RI "static void \fBgetScreenSize\fP (\fBSoState\fP *const state, const \fBSbBox3f\fP &boundingbox, \fBSbVec2s\fP &rectsize)"
.br
.ti -1c
.RI "static float \fBgetDecimatedComplexity\fP (\fBSoState\fP *state, float complexity)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual const \fBSoFieldData\fP * \fBgetFieldData\fP (void) const"
.br
.ti -1c
.RI "\fBSoShape\fP (void)"
.br
.ti -1c
.RI "virtual \fB~SoShape\fP ()"
.br
.ti -1c
.RI "float \fBgetComplexityValue\fP (\fBSoAction\fP *action)"
.br
.ti -1c
.RI "virtual void \fBgeneratePrimitives\fP (\fBSoAction\fP *action)=0"
.br
.ti -1c
.RI "virtual SbBool \fBshouldGLRender\fP (\fBSoGLRenderAction\fP *action)"
.br
.ti -1c
.RI "void \fBbeginSolidShape\fP (\fBSoGLRenderAction\fP *action)"
.br
.ti -1c
.RI "void \fBendSolidShape\fP (\fBSoGLRenderAction\fP *action)"
.br
.ti -1c
.RI "void \fBGLRenderBoundingBox\fP (\fBSoGLRenderAction\fP *action)"
.br
.ti -1c
.RI "SbBool \fBshouldPrimitiveCount\fP (\fBSoGetPrimitiveCountAction\fP *action)"
.br
.ti -1c
.RI "SbBool \fBshouldRayPick\fP (\fBSoRayPickAction\fP *const action)"
.br
.ti -1c
.RI "void \fBcomputeObjectSpaceRay\fP (\fBSoRayPickAction\fP *const action)"
.br
.ti -1c
.RI "void \fBcomputeObjectSpaceRay\fP (\fBSoRayPickAction\fP *const action, const \fBSbMatrix\fP &matrix)"
.br
.ti -1c
.RI "virtual \fBSoDetail\fP * \fBcreateTriangleDetail\fP (\fBSoRayPickAction\fP *action, const \fBSoPrimitiveVertex\fP *v1, const \fBSoPrimitiveVertex\fP *v2, const \fBSoPrimitiveVertex\fP *v3, \fBSoPickedPoint\fP *pp)"
.br
.ti -1c
.RI "virtual \fBSoDetail\fP * \fBcreateLineSegmentDetail\fP (\fBSoRayPickAction\fP *action, const \fBSoPrimitiveVertex\fP *v1, const \fBSoPrimitiveVertex\fP *v2, \fBSoPickedPoint\fP *pp)"
.br
.ti -1c
.RI "virtual \fBSoDetail\fP * \fBcreatePointDetail\fP (\fBSoRayPickAction\fP *action, const \fBSoPrimitiveVertex\fP *v, \fBSoPickedPoint\fP *pp)"
.br
.ti -1c
.RI "void \fBinvokeTriangleCallbacks\fP (\fBSoAction\fP *const action, const \fBSoPrimitiveVertex\fP *const v1, const \fBSoPrimitiveVertex\fP *const v2, const \fBSoPrimitiveVertex\fP *const v3)"
.br
.ti -1c
.RI "void \fBinvokeLineSegmentCallbacks\fP (\fBSoAction\fP *const action, const \fBSoPrimitiveVertex\fP *const v1, const \fBSoPrimitiveVertex\fP *const v2)"
.br
.ti -1c
.RI "void \fBinvokePointCallbacks\fP (\fBSoAction\fP *const action, const \fBSoPrimitiveVertex\fP *const v)"
.br
.ti -1c
.RI "void \fBbeginShape\fP (\fBSoAction\fP *const action, const \fBTriangleShape\fP shapetype, \fBSoDetail\fP *const detail=NULL)"
.br
.ti -1c
.RI "void \fBshapeVertex\fP (const \fBSoPrimitiveVertex\fP *const v)"
.br
.ti -1c
.RI "void \fBendShape\fP (void)"
.br
.ti -1c
.RI "void \fBgenerateVertex\fP (\fBSoPrimitiveVertex\fP *const pv, const \fBSbVec3f\fP &point, const SbBool useTexFunc, const \fBSoMultiTextureCoordinateElement\fP *const tce, const float s, const float t, const \fBSbVec3f\fP &normal)"
.br
.ti -1c
.RI "void \fBgenerateVertex\fP (\fBSoPrimitiveVertex\fP *const pv, const \fBSbVec3f\fP &point, const SbBool useTexFunc, const \fBSoMultiTextureCoordinateElement\fP *const tce, const float s, const float t, const float r, const \fBSbVec3f\fP &normal)"
.br
.ti -1c
.RI "SbBool \fBstartVertexArray\fP (\fBSoGLRenderAction\fP *action, const \fBSoCoordinateElement\fP *coords, const \fBSbVec3f\fP *pervertexnormals, const SbBool texpervertex, const SbBool colorpervertex)"
.br
.ti -1c
.RI "void \fBfinishVertexArray\fP (\fBSoGLRenderAction\fP *action, const SbBool vbo, const SbBool normpervertex, const SbBool texpervertex, const SbBool colorpervertex)"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static const \fBSoFieldData\fP ** \fBgetFieldDataPtr\fP (void)"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
The \fBSoShape\fP class is the superclass for geometry shapes\&.
.PP
The node types which have actual geometry to render inherits this class\&. For convenience, the \fBSoShape\fP class contains various common code used by the subclasses\&. 
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBSoShape::TriangleShape\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SoShape::SoShape (void)\fC [protected]\fP"
Constructor\&. 
.SS "SoShape::~SoShape ()\fC [protected]\fP, \fC [virtual]\fP"
Destructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBSoType\fP SoShape::getTypeId (void) const\fC [virtual]\fP"

.PP
Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. Usage example:
.PP
.PP
.nf
void foo(SoNode * node)
{
  if (node->getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
.fi
.PP
.PP
For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in \fIall\fP subclasses\&. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance \fBInventor/nodes/SoSubNode\&.h\fP (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), \fBInventor/engines/SoSubEngine\&.h\fP (for engine classes) and so on\&.
.PP
For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups\&. 
.PP
Implements \fBSoBase\fP\&.
.PP
Reimplemented in \fBSoVertexShape\fP, \fBSoVRMLElevationGrid\fP, \fBSoVRMLVertexShape\fP, \fBSoText3\fP, \fBSoImage\fP, \fBSoVRMLIndexedFaceSet\fP, \fBSoIndexedLineSet\fP, \fBSoIndexedFaceSet\fP, \fBSoIndexedTriangleStripSet\fP, \fBSoVRMLIndexedLineSet\fP, \fBSoVRMLText\fP, \fBSoIndexedNurbsSurface\fP, \fBSoAsciiText\fP, \fBSoIndexedNurbsCurve\fP, \fBSoVRMLExtrusion\fP, \fBSoIndexedPointSet\fP, \fBSoNurbsCurve\fP, \fBSoNurbsSurface\fP, \fBSoText2\fP, \fBSoFaceSet\fP, \fBSoIndexedShape\fP, \fBSoIndexedMarkerSet\fP, \fBSoCube\fP, \fBSoVRMLVertexPoint\fP, \fBSoCylinder\fP, \fBSoCone\fP, \fBSoNonIndexedShape\fP, \fBSoVRMLCylinder\fP, \fBSoVRMLGeometry\fP, \fBSoVRMLCone\fP, \fBSoVRMLVertexLine\fP, \fBSoPointSet\fP, \fBSoMarkerSet\fP, \fBSoLineSet\fP, \fBSoTriangleStripSet\fP, \fBSoSphere\fP, \fBSoQuadMesh\fP, \fBSoVRMLBox\fP, \fBSoVRMLIndexedLine\fP, \fBSoVRMLSphere\fP, \fBSoVRMLPointSet\fP, and \fBSoVRMLIndexedShape\fP\&.
.SS "const \fBSoFieldData\fP * SoShape::getFieldData (void) const\fC [protected]\fP, \fC [virtual]\fP"
Returns a pointer to the class-wide field data storage object for this instance\&. If no fields are present, returns \fCNULL\fP\&. 
.PP
Reimplemented from \fBSoFieldContainer\fP\&.
.PP
Reimplemented in \fBSoVertexShape\fP, \fBSoVRMLElevationGrid\fP, \fBSoVRMLVertexShape\fP, \fBSoText3\fP, \fBSoImage\fP, \fBSoVRMLIndexedFaceSet\fP, \fBSoIndexedLineSet\fP, \fBSoIndexedFaceSet\fP, \fBSoIndexedTriangleStripSet\fP, \fBSoVRMLIndexedLineSet\fP, \fBSoVRMLText\fP, \fBSoIndexedNurbsSurface\fP, \fBSoAsciiText\fP, \fBSoIndexedNurbsCurve\fP, \fBSoVRMLExtrusion\fP, \fBSoIndexedPointSet\fP, \fBSoNurbsCurve\fP, \fBSoNurbsSurface\fP, \fBSoText2\fP, \fBSoFaceSet\fP, \fBSoIndexedShape\fP, \fBSoIndexedMarkerSet\fP, \fBSoCube\fP, \fBSoVRMLVertexPoint\fP, \fBSoCylinder\fP, \fBSoCone\fP, \fBSoNonIndexedShape\fP, \fBSoVRMLCylinder\fP, \fBSoVRMLGeometry\fP, \fBSoVRMLCone\fP, \fBSoVRMLVertexLine\fP, \fBSoPointSet\fP, \fBSoMarkerSet\fP, \fBSoLineSet\fP, \fBSoTriangleStripSet\fP, \fBSoSphere\fP, \fBSoQuadMesh\fP, \fBSoVRMLBox\fP, \fBSoVRMLIndexedLine\fP, \fBSoVRMLSphere\fP, \fBSoVRMLPointSet\fP, and \fBSoVRMLIndexedShape\fP\&.
.SS "SbBool SoShape::affectsState (void) const\fC [virtual]\fP"
Returns \fCTRUE\fP if the node could have any effect on the state during traversal\&.
.PP
If it returns \fCFALSE\fP, no data in the traversal-state will change from the pre-traversal state to the post-traversal state\&. The \fBSoSeparator\fP node will for instance return \fCFALSE\fP, as it pushes and pops the state before and after traversal of its children\&. All \fBSoShape\fP nodes will also return \fCFALSE\fP, as just pushing out geometry data to the rendering engine won't affect the actual rendering state\&.
.PP
The default method returns \fCTRUE\fP, on a 'better safe than sorry' philosophy\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SS "void SoShape::notify (\fBSoNotList\fP * l)\fC [virtual]\fP"
Notifies all auditors for this instance when changes are made\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.PP
Reimplemented in \fBSoText3\fP, \fBSoImage\fP, \fBSoVRMLVertexShape\fP, \fBSoVRMLElevationGrid\fP, \fBSoAsciiText\fP, \fBSoVRMLExtrusion\fP, \fBSoVRMLText\fP, \fBSoVRMLIndexedLine\fP, \fBSoVRMLIndexedLineSet\fP, \fBSoVertexShape\fP, \fBSoIndexedLineSet\fP, \fBSoVRMLVertexPoint\fP, \fBSoVRMLGeometry\fP, \fBSoVRMLVertexLine\fP, \fBSoVRMLIndexedShape\fP, and \fBSoIndexedPointSet\fP\&.
.SS "void SoShape::getBoundingBox (\fBSoGetBoundingBoxAction\fP * action)\fC [virtual]\fP"
Action method for the \fBSoGetBoundingBoxAction\fP\&.
.PP
Calculates bounding box and center coordinates for node and modifies the values of the \fIaction\fP to encompass the bounding box for this node and to shift the center point for the scene more towards the one for this node\&.
.PP
Nodes influencing how geometry nodes calculates their bounding box also overrides this method to change the relevant state variables\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.PP
Reimplemented in \fBSoVRMLVertexShape\fP, \fBSoIndexedNurbsCurve\fP, \fBSoNurbsCurve\fP, \fBSoVRMLIndexedLineSet\fP, \fBSoIndexedLineSet\fP, \fBSoVRMLVertexPoint\fP, \fBSoVRMLVertexLine\fP, \fBSoIndexedPointSet\fP, \fBSoLineSet\fP, \fBSoPointSet\fP, and \fBSoVRMLPointSet\fP\&.
.SS "void SoShape::GLRender (\fBSoGLRenderAction\fP * action)\fC [virtual]\fP"
Action method for the \fBSoGLRenderAction\fP\&.
.PP
This is called during rendering traversals\&. Nodes influencing the rendering state in any way or who wants to throw geometry primitives at OpenGL overrides this method\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.PP
Reimplemented in \fBSoMarkerSet\fP, \fBSoVRMLVertexShape\fP, \fBSoText3\fP, \fBSoImage\fP, \fBSoVRMLElevationGrid\fP, \fBSoCylinder\fP, \fBSoVRMLText\fP, \fBSoIndexedNurbsSurface\fP, \fBSoAsciiText\fP, \fBSoCone\fP, \fBSoVRMLExtrusion\fP, \fBSoText2\fP, \fBSoNurbsSurface\fP, \fBSoVRMLIndexedFaceSet\fP, \fBSoIndexedNurbsCurve\fP, \fBSoVRMLCylinder\fP, \fBSoNurbsCurve\fP, \fBSoCube\fP, \fBSoVRMLCone\fP, \fBSoIndexedLineSet\fP, \fBSoIndexedFaceSet\fP, \fBSoIndexedTriangleStripSet\fP, \fBSoVRMLIndexedLineSet\fP, \fBSoVRMLVertexPoint\fP, \fBSoVRMLVertexLine\fP, \fBSoFaceSet\fP, \fBSoIndexedMarkerSet\fP, \fBSoIndexedPointSet\fP, \fBSoLineSet\fP, \fBSoQuadMesh\fP, \fBSoPointSet\fP, \fBSoTriangleStripSet\fP, \fBSoSphere\fP, \fBSoVRMLBox\fP, \fBSoVRMLSphere\fP, and \fBSoVRMLPointSet\fP\&.
.SS "void SoShape::rayPick (\fBSoRayPickAction\fP * action)\fC [virtual]\fP"
Calculates picked point based on primitives generated by subclasses\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.PP
Reimplemented in \fBSoImage\fP, \fBSoVRMLElevationGrid\fP, \fBSoIndexedNurbsSurface\fP, \fBSoCylinder\fP, \fBSoCone\fP, \fBSoText2\fP, \fBSoNurbsSurface\fP, \fBSoIndexedNurbsCurve\fP, \fBSoVRMLCylinder\fP, \fBSoNurbsCurve\fP, \fBSoCube\fP, \fBSoVRMLCone\fP, \fBSoSphere\fP, \fBSoVRMLBox\fP, and \fBSoVRMLSphere\fP\&.
.SS "void SoShape::callback (\fBSoCallbackAction\fP * action)\fC [virtual]\fP"
Action method for \fBSoCallbackAction\fP\&.
.PP
Simply updates the state according to how the node behaves for the render action, so the application programmer can use the \fBSoCallbackAction\fP for extracting information about the scene graph\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.PP
Reimplemented in \fBSoVRMLVertexShape\fP, \fBSoVRMLVertexPoint\fP, and \fBSoVRMLVertexLine\fP\&.
.SS "void SoShape::computeBBox (\fBSoAction\fP * action, \fBSbBox3f\fP & box, \fBSbVec3f\fP & center)\fC [pure virtual]\fP"
Implemented by \fBSoShape\fP subclasses to let the \fBSoShape\fP superclass know the exact size and weighted center point of the shape's bounding box\&.
.PP
The bounding box and center point should be calculated and returned in the local coordinate system\&.
.PP
The method implements action behavior for shape nodes for \fBSoGetBoundingBoxAction\fP\&. It is invoked from \fBSoShape::getBoundingBox()\fP\&. (Subclasses should \fInot\fP override \fBSoNode::getBoundingBox()\fP\&.)
.PP
The \fIbox\fP parameter sent in is guaranteed to be an empty box, while \fIcenter\fP is undefined upon function entry\&. 
.PP
Implemented in \fBSoText3\fP, \fBSoImage\fP, \fBSoVRMLElevationGrid\fP, \fBSoVRMLText\fP, \fBSoIndexedNurbsSurface\fP, \fBSoCylinder\fP, \fBSoCone\fP, \fBSoAsciiText\fP, \fBSoNurbsSurface\fP, \fBSoText2\fP, \fBSoIndexedNurbsCurve\fP, \fBSoVRMLVertexPoint\fP, \fBSoVRMLExtrusion\fP, \fBSoNurbsCurve\fP, \fBSoVRMLCylinder\fP, \fBSoCube\fP, \fBSoVRMLCone\fP, \fBSoFaceSet\fP, \fBSoQuadMesh\fP, \fBSoLineSet\fP, \fBSoPointSet\fP, \fBSoTriangleStripSet\fP, \fBSoIndexedShape\fP, \fBSoSphere\fP, \fBSoVRMLBox\fP, \fBSoVRMLSphere\fP, \fBSoVRMLIndexedShape\fP, and \fBSoVRMLIndexedLine\fP\&.
.SS "void SoShape::getPrimitiveCount (\fBSoGetPrimitiveCountAction\fP * action)\fC [virtual]\fP"
Action method for the \fBSoGetPrimitiveCountAction\fP\&.
.PP
Calculates the number of triangle, line segment and point primitives for the node and adds these to the counters of the \fIaction\fP\&.
.PP
Nodes influencing how geometry nodes calculates their primitive count also overrides this method to change the relevant state variables\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.PP
Reimplemented in \fBSoMarkerSet\fP, \fBSoText3\fP, \fBSoImage\fP, \fBSoVRMLElevationGrid\fP, \fBSoIndexedNurbsSurface\fP, \fBSoCylinder\fP, \fBSoCone\fP, \fBSoVRMLText\fP, \fBSoAsciiText\fP, \fBSoVRMLExtrusion\fP, \fBSoText2\fP, \fBSoNurbsSurface\fP, \fBSoVRMLIndexedFaceSet\fP, \fBSoIndexedNurbsCurve\fP, \fBSoVRMLCylinder\fP, \fBSoVRMLVertexPoint\fP, \fBSoNurbsCurve\fP, \fBSoCube\fP, \fBSoVRMLCone\fP, \fBSoIndexedLineSet\fP, \fBSoIndexedFaceSet\fP, \fBSoFaceSet\fP, \fBSoIndexedTriangleStripSet\fP, \fBSoVRMLIndexedLineSet\fP, \fBSoIndexedPointSet\fP, \fBSoLineSet\fP, \fBSoPointSet\fP, \fBSoSphere\fP, \fBSoQuadMesh\fP, \fBSoVRMLBox\fP, \fBSoVRMLSphere\fP, and \fBSoTriangleStripSet\fP\&.
.SS "void SoShape::getScreenSize (\fBSoState\fP *const state, const \fBSbBox3f\fP & boundingbox, \fBSbVec2s\fP & rectsize)\fC [static]\fP"
A convenience function that returns the size of a \fIboundingbox\fP projected onto the screen\&. Useful for \fCSCREEN_SPACE\fP complexity geometry\&. 
.SS "float SoShape::getDecimatedComplexity (\fBSoState\fP * state, float complexity)\fC [static]\fP"
Not implemented in Coin\&. Should probably have been private in TGS Inventor API\&. 
.SS "const \fBSoBoundingBoxCache\fP * SoShape::getBoundingBoxCache (void) const"
Return the bounding box cache for this shape\&. It might return NULL if no bounding box cache has been created\&. If not NULL, the caller must check if the cache is valid before using it\&. This can be done using \fBSoCache::isValid()\fP\&.
.PP
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2\&.1 API\&.
.PP
\fBSince:\fP
.RS 4
Coin 2\&.0 
.RE
.PP

.SS "float SoShape::getComplexityValue (\fBSoAction\fP * action)\fC [protected]\fP"
Returns the complexity value to be used by subclasses\&. Considers complexity type\&. For \fCOBJECT_SPACE\fP complexity this will be a number between 0 and 1\&. For \fCSCREEN_SPACE\fP complexity it is a number from 0 and up\&. 
.SS "void SoShape::generatePrimitives (\fBSoAction\fP * action)\fC [protected]\fP, \fC [pure virtual]\fP"
The method implements action behavior for shape nodes for \fBSoCallbackAction\fP\&. It is invoked from \fBSoShape::callback()\fP\&. (Subclasses should \fInot\fP override \fBSoNode::callback()\fP\&.)
.PP
The subclass implementations uses the convenience methods \fBSoShape::beginShape()\fP, \fBSoShape::shapeVertex()\fP, and \fBSoShape::endShape()\fP, with \fBSoDetail\fP instances, to pass the primitives making up the shape back to the caller\&. 
.PP
Implemented in \fBSoText3\fP, \fBSoImage\fP, \fBSoVRMLElevationGrid\fP, \fBSoVRMLText\fP, \fBSoVRMLExtrusion\fP, \fBSoIndexedNurbsSurface\fP, \fBSoCylinder\fP, \fBSoAsciiText\fP, \fBSoCone\fP, \fBSoVRMLIndexedFaceSet\fP, \fBSoNurbsSurface\fP, \fBSoText2\fP, \fBSoIndexedNurbsCurve\fP, \fBSoIndexedFaceSet\fP, \fBSoNurbsCurve\fP, \fBSoVRMLCylinder\fP, \fBSoIndexedTriangleStripSet\fP, \fBSoCube\fP, \fBSoVRMLCone\fP, \fBSoIndexedPointSet\fP, \fBSoFaceSet\fP, \fBSoQuadMesh\fP, \fBSoVRMLIndexedLineSet\fP, \fBSoLineSet\fP, \fBSoPointSet\fP, \fBSoTriangleStripSet\fP, \fBSoSphere\fP, \fBSoVRMLBox\fP, \fBSoVRMLSphere\fP, and \fBSoVRMLPointSet\fP\&.
.SS "SbBool SoShape::shouldGLRender (\fBSoGLRenderAction\fP * action)\fC [protected]\fP, \fC [virtual]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.PP
Reimplemented in \fBSoVRMLVertexShape\fP, \fBSoVertexShape\fP, \fBSoVRMLVertexPoint\fP, \fBSoVRMLVertexLine\fP, and \fBSoVRMLGeometry\fP\&.
.SS "void SoShape::beginSolidShape (\fBSoGLRenderAction\fP * action)\fC [protected]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "void SoShape::endSolidShape (\fBSoGLRenderAction\fP * action)\fC [protected]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "void SoShape::GLRenderBoundingBox (\fBSoGLRenderAction\fP * action)\fC [protected]\fP"
Render a bounding box\&. 
.SS "SbBool SoShape::shouldPrimitiveCount (\fBSoGetPrimitiveCountAction\fP * action)\fC [protected]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "SbBool SoShape::shouldRayPick (\fBSoRayPickAction\fP *const action)\fC [protected]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "void SoShape::computeObjectSpaceRay (\fBSoRayPickAction\fP *const action)\fC [protected]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "void SoShape::computeObjectSpaceRay (\fBSoRayPickAction\fP *const action, const \fBSbMatrix\fP & matrix)\fC [protected]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "\fBSoDetail\fP * SoShape::createTriangleDetail (\fBSoRayPickAction\fP * action, const \fBSoPrimitiveVertex\fP * v1, const \fBSoPrimitiveVertex\fP * v2, const \fBSoPrimitiveVertex\fP * v3, \fBSoPickedPoint\fP * pp)\fC [protected]\fP, \fC [virtual]\fP"
Will create triangle detail for a \fBSoPickedPoint\fP\&. This method will only be called internally, when \fBgeneratePrimitives()\fP is used for picking (\fBSoShape::rayPick()\fP is not overridden)\&.
.PP
This method returns \fCNULL\fP in Open Inventor, and subclasses will need to override this method to create details for a \fBSoPickedPoint\fP\&.
.PP
This is not necessary with Coin\&. Of course, if you choose to override it, it will work in the same way as Open Inventor\&.
.PP
For this to work, you must supply a face or line detail when generating primitives\&. If you supply \fCNULL\fP for the detail argument in \fBSoShape::beginShape()\fP, you'll have to override this method\&. 
.PP
Reimplemented in \fBSoText3\fP, \fBSoVRMLExtrusion\fP, \fBSoIndexedNurbsSurface\fP, \fBSoAsciiText\fP, and \fBSoNurbsSurface\fP\&.
.SS "\fBSoDetail\fP * SoShape::createLineSegmentDetail (\fBSoRayPickAction\fP * action, const \fBSoPrimitiveVertex\fP * v1, const \fBSoPrimitiveVertex\fP * v2, \fBSoPickedPoint\fP * pp)\fC [protected]\fP, \fC [virtual]\fP"
Will create line detail for a \fBSoPickedPoint\fP\&. This method will only be called internally, when \fBgeneratePrimitives()\fP is used for picking (\fBSoShape::rayPick()\fP is not overridden)\&.
.PP
This method returns \fCNULL\fP in Open Inventor, and subclasses will need to override this method to create details for a \fBSoPickedPoint\fP\&.
.PP
This is not necessary with Coin\&. Of course, if you choose to override it, it will work in the same way as Open Inventor\&.
.PP
For this to work, you must supply a face or line detail when generating primitives\&. If you supply \fCNULL\fP for the detail argument in \fBSoShape::beginShape()\fP, you'll have to override this method\&. 
.PP
Reimplemented in \fBSoIndexedNurbsCurve\fP, and \fBSoNurbsCurve\fP\&.
.SS "\fBSoDetail\fP * SoShape::createPointDetail (\fBSoRayPickAction\fP * action, const \fBSoPrimitiveVertex\fP * v, \fBSoPickedPoint\fP * pp)\fC [protected]\fP, \fC [virtual]\fP"
Will create point detail for a \fBSoPickedPoint\fP\&. This method will only be called internally, when \fBgeneratePrimitives()\fP is used for picking (\fBSoShape::rayPick()\fP is not overridden)\&.
.PP
This method returns \fCNULL\fP in Open Inventor, and subclasses will need to override this method to create details for a \fBSoPickedPoint\fP\&.
.PP
This is not necessary with Coin\&. Of course, if you choose to override it, it will work in the same way as Open Inventor\&.
.PP
For this to work, you must supply a point detail in the \fBSoPrimitiveVertex\fP in \fBgeneratePrimitives()\fP\&. 
.SS "void SoShape::invokeTriangleCallbacks (\fBSoAction\fP *const action, const \fBSoPrimitiveVertex\fP *const v1, const \fBSoPrimitiveVertex\fP *const v2, const \fBSoPrimitiveVertex\fP *const v3)\fC [protected]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "void SoShape::invokeLineSegmentCallbacks (\fBSoAction\fP *const action, const \fBSoPrimitiveVertex\fP *const v1, const \fBSoPrimitiveVertex\fP *const v2)\fC [protected]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "void SoShape::invokePointCallbacks (\fBSoAction\fP *const action, const \fBSoPrimitiveVertex\fP *const v)\fC [protected]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "void SoShape::beginShape (\fBSoAction\fP *const action, const \fBTriangleShape\fP shapetype, \fBSoDetail\fP *const detail = \fCNULL\fP)\fC [protected]\fP"
This method is used to generate primitives for a shape\&. It's typically called from a node's \fBgeneratePrimitives()\fP method\&. If you have your own shape and want to write a \fBgeneratePrimitives()\fP method for that shape, it's probably a good idea to take a peek in the \fBgeneratePrimitives()\fP method for a similar shape in Coin\&.
.PP
\fBgeneratePrimitives()\fP can contain several \fBbeginShape()\fP/endShape() sequences\&. \fBshapeVertex()\fP is used for each vertex between \fBbeginShape()\fP and \fBendShape()\fP\&. For instance, to generate primitives for a triangle you'd do something like this:
.PP
.PP
.nf
SoPrimitiveVertex vertex;

this->beginShape(action, SoShape::POLYGON);
vertex.setPoint(SbVec3f(0.0f, 0.0f, 0.0f));
this->shapeVertex(&vertex);
vertex.setPoint(SbVec3f(1.0f, 0.0f, 0.0f));
this->shapeVertex(&vertex);
vertex.setPoint(SbVec3f(1.0f, 1.0f, 0.0f));
this->shapeVertex(&vertex);
this->endShape();
.fi
.PP
.PP
Note that the \fBSoPrimitiveVertex\fP instance can simply be placed on the stack and not allocated\&. \fBSoShape\fP will copy the needed information when you call \fBshapeVertex()\fP\&.
.PP
Before calling \fBshapeVertex()\fP, you can set extra information for the \fBSoPrimitiveVertex\fP, including normal, material index, and texture coordinates\&.
.PP
This method is slightly different from its counterpart from the original Open Inventor library, as this method has an \fBSoDetail\fP as the last argument, and not an \fBSoFaceDetail\fP\&. This is because we accept more TriangleShape types, and the detail might be a \fBSoFaceDetail\fP or a \fBSoLineDetail\fP\&. There is no use sending in a \fBSoPointDetail\fP, as nothing will be done with it\&. 
.SS "void SoShape::shapeVertex (const \fBSoPrimitiveVertex\fP *const v)\fC [protected]\fP"
This method is used while generating primitives for a shape\&. See \fBbeginShape()\fP for more details\&.
.PP
\fBSee also:\fP
.RS 4
\fBbeginShape()\fP, \fBendShape()\fP 
.RE
.PP

.SS "void SoShape::endShape (void)\fC [protected]\fP"
This method is used while generating primitives for a shape\&. See \fBbeginShape()\fP for more details\&.
.PP
\fBSee also:\fP
.RS 4
\fBbeginShape()\fP, \fBshapeVertex()\fP 
.RE
.PP

.SS "void SoShape::generateVertex (\fBSoPrimitiveVertex\fP *const pv, const \fBSbVec3f\fP & point, const SbBool usetexfunc, const \fBSoMultiTextureCoordinateElement\fP *const tce, const float s, const float t, const \fBSbVec3f\fP & normal)\fC [protected]\fP"
Convenience function which sets up an \fBSoPrimitiveVertex\fP, and sends it using the \fBSoShape::shapeVertex()\fP function\&. 2D version 
.SS "void SoShape::generateVertex (\fBSoPrimitiveVertex\fP *const pv, const \fBSbVec3f\fP & point, const SbBool usetexfunc, const \fBSoMultiTextureCoordinateElement\fP *const tce, const float s, const float t, const float r, const \fBSbVec3f\fP & normal)\fC [protected]\fP"
Convenience function which sets up an \fBSoPrimitiveVertex\fP, and sends it using the \fBSoShape::shapeVertex()\fP function\&. 3D version\&.
.PP
This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2\&.1 API\&.
.PP
\fBSince:\fP
.RS 4
Coin 2\&.0 
.RE
.PP

.SS "SbBool SoShape::startVertexArray (\fBSoGLRenderAction\fP * action, const \fBSoCoordinateElement\fP * coords, const \fBSbVec3f\fP * pervertexnormals, const SbBool texpervertex, const SbBool colorpervertex)\fC [protected]\fP"
Convenience method that enables vertex arrays and/or VBOs Returns \fITRUE\fP if VBO is used\&.
.PP
\fBSee also:\fP
.RS 4
\fBfinishVertexArray()\fP 
.RE
.PP
\fBSince:\fP
.RS 4
Coin 3\&.0 
.RE
.PP

.SS "void SoShape::finishVertexArray (\fBSoGLRenderAction\fP * action, const SbBool vbo, const SbBool normpervertex, const SbBool texpervertex, const SbBool colorpervertex)\fC [protected]\fP"
Should be called after rendering with vertex arrays\&. This method will disable arrays and VBOs enabled in the \fBstartVertexArray()\fP function\&.
.PP
\fBSee also:\fP
.RS 4
\fBstartVertexArray()\fP 
.RE
.PP
\fBSince:\fP
.RS 4
Coin 3\&.0 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
