.TH "SoTextureScalePolicy" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SoTextureScalePolicy \- The \fBSoTextureScalePolicy\fP class is a node for controlling the texture scale policy\&.
.PP
If a texture map is of size != 2^n, it must be scaled before OpenGL can handle it\&. This node enables you to control how/if textures are scaled before it is sent to OpenGL\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Inventor/nodes/SoTextureScalePolicy\&.h>\fP
.PP
Inherits \fBSoNode\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBPolicy\fP { \fBUSE_TEXTURE_QUALITY\fP, \fBSCALE_DOWN\fP, \fBSCALE_UP\fP, \fBFRACTURE\fP }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fBSoType\fP \fBgetTypeId\fP (void) const"
.br
.RI "Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. "
.ti -1c
.RI "\fBSoTextureScalePolicy\fP (void)"
.br
.ti -1c
.RI "virtual void \fBGLRender\fP (\fBSoGLRenderAction\fP *action)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBSoType\fP \fBgetClassTypeId\fP (void)"
.br
.ti -1c
.RI "static void \fBinitClass\fP (void)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBSoSFEnum\fP \fBpolicy\fP"
.br
.ti -1c
.RI "\fBSoSFFloat\fP \fBquality\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual const \fBSoFieldData\fP * \fBgetFieldData\fP (void) const"
.br
.ti -1c
.RI "virtual \fB~SoTextureScalePolicy\fP ()"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static const \fBSoFieldData\fP ** \fBgetFieldDataPtr\fP (void)"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
The \fBSoTextureScalePolicy\fP class is a node for controlling the texture scale policy\&.
.PP
If a texture map is of size != 2^n, it must be scaled before OpenGL can handle it\&. This node enables you to control how/if textures are scaled before it is sent to OpenGL\&. 

Also, if a texture map is bigger than the maximum OpenGL texture size (implementation and context dependent), it will be scaled down to the maximum size\&. You can avoid this by setting the texture policy to \fBSoTextureScalePolicy::FRACTURE\fP, in which case the texture will be split into several small subtextures before the geometry using the texture is rendered\&.
.PP
Setting \fBSoTextureScalePolicy::policy\fP to \fBSoTextureScalePolicy::FRACTURE\fP will also cause the internal texture handling unit in Coin to automatically downsample the individual subtextures to not use more graphics card memory than necessary to cover the current screen size of the texture\&.
.PP
These two aspects of \fBSoTextureScalePolicy::FRACTURE\fP rendering together, subtexture fracturing and automatic downsampling, makes it possible to have textures with almost unlimited size\&. The only real limit is the amount of memory on the system, since the entire texture must fit into CPU memory\&.
.PP
The \fBSoTextureScalePolicy::FRACTURE\fP policy is also very handy for using the Coin library's built-in handling of non-power-of-2 textures\&. This will then be done completely transparent to the application programmer, for maximum convenience\&. Below is a very simple example which demonstrates how to use it\&. The texture has dimensions 3x3, but no scaling (and thereby interpolation) will have to be done when \fBSoTextureScalePolicy::FRACTURE\fP is specified:
.PP
.PP
.nf
#Inventor V2.1 ascii

Separator {
   TextureScalePolicy { policy FRACTURE }
   Complexity { textureQuality 0.01 }  # don't generate smoothed mipmaps
   Texture2 { 
      image 3 3 4  # dimensions 3x3, RGBA (4-component) image
      0xff0000ff 0x00ff00ff 0x0000ffff  # red, green, blue
      0xffff00ff 0xff00ffff 0x00ffffff  # yellow, magenta, cyan
      0x222222ff 0x777777ff 0xccccccff  # dark, medium and light grey
   }
   Cube { }
}
.fi
.PP
.PP
Be aware that the triangle throughput is much slower when using the FRACTURE texture mode, since all triangles need to be clipped (using the CPU) against subtextures\&. It's therefore usually not a good idea to use the FRACTURE mode on large triangle meshes\&.
.PP
Be aware that this class is an extension for Coin, and it is not available in the original SGI Open Inventor v2\&.1 API\&.
.PP
\fBFILE FORMAT/DEFAULTS:\fP 
.PP
.nf
TextureScalePolicy {
    policy USE_TEXTURE_QUALITY
    quality 0\&.5
}

.fi
.PP
.PP
\fBSince:\fP
.RS 4
Coin 2\&.0 
.RE
.PP

.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBSoTextureScalePolicy::Policy\fP"
Enumerates the available policy settings\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIUSE_TEXTURE_QUALITY \fP\fP
Uses the texture quality to decide whether to scale up or down\&. 
.TP
\fB\fISCALE_DOWN \fP\fP
Always scales down\&. 
.TP
\fB\fISCALE_UP \fP\fP
Always scales up\&. 
.TP
\fB\fIFRACTURE \fP\fP
Splits the texture into several subtextures, and clips the geometry into each subtexture\&. Also automatically downsamples the subtextures to not use more graphics card memory than necessary versus the current screen size of the texture\&.
.PP
These two features makes it possible to have textures with almost unlimited size\&. The only real limit is the amount of memory on the system, since the entire texture must fit into CPU memory\&.
.PP
Be aware that the rendering is quite slow with this mode if the texture(s) will be mapped onto lots of polygon primitives\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SoTextureScalePolicy::SoTextureScalePolicy (void)"
Constructor\&. 
.SS "SoTextureScalePolicy::~SoTextureScalePolicy ()\fC [protected]\fP, \fC [virtual]\fP"
Destructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBSoType\fP SoTextureScalePolicy::getTypeId (void) const\fC [virtual]\fP"

.PP
Returns the type identification of an object derived from a class inheriting \fBSoBase\fP\&. This is used for run-time type checking and 'downward' casting\&. Usage example:
.PP
.PP
.nf
void foo(SoNode * node)
{
  if (node->getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
.fi
.PP
.PP
For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in \fIall\fP subclasses\&. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance \fBInventor/nodes/SoSubNode\&.h\fP (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), \fBInventor/engines/SoSubEngine\&.h\fP (for engine classes) and so on\&.
.PP
For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups\&. 
.PP
Implements \fBSoBase\fP\&.
.SS "const \fBSoFieldData\fP * SoTextureScalePolicy::getFieldData (void) const\fC [protected]\fP, \fC [virtual]\fP"
Returns a pointer to the class-wide field data storage object for this instance\&. If no fields are present, returns \fCNULL\fP\&. 
.PP
Reimplemented from \fBSoFieldContainer\fP\&.
.SS "void SoTextureScalePolicy::GLRender (\fBSoGLRenderAction\fP * action)\fC [virtual]\fP"
Action method for the \fBSoGLRenderAction\fP\&.
.PP
This is called during rendering traversals\&. Nodes influencing the rendering state in any way or who wants to throw geometry primitives at OpenGL overrides this method\&. 
.PP
Reimplemented from \fBSoNode\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBSoSFEnum\fP SoTextureScalePolicy::policy"
The policy setting\&. Default value is USE_TEXTURE_QUALITY\&.
.PP
USE_TEXTURE_QUALITY means that \fBSoComplexity::textureQuality\fP will be used to decide if the texture should be scaled up or down\&. \fBSoComplexity::textureQuality\fP >= 0\&.7 means scale up, while < 0\&.7 means scale down\&. Textures smaller than 256 pixels are never scaled down since you lose too much information\&. 
.SS "\fBSoSFFloat\fP SoTextureScalePolicy::quality"
The texture scale/resize quality\&. Default value is 0\&.5\&.
.PP
This field can be used to force Coin to use a lower quality (but much faster) image resize function\&. Currently, if you set this field to a value < 0\&.5, a low quality resize function will be used, otherwise a high quality (but slow) function will be used\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
