.TH "SoReorganizeAction" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SoReorganizeAction \- The \fBSoReorganizeAction\fP class reorganizes your scene graph to optimize traversal/rendering\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Inventor/actions/SoReorganizeAction\&.h>\fP
.PP
Inherits \fBSoSimplifyAction\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fBSoType\fP \fBgetTypeId\fP (void) const"
.br
.ti -1c
.RI "\fBSoReorganizeAction\fP (SoSimplifier *simplifier=NULL)"
.br
.ti -1c
.RI "virtual \fB~SoReorganizeAction\fP (void)"
.br
.ti -1c
.RI "\fBSoSeparator\fP * \fBgetSimplifiedSceneGraph\fP (void) const"
.br
.ti -1c
.RI "void \fBgenerateNormals\fP (SbBool onoff)"
.br
.ti -1c
.RI "SbBool \fBareNormalGenerated\fP (void) const"
.br
.ti -1c
.RI "void \fBgenerateTriangleStrips\fP (SbBool onoff)"
.br
.ti -1c
.RI "SbBool \fBareTriangleStripGenerated\fP (void) const"
.br
.ti -1c
.RI "void \fBgenerateTexCoords\fP (SbBool onoff)"
.br
.ti -1c
.RI "SbBool \fBareTexCoordsGenerated\fP (void) const"
.br
.ti -1c
.RI "void \fBgenerateVPNodes\fP (SbBool onoff)"
.br
.ti -1c
.RI "SbBool \fBareVPNodesGenerated\fP (void)"
.br
.ti -1c
.RI "void \fBmatchIndexArrays\fP (SbBool onoff)"
.br
.ti -1c
.RI "SbBool \fBareIndexArraysMatched\fP (void) const"
.br
.ti -1c
.RI "SoSimplifier * \fBgetSimplifier\fP (void) const"
.br
.ti -1c
.RI "virtual void \fBapply\fP (\fBSoNode\fP *root)"
.br
.ti -1c
.RI "virtual void \fBapply\fP (\fBSoPath\fP *path)"
.br
.ti -1c
.RI "virtual void \fBapply\fP (const \fBSoPathList\fP &pathlist, SbBool obeysrules=FALSE)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBSoType\fP \fBgetClassTypeId\fP (void)"
.br
.ti -1c
.RI "static void \fBaddMethod\fP (const \fBSoType\fP type, \fBSoActionMethod\fP method)"
.br
.ti -1c
.RI "static void \fBenableElement\fP (const \fBSoType\fP type, const \fBint\fP stackindex)"
.br
.ti -1c
.RI "static void \fBinitClass\fP (void)"
.br
.ti -1c
.RI "static void \fBstartReport\fP (const char *msg)"
.br
.ti -1c
.RI "static void \fBfinishReport\fP (void)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual const \fBSoEnabledElementsList\fP & \fBgetEnabledElements\fP (void) const"
.br
.ti -1c
.RI "virtual void \fBbeginTraversal\fP (\fBSoNode\fP *node)"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static \fBSoEnabledElementsList\fP * \fBgetClassEnabledElements\fP (void)"
.br
.ti -1c
.RI "static \fBSoActionMethodList\fP * \fBgetClassActionMethods\fP (void)"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
The \fBSoReorganizeAction\fP class reorganizes your scene graph to optimize traversal/rendering\&. 

Note\&. This is work-in-progress\&. pederb, 2005-04-05\&.
.PP
The code below is an example of a program that applies an \fBSoReorganizeAction\fP on a scene graph, converting all shapes into shapes that can be rendered using vertex array or VBO rendering\&.
.PP
.PP
.nf
#include <Inventor/SoDB\&.h>
#include <Inventor/nodes/SoSeparator\&.h>
#include <Inventor/nodes/SoCoordinate3\&.h>
#include <Inventor/nodes/SoCoordinate4\&.h>
#include <Inventor/nodes/SoNormal\&.h>
#include <Inventor/nodes/SoTextureCoordinate2\&.h>
#include <Inventor/nodes/SoSeparator\&.h>
#include <Inventor/actions/SoWriteAction\&.h>
#include <Inventor/actions/SoSearchAction\&.h>
#include <Inventor/errors/SoDebugError\&.h>
#include <Inventor/nodes/SoShapeHints\&.h>
#include <Inventor/SoInput\&.h>
#include <Inventor/SoOutput\&.h>
#include <Inventor/SoInteraction\&.h>
#include <Inventor/actions/SoReorganizeAction\&.h>
#include <cassert>
#include <cstdio>

static void strip_node(SoType type, SoNode * root)
{
  SoSearchAction sa;
  sa\&.setType(type);
  sa\&.setSearchingAll(TRUE);
  sa\&.setInterest(SoSearchAction::ALL);
  sa\&.apply(root);

  SoPathList & pl = sa\&.getPaths();
  for (int i = 0; i < pl\&.getLength(); i++) {
    SoFullPath * p = (SoFullPath*) pl[i];
      if (p->getTail()->isOfType(type)) {
        SoGroup * g = (SoGroup*) p->getNodeFromTail(1);
        g->removeChild(p->getIndexFromTail(0));
      }
    }
  sa\&.reset();
}

int
main(int argc, char ** argv )
{
  if (argc < 3) {
    fprintf(stderr,"Usage: reorganize <infile> <outfile> [nostrip]\n");
    return -1;
  }

  SbBool strip = TRUE;
  if (argc > 3) {
    if (strcmp(argv[3], "nostrip") == 0) strip = FALSE;
    else {
      fprintf(stderr,"Usage: reorganize <infile> <outfile> [nostrip]\n");
      return -1;
    }
  }

  SoDB::init();
  SoInteraction::init();

  SoInput input;
  SbBool ok = input\&.openFile(argv[1]);
  if (!ok) {
    fprintf(stderr,"Unable to open file\&.\n");
    return -1;
  }
  SoSeparator * root = SoDB::readAll(&input);

  SbBool vrml1 = input\&.isFileVRML1();
  SbBool vrml2 = input\&.isFileVRML2();

  if (vrml2) {
    fprintf(stderr,"VRML2 not supported yet\n");
    return -1;
  }

  if (!root) {
    fprintf(stderr,"Unable to read file\&.\n");
    return -1;
  }
  root->ref();

  fprintf(stderr,"Applying SoReorganizeAction\&.\&.\&.");
  SoReorganizeAction reorg;
  reorg\&.apply(root);
  fprintf(stderr,"done\n");

  SoOutput out;
  if (out\&.openFile(argv[2])) {
    if (strip) { // strip coord3, texcoord and normal nodes
      fprintf(stderr,"stripping old nodes from scene graph\n");
      strip_node(SoCoordinate3::getClassTypeId(), root);
      strip_node(SoCoordinate4::getClassTypeId(), root);
      strip_node(SoNormal::getClassTypeId(), root);
      strip_node(SoTextureCoordinate2::getClassTypeId(), root);
    }
    fprintf(stderr,"writing target\n");
    SoWriteAction wa(&out);
    wa\&.apply(root);
  }
  root->unref();
  return 0;
} // main()
.fi
.PP
.PP
\fBSince:\fP
.RS 4
Coin 2\&.5 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "SoReorganizeAction::SoReorganizeAction (SoSimplifier * simplifier = \fCNULL\fP)"
A constructor\&. 
.SS "SoReorganizeAction::~SoReorganizeAction (void)\fC [virtual]\fP"
The destructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBSoType\fP SoReorganizeAction::getTypeId (void) const\fC [virtual]\fP"
Returns the type identification of an action derived from a class inheriting \fBSoAction\fP\&. This is used for run-time type checking and 'downward' casting\&.
.PP
Usage example:
.PP
.PP
.nf
void bar(SoAction * action)
{
  if (action->getTypeId() == SoGLRenderAction::getClassTypeId()) {
    // safe downward cast, know the type
    SoGLRenderAction * glrender = (SoGLRenderAction *)action;
  }
  return; // ignore if not renderaction
}
.fi
.PP
.PP
For application programmers wanting to extend the library with new actions: this method needs to be overridden in \fIall\fP subclasses\&. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through Inventor/nodes/SoSubAction\&.h: SO_ACTION_SOURCE, SO_ACTION_INIT_CLASS and SO_ACTION_CONSTRUCTOR\&.
.PP
For more information on writing Coin extensions, see the \fBSoAction\fP class documentation\&.
.PP
Returns the actual type id of an object derived from a class inheriting \fBSoAction\fP\&. Needs to be overridden in \fIall\fP subclasses\&. 
.PP
Reimplemented from \fBSoSimplifyAction\fP\&.
.SS "void SoReorganizeAction::addMethod (const \fBSoType\fP type, \fBSoActionMethod\fP method)\fC [static]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "void SoReorganizeAction::enableElement (const \fBSoType\fP type, const \fBint\fP stackindex)\fC [static]\fP"
\fIThis API member is considered internal to the library, as it is not likely to be of interest to the application programmer\&.\fP 
.SS "const \fBSoEnabledElementsList\fP & SoReorganizeAction::getEnabledElements (void) const\fC [protected]\fP, \fC [virtual]\fP"
Returns a list of the elements used by action instances of this class upon traversal operations\&. 
.PP
Reimplemented from \fBSoSimplifyAction\fP\&.
.SS "void SoReorganizeAction::apply (\fBSoNode\fP * root)\fC [virtual]\fP"
Applies the action to the scene graph rooted at \fIroot\fP\&.
.PP
Note that you should \fInot\fP apply an action to a node with a zero reference count\&. The behavior in that case is undefined\&. 
.PP
Reimplemented from \fBSoSimplifyAction\fP\&.
.SS "void SoReorganizeAction::apply (\fBSoPath\fP * path)\fC [virtual]\fP"
Applies the action to the parts of the graph defined by \fIpath\fP\&.
.PP
Note that an \fBSoPath\fP will also contain all nodes that may influence e\&.g\&. geometry nodes in the path\&. So for instance applying an \fBSoGLRenderAction\fP on an \fBSoPath\fP will render that path as expected in the view, where geometry will get its materials, textures, and other appearance settings correctly\&.
.PP
If the \fIpath\fP ends in an \fBSoGroup\fP node, the action will also traverse the tail node's children\&. 
.PP
Reimplemented from \fBSoSimplifyAction\fP\&.
.SS "void SoReorganizeAction::apply (const \fBSoPathList\fP & pathlist, SbBool obeysrules = \fCFALSE\fP)\fC [virtual]\fP"
Applies action to the graphs defined by \fIpathlist\fP\&. If \fIobeysrules\fP is set to \fCTRUE\fP, \fIpathlist\fP must obey the following four conditions (which is the case for path lists returned from search actions for non-group nodes and path lists returned from picking actions):
.PP
All paths must start at the same head node\&. All paths must be sorted in traversal order\&. The paths must be unique\&. No path can continue through the end point of another path\&.
.PP
\fBSee also:\fP
.RS 4
\fBSoAction::apply(SoPath * path)\fP 
.RE
.PP

.PP
Reimplemented from \fBSoSimplifyAction\fP\&.
.SS "void SoReorganizeAction::beginTraversal (\fBSoNode\fP * node)\fC [protected]\fP, \fC [virtual]\fP"
This virtual method is called from \fBSoAction::apply()\fP, and is the entry point for the actual scenegraph traversal\&.
.PP
It can be overridden to initialize the action at traversal start, for specific initializations in the action subclasses inheriting \fBSoAction\fP\&.
.PP
Default method just calls \fBtraverse()\fP, which any overridden implementation of the method must do too (or call \fBSoAction::beginTraversal()\fP) to trigger the scenegraph traversal\&. 
.PP
Reimplemented from \fBSoSimplifyAction\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
