.TH "SoDelayQueueSensor" 3 "Sun May 28 2017" "Version 4.0.0a" "Coin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SoDelayQueueSensor \- The \fBSoDelayQueueSensor\fP class is the abstract base class for priority scheduled sensors\&.
.PP
Delay queue sensors are invoked upon various events \fInot\fP related to time occurrences\&. See documentation of subclasses to see which types of events can be surveilled by the builtin sensor types\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Inventor/sensors/SoDelayQueueSensor\&.h>\fP
.PP
Inherits \fBSoSensor\fP\&.
.PP
Inherited by \fBSoDataSensor\fP, \fBSoIdleSensor\fP, and \fBSoOneShotSensor\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSoDelayQueueSensor\fP (void)"
.br
.ti -1c
.RI "\fBSoDelayQueueSensor\fP (\fBSoSensorCB\fP *\fBfunc\fP, void *data)"
.br
.ti -1c
.RI "virtual \fB~SoDelayQueueSensor\fP (void)"
.br
.ti -1c
.RI "void \fBsetPriority\fP (uint32_t pri)"
.br
.ti -1c
.RI "uint32_t \fBgetPriority\fP (void) const"
.br
.ti -1c
.RI "virtual void \fBschedule\fP (void)"
.br
.ti -1c
.RI "virtual void \fBunschedule\fP (void)"
.br
.ti -1c
.RI "virtual SbBool \fBisScheduled\fP (void) const"
.br
.ti -1c
.RI "virtual SbBool \fBisIdleOnly\fP (void) const"
.br
.ti -1c
.RI "virtual void \fBtrigger\fP (void)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static uint32_t \fBgetDefaultPriority\fP (void)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "SbBool \fBscheduled\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
The \fBSoDelayQueueSensor\fP class is the abstract base class for priority scheduled sensors\&.
.PP
Delay queue sensors are invoked upon various events \fInot\fP related to time occurrences\&. See documentation of subclasses to see which types of events can be surveilled by the builtin sensor types\&. 

The priority values can be used to queue events by their importance, so the sensors are triggered in the sequence you want\&.
.PP
The queue of delay sensors (i\&.e\&. instances of subclasses of \fBSoDelayQueueSensor\fP) will be processed as soon as either the run-time system is idle, or if it is continually busy they will be processed within a fixed amount of time\&.
.PP
This time interval is by default 1/12th of a second, but can be controlled with the \fBSoSensorManager::setDelaySensorTimeout()\fP interface\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SoDelayQueueSensor::SoDelayQueueSensor (void)"
Default constructor\&. 
.SS "SoDelayQueueSensor::SoDelayQueueSensor (\fBSoSensorCB\fP * func, void * data)"
Constructor taking as arguments the sensor callback function and the userdata which will be passed the callback\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetFunction()\fP, \fBsetData()\fP 
.RE
.PP

.SS "SoDelayQueueSensor::~SoDelayQueueSensor (void)\fC [virtual]\fP"
Destructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "void SoDelayQueueSensor::setPriority (uint32_t pri)"
Set this sensor's priority in the scheduling queue\&. When sensors are processed, high priority sensors will trigger before low priority sensors\&.
.PP
Please note that a low number means a high priority\&. A sensor with priority 5 will trigger before a sensor with priority 6\&.
.PP
Sensors with priority 0 have a special meaning in Coin/Inventor\&. They are called immediate sensors, and will trigger immediately after the current notification chain has finished\&. Priority 0 sensors should be used with care, since they might lead to bad performance if you do some processing in the sensor callback\&.
.PP
This setting does not affect \fBSoDataSensor\fP delete-callback invocations, which always are immediate\&.
.PP
\fBSee also:\fP
.RS 4
\fBgetPriority()\fP, \fBgetDefaultPriority()\fP 
.RE
.PP

.SS "uint32_t SoDelayQueueSensor::getPriority (void) const"
Returns sensor scheduling priority\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetPriority()\fP, \fBgetDefaultPriority()\fP 
.RE
.PP

.SS "uint32_t SoDelayQueueSensor::getDefaultPriority (void)\fC [static]\fP"
Returns the default scheduling priority value\&. The default sensor priority is 100\&.
.PP
\fBSee also:\fP
.RS 4
\fBgetPriority()\fP 
.RE
.PP

.SS "void SoDelayQueueSensor::schedule (void)\fC [virtual]\fP"
Put the sensor in the global delay queue\&. This means it will be triggered either when the CPU is idle, or when the specified delay queue time-out is reached\&.
.PP
\fBSee also:\fP
.RS 4
\fBSoDB::setDelaySensorTimeout()\fP, \fBunschedule()\fP, \fBisScheduled()\fP 
.RE
.PP

.PP
Implements \fBSoSensor\fP\&.
.SS "void SoDelayQueueSensor::unschedule (void)\fC [virtual]\fP"
Remove sensor from the delay queue, without triggering it first\&.
.PP
\fBSee also:\fP
.RS 4
\fBschedule()\fP, \fBisScheduled()\fP 
.RE
.PP

.PP
Implements \fBSoSensor\fP\&.
.SS "SbBool SoDelayQueueSensor::isScheduled (void) const\fC [virtual]\fP"
Check if this sensor is scheduled for triggering\&.
.PP
\fBSee also:\fP
.RS 4
\fBschedule()\fP, \fBunschedule()\fP 
.RE
.PP

.PP
Implements \fBSoSensor\fP\&.
.SS "SbBool SoDelayQueueSensor::isIdleOnly (void) const\fC [virtual]\fP"
Returns a flag indicating whether or not the sensor should only be triggered if the application is truly idle, and \fInot\fP when the delay queue is processed because of the delay queue timeout\&.
.PP
\fBSee also:\fP
.RS 4
\fBSoDB::setDelaySensorTimeout()\fP 
.RE
.PP

.SS "void SoDelayQueueSensor::trigger (void)\fC [virtual]\fP"
Trigger the sensor's callback function\&. 
.PP
Reimplemented from \fBSoSensor\fP\&.
.PP
Reimplemented in \fBSoDataSensor\fP, and \fBSoFieldSensor\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "SbBool SoDelayQueueSensor::scheduled\fC [protected]\fP"
\fCTRUE\fP if the sensor is currently scheduled\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Coin from the source code\&.
