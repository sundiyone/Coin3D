<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>Coin: SoOffscreenRenderer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%; background-image:url('nav_f.png'); background-color: #E2E8F2; background-repeat:repeat-x">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em; width: 66px;">
   <img src="Coin_logo.png" alt="Coin Logo" />
  </td>
  <td>
    Coin3D is Free Software,<br />published under the <a href="http://opensource.org/licenses/BSD-3-Clause">BSD 3-clause license</a>.
  </td>
  <td style="text-align: right; padding-right: 0.5em;">
    <a href="https://bitbucket.org/Coin3D/">https://bitbucket.org/Coin3D/</a><br />
    <a href="http://www.kongsberg.com/kogt/">http://www.kongsberg.com/kogt/</a><br />  
    </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSoOffscreenRenderer.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classSoOffscreenRenderer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SoOffscreenRenderer Class Reference<div class="ingroups"><a class="el" href="group__general.html">Miscellaneous Classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classSoOffscreenRenderer.html" title="The SoOffscreenRenderer class is used for rendering scenes in offscreen buffers.If you want to render...">SoOffscreenRenderer</a> class is used for rendering scenes in offscreen buffers.If you want to render to a memory buffer instead of an on-screen OpenGL context, use this class. Rendering to a memory buffer can be used to generate texture maps on-the-fly, or for saving snapshots of the scene to disk files (as pixel bitmaps or as Postscript files for sending to a Postscript-capable printer).  
 <a href="classSoOffscreenRenderer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SoOffscreenRenderer_8h_source.html">Inventor/SoOffscreenRenderer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acd70da14761ef3b54c07d0e6f642a338"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#acd70da14761ef3b54c07d0e6f642a338">Components</a> { <b>LUMINANCE</b> = 1, 
<b>LUMINANCE_TRANSPARENCY</b> = 2, 
<b>RGB</b> = 3, 
<b>RGB_TRANSPARENCY</b> = 4
 }</td></tr>
<tr class="separator:acd70da14761ef3b54c07d0e6f642a338"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a77b05979638e69baa4b8df817f5c2b6f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#a77b05979638e69baa4b8df817f5c2b6f">SoOffscreenRenderer</a> (const <a class="el" href="classSbViewportRegion.html">SbViewportRegion</a> &amp;viewportregion)</td></tr>
<tr class="separator:a77b05979638e69baa4b8df817f5c2b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bd02d137b6f8edc298b6099ab15c6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#a68bd02d137b6f8edc298b6099ab15c6b">SoOffscreenRenderer</a> (<a class="el" href="classSoGLRenderAction.html">SoGLRenderAction</a> *action)</td></tr>
<tr class="separator:a68bd02d137b6f8edc298b6099ab15c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff1873304cf86867b06a4b146c1f764"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#adff1873304cf86867b06a4b146c1f764">~SoOffscreenRenderer</a> ()</td></tr>
<tr class="separator:adff1873304cf86867b06a4b146c1f764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009e27700869d11686d47d61c5e53a72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#a009e27700869d11686d47d61c5e53a72">setComponents</a> (const <a class="el" href="classSoOffscreenRenderer.html#acd70da14761ef3b54c07d0e6f642a338">Components</a> components)</td></tr>
<tr class="separator:a009e27700869d11686d47d61c5e53a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27cd58af6cbb976258775752493fd6c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoOffscreenRenderer.html#acd70da14761ef3b54c07d0e6f642a338">Components</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#a27cd58af6cbb976258775752493fd6c1">getComponents</a> (void) const</td></tr>
<tr class="separator:a27cd58af6cbb976258775752493fd6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc12ce58b3ac94b37b0cbf79f548214"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#aafc12ce58b3ac94b37b0cbf79f548214">setViewportRegion</a> (const <a class="el" href="classSbViewportRegion.html">SbViewportRegion</a> &amp;region)</td></tr>
<tr class="separator:aafc12ce58b3ac94b37b0cbf79f548214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54f0a80d41428c228ec90b3e632a58c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSbViewportRegion.html">SbViewportRegion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#aa54f0a80d41428c228ec90b3e632a58c">getViewportRegion</a> (void) const</td></tr>
<tr class="separator:aa54f0a80d41428c228ec90b3e632a58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59934bffc73bbfa8242ab16e9a0000f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#ac59934bffc73bbfa8242ab16e9a0000f">setBackgroundColor</a> (const <a class="el" href="classSbColor.html">SbColor</a> &amp;color)</td></tr>
<tr class="separator:ac59934bffc73bbfa8242ab16e9a0000f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6dad396fbe28ec07be230ae0914a40"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSbColor.html">SbColor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#a6c6dad396fbe28ec07be230ae0914a40">getBackgroundColor</a> (void) const</td></tr>
<tr class="separator:a6c6dad396fbe28ec07be230ae0914a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0d9ddb3466b29d38f9873a30530d8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#a9e0d9ddb3466b29d38f9873a30530d8d">setGLRenderAction</a> (<a class="el" href="classSoGLRenderAction.html">SoGLRenderAction</a> *action)</td></tr>
<tr class="separator:a9e0d9ddb3466b29d38f9873a30530d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd57de62f8768ff67b20f115a7865c5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoGLRenderAction.html">SoGLRenderAction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#acd57de62f8768ff67b20f115a7865c5f">getGLRenderAction</a> (void) const</td></tr>
<tr class="separator:acd57de62f8768ff67b20f115a7865c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ae3abd666f819002798abad9385638"><td class="memItemLeft" align="right" valign="top">SbBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#ae2ae3abd666f819002798abad9385638">render</a> (<a class="el" href="classSoNode.html">SoNode</a> *scene)</td></tr>
<tr class="separator:ae2ae3abd666f819002798abad9385638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa113ccb637bf0d213d64883ec01123"><td class="memItemLeft" align="right" valign="top">SbBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#abaa113ccb637bf0d213d64883ec01123">render</a> (<a class="el" href="classSoPath.html">SoPath</a> *scene)</td></tr>
<tr class="separator:abaa113ccb637bf0d213d64883ec01123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799383db891d6d913b670bd2fff53c42"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#a799383db891d6d913b670bd2fff53c42">getBuffer</a> (void) const</td></tr>
<tr class="separator:a799383db891d6d913b670bd2fff53c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78885ba296816cf91349d9dd4888055"><td class="memItemLeft" align="right" valign="top">const void *const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#aa78885ba296816cf91349d9dd4888055">getDC</a> (void) const</td></tr>
<tr class="separator:aa78885ba296816cf91349d9dd4888055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9981f8b802d3c2be55d48c91fa6db3"><td class="memItemLeft" align="right" valign="top">SbBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#a6d9981f8b802d3c2be55d48c91fa6db3">writeToRGB</a> (FILE *fp) const</td></tr>
<tr class="separator:a6d9981f8b802d3c2be55d48c91fa6db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefa4dbe02271b4106bb540a3822d6e4"><td class="memItemLeft" align="right" valign="top">SbBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#afefa4dbe02271b4106bb540a3822d6e4">writeToPostScript</a> (FILE *fp) const</td></tr>
<tr class="separator:afefa4dbe02271b4106bb540a3822d6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d111ee3193d7dcbe9ec24176d8e3606"><td class="memItemLeft" align="right" valign="top">SbBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#a3d111ee3193d7dcbe9ec24176d8e3606">writeToPostScript</a> (FILE *fp, const <a class="el" href="classSbVec2f.html">SbVec2f</a> &amp;printsize) const</td></tr>
<tr class="separator:a3d111ee3193d7dcbe9ec24176d8e3606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea11d989352f6ddfa3ef50e9721913d"><td class="memItemLeft" align="right" valign="top">SbBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#a0ea11d989352f6ddfa3ef50e9721913d">writeToRGB</a> (const char *filename) const</td></tr>
<tr class="separator:a0ea11d989352f6ddfa3ef50e9721913d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32144ad948f3710b58cf14d2439bbf90"><td class="memItemLeft" align="right" valign="top">SbBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#a32144ad948f3710b58cf14d2439bbf90">writeToPostScript</a> (const char *filename) const</td></tr>
<tr class="separator:a32144ad948f3710b58cf14d2439bbf90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a70e5db92a84860175edb70f7416eb0"><td class="memItemLeft" align="right" valign="top">SbBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#a0a70e5db92a84860175edb70f7416eb0">writeToPostScript</a> (const char *filename, const <a class="el" href="classSbVec2f.html">SbVec2f</a> &amp;printsize) const</td></tr>
<tr class="separator:a0a70e5db92a84860175edb70f7416eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e63a0d6e2429b837b42d1759d17b5a"><td class="memItemLeft" align="right" valign="top">SbBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#a35e63a0d6e2429b837b42d1759d17b5a">isWriteSupported</a> (const <a class="el" href="classSbName.html">SbName</a> &amp;filetypeextension) const</td></tr>
<tr class="separator:a35e63a0d6e2429b837b42d1759d17b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7cd797da0585a2b4f0bb321e4b925da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#af7cd797da0585a2b4f0bb321e4b925da">getNumWriteFiletypes</a> (void) const</td></tr>
<tr class="separator:af7cd797da0585a2b4f0bb321e4b925da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6757d586bdaaa32e19cb9db161756d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#a3d6757d586bdaaa32e19cb9db161756d">getWriteFiletypeInfo</a> (const <a class="el" href="classint.html">int</a> idx, <a class="el" href="classSbPList.html">SbPList</a> &amp;extlist, <a class="el" href="classSbString.html">SbString</a> &amp;fullname, <a class="el" href="classSbString.html">SbString</a> &amp;description)</td></tr>
<tr class="separator:a3d6757d586bdaaa32e19cb9db161756d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9c7c4603b1a29353c0b26dc4e57586"><td class="memItemLeft" align="right" valign="top">SbBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#a7f9c7c4603b1a29353c0b26dc4e57586">writeToFile</a> (const <a class="el" href="classSbString.html">SbString</a> &amp;filename, const <a class="el" href="classSbName.html">SbName</a> &amp;filetypeextension) const</td></tr>
<tr class="separator:a7f9c7c4603b1a29353c0b26dc4e57586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae400ae638df4585c8881ee718ccb8189"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#ae400ae638df4585c8881ee718ccb8189">setPbufferEnable</a> (SbBool enable)</td></tr>
<tr class="separator:ae400ae638df4585c8881ee718ccb8189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcfc5af69338e38ed9f6460bd3542ac"><td class="memItemLeft" align="right" valign="top">SbBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#adbcfc5af69338e38ed9f6460bd3542ac">getPbufferEnable</a> (void) const</td></tr>
<tr class="separator:adbcfc5af69338e38ed9f6460bd3542ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a83ce4f862d4bc99aaa72368a638c587b"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#a83ce4f862d4bc99aaa72368a638c587b">getScreenPixelsPerInch</a> (void)</td></tr>
<tr class="separator:a83ce4f862d4bc99aaa72368a638c587b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16cf2d7ac5a87dae6a6888e0ec9bc94"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSbVec2s.html">SbVec2s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOffscreenRenderer.html#ae16cf2d7ac5a87dae6a6888e0ec9bc94">getMaximumResolution</a> (void)</td></tr>
<tr class="separator:ae16cf2d7ac5a87dae6a6888e0ec9bc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classSoOffscreenRenderer.html" title="The SoOffscreenRenderer class is used for rendering scenes in offscreen buffers.If you want to render...">SoOffscreenRenderer</a> class is used for rendering scenes in offscreen buffers.</p>
<p>If you want to render to a memory buffer instead of an on-screen OpenGL context, use this class. Rendering to a memory buffer can be used to generate texture maps on-the-fly, or for saving snapshots of the scene to disk files (as pixel bitmaps or as Postscript files for sending to a Postscript-capable printer). </p>
<p>Here's a dead simple usage example, just the code directly related to the <a class="el" href="classSoOffscreenRenderer.html" title="The SoOffscreenRenderer class is used for rendering scenes in offscreen buffers.If you want to render...">SoOffscreenRenderer</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="classSoOffscreenRenderer.html">SoOffscreenRenderer</a> myRenderer(vpregion);</div><div class="line"><a class="code" href="classSoNode.html">SoNode</a> * root = myViewer-&gt;getSceneManager()-&gt;getSceneGraph();</div><div class="line">SbBool ok = myRenderer.render(root);</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * imgbuffer = myRenderer.getBuffer();</div><div class="line"><span class="comment">// [then use image buffer in a texture, or write it to file, or whatever]</span></div></div><!-- fragment --><p>And here a complete stand-alone example with a moving camera saving multiple frames to disk as JPGs:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="SoDB_8h.html">Inventor/SoDB.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;Inventor/SoOffscreenRenderer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;Inventor/engines/SoInterpolateVec3f.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;Inventor/nodes/SoCube.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;Inventor/nodes/SoDirectionalLight.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;Inventor/nodes/SoPerspectiveCamera.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;Inventor/nodes/SoSeparator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="comment">// Init Coin</span></div><div class="line">  <a class="code" href="classSoDB.html#a970f42dfd362c33c69fa1869bfae72b5">SoDB::init</a>();</div><div class="line"></div><div class="line">  <span class="comment">// The root node</span></div><div class="line">  <a class="code" href="classSoSeparator.html">SoSeparator</a> * root = <span class="keyword">new</span> <a class="code" href="classSoSeparator.html">SoSeparator</a>;</div><div class="line">  root-&gt;<a class="code" href="classSoBase.html#ac01cf34901b2a2be1bc2671bb2463851">ref</a>();</div><div class="line"></div><div class="line">  <span class="comment">// It is mandatory to have at least one light for the offscreen renderer</span></div><div class="line">  <a class="code" href="classSoDirectionalLight.html">SoDirectionalLight</a> * light = <span class="keyword">new</span> <a class="code" href="classSoDirectionalLight.html">SoDirectionalLight</a>;</div><div class="line">  root-&gt;<a class="code" href="classSoGroup.html#a23e0a7aebf3ec75c40638cc360c0e5e6">addChild</a>(light);</div><div class="line"></div><div class="line">  <span class="comment">// It is mandatory to have at least one camera for the offscreen renderer</span></div><div class="line">  <a class="code" href="classSoPerspectiveCamera.html">SoPerspectiveCamera</a> * camera = <span class="keyword">new</span> <a class="code" href="classSoPerspectiveCamera.html">SoPerspectiveCamera</a>;</div><div class="line">  <a class="code" href="classSbRotation.html">SbRotation</a> cameraRotation = <a class="code" href="classSbRotation.html#a185e88e106dbba29d4bb8339ff28c4ac">SbRotation::identity</a>();</div><div class="line">  cameraRotation *= <a class="code" href="classSbRotation.html">SbRotation</a>(<a class="code" href="classSbVec3f.html">SbVec3f</a>(1, 0, 0), -0.4f);</div><div class="line">  cameraRotation *= <a class="code" href="classSbRotation.html">SbRotation</a>(<a class="code" href="classSbVec3f.html">SbVec3f</a>(0, 1, 0), 0.4f);</div><div class="line">  camera-&gt;<a class="code" href="classSoCamera.html#a1e0dc74890db39d4c8ec2194ec7ab4a7">orientation</a> = cameraRotation;</div><div class="line">  root-&gt;<a class="code" href="classSoGroup.html#a23e0a7aebf3ec75c40638cc360c0e5e6">addChild</a>(camera);</div><div class="line"></div><div class="line">  <span class="comment">// Something to show... A box</span></div><div class="line">  <a class="code" href="classSoCube.html">SoCube</a> * cube = <span class="keyword">new</span> <a class="code" href="classSoCube.html">SoCube</a>;</div><div class="line">  root-&gt;<a class="code" href="classSoGroup.html#a23e0a7aebf3ec75c40638cc360c0e5e6">addChild</a>(cube);</div><div class="line"></div><div class="line">  <span class="comment">// Set up the two camera positions we want to move the camera between</span></div><div class="line">  <a class="code" href="classSoInterpolateVec3f.html">SoInterpolateVec3f</a> * interpolate = <span class="keyword">new</span> <a class="code" href="classSoInterpolateVec3f.html">SoInterpolateVec3f</a>;</div><div class="line">  interpolate-&gt;<a class="code" href="classSoInterpolateVec3f.html#a9cf5865c8ca8208ecde080182be03326">input0</a> = <a class="code" href="classSbVec3f.html">SbVec3f</a>(2, 2, 9);</div><div class="line">  interpolate-&gt;<a class="code" href="classSoInterpolateVec3f.html#ac8738d3973ee4680f8b0c4358dab17bd">input1</a> = <a class="code" href="classSbVec3f.html">SbVec3f</a>(2, 2, 5);</div><div class="line">  camera-&gt;<a class="code" href="classSoCamera.html#a1346f4606c4fd282818b4b7701bfeca9">position</a>.<a class="code" href="classSoField.html#a6fcfab4c669504fff42c63c99e05b82e">connectFrom</a>(&amp;interpolate-&gt;<a class="code" href="classSoInterpolate.html#a2a04c43bd50f973ef36e3a08f0b8887f">output</a>);</div><div class="line"></div><div class="line">  <span class="comment">// Set up the offscreen renderer</span></div><div class="line">  <a class="code" href="classSbViewportRegion.html">SbViewportRegion</a> vpRegion(400, 300);</div><div class="line">  <a class="code" href="classSoOffscreenRenderer.html">SoOffscreenRenderer</a> offscreenRenderer(vpRegion);</div><div class="line"></div><div class="line">  <span class="comment">// How many frames to render for the video</span></div><div class="line">  <span class="keywordtype">int</span> frames = 5;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Writing &quot;</span> &lt;&lt; frames &lt;&lt; <span class="stringliteral">&quot; frames...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; frames; i++) {</div><div class="line">    <span class="comment">// Update the camera position</span></div><div class="line">    interpolate-&gt;<a class="code" href="classSoInterpolate.html#a64d875addb45655774a2f3d374644c6f">alpha</a> = float(i) / (frames - 1);</div><div class="line"></div><div class="line">    <span class="comment">// Render the scene</span></div><div class="line">    SbBool ok = offscreenRenderer.render(root);</div><div class="line"></div><div class="line">    <span class="comment">// Save the image to disk</span></div><div class="line">    <a class="code" href="classSbString.html">SbString</a> filename = <a class="code" href="classSbString.html">SbString</a>(<span class="stringliteral">&quot;coinvideo-&quot;</span>) + (i + 1) + <span class="stringliteral">&quot;.jpg&quot;</span>;</div><div class="line">    <span class="keywordflow">if</span> (ok) {</div><div class="line">      offscreenRenderer.writeToFile(filename.<a class="code" href="classSbString.html#a6bfa023105342c057fe9eb555772ed6c">getString</a>(), <span class="stringliteral">&quot;jpg&quot;</span>);</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Error saving image: &quot;</span> &lt;&lt; filename.<a class="code" href="classSbString.html#a6bfa023105342c057fe9eb555772ed6c">getString</a>() &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Done!&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  root-&gt;<a class="code" href="classSoBase.html#a254b1ac395fe4d4d10438b994bdb3561">unref</a>();</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Note that the <a class="el" href="classSoOffscreenRenderer.html" title="The SoOffscreenRenderer class is used for rendering scenes in offscreen buffers.If you want to render...">SoOffscreenRenderer</a> potentially allocates a fairly large amount of resources, both OpenGL and general system resources, for each instance. You will therefore be well adviced to try to reuse <a class="el" href="classSoOffscreenRenderer.html" title="The SoOffscreenRenderer class is used for rendering scenes in offscreen buffers.If you want to render...">SoOffscreenRenderer</a> instances, instead of constructing and destructing a new instance e.g. for each frame when generating pictures for video.</p>
<p>Offscreen rendering is internally done through either a GLX offscreen context (i.e. OpenGL on X11), WGL (i.e. OpenGL on Win32), AGL (old-style OpenGL on the Mac OS X) or CGL (new-style Mac OS X).</p>
<p>If the OpenGL driver supports the pbuffer extension, it is detected and used to provide hardware-accelerated offscreen rendering.</p>
<p>The pixeldata is fetched from the OpenGL buffer with glReadPixels(), with the format and type arguments set to GL_RGBA and GL_UNSIGNED_BYTE, respectively. This means that the maximum resolution is 32 bits, 8 bits for each of the R/G/B/A components.</p>
<p>One particular usage of the <a class="el" href="classSoOffscreenRenderer.html" title="The SoOffscreenRenderer class is used for rendering scenes in offscreen buffers.If you want to render...">SoOffscreenRenderer</a> is to make it render frames to be used for the construction of movies. The general technique for doing this is to iterate over the following actions:</p>
<ul>
<li>
move camera to correct position for frame </li>
<li>
update the <code>realTime</code> global field (see explanation below) </li>
<li>
invoke the <a class="el" href="classSoOffscreenRenderer.html" title="The SoOffscreenRenderer class is used for rendering scenes in offscreen buffers.If you want to render...">SoOffscreenRenderer</a> </li>
<li>
dump rendered scene to file </li>
</ul>
<p>..then you use some external tool or library to construct the movie file, for instance in MPEG format, from the set of files dumped to disk from the iterative process above.</p>
<p>The code would go something like the following (pseudo-code style). First we need to stop the Coin library itself from doing any automatic updating of the <code>realTime</code> field, so your application initialization for Coin should look something like:</p>
<div class="fragment"><div class="line">[...] = SoQt::init([...]); <span class="comment">// or SoWin::init() or SoDB::init()</span></div><div class="line"><span class="comment">// ..and then immediately:</span></div><div class="line"></div><div class="line"><span class="comment">// Control realTime field ourselves, so animations within the scene</span></div><div class="line"><span class="comment">// follows &quot;movie-time&quot; and not &quot;wallclock-time&quot;.</span></div><div class="line"><a class="code" href="classSoDB.html#a89acf7863ffca8f10501c07ad3a70301">SoDB::enableRealTimeSensor</a>(FALSE);</div><div class="line"><a class="code" href="classSoSceneManager.html#a2ccbbe194653b58779339b4a6de58bc2">SoSceneManager::enableRealTimeUpdate</a>(FALSE);</div><div class="line"><a class="code" href="classSoSFTime.html">SoSFTime</a> * realtime = <a class="code" href="classSoDB.html#ab3b006bd268810d17dd3f57362aa9dd1">SoDB::getGlobalField</a>(<span class="stringliteral">&quot;realTime&quot;</span>);</div><div class="line">realtime-&gt;setValue(0.0);</div></div><!-- fragment --><p>Note that it is important that the <code>realTime</code> field is initialized to <em>your</em> start-time <em>before</em> setting up any engines or other entities in the system that uses the <code>realTime</code> field.</p>
<p>Then for the rendering loop, something like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; NRFRAMES; i++) {</div><div class="line">  <span class="comment">// [...reposition camera here, if necessary...]</span></div><div class="line"></div><div class="line">  <span class="comment">// render</span></div><div class="line">  offscreenrend-&gt;render(root);</div><div class="line"></div><div class="line">  <span class="comment">// dump to file</span></div><div class="line">  <a class="code" href="classSbString.html">SbString</a> framefile;</div><div class="line">  framefile.<a class="code" href="classSbString.html#a5b8b394310de686b49033d6e5ef16280">sprintf</a>(<span class="stringliteral">&quot;frame%06d.rgb&quot;</span>, i);</div><div class="line">  offscreenrend-&gt;writeToRGB(framefile.<a class="code" href="classSbString.html#a6bfa023105342c057fe9eb555772ed6c">getString</a>());</div><div class="line"></div><div class="line">  <span class="comment">// advance &quot;current time&quot; by the frames-per-second value, which</span></div><div class="line">  <span class="comment">// is 24 fps in this example</span></div><div class="line">  realtime-&gt;setValue(realtime.getValue() + 1/24.0);</div><div class="line">}</div></div><!-- fragment --><p>When making movies you need to write your application control code to take care of moving the camera along the correct trajectory yourself, and to explicitly control the global <code>realTime</code> field. The latter is so you're able to "step" with appropriate time units for each render operation (e.g. if you want a movie that has a 24 FPS refresh rate, first render with <code>realTime=0.0</code>, then add 1/24s to the <code>realTime</code> field, render again to a new frame, add another 1/24s to the <code>realTime</code> field, render, and so on).</p>
<p>For further information about how to control the <code>realTime</code> field, see documentation of <a class="el" href="classSoDB.html#ab3b006bd268810d17dd3f57362aa9dd1">SoDB::getGlobalField()</a>, <a class="el" href="classSoDB.html#a89acf7863ffca8f10501c07ad3a70301">SoDB::enableRealTimeSensor()</a>, and <a class="el" href="classSoSceneManager.html#a2ccbbe194653b58779339b4a6de58bc2">SoSceneManager::enableRealTimeUpdate()</a>.</p>
<p>If you want to use this class to create snapshots of your current viewer's view, but want to control the size of the snapshot, you need to modify the camera a bit while rendering to be sure that everything you see in the current view is visible in the snapshot.</p>
<p>Below you'll find some pseude-code that does this. There are probably other ways to do this as well.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> render_offscreen(<span class="keyword">const</span> <a class="code" href="classSbVec2s.html">SbVec2s</a> size)</div><div class="line">{</div><div class="line">  <a class="code" href="classSbVec2s.html">SbVec2s</a> glsize = this-&gt;getGLSize(); <span class="comment">// size of your normal viewer</span></div><div class="line">  <span class="keywordtype">float</span> glar = float(glsize[0] / <span class="keywordtype">float</span>(glsize[1]));</div><div class="line">  <span class="keywordtype">float</span> ar = float(size[0]) / float(size[1]);</div><div class="line">  <a class="code" href="classSoCamera.html">SoCamera</a> * camera = this-&gt;getCamera(); <span class="comment">// the camera you&#39;re using</span></div><div class="line">  <a class="code" href="classSoCamera.html#a46fd7a2f6e8ca20e44682d005e0bb44c">SoCamera::ViewportMapping</a> oldmap = (<a class="code" href="classSoCamera.html#a46fd7a2f6e8ca20e44682d005e0bb44c">SoCamera::ViewportMapping</a>)</div><div class="line">    camera-&gt;<a class="code" href="classSoCamera.html#abc6c62bbca8a24dd686a3fbb19adec2b">viewportMapping</a>.getValue();</div><div class="line">  <span class="keywordtype">float</span> oldar = camera-&gt;<a class="code" href="classSoCamera.html#a377ac1c352e965864712bcc5ad0459df">aspectRatio</a>.getValue();</div><div class="line"></div><div class="line">  camera-&gt;<a class="code" href="classSoCamera.html#abc6c62bbca8a24dd686a3fbb19adec2b">viewportMapping</a> = SoCamera::LEAVE_ALONE;</div><div class="line">  camera-&gt;<a class="code" href="classSoCamera.html#a377ac1c352e965864712bcc5ad0459df">aspectRatio</a> = ar;</div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> scaleheight = 1.0f;</div><div class="line">  <span class="keywordflow">if</span> (glar &gt; ar) {</div><div class="line">    scaleheight = glar / ar;</div><div class="line">    camera-&gt;<a class="code" href="classSoCamera.html#a2a860095b69cc575ba845d4e228956f3">scaleHeight</a>(scaleheight);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span> {</div><div class="line">    scaleheight = ar / glar;</div><div class="line">    camera-&gt;<a class="code" href="classSoCamera.html#a2a860095b69cc575ba845d4e228956f3">scaleHeight</a>(scaleheight);</div><div class="line">  }</div><div class="line">  <a class="code" href="classSoOffscreenRenderer.html">SoOffscreenRenderer</a> * renderer = <span class="keyword">new</span> <a class="code" href="classSoOffscreenRenderer.html#a77b05979638e69baa4b8df817f5c2b6f">SoOffscreenRenderer</a>(size);</div><div class="line">  renderer-&gt;<a class="code" href="classSoOffscreenRenderer.html#ae2ae3abd666f819002798abad9385638">render</a>(root);</div><div class="line"></div><div class="line">  <span class="comment">// ... save image</span></div><div class="line"></div><div class="line">  <span class="comment">// restore camera</span></div><div class="line">  camera-&gt;<a class="code" href="classSoCamera.html#abc6c62bbca8a24dd686a3fbb19adec2b">viewportMapping</a> = oldmap;</div><div class="line">  camera-&gt;<a class="code" href="classSoCamera.html#a377ac1c352e965864712bcc5ad0459df">aspectRatio</a> = oldar;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (scaleheight != 1.0f) {</div><div class="line">    camera-&gt;<a class="code" href="classSoCamera.html#a2a860095b69cc575ba845d4e228956f3">scaleHeight</a>(1.0f / scaleheight);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --> </div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="acd70da14761ef3b54c07d0e6f642a338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd70da14761ef3b54c07d0e6f642a338">&#9670;&nbsp;</a></span>Components</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSoOffscreenRenderer.html#acd70da14761ef3b54c07d0e6f642a338">SoOffscreenRenderer::Components</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumerated values for the available image formats.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOffscreenRenderer.html#a009e27700869d11686d47d61c5e53a72">setComponents()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a77b05979638e69baa4b8df817f5c2b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b05979638e69baa4b8df817f5c2b6f">&#9670;&nbsp;</a></span>SoOffscreenRenderer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SoOffscreenRenderer::SoOffscreenRenderer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSbViewportRegion.html">SbViewportRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>viewportregion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Argument is the <em>viewportregion</em> we should use when rendering. An internal <a class="el" href="classSoGLRenderAction.html" title="The SoGLRenderAction class renders the scene graph with OpenGL calls.Applying this method at a root n...">SoGLRenderAction</a> will be constructed. </p>

</div>
</div>
<a id="a68bd02d137b6f8edc298b6099ab15c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bd02d137b6f8edc298b6099ab15c6b">&#9670;&nbsp;</a></span>SoOffscreenRenderer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SoOffscreenRenderer::SoOffscreenRenderer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSoGLRenderAction.html">SoGLRenderAction</a> *&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Argument is the <em>action</em> we should apply to the scene graph when rendering the scene. Information about the viewport is extracted from the <em>action</em>. </p>

</div>
</div>
<a id="adff1873304cf86867b06a4b146c1f764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff1873304cf86867b06a4b146c1f764">&#9670;&nbsp;</a></span>~SoOffscreenRenderer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SoOffscreenRenderer::~SoOffscreenRenderer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a83ce4f862d4bc99aaa72368a638c587b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ce4f862d4bc99aaa72368a638c587b">&#9670;&nbsp;</a></span>getScreenPixelsPerInch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SoOffscreenRenderer::getScreenPixelsPerInch </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the screen pixels per inch resolution of your monitor. </p>

</div>
</div>
<a id="ae16cf2d7ac5a87dae6a6888e0ec9bc94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16cf2d7ac5a87dae6a6888e0ec9bc94">&#9670;&nbsp;</a></span>getMaximumResolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSbVec2s.html">SbVec2s</a> SoOffscreenRenderer::getMaximumResolution </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get maximum dimensions (width, height) of the offscreen buffer.</p>
<p>Note that from Coin version 2 onwards, the returned value will always be (<code>SHRT_MAX</code>, <code>SHRT_MAX</code>), where <code>SHRT_MAX</code> on most systems is equal to 32767.</p>
<p>This because the <a class="el" href="classSoOffscreenRenderer.html" title="The SoOffscreenRenderer class is used for rendering scenes in offscreen buffers.If you want to render...">SoOffscreenRenderer</a> can in principle generate unlimited size offscreen canvases by tiling together multiple renderings of the same scene. </p>

</div>
</div>
<a id="a009e27700869d11686d47d61c5e53a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009e27700869d11686d47d61c5e53a72">&#9670;&nbsp;</a></span>setComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SoOffscreenRenderer::setComponents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSoOffscreenRenderer.html#acd70da14761ef3b54c07d0e6f642a338">Components</a>&#160;</td>
          <td class="paramname"><em>components</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the component format of the offscreen buffer.</p>
<p>If set to <code>LUMINANCE</code>, a grayscale image is rendered, <code>LUMINANCE_TRANSPARENCY</code> gives us a grayscale image with transparency, <code>RGB</code> will give us a 24-bit image with 8 bits each for the red, green and blue component, and <code>RGB_TRANSPARENCY</code> yields a 32-bit image (<code>RGB</code> plus transparency).</p>
<p>The default format to render to is <code>RGB</code>.</p>
<p>This will invalidate the current buffer, if any. The buffer will not contain valid data until another call to <a class="el" href="classSoOffscreenRenderer.html#ae2ae3abd666f819002798abad9385638">SoOffscreenRenderer::render()</a> happens. </p>

</div>
</div>
<a id="a27cd58af6cbb976258775752493fd6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27cd58af6cbb976258775752493fd6c1">&#9670;&nbsp;</a></span>getComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoOffscreenRenderer.html#acd70da14761ef3b54c07d0e6f642a338">SoOffscreenRenderer::Components</a> SoOffscreenRenderer::getComponents </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the component format of the offscreen buffer.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOffscreenRenderer.html#a009e27700869d11686d47d61c5e53a72">setComponents()</a> </dd></dl>

</div>
</div>
<a id="aafc12ce58b3ac94b37b0cbf79f548214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc12ce58b3ac94b37b0cbf79f548214">&#9670;&nbsp;</a></span>setViewportRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SoOffscreenRenderer::setViewportRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSbViewportRegion.html">SbViewportRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the viewport region.</p>
<p>This will invalidate the current buffer, if any. The buffer will not contain valid data until another call to <a class="el" href="classSoOffscreenRenderer.html#ae2ae3abd666f819002798abad9385638">SoOffscreenRenderer::render()</a> happens. </p>

</div>
</div>
<a id="aa54f0a80d41428c228ec90b3e632a58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54f0a80d41428c228ec90b3e632a58c">&#9670;&nbsp;</a></span>getViewportRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSbViewportRegion.html">SbViewportRegion</a> &amp; SoOffscreenRenderer::getViewportRegion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the viewerport region. </p>

</div>
</div>
<a id="ac59934bffc73bbfa8242ab16e9a0000f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59934bffc73bbfa8242ab16e9a0000f">&#9670;&nbsp;</a></span>setBackgroundColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SoOffscreenRenderer::setBackgroundColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSbColor.html">SbColor</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the background color. The buffer is cleared to this color before rendering. </p>

</div>
</div>
<a id="a6c6dad396fbe28ec07be230ae0914a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6dad396fbe28ec07be230ae0914a40">&#9670;&nbsp;</a></span>getBackgroundColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSbColor.html">SbColor</a> &amp; SoOffscreenRenderer::getBackgroundColor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the background color. </p>

</div>
</div>
<a id="a9e0d9ddb3466b29d38f9873a30530d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0d9ddb3466b29d38f9873a30530d8d">&#9670;&nbsp;</a></span>setGLRenderAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SoOffscreenRenderer::setGLRenderAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSoGLRenderAction.html">SoGLRenderAction</a> *&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the render action. Use this if you have special rendering needs. </p>

</div>
</div>
<a id="acd57de62f8768ff67b20f115a7865c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd57de62f8768ff67b20f115a7865c5f">&#9670;&nbsp;</a></span>getGLRenderAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoGLRenderAction.html">SoGLRenderAction</a> * SoOffscreenRenderer::getGLRenderAction </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the rendering action currently used. </p>

</div>
</div>
<a id="ae2ae3abd666f819002798abad9385638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ae3abd666f819002798abad9385638">&#9670;&nbsp;</a></span>render() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SbBool SoOffscreenRenderer::render </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSoNode.html">SoNode</a> *&#160;</td>
          <td class="paramname"><em>scene</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Render the scenegraph rooted at <em>scene</em> into our internal pixel buffer.</p>
<p>Important note: make sure you pass in a <em>scene</em> node pointer which has both a camera and at least one lightsource below it &ndash; otherwise you are likely to end up with just a blank or black image buffer.</p>
<p>This mistake is easily made if you use an <a class="el" href="classSoOffscreenRenderer.html" title="The SoOffscreenRenderer class is used for rendering scenes in offscreen buffers.If you want to render...">SoOffscreenRenderer</a> on a scenegraph from one of the standard viewer components, as you will often just leave the addition of a camera and a headlight lightsource to the viewer to set up. This camera and lightsource are then part of the viewer's private "super-graph" outside of the scope of the scenegraph passed in by the application programmer. To make sure the complete scenegraph (including the viewer's "private parts" (<em>snicker</em>)) are passed to this method, you can get the scenegraph root from the viewer's internal <a class="el" href="classSoSceneManager.html" title="The SoSceneManager class provides the main interface between the scene graph and the GUI toolkit...">SoSceneManager</a> instance instead of from the viewer's own getSceneGraph() method, like this:</p>
<div class="fragment"><div class="line"><a class="code" href="classSoOffscreenRenderer.html">SoOffscreenRenderer</a> * myRenderer = <span class="keyword">new</span> <a class="code" href="classSoOffscreenRenderer.html#a77b05979638e69baa4b8df817f5c2b6f">SoOffscreenRenderer</a>(vpregion);</div><div class="line"><a class="code" href="classSoNode.html">SoNode</a> * root = myViewer-&gt;getSceneManager()-&gt;getSceneGraph();</div><div class="line">SbBool ok = myRenderer-&gt;<a class="code" href="classSoOffscreenRenderer.html#ae2ae3abd666f819002798abad9385638">render</a>(root);</div><div class="line"><span class="comment">// [then use image buffer in a texture, or write it to file, or whatever]</span></div></div><!-- fragment --><p>If you do this and still get a blank buffer, another common problem is to have a camera which is not actually pointing at the scene geometry you want a snapshot of. If you suspect that could be the cause of problems on your end, take a look at <a class="el" href="classSoCamera.html#a0419569e203a18c84870f288d79af31d">SoCamera::pointAt()</a> and <a class="el" href="classSoCamera.html#af04cc1f085e997c65832da9ddcd5a6aa">SoCamera::viewAll()</a> to see how you can make a camera node guaranteed to be directed at the scene geometry.</p>
<p>Yet another common mistake when setting up the camera is to specify values for the <a class="el" href="classSoCamera.html#a96b1bd10731d0a5b8addf3368a8ba53a">SoCamera::nearDistance</a> and <a class="el" href="classSoCamera.html#a34890d0e76849f4ce27beefae287f471">SoCamera::farDistance</a> fields which doesn't not enclose the full scene. This will result in either just the background color, or that parts at the front or the back of the scene will not be visible in the rendering.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOffscreenRenderer.html#a6d9981f8b802d3c2be55d48c91fa6db3">writeToRGB()</a> </dd></dl>

</div>
</div>
<a id="abaa113ccb637bf0d213d64883ec01123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa113ccb637bf0d213d64883ec01123">&#9670;&nbsp;</a></span>render() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SbBool SoOffscreenRenderer::render </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSoPath.html">SoPath</a> *&#160;</td>
          <td class="paramname"><em>scene</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Render the <em>scene</em> path into our internal memory buffer. </p>

</div>
</div>
<a id="a799383db891d6d913b670bd2fff53c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a799383db891d6d913b670bd2fff53c42">&#9670;&nbsp;</a></span>getBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char * SoOffscreenRenderer::getBuffer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the offscreen memory buffer. </p>

</div>
</div>
<a id="aa78885ba296816cf91349d9dd4888055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78885ba296816cf91349d9dd4888055">&#9670;&nbsp;</a></span>getDC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void *const  &amp; SoOffscreenRenderer::getDC </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Win32 only:</p>
<p>returns a direct handle to the internal DC of the offscreen context.</p>
<p>Useful for efficient access to the raw image under certain special circumstances. <a class="el" href="classSoOffscreenRenderer.html#a799383db891d6d913b670bd2fff53c42">getBuffer()</a> might be too slow, for instance due to pixel format conversion (Windows DCs are usually BGRA, while the 32-bit buffers returned from <a class="el" href="classSoOffscreenRenderer.html#a799383db891d6d913b670bd2fff53c42">getBuffer()</a> are RGBA).</p>
<p>Notes:</p>
<p>The return value is a reference to a HDC. The HDC typedef has been unwound to a native C++ type for multiplatform compatibility reasons.</p>
<p>Returned reference will contain a NULL value on other platforms.</p>
<p>Important limitation: if the current dimensions of the <a class="el" href="classSoOffscreenRenderer.html" title="The SoOffscreenRenderer class is used for rendering scenes in offscreen buffers.If you want to render...">SoOffscreenRenderer</a> instance are larger than what can be rendered with a single offscreen buffer, tiling will be used by the <a class="el" href="classSoOffscreenRenderer.html" title="The SoOffscreenRenderer class is used for rendering scenes in offscreen buffers.If you want to render...">SoOffscreenRenderer</a>, and the returned HDC will contain only part of the full rendered image.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOffscreenRenderer.html#a799383db891d6d913b670bd2fff53c42">getBuffer()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Coin 3.1 </dd></dl>

</div>
</div>
<a id="a6d9981f8b802d3c2be55d48c91fa6db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9981f8b802d3c2be55d48c91fa6db3">&#9670;&nbsp;</a></span>writeToRGB() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SbBool SoOffscreenRenderer::writeToRGB </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the buffer in SGI RGB format by appending it to the already open file. Returns <code>FALSE</code> if writing fails.</p>
<p>Important note: do <em>not</em> use this method when the Coin library has been compiled as an MSWindows DLL, as passing FILE* instances back or forth to DLLs is dangerous and will most likely cause a crash. This is an intrinsic limitation for MSWindows DLLs. </p>

</div>
</div>
<a id="afefa4dbe02271b4106bb540a3822d6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afefa4dbe02271b4106bb540a3822d6e4">&#9670;&nbsp;</a></span>writeToPostScript() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SbBool SoOffscreenRenderer::writeToPostScript </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the buffer in Postscript format by appending it to the already open file. Returns <code>FALSE</code> if writing fails.</p>
<p>Important note: do <em>not</em> use this method when the Coin library has been compiled as an MSWindows DLL, as passing FILE* instances back or forth to DLLs is dangerous and will most likely cause a crash. This is an intrinsic limitation for MSWindows DLLs. </p>

</div>
</div>
<a id="a3d111ee3193d7dcbe9ec24176d8e3606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d111ee3193d7dcbe9ec24176d8e3606">&#9670;&nbsp;</a></span>writeToPostScript() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SbBool SoOffscreenRenderer::writeToPostScript </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSbVec2f.html">SbVec2f</a> &amp;&#160;</td>
          <td class="paramname"><em>printsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the buffer to a file in Postscript format, with <em>printsize</em> dimensions.</p>
<p>Important note: do <em>not</em> use this method when the Coin library has been compiled as an MSWindows DLL, as passing FILE* instances back or forth to DLLs is dangerous and will most likely cause a crash. This is an intrinsic limitation for MSWindows DLLs. </p>

</div>
</div>
<a id="a0ea11d989352f6ddfa3ef50e9721913d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea11d989352f6ddfa3ef50e9721913d">&#9670;&nbsp;</a></span>writeToRGB() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SbBool SoOffscreenRenderer::writeToRGB </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a file with the given name and writes the offscreen buffer in SGI RGB format to the new file. If the file already exists, it will be overwritten (if permitted by the filesystem).</p>
<p>Returns <code>TRUE</code> if all went ok, otherwise <code>FALSE</code>. </p>

</div>
</div>
<a id="a32144ad948f3710b58cf14d2439bbf90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32144ad948f3710b58cf14d2439bbf90">&#9670;&nbsp;</a></span>writeToPostScript() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SbBool SoOffscreenRenderer::writeToPostScript </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a file with the given name and writes the offscreen buffer in Postscript format to the new file. If the file already exists, it will be overwritten (if permitted by the filesystem).</p>
<p>Returns <code>TRUE</code> if all went ok, otherwise <code>FALSE</code>. </p>

</div>
</div>
<a id="a0a70e5db92a84860175edb70f7416eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a70e5db92a84860175edb70f7416eb0">&#9670;&nbsp;</a></span>writeToPostScript() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SbBool SoOffscreenRenderer::writeToPostScript </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSbVec2f.html">SbVec2f</a> &amp;&#160;</td>
          <td class="paramname"><em>printsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a file with the given name and writes the offscreen buffer in Postscript format with <em>printsize</em> dimensions to the new file. If the file already exists, it will be overwritten (if permitted by the filesystem).</p>
<p>Returns <code>TRUE</code> if all went ok, otherwise <code>FALSE</code>. </p>

</div>
</div>
<a id="a35e63a0d6e2429b837b42d1759d17b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e63a0d6e2429b837b42d1759d17b5a">&#9670;&nbsp;</a></span>isWriteSupported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SbBool SoOffscreenRenderer::isWriteSupported </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSbName.html">SbName</a> &amp;&#160;</td>
          <td class="paramname"><em>filetypeextension</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>TRUE</code> if the buffer can be saved as a file of type <em>filetypeextension</em>, using <a class="el" href="classSoOffscreenRenderer.html#a7f9c7c4603b1a29353c0b26dc4e57586">SoOffscreenRenderer::writeToFile()</a>. This function needs simage v1.1 or newer.</p>
<p>Examples of possibly supported extensions are: "jpg", "png", "tiff", "gif", "bmp", etc. The extension match is not case sensitive.</p>
<p>Which formats are <em>actually</em> supported depends on the capabilities of Coin's support library for handling import and export of pixel-data files: the simage library. If the simage library is not installed on your system, no extension output formats will be supported.</p>
<p>Also, note that it is possible to build and install a simage library that lacks support for most or all of the file formats it is <em>capable</em> of supporting. This is so because the simage library depends on other, external 3rd party libraries &ndash; in the same manner as Coin depends on the simage library for added file format support.</p>
<p>The two built-in formats that are supported through the <a class="el" href="classSoOffscreenRenderer.html#a6d9981f8b802d3c2be55d48c91fa6db3">SoOffscreenRenderer::writeToRGB()</a> and <a class="el" href="classSoOffscreenRenderer.html#afefa4dbe02271b4106bb540a3822d6e4">SoOffscreenRenderer::writeToPostScript()</a> methods (for SGI RGB format and for Adobe Postscript files, respectively) are <em>not</em> considered by this method, as those two formats are guaranteed to <em>always</em> be supported through those functions.</p>
<p>So if you want to be guaranteed to be able to export a screenshot in your wanted format, you will have to use either one of the above mentioned method for writing SGI RGB or Adobe Postscript directly, or make sure the Coin library has been built and is running on top of a version of the simage library (that you have preferably built yourself) with the file format(s) you want support for.</p>
<p>This method is an extension versus the original SGI Open Inventor API.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOffscreenRenderer.html#af7cd797da0585a2b4f0bb321e4b925da">getNumWriteFiletypes()</a>, <a class="el" href="classSoOffscreenRenderer.html#a3d6757d586bdaaa32e19cb9db161756d">getWriteFiletypeInfo()</a>, <a class="el" href="classSoOffscreenRenderer.html#a7f9c7c4603b1a29353c0b26dc4e57586">writeToFile()</a> </dd></dl>

</div>
</div>
<a id="af7cd797da0585a2b4f0bb321e4b925da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7cd797da0585a2b4f0bb321e4b925da">&#9670;&nbsp;</a></span>getNumWriteFiletypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> SoOffscreenRenderer::getNumWriteFiletypes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of available exporters. Detailed information about the exporters can then be found using <a class="el" href="classSoOffscreenRenderer.html#a3d6757d586bdaaa32e19cb9db161756d">getWriteFiletypeInfo()</a>.</p>
<p>See <a class="el" href="classSoOffscreenRenderer.html#a35e63a0d6e2429b837b42d1759d17b5a">SoOffscreenRenderer::isWriteSupported()</a> for information about which file formats you can expect to be present.</p>
<p>Note that the two built-in export formats, SGI RGB and Adobe Postscript, are not counted.</p>
<p>This method is an extension versus the original SGI Open Inventor API.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOffscreenRenderer.html#a3d6757d586bdaaa32e19cb9db161756d">getWriteFiletypeInfo()</a> </dd></dl>

</div>
</div>
<a id="a3d6757d586bdaaa32e19cb9db161756d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6757d586bdaaa32e19cb9db161756d">&#9670;&nbsp;</a></span>getWriteFiletypeInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SoOffscreenRenderer::getWriteFiletypeInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSbPList.html">SbPList</a> &amp;&#160;</td>
          <td class="paramname"><em>extlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSbString.html">SbString</a> &amp;&#160;</td>
          <td class="paramname"><em>fullname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSbString.html">SbString</a> &amp;&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns information about an image exporter. <em>extlist</em> is a list of filename extensions for a file format. E.g. for JPEG it is legal to use both jpg and jpeg. Extlist will contain const char * pointers (you need to cast the void * pointers to const char * before using them).</p>
<p><em>fullname</em> is the full name of the image format. <em>description</em> is an optional string with more information about the file format.</p>
<p>See <a class="el" href="classSoOffscreenRenderer.html#a35e63a0d6e2429b837b42d1759d17b5a">SoOffscreenRenderer::isWriteSupported()</a> for information about which file formats you can expect to be present.</p>
<p>This method is an extension versus the original SGI Open Inventor API.</p>
<p>Here is a stand-alone, complete code example that shows how you can check exactly which output formats are supported:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="SoDB_8h.html">Inventor/SoDB.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;Inventor/SoOffscreenRenderer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">  <a class="code" href="classSoDB.html#a970f42dfd362c33c69fa1869bfae72b5">SoDB::init</a>();</div><div class="line">  <a class="code" href="classSoOffscreenRenderer.html">SoOffscreenRenderer</a> * r = <span class="keyword">new</span> <a class="code" href="classSoOffscreenRenderer.html#a77b05979638e69baa4b8df817f5c2b6f">SoOffscreenRenderer</a>(*(<span class="keyword">new</span> <a class="code" href="classSbViewportRegion.html">SbViewportRegion</a>));</div><div class="line">  <span class="keywordtype">int</span> num = r-&gt;<a class="code" href="classSoOffscreenRenderer.html#af7cd797da0585a2b4f0bb321e4b925da">getNumWriteFiletypes</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (num == 0) {</div><div class="line">    (void)fprintf(stdout,</div><div class="line">                  <span class="stringliteral">&quot;No image formats supported by the &quot;</span></div><div class="line">                  <span class="stringliteral">&quot;SoOffscreenRenderer except SGI RGB and Postscript.\n&quot;</span>);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span> {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; num; i++) {</div><div class="line">      <a class="code" href="classSbPList.html">SbPList</a> extlist;</div><div class="line">      <a class="code" href="classSbString.html">SbString</a> fullname, description;</div><div class="line">      r-&gt;<a class="code" href="classSoOffscreenRenderer.html#a3d6757d586bdaaa32e19cb9db161756d">getWriteFiletypeInfo</a>(i, extlist, fullname, description);</div><div class="line">      (void)fprintf(stdout, <span class="stringliteral">&quot;%s: %s (extension%s: &quot;</span>,</div><div class="line">                    fullname.<a class="code" href="classSbString.html#a6bfa023105342c057fe9eb555772ed6c">getString</a>(), description.<a class="code" href="classSbString.html#a6bfa023105342c057fe9eb555772ed6c">getString</a>(),</div><div class="line">                    extlist.<a class="code" href="classSbPList.html#a6a5fdef8d0e2776880391f3b9a5fbb9e">getLength</a>() &gt; 1 ? <span class="stringliteral">&quot;s&quot;</span> : <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; extlist.<a class="code" href="classSbPList.html#a6a5fdef8d0e2776880391f3b9a5fbb9e">getLength</a>(); j++) {</div><div class="line">        (void)fprintf(stdout, <span class="stringliteral">&quot;%s%s&quot;</span>, j&gt;0 ? <span class="stringliteral">&quot;, &quot;</span> : <span class="stringliteral">&quot;&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*) extlist[j]);</div><div class="line">      }</div><div class="line">      (void)fprintf(stdout, <span class="stringliteral">&quot;)\n&quot;</span>);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">delete</span> r;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOffscreenRenderer.html#af7cd797da0585a2b4f0bb321e4b925da">getNumWriteFiletypes()</a>, <a class="el" href="classSoOffscreenRenderer.html#a7f9c7c4603b1a29353c0b26dc4e57586">writeToFile()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Coin 2.3 </dd></dl>

</div>
</div>
<a id="a7f9c7c4603b1a29353c0b26dc4e57586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9c7c4603b1a29353c0b26dc4e57586">&#9670;&nbsp;</a></span>writeToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SbBool SoOffscreenRenderer::writeToFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSbString.html">SbString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSbName.html">SbName</a> &amp;&#160;</td>
          <td class="paramname"><em>filetypeextension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves the buffer to <em>filename</em>, in the filetype specified by <em>filetypeextensions</em>.</p>
<p>Note that you must still specify the <em>full</em> <em>filename</em> for the first argument, i.e. the second argument will not automatically be attached to the filename &ndash; it is only used to decide the filetype.</p>
<p>This method is an extension versus the orignal SGI Open Inventor API.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOffscreenRenderer.html#a35e63a0d6e2429b837b42d1759d17b5a">isWriteSupported()</a> </dd></dl>

</div>
</div>
<a id="ae400ae638df4585c8881ee718ccb8189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae400ae638df4585c8881ee718ccb8189">&#9670;&nbsp;</a></span>setPbufferEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SoOffscreenRenderer::setPbufferEnable </td>
          <td>(</td>
          <td class="paramtype">SbBool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Control whether or not <a class="el" href="classSoOffscreenRenderer.html" title="The SoOffscreenRenderer class is used for rendering scenes in offscreen buffers.If you want to render...">SoOffscreenRenderer</a> can use the "pbuffer" feature of OpenGL to render the scenes with hardware acceleration.</p>
<p>This is a dummy function in Coin, provided for API compatibility reasons, as it is really superfluous:</p>
<p>Coin has internal heuristics to figure out if pbuffers are available and can be allocated and used for the <a class="el" href="classSoOffscreenRenderer.html" title="The SoOffscreenRenderer class is used for rendering scenes in offscreen buffers.If you want to render...">SoOffscreenRenderer</a>. The <a class="el" href="classSoOffscreenRenderer.html" title="The SoOffscreenRenderer class is used for rendering scenes in offscreen buffers.If you want to render...">SoOffscreenRenderer</a> will also automatically fall back on "soft" buffers if it can not use pbuffers (or any other hardware accelerated rendering technique).</p>
<dl class="section since"><dt>Since</dt><dd>Coin 3.1 </dd></dl>

</div>
</div>
<a id="adbcfc5af69338e38ed9f6460bd3542ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcfc5af69338e38ed9f6460bd3542ac">&#9670;&nbsp;</a></span>getPbufferEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SbBool SoOffscreenRenderer::getPbufferEnable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See <a class="el" href="classSoOffscreenRenderer.html#ae400ae638df4585c8881ee718ccb8189">SoOffscreenRenderer::setPbufferEnable()</a>.</p>
<dl class="section since"><dt>Since</dt><dd>Coin 3.1 </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="SoOffscreenRenderer_8h_source.html">SoOffscreenRenderer.h</a></li>
<li>SoOffscreenRenderer.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classSoOffscreenRenderer.html">SoOffscreenRenderer</a></li>
    <li class="footer">Generated on Sun May 28 2017 02:26:05 for Coin by
    <a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
