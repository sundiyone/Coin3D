<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>Coin: SoOutput Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%; background-image:url('nav_f.png'); background-color: #E2E8F2; background-repeat:repeat-x">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em; width: 66px;">
   <img src="Coin_logo.png" alt="Coin Logo" />
  </td>
  <td>
    Coin3D is Free Software,<br />published under the <a href="http://opensource.org/licenses/BSD-3-Clause">BSD 3-clause license</a>.
  </td>
  <td style="text-align: right; padding-right: 0.5em;">
    <a href="https://bitbucket.org/Coin3D/">https://bitbucket.org/Coin3D/</a><br />
    <a href="http://www.kongsberg.com/kogt/">http://www.kongsberg.com/kogt/</a><br />  
    </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSoOutput.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classSoOutput-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SoOutput Class Reference<div class="ingroups"><a class="el" href="group__general.html">Miscellaneous Classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classSoOutput.html" title="The SoOutput class is an abstraction of an output stream.SoOutput offers the ability to write basic t...">SoOutput</a> class is an abstraction of an output stream.<a class="el" href="classSoOutput.html" title="The SoOutput class is an abstraction of an output stream.SoOutput offers the ability to write basic t...">SoOutput</a> offers the ability to write basic types to a file or a memory buffer in either ASCII or binary format.  
 <a href="classSoOutput.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SoOutput_8h_source.html">Inventor/SoOutput.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af5f67f92434acc6d7c7619d3ef1dfb7f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#af5f67f92434acc6d7c7619d3ef1dfb7f">Stage</a> { <a class="el" href="classSoOutput.html#af5f67f92434acc6d7c7619d3ef1dfb7fae0d98ba0aaa299ac5309ba8280c54282">COUNT_REFS</a>, 
<a class="el" href="classSoOutput.html#af5f67f92434acc6d7c7619d3ef1dfb7fa65828b821d5c69d570a053c2f0b032b2">WRITE</a>
 }</td></tr>
<tr class="separator:af5f67f92434acc6d7c7619d3ef1dfb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6557a37a92efd9a0dc80f717f832f65c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a6557a37a92efd9a0dc80f717f832f65c">Annotations</a> { <a class="el" href="classSoOutput.html#a6557a37a92efd9a0dc80f717f832f65cae6f5a8f71f72eb2287c6c5f9715de398">ADDRESSES</a> = 0x01, 
<a class="el" href="classSoOutput.html#a6557a37a92efd9a0dc80f717f832f65cab8cd4cd580cbe52f6f29a34b3593edb1">REF_COUNTS</a> = 0x02
 }</td></tr>
<tr class="separator:a6557a37a92efd9a0dc80f717f832f65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af6b0a04ee8bfd49d99fe40d691dc2564"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#af6b0a04ee8bfd49d99fe40d691dc2564">SoOutput</a> (void)</td></tr>
<tr class="separator:af6b0a04ee8bfd49d99fe40d691dc2564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7cc39477298359896a2d542a8996c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#abb7cc39477298359896a2d542a8996c4">SoOutput</a> (<a class="el" href="classSoOutput.html">SoOutput</a> *dictOut)</td></tr>
<tr class="separator:abb7cc39477298359896a2d542a8996c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670ea6c80f55d25c7b0021c3e86b883a"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a670ea6c80f55d25c7b0021c3e86b883a">~SoOutput</a> ()</td></tr>
<tr class="separator:a670ea6c80f55d25c7b0021c3e86b883a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b6ff34263ce8bbe6e6a354b8e24382"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a23b6ff34263ce8bbe6e6a354b8e24382">setFilePointer</a> (FILE *newFP)</td></tr>
<tr class="separator:a23b6ff34263ce8bbe6e6a354b8e24382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29933d0eef663faeae145afe9a567836"><td class="memItemLeft" align="right" valign="top">virtual FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a29933d0eef663faeae145afe9a567836">getFilePointer</a> (void) const</td></tr>
<tr class="separator:a29933d0eef663faeae145afe9a567836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bd93d4388bcbd7415c85241b2e9d3b"><td class="memItemLeft" align="right" valign="top">virtual SbBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a15bd93d4388bcbd7415c85241b2e9d3b">openFile</a> (const char *const fileName)</td></tr>
<tr class="separator:a15bd93d4388bcbd7415c85241b2e9d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731b0fb2e9d1bc7022072c731a016e80"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a731b0fb2e9d1bc7022072c731a016e80">closeFile</a> (void)</td></tr>
<tr class="separator:a731b0fb2e9d1bc7022072c731a016e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e3cda480c9a958e43d49e937925911"><td class="memItemLeft" align="right" valign="top">SbBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#aa6e3cda480c9a958e43d49e937925911">setCompression</a> (const <a class="el" href="classSbName.html">SbName</a> &amp;compmethod, const float level=0.5f)</td></tr>
<tr class="separator:aa6e3cda480c9a958e43d49e937925911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e03f4b73073ca6e120029581774bc7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a09e03f4b73073ca6e120029581774bc7">setBuffer</a> (void *bufPointer, size_t initSize, SoOutputReallocCB *reallocFunc, int32_t offset=0)</td></tr>
<tr class="separator:a09e03f4b73073ca6e120029581774bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff275ad2c2364a2f091a9bbc90a1f2e4"><td class="memItemLeft" align="right" valign="top">virtual SbBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#aff275ad2c2364a2f091a9bbc90a1f2e4">getBuffer</a> (void *&amp;bufPointer, size_t &amp;nBytes) const</td></tr>
<tr class="separator:aff275ad2c2364a2f091a9bbc90a1f2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ec26e51a5e6ba5af4562c67147eb5d"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#ad0ec26e51a5e6ba5af4562c67147eb5d">getBufferSize</a> (void) const</td></tr>
<tr class="separator:ad0ec26e51a5e6ba5af4562c67147eb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8509851087905c9952fa03a68e489e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#afa8509851087905c9952fa03a68e489e">resetBuffer</a> (void)</td></tr>
<tr class="separator:afa8509851087905c9952fa03a68e489e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae475769e022ccd316ad1125bbda7b3d3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#ae475769e022ccd316ad1125bbda7b3d3">setBinary</a> (const SbBool flag)</td></tr>
<tr class="separator:ae475769e022ccd316ad1125bbda7b3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6515a8b005df5d7f28fbec7c33590f"><td class="memItemLeft" align="right" valign="top">virtual SbBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a0c6515a8b005df5d7f28fbec7c33590f">isBinary</a> (void) const</td></tr>
<tr class="separator:a0c6515a8b005df5d7f28fbec7c33590f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad993f2c040c1b39d7dc560784188847c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#ad993f2c040c1b39d7dc560784188847c">setHeaderString</a> (const <a class="el" href="classSbString.html">SbString</a> &amp;str)</td></tr>
<tr class="separator:ad993f2c040c1b39d7dc560784188847c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a029142b4b708bb2f4ca4662a21fa2a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a6a029142b4b708bb2f4ca4662a21fa2a">resetHeaderString</a> (void)</td></tr>
<tr class="separator:a6a029142b4b708bb2f4ca4662a21fa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499be4cd2d30a68ef86849b924a1300b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a499be4cd2d30a68ef86849b924a1300b">setFloatPrecision</a> (const <a class="el" href="classint.html">int</a> precision)</td></tr>
<tr class="separator:a499be4cd2d30a68ef86849b924a1300b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b89daf5481cda8842a32d1731a919f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#ad6b89daf5481cda8842a32d1731a919f">setStage</a> (<a class="el" href="classSoOutput.html#af5f67f92434acc6d7c7619d3ef1dfb7f">Stage</a> stage)</td></tr>
<tr class="separator:ad6b89daf5481cda8842a32d1731a919f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d454949ef2bcba49c3940fe0418999c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoOutput.html#af5f67f92434acc6d7c7619d3ef1dfb7f">Stage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a5d454949ef2bcba49c3940fe0418999c">getStage</a> (void) const</td></tr>
<tr class="separator:a5d454949ef2bcba49c3940fe0418999c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8625a0963e65ae38cf211979b0ea0c7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a8625a0963e65ae38cf211979b0ea0c7c">incrementIndent</a> (const <a class="el" href="classint.html">int</a> levels=1)</td></tr>
<tr class="separator:a8625a0963e65ae38cf211979b0ea0c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164e1c3bc35933add8a2651905a3735a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a164e1c3bc35933add8a2651905a3735a">decrementIndent</a> (const <a class="el" href="classint.html">int</a> levels=1)</td></tr>
<tr class="separator:a164e1c3bc35933add8a2651905a3735a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab175e8569a99c5b78a02fc4210a50d5d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#ab175e8569a99c5b78a02fc4210a50d5d">write</a> (const char c)</td></tr>
<tr class="separator:ab175e8569a99c5b78a02fc4210a50d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0fdc3bb8f3dd2c69f771f8d7c892e96"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#ad0fdc3bb8f3dd2c69f771f8d7c892e96">write</a> (const char *s)</td></tr>
<tr class="separator:ad0fdc3bb8f3dd2c69f771f8d7c892e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea09a032e44d59688fe1855be110c4a4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#aea09a032e44d59688fe1855be110c4a4">write</a> (const <a class="el" href="classSbString.html">SbString</a> &amp;s)</td></tr>
<tr class="separator:aea09a032e44d59688fe1855be110c4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2835386710c5744793bac2fdfb3038"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a7f2835386710c5744793bac2fdfb3038">write</a> (const <a class="el" href="classSbName.html">SbName</a> &amp;n)</td></tr>
<tr class="separator:a7f2835386710c5744793bac2fdfb3038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1835bb7abf99a29d19650be36e51ee9f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a1835bb7abf99a29d19650be36e51ee9f">write</a> (const <a class="el" href="classint.html">int</a> i)</td></tr>
<tr class="separator:a1835bb7abf99a29d19650be36e51ee9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1673aac3831873bcfa7e257175447a6b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a1673aac3831873bcfa7e257175447a6b">write</a> (const unsigned <a class="el" href="classint.html">int</a> i)</td></tr>
<tr class="separator:a1673aac3831873bcfa7e257175447a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6434dfbac3a2baf7ef766083eb7875"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a9a6434dfbac3a2baf7ef766083eb7875">write</a> (const short s)</td></tr>
<tr class="separator:a9a6434dfbac3a2baf7ef766083eb7875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b9e65b5c83d3bf70bde83ffb55efdc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a24b9e65b5c83d3bf70bde83ffb55efdc">write</a> (const unsigned short s)</td></tr>
<tr class="separator:a24b9e65b5c83d3bf70bde83ffb55efdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762585e6856d8e234ae358a1e5de4c91"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a762585e6856d8e234ae358a1e5de4c91">write</a> (const float f)</td></tr>
<tr class="separator:a762585e6856d8e234ae358a1e5de4c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46f450533be763ccd3f45484ed3f139"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#aa46f450533be763ccd3f45484ed3f139">write</a> (const double d)</td></tr>
<tr class="separator:aa46f450533be763ccd3f45484ed3f139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1cce06bcb3e36cefb419da32cf70e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a1d1cce06bcb3e36cefb419da32cf70e9">writeBinaryArray</a> (const unsigned char *c, const <a class="el" href="classint.html">int</a> length)</td></tr>
<tr class="separator:a1d1cce06bcb3e36cefb419da32cf70e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d676b7c5e16473572bf1c7925615600"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a7d676b7c5e16473572bf1c7925615600">writeBinaryArray</a> (const int32_t *const l, const <a class="el" href="classint.html">int</a> length)</td></tr>
<tr class="separator:a7d676b7c5e16473572bf1c7925615600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c825150ca0a1b3bef4d41c38bda5ef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a93c825150ca0a1b3bef4d41c38bda5ef">writeBinaryArray</a> (const float *const f, const <a class="el" href="classint.html">int</a> length)</td></tr>
<tr class="separator:a93c825150ca0a1b3bef4d41c38bda5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943723970330050a9d23c97a89e089e2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a943723970330050a9d23c97a89e089e2">writeBinaryArray</a> (const double *const d, const <a class="el" href="classint.html">int</a> length)</td></tr>
<tr class="separator:a943723970330050a9d23c97a89e089e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e9261a4563b7441d2fe7cdca92471c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a80e9261a4563b7441d2fe7cdca92471c">indent</a> (void)</td></tr>
<tr class="separator:a80e9261a4563b7441d2fe7cdca92471c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00035cbc43d148976dc9dfef26f13932"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a00035cbc43d148976dc9dfef26f13932">reset</a> (void)</td></tr>
<tr class="separator:a00035cbc43d148976dc9dfef26f13932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff4168e5475effe76369d9095f86ef7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a9ff4168e5475effe76369d9095f86ef7">setCompact</a> (SbBool flag)</td></tr>
<tr class="separator:a9ff4168e5475effe76369d9095f86ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6099591cf804a8bfe2283a315232da"><td class="memItemLeft" align="right" valign="top">SbBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a4f6099591cf804a8bfe2283a315232da">isCompact</a> (void) const</td></tr>
<tr class="separator:a4f6099591cf804a8bfe2283a315232da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edfea0bd68a9b59100464883534f64e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a7edfea0bd68a9b59100464883534f64e">setAnnotation</a> (uint32_t bits)</td></tr>
<tr class="separator:a7edfea0bd68a9b59100464883534f64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a2381046d761beeaa7f76145bc02fd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a93a2381046d761beeaa7f76145bc02fd">getAnnotation</a> (void)</td></tr>
<tr class="separator:a93a2381046d761beeaa7f76145bc02fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a62c959a6b070ca51af5ca64af63360"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a3a62c959a6b070ca51af5ca64af63360">addReference</a> (const <a class="el" href="classSoBase.html">SoBase</a> *base)</td></tr>
<tr class="separator:a3a62c959a6b070ca51af5ca64af63360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb8384168c1d95488cb537c063e30e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a9cb8384168c1d95488cb537c063e30e4">findReference</a> (const <a class="el" href="classSoBase.html">SoBase</a> *base) const</td></tr>
<tr class="separator:a9cb8384168c1d95488cb537c063e30e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ba02856c3f3e90753700fa51a837a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a85ba02856c3f3e90753700fa51a837a8">setReference</a> (const <a class="el" href="classSoBase.html">SoBase</a> *base, <a class="el" href="classint.html">int</a> refid)</td></tr>
<tr class="separator:a85ba02856c3f3e90753700fa51a837a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af119503db875683d18470c5dec34d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a3af119503db875683d18470c5dec34d1">addDEFNode</a> (<a class="el" href="classSbName.html">SbName</a> name)</td></tr>
<tr class="separator:a3af119503db875683d18470c5dec34d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0106943506a2ed550af5897069a80c32"><td class="memItemLeft" align="right" valign="top">SbBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a0106943506a2ed550af5897069a80c32">lookupDEFNode</a> (<a class="el" href="classSbName.html">SbName</a> name)</td></tr>
<tr class="separator:a0106943506a2ed550af5897069a80c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7555f4de703a968d5b00f5b044df801e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a7555f4de703a968d5b00f5b044df801e">removeDEFNode</a> (<a class="el" href="classSbName.html">SbName</a> name)</td></tr>
<tr class="separator:a7555f4de703a968d5b00f5b044df801e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff364eb3e0d6b21817684503414f252"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a5ff364eb3e0d6b21817684503414f252">pushProto</a> (<a class="el" href="classSoProto.html">SoProto</a> *proto)</td></tr>
<tr class="separator:a5ff364eb3e0d6b21817684503414f252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d072e2cc8dde6a67f26db6d36bc16f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoProto.html">SoProto</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a8d072e2cc8dde6a67f26db6d36bc16f4">getCurrentProto</a> (void) const</td></tr>
<tr class="separator:a8d072e2cc8dde6a67f26db6d36bc16f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59dc3572204939c84da139f4ddc441e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a59dc3572204939c84da139f4ddc441e0">popProto</a> (void)</td></tr>
<tr class="separator:a59dc3572204939c84da139f4ddc441e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13040af220e1a609e2402c7b4b6a3b3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a13040af220e1a609e2402c7b4b6a3b3d">addRoute</a> (<a class="el" href="classSoFieldContainer.html">SoFieldContainer</a> *from, const <a class="el" href="classSbName.html">SbName</a> &amp;fromfield, <a class="el" href="classSoFieldContainer.html">SoFieldContainer</a> *to, const <a class="el" href="classSbName.html">SbName</a> &amp;tofield)</td></tr>
<tr class="separator:a13040af220e1a609e2402c7b4b6a3b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4d22c3ae245f50060e2e6ab5272012"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a8a4d22c3ae245f50060e2e6ab5272012">resolveRoutes</a> (void)</td></tr>
<tr class="separator:a8a4d22c3ae245f50060e2e6ab5272012"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a902c5214a8a02777bca40f69f37a817a"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classSbName.html">SbName</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a902c5214a8a02777bca40f69f37a817a">getAvailableCompressionMethods</a> (unsigned <a class="el" href="classint.html">int</a> &amp;num)</td></tr>
<tr class="separator:a902c5214a8a02777bca40f69f37a817a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28e992d4158657626b1dfcca79d2ae6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSbString.html">SbString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#ab28e992d4158657626b1dfcca79d2ae6">getDefaultASCIIHeader</a> (void)</td></tr>
<tr class="separator:ab28e992d4158657626b1dfcca79d2ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af494abf9f4e052c86c9e53910fe0fc81"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSbString.html">SbString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#af494abf9f4e052c86c9e53910fe0fc81">getDefaultBinaryHeader</a> (void)</td></tr>
<tr class="separator:af494abf9f4e052c86c9e53910fe0fc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a498c9f2202fbd66713c3028000ac8652"><td class="memItemLeft" align="right" valign="top">SbBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a498c9f2202fbd66713c3028000ac8652">isToBuffer</a> (void) const</td></tr>
<tr class="separator:a498c9f2202fbd66713c3028000ac8652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ab642a8e281f414db095e11cef746d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a57ab642a8e281f414db095e11cef746d">bytesInBuf</a> (void) const</td></tr>
<tr class="separator:a57ab642a8e281f414db095e11cef746d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e2ef06c15f73d0b50cfa899df46d9b"><td class="memItemLeft" align="right" valign="top">SbBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#ac0e2ef06c15f73d0b50cfa899df46d9b">makeRoomInBuf</a> (size_t nBytes)</td></tr>
<tr class="separator:ac0e2ef06c15f73d0b50cfa899df46d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae722ef6508d77fec90d3842d426782cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#ae722ef6508d77fec90d3842d426782cc">convertShort</a> (short s, char *to)</td></tr>
<tr class="separator:ae722ef6508d77fec90d3842d426782cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03ec3e531799b0ab872dbd6f2feefd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#af03ec3e531799b0ab872dbd6f2feefd6">convertInt32</a> (int32_t l, char *to)</td></tr>
<tr class="separator:af03ec3e531799b0ab872dbd6f2feefd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a6d2389dbb3a6fb43df619588243f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#ae2a6d2389dbb3a6fb43df619588243f1">convertFloat</a> (float f, char *to)</td></tr>
<tr class="separator:ae2a6d2389dbb3a6fb43df619588243f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa735b7f04b8175020d674bfb3f7841e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#aa735b7f04b8175020d674bfb3f7841e5">convertDouble</a> (double d, char *to)</td></tr>
<tr class="separator:aa735b7f04b8175020d674bfb3f7841e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4067438e84b6ab7b32a22cb7b5f746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a0b4067438e84b6ab7b32a22cb7b5f746">convertShortArray</a> (short *from, char *to, <a class="el" href="classint.html">int</a> len)</td></tr>
<tr class="separator:a0b4067438e84b6ab7b32a22cb7b5f746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d1259c90e3f9d45680511216befca8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#aa5d1259c90e3f9d45680511216befca8">convertInt32Array</a> (int32_t *from, char *to, <a class="el" href="classint.html">int</a> len)</td></tr>
<tr class="separator:aa5d1259c90e3f9d45680511216befca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c28b4db51c1e81e4edc7078c43a054e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a1c28b4db51c1e81e4edc7078c43a054e">convertFloatArray</a> (float *from, char *to, <a class="el" href="classint.html">int</a> len)</td></tr>
<tr class="separator:a1c28b4db51c1e81e4edc7078c43a054e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb0aac2bae9ef5fabdf6dcfec9bff3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a7fb0aac2bae9ef5fabdf6dcfec9bff3b">convertDoubleArray</a> (double *from, char *to, <a class="el" href="classint.html">int</a> len)</td></tr>
<tr class="separator:a7fb0aac2bae9ef5fabdf6dcfec9bff3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a998d4708239ebb78dc26d23a3e452794"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSbString.html">SbString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a998d4708239ebb78dc26d23a3e452794">padHeader</a> (const <a class="el" href="classSbString.html">SbString</a> &amp;inString)</td></tr>
<tr class="separator:a998d4708239ebb78dc26d23a3e452794"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a115045b8a4e57f8936223a75c991e8e8"><td class="memItemLeft" align="right" valign="top">SbBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSoOutput.html#a115045b8a4e57f8936223a75c991e8e8">wroteHeader</a></td></tr>
<tr class="separator:a115045b8a4e57f8936223a75c991e8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classSoOutput.html" title="The SoOutput class is an abstraction of an output stream.SoOutput offers the ability to write basic t...">SoOutput</a> class is an abstraction of an output stream.</p>
<p><a class="el" href="classSoOutput.html" title="The SoOutput class is an abstraction of an output stream.SoOutput offers the ability to write basic t...">SoOutput</a> offers the ability to write basic types to a file or a memory buffer in either ASCII or binary format. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoInput.html" title="The SoInput class is an abstraction of file import functionality.This class takes care of most of the...">SoInput</a>, <a class="el" href="classSoWriteAction.html" title="The SoWriteAction class writes a scene graph to file.When applied to a scene, this action writes its ...">SoWriteAction</a> </dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="af5f67f92434acc6d7c7619d3ef1dfb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f67f92434acc6d7c7619d3ef1dfb7f">&#9670;&nbsp;</a></span>Stage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSoOutput.html#af5f67f92434acc6d7c7619d3ef1dfb7f">SoOutput::Stage</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumerates the possible stages of a write operation (writing needs to be done in mutiple passes).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOutput.html#ad6b89daf5481cda8842a32d1731a919f">setStage()</a>, <a class="el" href="classSoOutput.html#a5d454949ef2bcba49c3940fe0418999c">getStage()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af5f67f92434acc6d7c7619d3ef1dfb7fae0d98ba0aaa299ac5309ba8280c54282"></a>COUNT_REFS&#160;</td><td class="fielddoc"><p>Not writing, just counting the internal references in the scene graph. </p>
</td></tr>
<tr><td class="fieldname"><a id="af5f67f92434acc6d7c7619d3ef1dfb7fa65828b821d5c69d570a053c2f0b032b2"></a>WRITE&#160;</td><td class="fielddoc"><p>Signifies that actual data export should take place during this pass. </p>
</td></tr>
</table>

</div>
</div>
<a id="a6557a37a92efd9a0dc80f717f832f65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6557a37a92efd9a0dc80f717f832f65c">&#9670;&nbsp;</a></span>Annotations</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSoOutput.html#a6557a37a92efd9a0dc80f717f832f65c">SoOutput::Annotations</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values from this enum is used for debugging purposes to annotate the output from a write operation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6557a37a92efd9a0dc80f717f832f65cae6f5a8f71f72eb2287c6c5f9715de398"></a>ADDRESSES&#160;</td><td class="fielddoc"><p>Annotate output with pointer address information. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6557a37a92efd9a0dc80f717f832f65cab8cd4cd580cbe52f6f29a34b3593edb1"></a>REF_COUNTS&#160;</td><td class="fielddoc"><p>Annotate output with reference counts of the objects written. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af6b0a04ee8bfd49d99fe40d691dc2564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b0a04ee8bfd49d99fe40d691dc2564">&#9670;&nbsp;</a></span>SoOutput() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SoOutput::SoOutput </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default constructor makes an <a class="el" href="classSoOutput.html" title="The SoOutput class is an abstraction of an output stream.SoOutput offers the ability to write basic t...">SoOutput</a> instance which will write to the standard output.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOutput.html#a23b6ff34263ce8bbe6e6a354b8e24382">setFilePointer()</a>, <a class="el" href="classSoOutput.html#a15bd93d4388bcbd7415c85241b2e9d3b">openFile()</a>, <a class="el" href="classSoOutput.html#a09e03f4b73073ca6e120029581774bc7">setBuffer()</a> </dd></dl>

</div>
</div>
<a id="abb7cc39477298359896a2d542a8996c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7cc39477298359896a2d542a8996c4">&#9670;&nbsp;</a></span>SoOutput() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SoOutput::SoOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSoOutput.html">SoOutput</a> *&#160;</td>
          <td class="paramname"><em>dictOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an <a class="el" href="classSoOutput.html" title="The SoOutput class is an abstraction of an output stream.SoOutput offers the ability to write basic t...">SoOutput</a> which has a copy of the set of named references from <em>dictOut</em>. </p>

</div>
</div>
<a id="a670ea6c80f55d25c7b0021c3e86b883a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670ea6c80f55d25c7b0021c3e86b883a">&#9670;&nbsp;</a></span>~SoOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SoOutput::~SoOutput </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a23b6ff34263ce8bbe6e6a354b8e24382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b6ff34263ce8bbe6e6a354b8e24382">&#9670;&nbsp;</a></span>setFilePointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::setFilePointer </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>newFP</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set up a new file pointer which we will write to.</p>
<p>Important note: do <em>not</em> use this method when the Coin library has been compiled as an MSWindows DLL, as passing FILE* instances back or forth to DLLs is dangerous and will most likely cause a crash. This is an intrinsic limitation for MSWindows DLLs.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOutput.html#a15bd93d4388bcbd7415c85241b2e9d3b">openFile()</a>, <a class="el" href="classSoOutput.html#a09e03f4b73073ca6e120029581774bc7">setBuffer()</a>, <a class="el" href="classSoOutput.html#a29933d0eef663faeae145afe9a567836">getFilePointer()</a> </dd></dl>

</div>
</div>
<a id="a29933d0eef663faeae145afe9a567836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29933d0eef663faeae145afe9a567836">&#9670;&nbsp;</a></span>getFilePointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FILE * SoOutput::getFilePointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current filepointer. If we're writing to a memory buffer, <code>NULL</code> is returned.</p>
<p>Important note: do <em>not</em> use this method when the Coin library has been compiled as an MSWindows DLL, as passing FILE* instances back or forth to DLLs is dangerous and will most likely cause a crash. This is an intrinsic limitation for MSWindows DLLs.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOutput.html#a23b6ff34263ce8bbe6e6a354b8e24382">setFilePointer()</a> </dd></dl>

</div>
</div>
<a id="a15bd93d4388bcbd7415c85241b2e9d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bd93d4388bcbd7415c85241b2e9d3b">&#9670;&nbsp;</a></span>openFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SbBool SoOutput::openFile </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Opens a file for writing. If the file can not be opened or is not writeable, <em>FALSE</em> will be returned.</p>
<p>Files opened by this method will automatically be closed if the user supplies another filepointer, another filename for writing, or if the <a class="el" href="classSoOutput.html" title="The SoOutput class is an abstraction of an output stream.SoOutput offers the ability to write basic t...">SoOutput</a> instance is deleted.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOutput.html#a23b6ff34263ce8bbe6e6a354b8e24382">setFilePointer()</a>, <a class="el" href="classSoOutput.html#a09e03f4b73073ca6e120029581774bc7">setBuffer()</a>, <a class="el" href="classSoOutput.html#a731b0fb2e9d1bc7022072c731a016e80">closeFile()</a> </dd></dl>

</div>
</div>
<a id="a731b0fb2e9d1bc7022072c731a016e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731b0fb2e9d1bc7022072c731a016e80">&#9670;&nbsp;</a></span>closeFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::closeFile </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Closes the currently opened file, but only if the file was passed to <a class="el" href="classSoOutput.html" title="The SoOutput class is an abstraction of an output stream.SoOutput offers the ability to write basic t...">SoOutput</a> through the <a class="el" href="classSoOutput.html#a15bd93d4388bcbd7415c85241b2e9d3b">openFile()</a> method.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOutput.html#a15bd93d4388bcbd7415c85241b2e9d3b">openFile()</a> </dd></dl>

</div>
</div>
<a id="aa6e3cda480c9a958e43d49e937925911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e3cda480c9a958e43d49e937925911">&#9670;&nbsp;</a></span>setCompression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SbBool SoOutput::setCompression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSbName.html">SbName</a> &amp;&#160;</td>
          <td class="paramname"><em>compmethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>level</em> = <code>0.5f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the compression method and level used when writing the file. <em>compmethod</em> is the compression library/method to use when compressing. <em>level</em> is the compression level, where 0.0 means no compression and 1.0 means maximum compression.</p>
<p>Currently <em>BZIP2</em>, <em>GZIP</em> are the only compression methods supported, and you have to compile Coin with zlib and bzip2-support to enable them.</p>
<p>Supply <em>compmethod</em> = <em>NONE</em> or <em>level</em> = 0.0 if you want to disable compression. The compression is disabled by default.</p>
<p>Please note that it's not possible to compress when writing to a memory buffer.</p>
<p>This method will return <em>TRUE</em> if the compression method selected is available. If it's not available, <em>FALSE</em> will be returned and compression is disabled.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOutput.html#a902c5214a8a02777bca40f69f37a817a">getAvailableCompressionMethods()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Coin 2.1 </dd></dl>

</div>
</div>
<a id="a902c5214a8a02777bca40f69f37a817a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902c5214a8a02777bca40f69f37a817a">&#9670;&nbsp;</a></span>getAvailableCompressionMethods()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSbName.html">SbName</a> * SoOutput::getAvailableCompressionMethods </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the array of available compression methods. The number of elements in the array will be stored in <em>num</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOutput.html#aa6e3cda480c9a958e43d49e937925911">setCompression()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Coin 2.1 </dd></dl>

</div>
</div>
<a id="a09e03f4b73073ca6e120029581774bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e03f4b73073ca6e120029581774bc7">&#9670;&nbsp;</a></span>setBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::setBuffer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>bufPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>initSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SoOutputReallocCB *&#160;</td>
          <td class="paramname"><em>reallocFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets up a memory buffer of size <em>initSize</em> for writing. Writing will start at <em>bufPointer</em> + <em>offset</em>.</p>
<p>If the buffer is filled up, <em>reallocFunc</em> is called to get more memory. If <em>reallocFunc</em> returns <em>NULL</em>, further writing is disabled.</p>
<p>Important note: remember that the resultant memory buffer after write operations have completed may reside somewhere else in memory than on <em>bufPointer</em> if <em>reallocFunc</em> is set. It is a good idea to make it a habit to always use <a class="el" href="classSoOutput.html#aff275ad2c2364a2f091a9bbc90a1f2e4">getBuffer()</a> to retrieve the memory buffer pointer after write operations.</p>
<p>Here's a complete, stand-alone usage example which shows how to write a scene graph to a memory buffer:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="SoDB_8h.html">Inventor/SoDB.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;Inventor/actions/SoWriteAction.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;Inventor/nodes/SoCone.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;Inventor/nodes/SoSeparator.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">char</span> * buffer;</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">size_t</span> buffer_size = 0;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> *</div><div class="line">buffer_realloc(<span class="keywordtype">void</span> * bufptr, <span class="keywordtype">size_t</span> size)</div><div class="line">{</div><div class="line">  buffer = (<span class="keywordtype">char</span> *)realloc(bufptr, size);</div><div class="line">  buffer_size = size;</div><div class="line">  <span class="keywordflow">return</span> buffer;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <a class="code" href="classSbString.html">SbString</a></div><div class="line">buffer_writeaction(<a class="code" href="classSoNode.html">SoNode</a> * root)</div><div class="line">{</div><div class="line">  <a class="code" href="classSoOutput.html">SoOutput</a> out;</div><div class="line">  buffer = (<span class="keywordtype">char</span> *)malloc(1024);</div><div class="line">  buffer_size = 1024;</div><div class="line">  out.<a class="code" href="classSoOutput.html#a09e03f4b73073ca6e120029581774bc7">setBuffer</a>(buffer, buffer_size, buffer_realloc);</div><div class="line"></div><div class="line">  <a class="code" href="classSoWriteAction.html">SoWriteAction</a> wa(&amp;out);</div><div class="line">  wa.apply(root);</div><div class="line"></div><div class="line">  <a class="code" href="classSbString.html">SbString</a> s(buffer);</div><div class="line">  free(buffer);</div><div class="line">  <span class="keywordflow">return</span> s;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv)</div><div class="line">{</div><div class="line">  <a class="code" href="classSoDB.html#a970f42dfd362c33c69fa1869bfae72b5">SoDB::init</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classSoSeparator.html">SoSeparator</a> * root = <span class="keyword">new</span> <a class="code" href="classSoSeparator.html">SoSeparator</a>;</div><div class="line">  root-&gt;<a class="code" href="classSoBase.html#ac01cf34901b2a2be1bc2671bb2463851">ref</a>();</div><div class="line"></div><div class="line">  root-&gt;<a class="code" href="classSoGroup.html#a23e0a7aebf3ec75c40638cc360c0e5e6">addChild</a>(<span class="keyword">new</span> <a class="code" href="classSoCone.html">SoCone</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classSbString.html">SbString</a> s = buffer_writeaction(root);</div><div class="line">  (void)fprintf(stdout, <span class="stringliteral">&quot;%s\n&quot;</span>, s.<a class="code" href="classSbString.html#a6bfa023105342c057fe9eb555772ed6c">getString</a>());</div><div class="line"></div><div class="line">  root-&gt;<a class="code" href="classSoBase.html#a254b1ac395fe4d4d10438b994bdb3561">unref</a>();</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOutput.html#aff275ad2c2364a2f091a9bbc90a1f2e4">getBuffer()</a>, <a class="el" href="classSoOutput.html#ad0ec26e51a5e6ba5af4562c67147eb5d">getBufferSize()</a>, <a class="el" href="classSoOutput.html#afa8509851087905c9952fa03a68e489e">resetBuffer()</a> </dd></dl>

</div>
</div>
<a id="aff275ad2c2364a2f091a9bbc90a1f2e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff275ad2c2364a2f091a9bbc90a1f2e4">&#9670;&nbsp;</a></span>getBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SbBool SoOutput::getBuffer </td>
          <td>(</td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>bufPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>nBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current buffer in <em>bufPointer</em> and the current write position of the buffer in <em>nBytes</em>. If we're writing into a file and not a memory buffer, <em>FALSE</em> is returned and the other return values will be undefined.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOutput.html#ad0ec26e51a5e6ba5af4562c67147eb5d">getBufferSize()</a> </dd></dl>

</div>
</div>
<a id="ad0ec26e51a5e6ba5af4562c67147eb5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ec26e51a5e6ba5af4562c67147eb5d">&#9670;&nbsp;</a></span>getBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SoOutput::getBufferSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns total size of memory buffer.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOutput.html#aff275ad2c2364a2f091a9bbc90a1f2e4">getBuffer()</a> </dd></dl>

</div>
</div>
<a id="afa8509851087905c9952fa03a68e489e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8509851087905c9952fa03a68e489e">&#9670;&nbsp;</a></span>resetBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::resetBuffer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the memory buffer write pointer back to the beginning of the buffer. </p>

</div>
</div>
<a id="ae475769e022ccd316ad1125bbda7b3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae475769e022ccd316ad1125bbda7b3d3">&#9670;&nbsp;</a></span>setBinary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::setBinary </td>
          <td>(</td>
          <td class="paramtype">const SbBool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set whether or not to write the output as a binary stream.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOutput.html#a0c6515a8b005df5d7f28fbec7c33590f">isBinary()</a> </dd></dl>

</div>
</div>
<a id="a0c6515a8b005df5d7f28fbec7c33590f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c6515a8b005df5d7f28fbec7c33590f">&#9670;&nbsp;</a></span>isBinary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SbBool SoOutput::isBinary </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a flag which indicates whether or not we're writing the output as a binary stream.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOutput.html#ae475769e022ccd316ad1125bbda7b3d3">setBinary()</a> </dd></dl>

</div>
</div>
<a id="ad993f2c040c1b39d7dc560784188847c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad993f2c040c1b39d7dc560784188847c">&#9670;&nbsp;</a></span>setHeaderString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::setHeaderString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSbString.html">SbString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the output file header string.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOutput.html#a6a029142b4b708bb2f4ca4662a21fa2a">resetHeaderString()</a>, <a class="el" href="classSoOutput.html#ab28e992d4158657626b1dfcca79d2ae6">getDefaultASCIIHeader()</a>, <a class="el" href="classSoOutput.html#af494abf9f4e052c86c9e53910fe0fc81">getDefaultBinaryHeader()</a> </dd></dl>

</div>
</div>
<a id="a6a029142b4b708bb2f4ca4662a21fa2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a029142b4b708bb2f4ca4662a21fa2a">&#9670;&nbsp;</a></span>resetHeaderString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::resetHeaderString </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the header string to the default one.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOutput.html#ad993f2c040c1b39d7dc560784188847c">setHeaderString()</a>, <a class="el" href="classSoOutput.html#ab28e992d4158657626b1dfcca79d2ae6">getDefaultASCIIHeader()</a>, <a class="el" href="classSoOutput.html#af494abf9f4e052c86c9e53910fe0fc81">getDefaultBinaryHeader()</a> </dd></dl>

</div>
</div>
<a id="a499be4cd2d30a68ef86849b924a1300b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499be4cd2d30a68ef86849b924a1300b">&#9670;&nbsp;</a></span>setFloatPrecision()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::setFloatPrecision </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the precision used when writing floating point numbers to ASCII files. <em>precision</em> should be between 0 and 8. The double precision will be set to <em>precision</em> * 2. </p>

</div>
</div>
<a id="ad6b89daf5481cda8842a32d1731a919f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b89daf5481cda8842a32d1731a919f">&#9670;&nbsp;</a></span>setStage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::setStage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSoOutput.html#af5f67f92434acc6d7c7619d3ef1dfb7f">Stage</a>&#160;</td>
          <td class="paramname"><em>stage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets an indicator on the current stage. This is necessary to do as writing has to be done in multiple stages to account for the export of references/connections within the scene graphs.</p>
<p>This method is basically just used from within <a class="el" href="classSoWriteAction.html" title="The SoWriteAction class writes a scene graph to file.When applied to a scene, this action writes its ...">SoWriteAction</a>, and should usually not be of interest to the application programmer. Do not use it unless you <em>really</em> know what you are doing.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOutput.html#a5d454949ef2bcba49c3940fe0418999c">getStage()</a> </dd></dl>

</div>
</div>
<a id="a5d454949ef2bcba49c3940fe0418999c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d454949ef2bcba49c3940fe0418999c">&#9670;&nbsp;</a></span>getStage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoOutput.html#af5f67f92434acc6d7c7619d3ef1dfb7f">SoOutput::Stage</a> SoOutput::getStage </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an indicator on the current write stage. Writing is done in two passes, one to count and check connections, one to do the actual ascii or binary export of data.</p>
<p>You should not need to use this method, as it is meant for internal purposes in Coin.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOutput.html#ad6b89daf5481cda8842a32d1731a919f">setStage()</a> </dd></dl>

</div>
</div>
<a id="a8625a0963e65ae38cf211979b0ea0c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8625a0963e65ae38cf211979b0ea0c7c">&#9670;&nbsp;</a></span>incrementIndent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::incrementIndent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>levels</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increase indentation level in the file.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOutput.html#a164e1c3bc35933add8a2651905a3735a">decrementIndent()</a>, <a class="el" href="classSoOutput.html#a80e9261a4563b7441d2fe7cdca92471c">indent()</a> </dd></dl>

</div>
</div>
<a id="a164e1c3bc35933add8a2651905a3735a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164e1c3bc35933add8a2651905a3735a">&#9670;&nbsp;</a></span>decrementIndent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::decrementIndent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>levels</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrease indentation level in the file.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOutput.html#a8625a0963e65ae38cf211979b0ea0c7c">incrementIndent()</a>, <a class="el" href="classSoOutput.html#a80e9261a4563b7441d2fe7cdca92471c">indent()</a> </dd></dl>

</div>
</div>
<a id="ab175e8569a99c5b78a02fc4210a50d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab175e8569a99c5b78a02fc4210a50d5d">&#9670;&nbsp;</a></span>write() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::write </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the character in <em>c</em>.</p>
<p>For binary write, the character plus 3 padding zero characters will be written. </p>

</div>
</div>
<a id="ad0fdc3bb8f3dd2c69f771f8d7c892e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0fdc3bb8f3dd2c69f771f8d7c892e96">&#9670;&nbsp;</a></span>write() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the character string pointed to by <em>s</em>.</p>
<p>For binary write, a 4-byte MSB-ordered integer with the string length, plus the string plus padding zero characters to get on a 4-byte boundary (if necessary) will be written. </p>

</div>
</div>
<a id="aea09a032e44d59688fe1855be110c4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea09a032e44d59688fe1855be110c4a4">&#9670;&nbsp;</a></span>write() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSbString.html">SbString</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the character string in <em>s</em>. The string will be written with apostrophes. Cast <a class="el" href="classSbString.html" title="The SbString class is a string class with convenience functions for string operations.This is the class used for storing and working with character strings. It automatically takes care of supporting all the &quot;bookkeeping&quot; tasks usually associated with working with character strings, like memory allocation and deallocation etc. ">SbString</a> to char * to write without apostrophes.</p>
<p>If we are supposed to write in binary format, no apostrophes will be added, and writing will be done in the exact same manner as with <a class="el" href="classSoOutput.html#ad0fdc3bb8f3dd2c69f771f8d7c892e96">SoOutput::write(const char * s)</a>. </p>

</div>
</div>
<a id="a7f2835386710c5744793bac2fdfb3038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2835386710c5744793bac2fdfb3038">&#9670;&nbsp;</a></span>write() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSbName.html">SbName</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the character string in <em>n</em>. The name will be enclosed by apostrophes. If you want to write an <a class="el" href="classSbName.html" title="The SbName class stores strings by reference.The class is used by Coin for storing keywords...">SbName</a> instance without the apostrophes, cast the argument to a char *.</p>
<p>If we are supposed to write in binary format, no apostrophes will be added, and writing will be done in the exact same manner as with <a class="el" href="classSoOutput.html#ad0fdc3bb8f3dd2c69f771f8d7c892e96">SoOutput::write(const char * s)</a>. </p>

</div>
</div>
<a id="a1835bb7abf99a29d19650be36e51ee9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1835bb7abf99a29d19650be36e51ee9f">&#9670;&nbsp;</a></span>write() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write <em>i</em> as a character string, or as an architecture independent binary pattern if the <a class="el" href="classSoOutput.html#ae475769e022ccd316ad1125bbda7b3d3">setBinary()</a> flag is activated. </p>

</div>
</div>
<a id="a1673aac3831873bcfa7e257175447a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1673aac3831873bcfa7e257175447a6b">&#9670;&nbsp;</a></span>write() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::write </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write <em>i</em> as a character string, or as an architecture independent binary pattern if the <a class="el" href="classSoOutput.html#ae475769e022ccd316ad1125bbda7b3d3">setBinary()</a> flag is activated. </p>

</div>
</div>
<a id="a9a6434dfbac3a2baf7ef766083eb7875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6434dfbac3a2baf7ef766083eb7875">&#9670;&nbsp;</a></span>write() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::write </td>
          <td>(</td>
          <td class="paramtype">const short&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write <em>s</em> as a character string, or as an architecture independent binary pattern if the <a class="el" href="classSoOutput.html#ae475769e022ccd316ad1125bbda7b3d3">setBinary()</a> flag is activated. </p>

</div>
</div>
<a id="a24b9e65b5c83d3bf70bde83ffb55efdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b9e65b5c83d3bf70bde83ffb55efdc">&#9670;&nbsp;</a></span>write() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::write </td>
          <td>(</td>
          <td class="paramtype">const unsigned short&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write <em>s</em> as a character string, or as an architecture independent binary pattern if the <a class="el" href="classSoOutput.html#ae475769e022ccd316ad1125bbda7b3d3">setBinary()</a> flag is activated. If we're writing in ASCII format, the value will be written in base 16 (hexadecimal). </p>

</div>
</div>
<a id="a762585e6856d8e234ae358a1e5de4c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762585e6856d8e234ae358a1e5de4c91">&#9670;&nbsp;</a></span>write() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::write </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write <em>f</em> as a character string. </p>

</div>
</div>
<a id="aa46f450533be763ccd3f45484ed3f139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46f450533be763ccd3f45484ed3f139">&#9670;&nbsp;</a></span>write() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::write </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write <em>d</em> as a character string. </p>

</div>
</div>
<a id="a1d1cce06bcb3e36cefb419da32cf70e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1cce06bcb3e36cefb419da32cf70e9">&#9670;&nbsp;</a></span>writeBinaryArray() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::writeBinaryArray </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>constc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the given number of bytes to either a file or a memory buffer in binary format. </p>

</div>
</div>
<a id="a7d676b7c5e16473572bf1c7925615600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d676b7c5e16473572bf1c7925615600">&#9670;&nbsp;</a></span>writeBinaryArray() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::writeBinaryArray </td>
          <td>(</td>
          <td class="paramtype">const int32_t *const&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write an <em>length</em> array of int32_t values in binary format. </p>

</div>
</div>
<a id="a93c825150ca0a1b3bef4d41c38bda5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c825150ca0a1b3bef4d41c38bda5ef">&#9670;&nbsp;</a></span>writeBinaryArray() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::writeBinaryArray </td>
          <td>(</td>
          <td class="paramtype">const float *const&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write an array of float values in binary format. </p>

</div>
</div>
<a id="a943723970330050a9d23c97a89e089e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943723970330050a9d23c97a89e089e2">&#9670;&nbsp;</a></span>writeBinaryArray() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::writeBinaryArray </td>
          <td>(</td>
          <td class="paramtype">const double *const&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write an array of double values in binary format. </p>

</div>
</div>
<a id="a80e9261a4563b7441d2fe7cdca92471c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e9261a4563b7441d2fe7cdca92471c">&#9670;&nbsp;</a></span>indent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::indent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call this method after writing a newline to a file to indent the next line to the correct position.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOutput.html#a8625a0963e65ae38cf211979b0ea0c7c">incrementIndent()</a>, <a class="el" href="classSoOutput.html#a164e1c3bc35933add8a2651905a3735a">decrementIndent()</a> </dd></dl>

</div>
</div>
<a id="a00035cbc43d148976dc9dfef26f13932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00035cbc43d148976dc9dfef26f13932">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset all value and make ready for using another filepointer or buffer. </p>

</div>
</div>
<a id="a9ff4168e5475effe76369d9095f86ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff4168e5475effe76369d9095f86ef7">&#9670;&nbsp;</a></span>setCompact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::setCompact </td>
          <td>(</td>
          <td class="paramtype">SbBool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set up the output to be more compact than with the default write routines. </p>

</div>
</div>
<a id="a4f6099591cf804a8bfe2283a315232da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6099591cf804a8bfe2283a315232da">&#9670;&nbsp;</a></span>isCompact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SbBool SoOutput::isCompact </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether or not the write routines tries to compact the data when writing it (i.e. using less whitespace, etc).</p>
<p>Note that "compact" in this sense does <em>not</em> mean "bitwise compression", as it could easily be mistaken for. </p>

</div>
</div>
<a id="a7edfea0bd68a9b59100464883534f64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7edfea0bd68a9b59100464883534f64e">&#9670;&nbsp;</a></span>setAnnotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::setAnnotation </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set up annotation of different aspects of the output data. This is not useful for much else than debugging purposes, I s'pose. </p>

</div>
</div>
<a id="a93a2381046d761beeaa7f76145bc02fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a2381046d761beeaa7f76145bc02fd">&#9670;&nbsp;</a></span>getAnnotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SoOutput::getAnnotation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current annotation debug bitflag settings. </p>

</div>
</div>
<a id="ab28e992d4158657626b1dfcca79d2ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28e992d4158657626b1dfcca79d2ae6">&#9670;&nbsp;</a></span>getDefaultASCIIHeader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSbString.html">SbString</a> SoOutput::getDefaultASCIIHeader </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the default header string written to ASCII files.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOutput.html#ad993f2c040c1b39d7dc560784188847c">setHeaderString()</a>, <a class="el" href="classSoOutput.html#a6a029142b4b708bb2f4ca4662a21fa2a">resetHeaderString()</a>, <a class="el" href="classSoOutput.html#af494abf9f4e052c86c9e53910fe0fc81">getDefaultBinaryHeader()</a> </dd></dl>

</div>
</div>
<a id="af494abf9f4e052c86c9e53910fe0fc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af494abf9f4e052c86c9e53910fe0fc81">&#9670;&nbsp;</a></span>getDefaultBinaryHeader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSbString.html">SbString</a> SoOutput::getDefaultBinaryHeader </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the default header string written to binary files.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoOutput.html#ad993f2c040c1b39d7dc560784188847c">setHeaderString()</a>, <a class="el" href="classSoOutput.html#a6a029142b4b708bb2f4ca4662a21fa2a">resetHeaderString()</a>, <a class="el" href="classSoOutput.html#ab28e992d4158657626b1dfcca79d2ae6">getDefaultASCIIHeader()</a> </dd></dl>

</div>
</div>
<a id="a3a62c959a6b070ca51af5ca64af63360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a62c959a6b070ca51af5ca64af63360">&#9670;&nbsp;</a></span>addReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> SoOutput::addReference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSoBase.html">SoBase</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes a unique id for <em>base</em> and adds a mapping into our dictionary. </p>

</div>
</div>
<a id="a9cb8384168c1d95488cb537c063e30e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb8384168c1d95488cb537c063e30e4">&#9670;&nbsp;</a></span>findReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> SoOutput::findReference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSoBase.html">SoBase</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the unique identifier for <em>base</em> or -1 if not found. </p>

</div>
</div>
<a id="a85ba02856c3f3e90753700fa51a837a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ba02856c3f3e90753700fa51a837a8">&#9670;&nbsp;</a></span>setReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::setReference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSoBase.html">SoBase</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>refid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the reference for <em>base</em> manually. </p>

</div>
</div>
<a id="a3af119503db875683d18470c5dec34d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af119503db875683d18470c5dec34d1">&#9670;&nbsp;</a></span>addDEFNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::addDEFNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSbName.html">SbName</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds <em>name</em> to the set of currently DEF'ed node names so far in the output process. </p>

</div>
</div>
<a id="a0106943506a2ed550af5897069a80c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0106943506a2ed550af5897069a80c32">&#9670;&nbsp;</a></span>lookupDEFNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SbBool SoOutput::lookupDEFNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSbName.html">SbName</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether <em>name</em> is already DEF'ed at this point in the output process. Returns TRUE if <em>name</em> is DEF'ed. </p>

</div>
</div>
<a id="a7555f4de703a968d5b00f5b044df801e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7555f4de703a968d5b00f5b044df801e">&#9670;&nbsp;</a></span>removeDEFNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::removeDEFNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSbName.html">SbName</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes <em>name</em> from the set of DEF'ed node names. Used after the last reference to a DEF'ed node if we want to reuse the DEF at a later point in the file. </p>

</div>
</div>
<a id="a5ff364eb3e0d6b21817684503414f252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff364eb3e0d6b21817684503414f252">&#9670;&nbsp;</a></span>pushProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::pushProto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSoProto.html">SoProto</a> *&#160;</td>
          <td class="paramname"><em>proto</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p>
<dl class="section since"><dt>Since</dt><dd>Coin 2.0 </dd></dl>

</div>
</div>
<a id="a8d072e2cc8dde6a67f26db6d36bc16f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d072e2cc8dde6a67f26db6d36bc16f4">&#9670;&nbsp;</a></span>getCurrentProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoProto.html">SoProto</a> * SoOutput::getCurrentProto </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p>
<dl class="section since"><dt>Since</dt><dd>Coin 2.0 </dd></dl>

</div>
</div>
<a id="a59dc3572204939c84da139f4ddc441e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59dc3572204939c84da139f4ddc441e0">&#9670;&nbsp;</a></span>popProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::popProto </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p>
<dl class="section since"><dt>Since</dt><dd>Coin 2.0 </dd></dl>

</div>
</div>
<a id="a13040af220e1a609e2402c7b4b6a3b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13040af220e1a609e2402c7b4b6a3b3d">&#9670;&nbsp;</a></span>addRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::addRoute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSoFieldContainer.html">SoFieldContainer</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSbName.html">SbName</a> &amp;&#160;</td>
          <td class="paramname"><em>fromfield</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSoFieldContainer.html">SoFieldContainer</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSbName.html">SbName</a> &amp;&#160;</td>
          <td class="paramname"><em>tofield</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p>
<dl class="section since"><dt>Since</dt><dd>Coin 2.0 </dd></dl>

</div>
</div>
<a id="a8a4d22c3ae245f50060e2e6ab5272012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4d22c3ae245f50060e2e6ab5272012">&#9670;&nbsp;</a></span>resolveRoutes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::resolveRoutes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p>
<dl class="section since"><dt>Since</dt><dd>Coin 2.0 </dd></dl>

</div>
</div>
<a id="a498c9f2202fbd66713c3028000ac8652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498c9f2202fbd66713c3028000ac8652">&#9670;&nbsp;</a></span>isToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SbBool SoOutput::isToBuffer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <em>TRUE</em> of we're set up to write to a memory buffer. </p>

</div>
</div>
<a id="a57ab642a8e281f414db095e11cef746d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ab642a8e281f414db095e11cef746d">&#9670;&nbsp;</a></span>bytesInBuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SoOutput::bytesInBuf </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns current write position.</p>
<p>Note that for memory buffer writing, this includes the offset from <a class="el" href="classSoOutput.html#a09e03f4b73073ca6e120029581774bc7">SoOutput::setBuffer()</a>, if any. </p>

</div>
</div>
<a id="ac0e2ef06c15f73d0b50cfa899df46d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e2ef06c15f73d0b50cfa899df46d9b">&#9670;&nbsp;</a></span>makeRoomInBuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SbBool SoOutput::makeRoomInBuf </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check that the current memory buffer has enough space to contain the given number of bytes needed for the next write operation.</p>
<p>Returns <em>FALSE</em> if there's not enough space left, otherwise <em>TRUE</em>.</p>
<p>Note that there will automatically be made an attempt at allocating more memory if the realloction callback function argument of <a class="el" href="classSoOutput.html#a09e03f4b73073ca6e120029581774bc7">setBuffer()</a> was not <em>NULL</em>. </p>

</div>
</div>
<a id="ae722ef6508d77fec90d3842d426782cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae722ef6508d77fec90d3842d426782cc">&#9670;&nbsp;</a></span>convertShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::convertShort </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert the short integer in <em>s</em> to most-significant-byte first format and put the resulting bytes sequentially at <em>to</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoInput.html#a35ad479e386e0349bd7b95ca365db523">SoInput::convertShort()</a> </dd></dl>

</div>
</div>
<a id="af03ec3e531799b0ab872dbd6f2feefd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03ec3e531799b0ab872dbd6f2feefd6">&#9670;&nbsp;</a></span>convertInt32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::convertInt32 </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert the 32-bit integer in <em>l</em> to most-significant-byte first format and put the resulting bytes sequentially at <em>to</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoInput.html#a3f85a5dd4636f5f6884997c81bb1255f">SoInput::convertInt32()</a> </dd></dl>

</div>
</div>
<a id="ae2a6d2389dbb3a6fb43df619588243f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a6d2389dbb3a6fb43df619588243f1">&#9670;&nbsp;</a></span>convertFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::convertFloat </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert the single-precision floating point number in <em>f</em> to most-significant-byte first format and put the resulting bytes sequentially at <em>to</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoInput.html#a993edbf51f25c038a9ab12b5e1d1a8df">SoInput::convertFloat()</a> </dd></dl>

</div>
</div>
<a id="aa735b7f04b8175020d674bfb3f7841e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa735b7f04b8175020d674bfb3f7841e5">&#9670;&nbsp;</a></span>convertDouble()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::convertDouble </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert the double-precision floating point number in <em>d</em> to most-significant-byte first format and put the resulting bytes sequentially at <em>to</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSoInput.html#a12c7f06ddcd60090e1465810dabbfefe">SoInput::convertDouble()</a> </dd></dl>

</div>
</div>
<a id="a0b4067438e84b6ab7b32a22cb7b5f746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4067438e84b6ab7b32a22cb7b5f746">&#9670;&nbsp;</a></span>convertShortArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::convertShortArray </td>
          <td>(</td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert <em>len</em> short integer values from the array at <em>from</em> into the array at <em>to</em> from native host format to network independent format (i.e. most significant byte first). </p>

</div>
</div>
<a id="aa5d1259c90e3f9d45680511216befca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d1259c90e3f9d45680511216befca8">&#9670;&nbsp;</a></span>convertInt32Array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::convertInt32Array </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert <em>len</em> 32-bit integer values from the array at <em>from</em> into the array at <em>to</em> from native host format to network independent format (i.e. most significant byte first). </p>

</div>
</div>
<a id="a1c28b4db51c1e81e4edc7078c43a054e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c28b4db51c1e81e4edc7078c43a054e">&#9670;&nbsp;</a></span>convertFloatArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::convertFloatArray </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert <em>len</em> single-precision floating point values from the array at <em>from</em> into the array at <em>to</em> from native host format to network independent format (i.e. most significant byte first). </p>

</div>
</div>
<a id="a7fb0aac2bae9ef5fabdf6dcfec9bff3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb0aac2bae9ef5fabdf6dcfec9bff3b">&#9670;&nbsp;</a></span>convertDoubleArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SoOutput::convertDoubleArray </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert <em>len</em> double-precision floating point values from the array at <em>from</em> into the array at <em>to</em> from native host format to network independent format (i.e. most significant byte first). </p>

</div>
</div>
<a id="a998d4708239ebb78dc26d23a3e452794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998d4708239ebb78dc26d23a3e452794">&#9670;&nbsp;</a></span>padHeader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSbString.html">SbString</a> SoOutput::padHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSbString.html">SbString</a> &amp;&#160;</td>
          <td class="paramname"><em>inString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pads the header we're writing so it contains the correct amount of bytes for the alignment of the following binary writes. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a115045b8a4e57f8936223a75c991e8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115045b8a4e57f8936223a75c991e8e8">&#9670;&nbsp;</a></span>wroteHeader</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SbBool SoOutput::wroteHeader</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicates whether or not the file format header has been written out. As long as this is <em>FALSE</em>, the header will be written once upon the first invocation of any write method in the class. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="SoOutput_8h_source.html">SoOutput.h</a></li>
<li>SoOutput.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classSoOutput.html">SoOutput</a></li>
    <li class="footer">Generated on Sun May 28 2017 02:26:05 for Coin by
    <a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
